{
  "hashmap": {
    "representation": [
      {
        "number": 1,
        "name": "Hashmap [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n\n        # sc: hashmap relative to input O(n)\n        count = defaultdict(int)\n\n        # tc: iterate over list O(n)\n        for num in nums:\n\n            # tc: in operation constant O(1)\n            if count[num] >= 1:\n                return True\n            # tc: put operation constant O(1)\n            count[num] += 1\n\n        # overall: tc O(n) \n        # overall: sc O(n)\n        return False",
        "questionNumber": 217,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Seen Set [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n        \n        # sc: set relative to input O(n)\n        seen = set()\n\n        # tc: iterate over list O(n)\n        for n in nums:\n\n            # tc: in operation O(1)\n            if n in seen:\n                return True\n            # tc: add operation O(1)\n            seen.add(n)\n            \n        # overall: tc O(n)\n        # overall: sc O(n)\n        return False",
        "questionNumber": 217,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-seen-set-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 3,
        "name": "Unique Set Length Comparison",
        "type": "hashmap",
        "application": "representation",
        "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n        \n        # Create unique set\n        # tc: iterate over original n list O(n)\n        # sc: set relative to input O(n)\n        unique = set(nums)\n\n        # Compare if unique set is different than original list\n        # tc: length operation constant O(1)\n        res = len(unique) != len(nums)\n            \n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 217,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-unique-set-length-comparison---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 4,
        "name": "Sort Iterate Comparison [SC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n        \n        # tc: python (2.3-3.10) TimSort, Python (3.11+) PowerSort Worst/Avg: O(n log n), Best: O(n)\n        # sc: sorts in place, no extra memory O(1)\n        nums.sort()\n\n        # tc: iterate over list O(n)\n        for i in range(1, len(nums)):\n\n            # tc: comparison operation O(1)\n            if nums[i] == nums[i - 1]\n                return True\n\n        # overall: tc O(n log n)\n        # overall: sc O(1)\n        return False",
        "questionNumber": 217,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-4-sort-iterate-comparison-sc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 1,
        "name": "Hashmap Foreach Double Pass [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def isAnagram(self, s: str, t: str) -> bool:\n        \n        # sc: hashmap of 26 elements O(1) \n        count = defaultdict(int)\n\n        # tc: two iteration over string length O(n) * 2 ~= O(n)\n        for x in s:\n           count[x] += 1\n        for x in t:\n           count[x] -= 1\n\n        # tc: iteration over char count O(n)\n        for value in count.values():\n\n            # tc: get() in constant O(1)\n            if value != 0:\n                return False\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return True",
        "questionNumber": 242,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-foreach-double-pass-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Array of 26 Indexing Single Pass [SC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def isAnagram(self, s: str, t: str) -> bool:\n\n        # Note:\n        # ord() converts unicode char to int representation\n        # and use int to index into array\n\n        # sc: array of 26 constant O(1)\n        count = [0] * 26\n\n        # Check: mismatch length\n        if len(s) != len(t):\n            return False\n\n        # tc: single iterate over both strings at same time O(n)\n        for i in range(len(s)):\n            count[ord(s[i]) - ord('a')] += 1\n            count[ord(t[i]) - ord('a')] -= 1\n\n        # tc: iterate over count array length 26 O(1)\n        for value in count:\n            if value != 0:\n                return False\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return True",
        "questionNumber": 242,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-26-indexing-single-pass-sc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 3,
        "name": "[Follow up] Unicode Extension Normalization For Hashmap Foreach Double Pass",
        "type": "hashmap",
        "application": "representation",
        "code": "def isAnagram(self, s: str, t: str) -> bool:\n        \n        # Note:\n        # Why Normalization is required in real life?\n        # Because Unicode allows characters to be represented in multiple valid ways.\n        # Why? Doesn't that make it more complicated?\n        # Yes, but the alternative would be needing millions of characters:\n        # Some languages have hundred of diacritics (e.g, dots, tildes, strokes) \n        # that can be superimposed to create the letters for their alphabet.\n        # When Unicode was created, it had to support existing encodings (Latin-1, MacRoman, Windows-1252)\n        # which have pre-composed/defined characters (é, ñ, ü) as well as other encodings as mentioned above \n        # with use diacritics.\n        # The solution is to allow a composing system, that instead of pre-encoding every possible combination (infinite)\n        # instead we use base characters + combining marks. (letter + marks)\n        \n        # Thus, we need normalization to allow visually equal characters which are built/composed in different\n        # ways to be equal.\n\n        # Real world examples:\n        # - Text copied from different platforms or editors\n        # - User input from different keyboards and OSes\n        # - Databases storing mixed Unicode forms\n        # - International and multilingual applications\n        # - Prevent subtle equality bugs and security issues\n        # - etc.\n        \n        # Without normalization (built/composed differently do not equal, even if visually equal):\n        #   \"é\" != \"e\\u0301\"\n        \n        # With normalization (build/composed differently do equal, because they are visually equal):\n        #   \"é\" == \"e\\u0301\"\n\n\n        # NFC = Normalization Form C, where the C means Canonical Composition\n        # Combines characters into their precomposed forms when possible.\n        # So e +  ́ = é.\n        # allows for even comparison\n\n        # NFD = Normalization Form C, where the C means Canonical Decomposition\n        # so the inverse\n\n        # tc: iteration relative to input O(n)\n        # sc: 2 string copies relative to input O(n)\n        import unicodedata\n        s = unicodedata.normalize(\"NFC\", s)\n        t = unicodedata.normalize(\"NFC\", t)\n\n        # early len check\n        if len(s) != len(t):\n            return False\n\n        # sc: dictionary possibly up to number of distinct characters O(k)\n        count = defaultdict(int)\n\n        # tc: O(n) over s\n        for c in s:\n            count[c] += 1\n\n        # tc: O(n) over t\n        for c in t:\n            count[c] -= 1\n\n        # tc: O(k) over unique keys (≤ n)\n        for value in count.values():\n            if value != 0:\n                return False\n\n        # overall: tc O(n)\n        # overall: sc O(k) <= O(n)\n        return True",
        "questionNumber": 242,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-follow-up-unicode-extension-normalization-for-hashmap-foreach-double-pass---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 4,
        "name": "[Follow up] Unicode Extension Normalization For Array of 26 Indexing Single Pass",
        "type": "hashmap",
        "application": "representation",
        "code": "def isAnagram(self, s: str, t: str) -> bool:\n\n        # Note: Unicode cannot be extended for fixed array of 26 solution \n\n        # English lowercase letters are bounded: only 26\n        # Unicode is not bounded:\n        # > 140,000+ code points\n        # multiple languages\n        # emojis\n        # symbols\n        # combining characters\n\n        # Thus, no fixed small upper bound we can use for our fixed array single pass solution\n        # We need a hashmap / dictionary approach for variable size flexibility\n\n        N/A",
        "questionNumber": 242,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-4-follow-up-unicode-extension-normalization-for-array-of-26-indexing-single-pass---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 1,
        "name": "DefaultDict With // Floor Division For (r,c) Immutable/Hashable Tuple Key",
        "type": "hashmap",
        "application": "representation",
        "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Dictionaries And Immutable/Hashable Keys:\n        # Since dictionaries use hashing, we can use any object that is \n        # both immutable and hashable as the key, \n        # which allows us to create tuples for our keys\n\n        # sc: dictionary for rows, columns, boxes O(n)\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        grids = defaultdict(set)\n\n        # tc: iterate over grid (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                cell = board[r][c]\n                if cell != \".\":\n\n                    # index between 9 box sets by tuple key (r/3, c/3)\n                    gridTuple = (r // 3, c // 3)\n\n                    # tc: lookup operation O(1)\n                    if (cell in rows[r] or \n                        cell in cols[c] or \n                        cell in grids[gridTuple] ):\n                        return False\n                    \n                    # tc: put operation O(1)\n                    cols[c].add(cell)\n                    rows[r].add(cell)\n                    grids[gridTuple].add(cell)\n\n        # overall: tc O(n^2)\n        # overall: sc O(n)\n        return True",
        "questionNumber": 36,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-defaultdict-with-floor-division-for-r-c-immutable-hashable-tuple-key---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Array of Arrays [[]] With // Floor Division For 9 Indexing Options [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Array of Array vs Dictionary:\n        # Due to the overhead of the dictionary functions,\n        # for a small use case such as 9x9 using direct array of arrays is faster.\n        # For larger use cases though, dictionary would be more optimal.\n\n        # sc: arrays for rows, columns, boxes O(n)\n        rows = [[], [], [], [], [], [], [], [], []]\n        col = [[], [], [], [], [], [], [], [], []]\n        grids = [[], [], [], [], [], [], [], [], []]\n\n        # tc: iterate over grid (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                cell = board[r][c]\n                if cell != \".\":  \n\n                    # indexing box sets by unique int calculation:\n                    # ------------\n                    #  (j//3)     = 0, 1, 2\n                    #  (i//3) * 3 = 0, 3, 6\n                    # ------------\n                    #    0 1 2\n                    # 0  0 1 2\n                    # 3  3 4 5\n                    # 6  6 7 8\n                    # ------------\n                    # allows to 9 indexing options\n\n                    boxKey = (r//3) + ((c//3) * 3)\n\n                    # tc: lookup operation O(1)\n                    if (cell in rows[r] or \n                        cell in col[c]  or \n                        cell in grids[boxKey]):\n                        return False\n\n                    # sc: put operation O(1)\n                    col[c].append(cell)\n                    rows[r].append(cell)\n                    grids[boxKey].append(cell)\n        \n        # overall: tc O(n^2)\n        # overall: sc  O(n)\n        return True",
        "questionNumber": 36,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-arrays-with-floor-division-for-9-indexing-options-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 1,
        "name": "HashMap Bridging Left/Right Neighbor Continents And Updating Boundaries [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def longestConsecutive(nums: List[int]) -> int:\n        \n        # Continent Boundaries:\n        # If we imagined a number line, with runs of consecutive numbers being colored\n        # different colors, we could have:\n        #\n        #    0 1   4 5 6 7 8   11 12 13 14  19 \n        #    ***   #########   -----------  ++ \n        #\n        # Continent boundaries builds the lengths of these 'continents' as we iterate\n        # by checking if a number has left and right neighbors who already have a \n        # continent length, and then just joins the continent lengths by 'bridging the continents'\n        # by adding both the left and right neighbor continent lengths and adding +1\n        # to the total length:\n        #\n        #     leftContinent_length   \"+1 Bridge\"   rightContinent_length \n\n        longest = 0\n\n        # sc: hashmap of list of n length O(n)\n        seqLen = defaultdict(int)\n\n        # sc: ignore duplicates O(n)\n        numSet = set(nums)\n\n        # tc: iterate list O(n)\n        for num in numSet:\n            \n            # Get lengths of neighbor sequences\n            leftContinentLenFromBoundary = seqLen[num - 1]\n            rightContinentLenFromBoundary = seqLen[num + 1]\n\n            # Calculate new bridged sequence length\n            bridgedLen = 1 + leftContinentLenFromBoundary + rightContinentLenFromBoundary\n\n            # Update new continent boundaries\n            seqLen[num - leftContinentLenFromBoundary] = bridgedLen\n            seqLen[num + rightContinentLenFromBoundary] = bridgedLen\n\n            # Update the global max\n            longest = max(longest, bridgedLen)\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return longest",
        "questionNumber": 128,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-bridging-left-right-neighbor-continents-and-updating-boundaries-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Unique Set Creating Rummy Run While Run Exists [TC Opt]",
        "type": "hashmap",
        "application": "representation",
        "code": "def longestConsecutive(self, nums: List[int]) -> int: \n\n    # Rummy Run:\n    # Each number is part of only 1 sequence\n    # and thus are only iterated over once.\n    # Thus, the number of times the loop runs across \n    # all iterations is O(n)\n\n    longest = 0\n\n    # sc: ignore duplicates O(n)\n    numSet = set(nums)\n\n    # tc: iterate list O(n)\n    for runStartCandidate in numSet:\n\n        # Check if we have found start of a new run: the left most element of a run\n        # tc: lookup constant O(1)\n        if (runStartCandidate-1) not in numSet: \n\n            currRunLen = 1\n\n            # Check if run's next element exists\n            # tc: iterate over run O(n)\n            while (runStartCandidate + currRunLen) in numSet:\n                # Point to next sequential element\n                currRunLen += 1 \n\n            # Compare max\n            longest = max(longest, currRunLen)\n\n    # overall: tc O(n)\n    # overall: sc O(n)\n    return longest",
        "questionNumber": 128,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-unique-set-creating-rummy-run-while-run-exists-tc-opt---hashmaprepresentation",
        "blog": "LeetCode: Arrays and Hashing"
      }
    ],
    "index-with-data-key": [
      {
        "number": 1,
        "name": "[Follow up] Hashmap Tracking Complement Target [TC Opt]",
        "type": "hashmap",
        "application": "index-with-data-key",
        "code": "def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        # Note:\n        # dictionary is complement -> index \n\n        # sc: dictionary size relative to input O(n)\n        tracking = {}\n \n        # tc: iterate over list O(n)\n        for i in range(len(nums)):\n\n            # find the complement we should be tracking\n            complement = target - nums[i]\n\n            # tc: in operation O(1)\n            if complement in tracking:\n                return [i, tracking[complement]]\n    \n            # tc: put operation O(1)\n            tracking[nums[i]] = i\n\n        # overall: tc O(n) \n        # overall: sc O(n)\n        return []",
        "questionNumber": 1,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-follow-up-hashmap-tracking-complement-target-tc-opt---hashmapindex-with-data-key",
        "blog": "LeetCode: Arrays and Hashing"
      }
    ],
    "grouping-by-criteria": [
      {
        "number": 1,
        "name": "Array to Tuple Count Key [TC Opt]",
        "type": "hashmap",
        "application": "grouping-by-criteria",
        "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \n        # Note: \n        # Tuples immutable, allowing them to be hashed\n        # Array allows for constant ordered representation\n\n        # sc: store k chars for n words O(n * k)\n        anaGroup = {}\n\n        # tc: iterate over list O(n) \n        for word in strs:\n            \n            # sc: array for 26 O(1)\n            charCount = [0] * 26  \n            \n            # tc: iterate over string k length O(k)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # sc: array of 26 to tuple O(1)\n            key = tuple(charCount)  \n            \n            # tc: in operation O(1) \n            if key not in anaGroup:\n                anaGroup[key] = []  \n\n            # tc: put operation O(1)\n            anaGroup[key].append(word)  \n\n\n        # overall: tc O(n * k)\n        # overall: sc O(n * k)\n        return list(anaGroup.values())",
        "questionNumber": 49,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-array-to-tuple-count-key-tc-opt---hashmapgrouping-by-criteria",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Array to String Delimited Count Key [TC Opt]",
        "type": "hashmap",
        "application": "grouping-by-criteria",
        "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n\n        # Note:\n        # Appending to a list and joining once is more efficient than repeatedly\n        # appending to a string. Strings are immutable, so each concatenation\n        # creates a new string and copies all existing characters.\n        # tc: list append + join: O(m), repeated string concat: O(m^2)\n\n        # sc: stores n tuple keys O(n) and lists of original k strings O(k), O(n * k)\n        anaGroup = {}\n\n        # tc: iterate over list O(n)\n        for word in strs:\n\n            # sc: array of 26 constant O(1)\n            charCount = [0] * 26\n            \n            # tc: iterate over string O(m)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # tc: array of 26 to list O(1)\n            values = []\n            for count in charCount:\n                values.append(str(count))\n                # delimiter\n                values.append(\"#\")  \n\n            # tc: concat list of 26 to string O(1)\n            groupCountKey = ''.join(values)\n\n            # tc: in operation O(1)\n            if groupCountKey not in anaGroup:\n                anaGroup[groupCountKey] = []\n\n            # tc: put operation O(1)\n            anaGroup[groupCountKey].append(word)\n\n        # overall: tc O(n * k)\n        # overall: sc O(n * k)\n        return list(anaGroup.values())",
        "questionNumber": 49,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-to-string-delimited-count-key-tc-opt---hashmapgrouping-by-criteria",
        "blog": "LeetCode: Arrays and Hashing"
      }
    ],
    "algorithm": [
      {
        "number": 1,
        "name": "MinHeap Track K Elements [TC Opt]",
        "type": "hashmap",
        "application": "algorithm",
        "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n\n        # MinHeap: \n        # Heap only guarantees that the root is the min or max, and\n        # provides no guarantee about the relative order of nodes. \n        # The minHeap root will hold the smallest element,\n        # as we iterate we will add elements, \n        # and we only remove the root/smallest element when heap exceeds size k.\n        # This ensures the heap will hold the k most frequent\n        # elements we have seen so far\n\n        # sc: freq count for list, m unique elements in worst case O(n)\n        freq = defaultdict(int)\n\n        # Calculate freq count for each element\n        # tc: iterate over list O(n)\n        for num in nums: \n            freq[num] += 1\n\n        # sc: minHeap holds smallest k elements O(k)\n        minHeap = []\n\n        # tc: iterate over freq count, m unique elements in worst case O(n)\n        for (num, freq) in freq.items(): \n\n            # tc: push operation O(log n)\n            heapq.heappush(minHeap, (freq, num)) \n            \n            # if heap grows to size k + 1, pop least freq root so we keep the k most freq elements\n            if len(minHeap) > k:\nt6\n                # tc: pop smallest element O(log k)\n                heapq.heappop(minHeap) \n        \n\n        # alternative expanded loop:\n        # tc: grab top k occurring elements from minHeap, worst case grab n elements O(n)\n        result = []\n        for (_, num) in minHeap:\n            result.append(num) \n\n        # alternative shorter notation\n        # result = [num for freq, num in minHeap]\n\n        # overall: tc O(n log n)\n        # overall: sc O(n)\n        return result",
        "questionNumber": 347,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-minheap-track-k-elements-tc-opt---hashmapalgorithm",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "QuickSelect BinarySearch High to Low Sort [TC Opt]",
        "type": "hashmap",
        "application": "algorithm",
        "code": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n    \n        # QuickSelect Modified QuickSort:\n        # QuickSort sorts based on a partitioned element, whereas when QuickSort\n        # complete, everything to the left of the partitioned element is less than it\n        # and everything to the right of the partitioned element is greater than it.\n        # QuickSelect uses a finalPartitionMarker marks the final expected correct position, \n        # where at which point it stops and elements to the left and right of finalPartitionMarker\n        # are guaranteed to be smaller/larger.\n        # This avoids sorting the entire array by only sorting as many elements until the \n        # finalPartitionMarker is in the correct place which\n        # isolates the minimum elements needed to complete the task\n\n        # Helper: \n        # In place partition of subarray [left,right] relative to random pivot index value\n        def partitionSection(left, right, randPivotElemIndex):\n            \n            # tc: subarray m elements, n in worst case O(n)\n            \n            # Frequency count of random pivot element\n            pivotElemFreq = frequency[unique[randPivotElemIndex]]\n\n            # Move random pivot element to end\n            # Tuple unpacking in python allows swapping two variables\n            unique[randPivotElemIndex], unique[right] = unique[right], unique[randPivotElemIndex]\n            \n            # Left index to partition/move larger elements to the left boundary of subarray\n            partitionIndex = left\n\n            # tc: iterate over subarray, n in worst case O(n)\n            for i in range(left, right):\n\n                # Partition elements with frequencies above the pivotElem Freq (pivotElemFreq < freq),\n                # move them to left (move larger elements greater than the pivot to the left of the pivot)\n                if pivotElemFreq < frequency[unique[i]]:  \n                    \n                    # Slicing:\n                    # Placing larger freq element on left [high... low] \n                    # allows [:k] to grab the first top k freq elements\n                    unique[i], unique[partitionIndex] = unique[partitionIndex], unique[i]\n                    partitionIndex += 1\n\n            # set pivot to correct partitioned index,\n            # elements left and right of pivot follow [greater... pivot ... lesser]\n            unique[partitionIndex], unique[right] = unique[right], unique[partitionIndex]\n            return partitionIndex\n\n        # Helper: \n        # Wrapper function that continues to pick random partition element until we have \n        # placed some element at the \"finalPartitionMarker\" index\n        # tc: average recursion depth O(log m)\n        # sc: recursion stack for in place partitioning on average O(log m)\n        def quickSelectBinarySearchHelper(left, right, finalPartitionMarker):\n            \n            # Base Case:\n            if left == right:\n                return\n\n            # Random pivot index:\n            # Differs from QuickSort \"median-of-three\" approach.\n            # Random pivot focuses on finding the kth smallest or largest,\n            # rather than fully sorting the array, and using random pivot avoids \n            # degrading to worst case O(n^2)\n            randPivotElemIndex = random.randint(left, right)\n\n            # Partition subarray\n            resultPivotElemIndex = partitionSection(left, right, randPivotElemIndex)\n            \n            # Base Case: Random partition marker ended up in correct place\n            if finalPartitionMarker == resultPivotElemIndex:\n                # -> allows us to grab k top freq count by [:k]\n                return \n            \n            # Binary Search Modification:\n            # Selects next subarray and partition pivot\n            # resultPivotElemIndex must recurse towards side where finalPartitionMark is on\n\n            # Result was to the right of final expected, \n            # search to the left of the result: [left, resultPivot-1]\n            elif finalPartitionMarker < resultPivotElemIndex:\n                quickSelectBinarySearchHelper(left, resultPivotElemIndex - 1, finalPartitionMarker)\n            \n            # Result was to the left of final expected,\n            # search to the right of the result: [resultPivot+1, right]\n            else:\n                quickSelectBinarySearchHelper(resultPivotElemIndex + 1, right, finalPartitionMarker)\n\n        # Calculate freq count for each element\n        # tc: iterate over list O(n)\n        # sc: allocate for list, n unique elements worst case O(n)\n        frequency = defaultdict(int)\n        for num in nums:\n            frequency[num] += 1\n\n        # Top Kth Elements Indexing: Top 2 elements are indexes [0, 1]\n        # [9 7 4 3 1]\n        #  0 1 2 3 4\n        finalPartition = k - 1\n\n        # Unique count to sort by during partitioning\n        unique = list(frequency.keys())\n        n = len(unique)\n        l, r = 0, n - 1\n\n        # For High to Low (descending) indexing:\n        # with list of 6 elements, grab largest 2 elements\n        # 2 - 1 = 1 (our 2nd largest)\n        # splice [:2] = [0, 1]\n        quickSelectBinarySearchHelper(l, r, finalPartition)\n\n        # Pivot is now in the correct partitioned index.\n        # Elements left and right of pivot follow [greater... pivot ... lesser]\n        # Slice the first k to grab the top k elements\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return unique[:k]",
        "questionNumber": 347,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-quickselect-binarysearch-high-to-low-sort-tc-opt---hashmapalgorithm",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 3,
        "name": "BucketSort by Count [TC Opt]",
        "type": "hashmap",
        "application": "algorithm",
        "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n        \n        # BucketSort:\n        # Grouping values by freq count into buckets.\n        # Allows us to iterate over most freq buckets and grab top k elements\n\n        # Calculate freq count for each element\n        # tc: iterate over list of n integers O(n)\n        # sc: frequency count for unique integers O(m) \n        count = defaultdict(int)\n        for key in nums:\n            count[key] += 1\n\n        # numBuckets index = items with that frequency count\n        # numBuckets must account for max freq count case, where list is full of only 1 element\n        # numBuckets must account for empty list, (but still needs a bucket index 0), so we need\n        # len(num)+1,\n        # empty: 1 bucket: [0] representing empty group\n        # else: list of len 5, 6 buckets: [0, 1, 2, 3, 4, 5] each representing length group,\n        # with max freq count of 5\n        numBuckets = len(nums) + 1\n\n        # list of empty lists, numBucket amount of times \n        # tc: iterate over list length O(n)\n        # sc: create len(list)+1 buckets O(n)\n        freqBuckets = [[] for i in range(numBuckets)]\n\n        # tc: iterate over frequency list for m unique integer tuples (int, occurrences) O(m) \n        for int, occurrences in count.items():\n            freqBuckets[occurrences].append(int)\n\n        # sc: grabbing top k integers, n worst case O(k)\n        res = []\n\n        # tc: iterate over len(list)+1 buckets O(n)\n        for i in range(len(freqBuckets) - 1, 0, -1):\n            \n            # tc: iterate over all elements in curr bucket O(m)\n            for num in freqBuckets[i]:\n                \n                # tc: insert operation O(1)\n                res.append(num)\n                \n                # tc: continue while less than k elements grabbed O(k)\n                if len(res) == k:\n                    return res\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 347,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-bucketsort-by-count-tc-opt---hashmapalgorithm",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 3,
        "name": "Union Find Tree Grouping Elements By Run [TC Opt]",
        "type": "hashmap",
        "application": "algorithm",
        "code": "def longestConsecutive(self, nums: List[int]) -> int:\n        \n        # Union Find Tree:\n        # Tracks sets of elements broken into non overlapping groups.\n        # In this case it tracks elements broken into groups of corresponding runs.\n\n        # Check Empty: \n        # Avoid max(size.values()) return error\n        if len(nums) == 0:\n            return 0\n\n        # Union Find Initialization:\n        \n        # Stores parent of each number\n        # sc: dictionary for list O(n)\n        parent = {}  \n\n        # Stores the size of connected components\n        # sc: dictionary for list O(n)\n        size = {}    \n\n        # Find + path compression\n        # tc: Amortized O(α(n)) per operation\n        def find(x):\n\n            # Find Representative:\n            # If the parent of x is not itself, keep going up, we have not reached the representative  \n            if parent[x] != x:\n\n                # Path compression:\n                # Set parent of current, to the parent of its eventual parent,\n                # By the end the representative will be the parent of all children\n                parent[x] = find(parent[x])\n\n            # Representative Found:\n            # Reached top of the group, either through compression or just regular parent, return representative\n            return parent[x]\n\n        # Union operation with size optimization\n        # tc: Amortized O(α(n)) per operation\n        def union(x, y):\n\n            # Get parent for trees x and y\n            rootX = find(x)\n            rootY = find(y)\n\n            # If trees do not share representative\n            if rootX != rootY:\n\n                # Grab tree sizes\n                xSize = size[rootX]\n                ySize = size[rootY]\n\n                # Attach smaller tree to larger tree:\n                # 1. update larger tree size \n                # 2. update smaller tree parent\n                if ySize < xSize:\n                    parent[rootY] = rootX\n                    size[rootX] += size[rootY]\n                else:\n                    parent[rootX] = rootY\n                    size[rootY] += size[rootX]\n\n        # Init Union Find Tree: \n        # tc: iterate n O(n)\n        for num in nums:\n\n            # Ignore duplicates that have already been initialized\n            if num not in parent:\n                # 1. Set all parents to self\n                # 2. Set all sizes to 1\n                parent[num] = num\n                size[num] = 1\n\n        # Move elements into groups of runs:\n        # Merge consecutive number sequences as trees\n        # tc: iterate list O(n)\n        for num in nums:\n            if num + 1 in parent:\n                union(num, num + 1)\n        \n        # Return group/tree (sequence of numbers) with longest size/length\n        res = max(size.values())\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 128,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-union-find-tree-grouping-elements-by-run-tc-opt---hashmapalgorithm",
        "blog": "LeetCode: Arrays and Hashing"
      }
    ]
  },
  "array": {
    "in-place-transformations": [
      {
        "number": 1,
        "name": "Prefix, Postfix, Result Arrays",
        "type": "array",
        "application": "in-place-transformations",
        "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        n = len(nums)\n\n        # sc: prefix, postfix, result, arrays O(n)\n        prefix = [1] * n\n        postfix = [1] * n\n        res = [1] * n\n\n        # Prefix\n        # tc: iterate list O(n)\n        for i in range(1, n):\n            \n            # calculate prefix of i = (prefix of i - 1) * (nums[i - 1])\n            prefix[i] = prefix[i - 1] * nums[i - 1]\n\n        # Postfix\n        # postfix starts at 1 = the postfix of len(n) - 1\n        # start reverse iteration at: len(n) - 2\n        # tc: iterate list O(n)\n        for i in range(n-2, -1, -1):\n\n            # calculate postfix of i = (postfix of i + 1) * (nums[i + 1])\n            postfix[i] = postfix[i + 1] * nums[i + 1]\n\n        # Result\n        # tc: iterate list O(n)\n        for i in range(n):\n\n            # calculate product except self for i = (prefix of i) * (postfix of i)\n            res[i] = prefix[i] * postfix[i]\n\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 238,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-prefix-postfix-result-arrays---arrayin-place-transformations",
        "blog": "LeetCode: Arrays and Hashing"
      },
      {
        "number": 2,
        "name": "Result Array",
        "type": "array",
        "application": "in-place-transformations",
        "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        n = len(nums)\n\n        # sc: result array O(1) \n        res = [1] * n\n\n        # Running Prefix: \n        # Generated through iteration with a starting prefix for the first element being 1, \n        # ignore and start at element 2 (index 1)\n\n        # tc: iterate list O(n)\n        for i in range(1, n):\n\n            # (prefix of i) = (prefix of i - 1) * (num at i - 1)\n            res[i] = res[i - 1] * nums[i - 1]\n\n        # Running Postfix: \n        # Generated through reverse iteration with a starting postfix for the last element is 1, \n        # start at the last element (index n-1)\n        postfix = 1\n\n        # tc: iterate list in reverse O(n)\n        for i in range(n-1, -1, -1):\n            \n            # calculate product except self for i = (prefix of i) * (postfix of i)\n            res[i] *= postfix\n            \n            # update postfix = (postfix of i) * (num at i) \n            postfix *= nums[i]\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return res",
        "questionNumber": 238,
        "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-result-array---arrayin-place-transformations",
        "blog": "LeetCode: Arrays and Hashing"
      }
    ]
  },
  "stack": {
    "tracking-nested-or-hierarchical-structures": [
      {
        "number": 1,
        "name": "Manual Condition Stack Check [TC Opt]",
        "type": "stack",
        "application": "tracking-nested-or-hierarchical-structures",
        "code": "def isValid(self, s: str) -> bool:\n\n        # Empty List In Python []:\n        # An empty list [] is falsy evaluating to false\n        # not [] -> true\n\n        # sc: relative to input O(n)\n        stack = []\n\n        # tc: iterate list O(n)\n        for c in s:\n\n            # found close bracket, match with open\n\n            # tc: constant length list check effectively constant O(1)\n            if c in ')]}':\n\n                # check if stack is empty, no open to match\n                # tc: len check O(1)\n                if not stack:\n                    return False\n\n                # tc: pop constant O(1)\n                topElem = stack.pop()\n\n                # check if open bracket matches\n                # tc: equal in constant O(1)\n                if  ((c == ')' and topElem != '(') or\n                     (c == '}' and topElem != '{') or\n                     (c == ']' and topElem != '[')):\n                    return False\n\n            # found open bracket, push to stack\n\n            # tc: constant length list check effectively constant O(1)\n            if c in '([{':\n\n                # tc: list append amortized O(1)\n                stack.append(c)\n                               \n        # stack is empty, success\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return not stack",
        "questionNumber": 20,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-manual-condition-stack-check-tc-opt---stacktracking-nested-or-hierarchical-structures",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "Stack with Hashmap lookup [TC Opt]",
        "type": "stack",
        "application": "tracking-nested-or-hierarchical-structures",
        "code": "def isValid(self, s: str) -> bool:\n\n        # sc: relative to input O(n)\n        stack = []\n\n        # bracket mapping: closed -> open\n\n        # sc: create hashmap fixed entries O(1)\n        mapping = {\n            ')' : '(',\n            ']' : '[',\n            '}' : '{'\n        }\n\n        # tc: iterate over string of n length O(n)\n        for c in s:\n            \n            # found close bracket, match open\n            if c in mapping:\n\n                # check if stack is empty, no open to match\n                # tc: len check O(1)\n                if not stack:\n                    return False\n\n                # tc: pop constant O(1)\n                topElem = stack.pop()\n\n                # check if open bracket matches\n                # tc: equal in constant O(1)\n                if mapping[c] != topElem:\n                    return False\n            \n            # found opening bracket, push to stack\n            else:\n\n                # tc: list append amortized O(1)\n                stack.append(c)\n                \n        # stack is empty, success\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return not stack",
        "questionNumber": 20,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-stack-with-hashmap-lookup-tc-opt---stacktracking-nested-or-hierarchical-structures",
        "blog": "LeetCode: Stacks"
      }
    ],
    "dynamic-programming-state-compression": [
      {
        "number": 1,
        "name": "2 Stacks For Main and Min With Length Pointer",
        "type": "stack",
        "application": "dynamic-programming-state-compression",
        "code": "class MinStack:\n\n    # MinStack:\n    # We need to track 2 things\n    #   - The item at the top of the stack\n    #   - The min item currently in the stack\n\n    # For our functions, they may need to update the above 2 details:\n\n    # Push():\n    #   - Put new item at top of stack\n    #   - Compare new item to current min item in stack\n\n    # Pop():\n    #   - Remove item at top of stack\n    #   - Update min item if min item was removed\n\n    # Top():\n    #   - Get item at top of stack\n    #   - Do not remove item\n    \n    # GetMin():\n    #   - Get current min element in the stack\n    #   - Do not remove item\n    \n    # Tracking Top Of Stack:\n    #   - Simple, just create a stack and pop()/push() when necessary\n\n    # Tracking Min Item:\n    #   - Push(): Represent to stack in a way that updates min item\n    #   - Pop(): Modify stack in way that updates min item if removed\n\n    # Representing The Stack:\n    # Tracking the min item is the tricky part here.\n    # But we can simply solve this by representing the stack certain way.\n    # If we keep track of the min item at each level of the stack,\n    # regardless of push() or pop(), we can track the 2 things\n\n    # Stack Represented By Level With Top Stack And Min Stack:\n    #\n    #        [ 10, 5, 7, 1, 4, 7 ]    <- top of stack\n    #        [ 10, 5, 5, 1, 1, 1 ]    <- min item at certain level of stack\n    # Level:    1  2  3  4  5  6\n\n    # This representation allows us to keep track of \n    #   - Top of stack via the top stack \n    #   - Min item in stack via the min stack\n\n    # overall: sc O(n)\n    def __init__(self):\n \n        # sc: two stacks for n elements O(n)\n\n        # literal stack to keep track of value on top of stack\n        self.mainStack = []\n        \n        # stack to keep track of min item for each level of the stack\n        self.minTracker = []\n        \n        # pointer to the curr element\n        self.logicalSize = 0\n\n    # helper:\n    # edge case checker for empty stack\n    def _validateNotEmpty(self, errMsg: str):\n        if self.logicalSize == 0:\n            raise IndexError(errMsg)\n\n    # helper:\n    # checks if logical pointer is behind actual length of stack\n    def _checkLogicalVsActualSize(self, stack):\n        return self.logicalSize < len(stack)\n            \n    # overall: tc O(1)\n    def push(self, val: int):\n\n        # If logical pointe ris behind actual length, we replace at pointer\n        # else append to end of the stack\n        if self._checkLogicalVsActualSize(self.mainStack):\n            self.mainStack[self.logicalSize] = val\n        else:\n            self.mainStack.append(val)\n\n        # new min:\n        # check if non empty stack, if so compare against previous min\n        # else update to new value\n        currMin = min(val, self.minTracker[self.logicalSize - 1] if self.logicalSize > 0 else val)\n\n        # If logical pointer is behind actual length, we replace at pointer\n        # else append to end of the stack\n        if self._checkLogicalVsActualSize(self.minTracker):\n            self.minTracker[self.logicalSize] = currMin\n        else:\n            self.minTracker.append(currMin)\n        \n        # increase logical size\n        self.logicalSize += 1\n\n    # overall: tc O(1)\n    def pop(self):\n        self.logicalSize -= 1\n\n    # overall: tc O(1)\n    def top(self):\n        return self.mainStack[self.logicalSize - 1]\n\n    # overall: tc O(1)\n    def getMin(self):\n        return self.minTracker[self.logicalSize - 1]\n\n    # overall: tc O(1)\n    # overall: sc O(n)",
        "questionNumber": 155,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-2-stacks-for-main-and-min-with-length-pointer---stackdynamic-programming-state-compression",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "Tuple Stack Without With Length Pointer",
        "type": "stack",
        "application": "dynamic-programming-state-compression",
        "code": "class MinStack:\n\n    # MinStack:\n    # We need to track 2 things\n    #   - The item at the top of the stack\n    #   - The min item currently in the stack\n\n    # For our functions, they may need to update the above 2 details:\n\n    # Push():\n    #   - Put new item at top of stack\n    #   - Compare new item to current min item in stack\n\n    # Pop():\n    #   - Remove item at top of stack\n    #   - Update min item if min item was removed\n\n    # Top():\n    #   - Get item at top of stack\n    #   - Do not remove item\n    \n    # GetMin():\n    #   - Get current min element in the stack\n    #   - Do not remove item\n    \n    # Tracking Top Of Stack:\n    #   - Simple, just create a stack and pop()/push() when necessary\n\n    # Tracking Min Item:\n    #   - Push(): Represent to stack in a way that updates min item\n    #   - Pop(): Modify stack in way that updates min item if removed\n\n    # Representing The Stack:\n    # Tracking the min item is the tricky part here.\n    # But we can simply solve this by representing the stack certain way.\n    # If we keep track of the min item at each level of the stack,\n    # regardless of push() or pop(), we can track the 2 things\n\n    # Stack Represented By Level Wit Tuple (Top Of Stack, Min At Level):\n    #\n    #        [ (10, 10), (5, 5), (7, 5), (1, 1), (4, 1), (7, 1)]\n    # Level:       1        2       3       4       5\n\n    # overall: sc O(n)\n    def __init__(self):\n\n        # sc: stores all pushed tuples (val, min) O(n)\n        self.stack = []\n        self.size = 0\n \n    # helper:\n    # checks if logical pointer is behind actual length of stack\n    def _checkLogicalVsActualSize(self):\n        return self.size < len(self.stack)\n\n    # overall: tc O(1)\n    def push(self, val: int):\n\n        # new min:\n        # check if non empty stack, if so compare against previous min\n        # else update to new value\n        currMin = min(val, self.stack[self.size - 1][1] if self.size > 0 else val)\n        \n        # If logical pointer is behind actual length, we replace at pointer\n        # else append to end of the stack\n        if self._checkLogicalVsActualSize():\n            self.stack[self.size] = (val, currMin)\n        else:\n            self.stack.append((val, currMin))\n\n        # increase logical size\n        self.size += 1\n\n    # overall: tc O(1)\n    def pop(self):\n        self.size -= 1\n\n    # overall: tc O(1)\n    def top(self):\n        return self.stack[self.size - 1][0]\n\n    # overall: tc O(1)\n    def getMin(self):\n        return self.stack[self.size - 1][1]\n\n    # overall: tc O(1)\n    # overall: sc O(n)",
        "questionNumber": 155,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-tuple-stack-without-with-length-pointer---stackdynamic-programming-state-compression",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 3,
        "name": "Simple Tuple Stack Using Pop And Push",
        "type": "stack",
        "application": "dynamic-programming-state-compression",
        "code": "class MinStack:\n\n    # MinStack:\n    # We need to track 2 things\n    #   - The item at the top of the stack\n    #   - The min item currently in the stack\n\n    # For our functions, they may need to update the above 2 details:\n\n    # Push():\n    #   - Put new item at top of stack\n    #   - Compare new item to current min item in stack\n\n    # Pop():\n    #   - Remove item at top of stack\n    #   - Update min item if min item was removed\n\n    # Top():\n    #   - Get item at top of stack\n    #   - Do not remove item\n    \n    # GetMin():\n    #   - Get current min element in the stack\n    #   - Do not remove item\n    \n    # Tracking Top Of Stack:\n    #   - Simple, just create a stack and pop()/push() when necessary\n\n    # Tracking Min Item:\n    #   - Push(): Represent to stack in a way that updates min item\n    #   - Pop(): Modify stack in way that updates min item if removed\n\n    # Representing The Stack:\n    # Tracking the min item is the tricky part here.\n    # But we can simply solve this by representing the stack certain way.\n    # If we keep track of the min item at each level of the stack,\n    # regardless of push() or pop(), we can track the 2 things\n\n    # Stack Represented By Level Wit Tuple (Top Of Stack, Min At Level):\n    #\n    #        [ (10, 10), (5, 5), (7, 5), (1, 1), (4, 1), (7, 1)]\n    # Level:       1        2       3       4       5\n\n    # overall: sc O(n)\n    def __init__(self):\n        # sc: stores all pushed tuples (val, min_so_far) O(n)\n        self.stack = []\n\n    # overall: tc O(1)\n    def push(self, val: int):\n        currMin = min(val, self.stack[-1][1] if self.stack else val)\n        self.stack.append((val, currMin))\n\n    # overall: tc O(1)\n    def pop(self):\n        self.stack.pop()\n\n    # overall: tc O(1)\n    def top(self):\n        return self.stack[-1][0]\n\n    # overall: tc O(1)\n    def getMin(self):\n        return self.stack[-1][1]",
        "questionNumber": 155,
        "solutionLink": "/Notes/leetcode-stacks#solution-3-simple-tuple-stack-using-pop-and-push---stackdynamic-programming-state-compression",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 4,
        "name": "[Dynamic Programming] Two Pointer Opposite Ends Catalan Pattern To Build Parentheses Combinations",
        "type": "stack",
        "application": "dynamic-programming-state-compression",
        "code": "def generateParenthesis(self, n: int) -> List[str]:\n        \n        # Dynamic Programming:\n        # We exploit the recursive structure of Catalan numbers\n        # by building a list of all valid parentheses combinations for each level n\n\n        # Two Pointer:\n        # If we have a list of valid combinations of parenthesis, \n        # we can append them in a format that generate more valid combinations\n\n        # dp:    list of list of parentheses combinations \n        # dp[n]: list containing all valid parenthesis combinations for the nth level (n pair of parenthesis)\n        dp = []\n        for _ in range(n + 1):\n            dp.append([])     \n\n        # Base case: valid combination for n = 0\n        dp[0] = [\"\"]  \n        \n        # Iterate: create valid lists from dp[1] to dp[n]\n        # Current: building list for ith pair\n        # tc: iterate over list of n length O(n) \n        for i in range(1, n + 1): \n\n            # iterate over stored lists up to now\n            for j in range(i):  \n\n                # Opposite Ends Two Pointer Variation:\n                # Since pointers will meet in middle and cross each other, \n                # they will get all variations of combinations already built,\n                # which allows us to format them to generate more valid combinations\n\n                # Setup: Opposite Ends Two Pointer Variation\n                # Forward and Reverse Iteration\n\n                # Forward Iteration List 1: \n                # Iterate over each valid string of parentheses for level j,\n                # starting at first parentheses pairs level of 0 pairs of parenthesis\n                for left in dp[j]:\n\n                    # Reverse Iteration List 2: \n                    # Iterate over each valid string of parentheses for level (i - 1 - j),\n                    # starting at last parenthesis pairs level of largest number pairs currently available\n                    for right in dp[i - 1 - j]:\n\n                        # Generation Format:\n                        # ({left}){right} or {left}({right}) are both valid formulas\n                        # Since we are doing Opposite Ends and left and right will cross over each other,\n                        # left and right will both individually use all values\n                        # which means with these 2 iterations\n                        # we are eventually doing both the same thing\n                        # dp[i].append(f\"{left}({right})\")\n                        dp[i].append(f\"({left}){right}\")\n\n        # overall: tc O(Catalan(n) * n)\n        # overall: sc O(Catalan(n) * n)\n        return dp[n]",
        "questionNumber": 22,
        "solutionLink": "/Notes/leetcode-stacks#solution-4-dynamic-programming-two-pointer-opposite-ends-catalan-pattern-to-build-parentheses-combinations---stackdynamic-programming-state-compression",
        "blog": "LeetCode: Stacks"
      }
    ],
    "expression-evaluation-and-parsing": [
      {
        "number": 1,
        "name": "Stack Postfix Expression Evaluation Algorithm",
        "type": "stack",
        "application": "expression-evaluation-and-parsing",
        "code": "def evalRPN(self, tokens: List[str]) -> int:\n        \n        # Reverse Polish Notation:\n        # We only push numbers to the stack,\n        # and when we hit an operator we pop b the a\n        # since the numbers are on the stack in reverse\n\n        # input:    [\"4\",\"13\",\"5\",\"/\",\"+\"]\n        # expected: 4 + (13 / 5) = 6\n        # \"4\"    -> [4]         push() 4 to stack\n        # \"13\"   -> [4, 13]     push() 13 to stack\n        # \"5\"    -> [4, 13, 5]  push() 5 to stack\n        # \"/\"    -> [4]         hit operator, pop() b = 5, pop() a = 13, complete operation int(13 / 5) = 2\n        # \"2\"    -> [4, 2]      push() 2 to stack\n        # \"+\"    -> []          hit operator, pop() b = 2, pop() a = 4, finish operator (4 + 2) = 6\n        # \"6\"    -> [6]         push() 6 to stack\n\n        # [6] stack holds answer\n\n        # sc: stack holds up to n/2 intermediate results O(n)\n        stack = []\n\n        # tc: iterate over n O(n)\n        for token in tokens:\n\n            # Found Integer:\n            # Cast to int and push() to stack\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            \n            # Found Operation:\n            # Pop() 2 numbers from stack, b then a, and compute\n            else:\n\n                # tc: pop operation constant O(1)\n                b = stack.pop()\n                a = stack.pop()\n\n                # Complete Operation: \n                # Push() result to stack\n                match token:\n                    case \"+\":\n                        stack.append(a + b)\n                    case \"-\":\n                        stack.append(a - b)\n                    case \"*\":\n                        stack.append(a * b)\n                    case \"/\":\n                        \n                        # a / b\n                        # 13 / 5\n\n                        # Explicit truncation towards zero\n                        # -7 / 3         # -2.333  division:        Remainder                                         x\n                        # -7 // 3        # -3      floor division:  Rounds down \"towards infinity\"                    x\n                        # int(-7 / 3)    # -2      int(division):   Rounds up \"towards 0\", as required by RPN      this one\n\n                        stack.append(int(a / b))\n\n        # Top of stack holds result\n        res = stack[-1]\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 150,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-stack-postfix-expression-evaluation-algorithm---stackexpression-evaluation-and-parsing",
        "blog": "LeetCode: Stacks"
      }
    ],
    "backtracking-by-tracking-history-or-state": [
      {
        "number": 1,
        "name": "[Backtracking] Recursive with Immutable String Concatenation",
        "type": "stack",
        "application": "backtracking-by-tracking-history-or-state",
        "code": "def generateParenthesis(self, n: int) -> List[str]:\n\n        # String Immutability:\n        # Every time we do current + \"(\" in python a new string is created\n        # and the entire contents of current are copied.\n        # Since this happens at every recursion level and there are Catalan(n) valid sequences,\n        # the time becomes O(Catalan(n) * n^2)\n        # due to copying. \n        # Solution 2 has a time of O(Catalan(n) * n), this is here to show the slow version\n\n        # Temporary/Working Memory:\n        # We also use more memory with strings as along one recursion path we create ~n strings\n        # each of up to length n, so peak temporary memory is O(n^2)\n        # Solution 2 has temporary memory of O(n), since we have a single stack we are popping/appending from\n\n        # Backtracking:\n        # Explores all valid sequences of parentheses.\n        # A new string is created on each recursive call using string \n        # concatenation for string length up to 2n leading to O(n^2).\n\n        res = []\n\n        # tc: each recursion path creates  explores a state; only leaf call does ''.join(), leading to O(n)\n        # sc: call stack depth is O(n), string copying adds O(n) per leaf path, leading to O(n^2)\n        def dfs_backtrack(current: List[str], num_open: int, num_closed: int):\n\n            # Process Root: reached valid string \n            if len(current) == n * 2:\n                res.append(current)\n                return\n\n            # Explore Choice 1: add '('\n            # Check: open count is less than total expected\n            # Implies: adding '(' will create valid string\n            if num_open < n: \n\n                # Build: append open '('\n                # tc: concat O(n)\n                new_str = current + \"(\"\n\n                # Explore: recursion with new string copy\n                dfs_backtrack(new_str, num_open + 1, num_closed)\n\n                # Backtrack: no need to modify copy as original string still exists\n\n            # Explore Choice 2: add ')'\n            # Check: closed count is less than open count\n            # Implied: adding ')' is required for valid string\n            if num_closed < num_open:\n                \n                # Build: append close ')'\n                # tc: concat per iteration O(n)\n                new_str = current + \")\"\n    \n                # Explore: recursion with new string copy\n                dfs_backtrack(new_str, num_open, num_closed + 1)\n\n                # Backtrack: no need to modify copy as original string still exists\n\n        # Initial call, empty list passed\n        dfs_backtrack(\"\", 0, 0)\n\n        # overall: tc O(Catalan(n) * n^2)\n        # overall: sc O(Catalan(n) * n)\n        return res",
        "questionNumber": 22,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-backtracking-recursive-with-immutable-string-concatenation---stackbacktracking-by-tracking-history-or-state",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "[Backtracking] Recursive with Mutable List Appending",
        "type": "stack",
        "application": "backtracking-by-tracking-history-or-state",
        "code": "def generateParenthesis(self, n: int) -> List[str]:\n        \n        # List Mutability:\n        # We use a single list curr and modify it in place using append/pop.\n        # Append() and pop() are both constant O(1) and no copying happens at each recursion step.\n        # The list only gets converted once we have found a valid combination using \"\".join(curr).\n        # Since there are Catalan(n) valid sequences \n        # the time becomes O(Catalan(n) * n) which is faster than the string version of O(Catalan(n) * n^2)\n\n        # Temporary/Working Memory:\n        # We use a single stack to track our changes, so peak temporary memory is O(n)\n\n        # Backtracking:\n        # Explores all valid sequences of parentheses.\n        # Only when a complete sequence is found (length == 2 * n), \n        # we convert the list to a string via concat in O(n)\n\n        res = []\n        \n        # tc: each recursion explores a state; only leaf call does ''.join(), leading to O(n)\n        # sc: call stack depth O(n), current list holds up to 2n\n        def dfs_backtrack(current, openCount, closeCount):\n\n            # Base case: \n            # If we have used all open and close parentheses\n            if openCount == n and closeCount == n:\n                # tc: convert once at leaf for 2n length O(n)\n                res.append(\"\".join(current))\n                return\n\n            # Recursive case 1: add '('\n            # Check: open count is less than total expected\n            # Ensures: string is always valid, with total number of parens being valid\n            if openCount < n: \n\n                # Build: append open '('\n                current.append('(')\n\n                # Explore: recurse with updated list\n                helper(current, openCount + 1, closeCount)\n\n                # Backtrack: remove last open '('\n                current.pop()\n            \n            # Recursive case 1: add ')'\n            # Check: closed count is less than open count\n            # Ensures: string is always valid, with each open having a matching close\n            if closeCount < openCount:\n\n                # Build: append close ')'\n                current.append(')')\n\n                # Explore: recurse with updated list\n                helper(current, openCount, closeCount + 1)\n\n                # Backtrack: remove last open '('\n                current.pop()\n\n        # Initial call, empty list passed\n        backtrack([], 0, 0)\n\n        # overall: tc O(Catalan(n) * n)\n        # overall: sc O(Catalan(n) * n)\n        return res",
        "questionNumber": 22,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-backtracking-recursive-with-mutable-list-appending---stackbacktracking-by-tracking-history-or-state",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 3,
        "name": "[Backtracking] Iterative Stack State Tracking To Mimic Recursion",
        "type": "stack",
        "application": "backtracking-by-tracking-history-or-state",
        "code": "def generateParenthesis(self, n: int) -> List[str]:\n\n        # Explicit Iterative Stack:\n        # Simulates backtracking process iteratively by storing state on the stack.\n        # Each state element holds the current string and counts of open and closed parentheses,\n        # which allows state tracking without recursion\n\n        # Store valid parentheses\n        result = []\n\n        # Tracks state (current_string, open_count, closed_count)\n        stack = [([], 0, 0)] \n\n        # Simulate backtracking\n        # tc: each state processed once, building up to O(Catalan(n)) strings\n        # sc: stack can grow to O(Catalan(n)), result stores O(Catalan(n)) strings\n        while stack:\n\n            # Process Root:\n            # Grab/pop current state from stack, current state is explored only once\n            curr, openCount, closeCount = stack.pop()\n\n            # Process Root: reached valid string\n            if openCount == n and closeCount == n:\n                result.append(\"\".join(curr))\n                continue\n\n            # Explore Choice 1: add '('\n            # Check: open count is less than total expected\n            # Implies: we have space to add an open parenthesis\n            if openCount < n:\n                \n                # Build: append open '('\n                # Creating copy of list to avoid mutating other branches,\n                # (cannot do curr.append('(') because that would modify the original list)\n                new_curr = curr.copy()\n                new_curr.append('(')\n\n                # Explore: iterative recursion by putting new state on stack for future exploration\n                stack.append((new_curr, openCount + 1, closeCount))\n\n                # Backtrack:\n                # No need to .pop() as the pop() from the stack will remove this new state eventually\n\n            # Explore Choice 2: add ')'\n            # Check: closed count is less than open count\n            # Implies: we have a matching open for our closed parenthesis\n            if closeCount < openCount:\n\n                # Build: append close ')'\n                # Creating copy of list to avoid mutating other branches,\n                # (cannot do curr.append(')') because that would modify the original list)\n                new_curr = curr + [')']\n\n                # Explore: iterative recursion by putting new state on stack for future exploration\n                stack.append((new_curr, openCount, closeCount + 1))\n\n                # Backtrack:\n                # No need to .pop() as the pop() from the stack will remove this new state eventually\n\n        # overall: tc O(Catalan(n) * n)\n        # overall: sc O(Catalan(n) * n)\n        return result",
        "questionNumber": 22,
        "solutionLink": "/Notes/leetcode-stacks#solution-3-backtracking-iterative-stack-state-tracking-to-mimic-recursion---stackbacktracking-by-tracking-history-or-state",
        "blog": "LeetCode: Stacks"
      }
    ],
    "monotonic-property-maintenance": [
      {
        "number": 1,
        "name": "[Monotonic] Monotonic Decreasing Stack of Cold Temps",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Monotonic Stack: \n        # A stack that maintains monotonic decreasing temperatures \n        # When monotonic decreasing rule breaks, that means we have found a temperature \n        # that is hotter than at least 1 of the previous temperatures.\n        \n        # Stack:\n        #      *                                   *                             *                        *                       *\n        #      *  *                                *  *                          *  *                     *  *                    *  *    \n        #      *  *             *                  *  *             *            *  *          *          *  *       *            *  *  * \n        #      *  *  *          *                  *  *  *          *            *  *  *       *          *  *       *            *  *  * \n        #      *  *  *          *                  *  *  *          *            *  *  *       *          *  *       *            *  *  * \n        #      *  *  *  *   +   *                  *  *  *  *   +   *            *  *  *   +   *          *  *   +   *            *  *  * \n        #     ------------     ---       ==>      ------------     ---    ==>   ---------     ---   ==>  ------     ---   ==>   --------- \n        #      0  1  2  3       4      calc wait   0  1  2  3       4            0  1  2       4          0  1       4   join()   0  1  4\n        #     older          hot day     days          \n        #                                          Day 3 waits 1 day           Day 2 waits 2 days     Day 4 is colder than Day 1\n\n        # sc: list for wait time for n temperatures O(n)\n        n = len(temperatures)\n        res = [0] * n\n\n        # sc: stores indices for up to n temperatures O(n)\n        stack = []\n\n        # tc: iterate over n O(n)\n        for i in range(n):\n\n            # Check: if stack is non empty, need to verify monotonic decreasing\n            # Check: if monotonic decreasing broken, current temperature will serve as hot day \n            # Implies: we need to pop off the stack until monotonic decreasing is true again\n            # Implies: for those temperatures popped, we can calculate a hot day wait time\n            while stack and temperatures[stack[-1]] < temperatures[i]:\n                \n                # i: hot day index\n                # stack[-1]: cold day index\n                coldDayIndex = stack.pop()\n                hotDayIndex = i\n\n                # hot day is the closest hotter day for the cold day,\n                # get distance between indexes to get how many days must be waited\n                coldDayWaitTime = hotDayIndex - coldDayIndex\n\n                # set wait time for current cold day\n                res[coldDayIndex] = coldDayWaitTime\n\n\n            # Check: appending temperature will keep monotonic decreasing rule\n            # Implies: this is the coldest day on the stack\n            stack.append(i)  \n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 739,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-monotonic-monotonic-decreasing-stack-of-cold-temps---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "[Reverse] [Monotonic] Monotonic Decreasing Stack of Warm Temps [SC Opt]",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Aggressive Pruning:\n        # Reverse tends to use less actual in memory.\n        # In the reverse, we are only keep track of hot temperatures in monotonic decreasing order\n        # ensuring we have a list of the most recent hot temperatures to ensure minimum wait time for cold\n        # days. So due to the aggressive pruning of colder temperatures during reverse traversal\n        # this tends to use less memory\n\n        # Temperatures:\n        # temp:[ 1, 2, 4, 5, 4, 3, 1]\n        # index: 0  1  2  3  4  5  6\n\n        # Monotonic increasing stacks when iterating backwards, represent decreasing temperatures\n        #                                        \n        #               *                       *\n        #            *  *                       *  *      \n        #         *  *  *                       *  *  *\n        #         *  *  *                       *  *  *  \n        #      *  *  *  *                       *  *  *  *  \n        #     ---------------     which      ---------------    none of these have hotter days,\n        #      6  5  4  3   ... represents      3  4  5  6      so we do not care about monotonic increasing stacks\n        \n\n        # Monotonic decreasing stacks when iterating backwards, represent increasing temperatures\n        #                                        \n        #      *                                        *\n        #      *  *                                  *  *  \n        #      *  *                                  *  *\n        #      *  *  *                            *  *  *\n        #      *  *  *  *                      *  *  *  *  \n        #     ---------------     which      ---------------   all of these have hotter days,\n        #      3  2  1  0   ... represents     0  1  2  3      so we care about monotonic decreasing stacks\n\n\n        # Forward vs Backwards Stack Tracking:\n        # So the difference\n        #       Forward iteration: we are tracking decreasing temperatures, in order to calculate distance when a hotter day appears\n        #       Backwards iteration: we are tracking increasing temperatures, in order to keep track of the most recent hotter temperatures\n\n        # sc: storing up to n indexes O(n)\n        n = len(temperatures)\n        stack = []\n\n        # sc: storing wait days for n temperatures\n        res = [0] * n\n\n        # tc: iterate over list of n temperatures O(n)\n        for i in range(n-1, -1, -1):\n\n            # Check: monotonic decreasing\n            # Implies: Keep list of decreasing temp of hot temps\n            # Check: if monotonic decreasing broken, we have found a more recent hotter temperature\n            # Then: pop() older hot temperature with new hotter temperature to ensure minimum wait time for cold days\n            while stack and temperatures[stack[-1]] <= temperatures[i]:\n                stack.pop()\n\n            # Check: if stack is not empty\n            # Implies: stack has a hotter temperature, can calculate wait days for current cold day\n            if stack:\n\n                # Hot and cold days\n                # Hot and cold days\n                futureHotDayIndex = stack[-1]\n                currentColdDayIndex = i\n\n                # Wait time calculation\n                # Wait time calculation\n                waitDays = futureHotDayIndex - currentColdDayIndex\n                res[i] = waitDays\n                res[i] = waitDays\n\n            # Invariant: current cold day could serve as potential more recent hot day for earlier days for earlier days, append to stack\n            # Invariant: this cold day will get replaced if a more recent hotter day appears\n            stack.append(i)        \n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 739,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-reverse-monotonic-monotonic-decreasing-stack-of-warm-temps-sc-opt---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 1,
        "name": "[Monotonic] [Sorting] Increasing Stack of Slower/Higher Fleet Times Tracking Monotonic Pattern [TC Opt]",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        \n        # Sorting By Distance To Target: \n        # We sort the cars by order of closest to target to farthest from target \n        # (higher value is closer, smaller value is further).\n        \n        # Sorting By Distance Allows For 2 implications:\n        #  1. Farther cars with lower arrival times (faster) than the car directly in front of it\n        #     will catch up with the car in front of it and form a fleet.\n        #    The entire fleet will then be determined by the slower car that was just caught up with (think of traffic)\n        #\n        #  2. Farther cars with higher arrival times (slower) than the car directly in front of it\n        #     will never catch up with the car in front of it, \n        #    thus, the slower car will be left behind and form a new fleet.\n        #     This new fleet will be determined by the slower car\n\n        # As we iterate from closest to farthest: \n        #  - Start with a new car\n        #  - Compare arrival time with the most recently created fleet\n        #  - Check if new car catches up with fleet (joins) or is does not catch up and is left behind (forms new fleet)\n        \n        # Implication Summary:\n        #  1. if that car has a lower (faster) arrival time than the car in front of it, it will join the car ahead (join fleet)\n        #  2. if the car has a higher (slower) arrival time than the car in front of it, it will stay behind the car ahead (form new fleet)\n\n        # Example: Cars ordered from farthest to closest to target, with numbers representing arrival times:\n        #                  \n        #                                     (estimated)                                                             fleet number\n        #   Time to                           no fleets exist, car 0 forms the first fleet                                 1\n        #   target   1  4  3  7  1  2         car 1 has higher time than car 0, does not catch up, forms second fleet      2\n        #           ------------------        car 2 has lower time than car 1, catches up, joins second fleet              2\n        #            0  1  2  3  4  5         car 3 has higher time than car 2, does not catch up, forms third fleet       3 \n        #       Closest             Farther   car 4 has lower time than car 3, catches up, joins third fleet               3 \n        #       car        -->      car       car 5 has lower time than car 3, catches up, joins third fleet               3\n\n        # Monotonic Stack: \n        # Maintains a monotonic increasing stack of times to target (lower times (faster) to high times (slower)).\n        # Every time a higher (slower) time to target is found, it means a car is slower than the current fleet, gets left behind, and creates a new fleet (is pushed to stack)\n        # Every time a lower (faster) time to target is found, it means a car catches up to the current fleet, and nothing is done as the car joins the current fleet, which is still limited by the current fleet's time\n\n        # Monotonic Summary:\n        # Implication 1: And every time monotonic increasing is broken, the current fleet is joined, no new fleets are formed\n        # Implication 2: So every time monotonic increasing is kept, a new fleet is formed\n\n        # sc: stores times for up to n fleets O(n)\n        # sc: stores times for up to n fleets O(n)\n        stack = []\n\n        # Grabbing Info:\n        # Pair each car's position with its speed\n        cars = list(zip(position, speed))\n\n        # Sort cars by descending position (closer/higher to farther/lower): \n        # tc: timSort cars by starting position distance descending O(n log n)\n        cars.sort(reverse=True)\n\n        # Iterate by closer to farthest cars\n        # tc: iterate over n cars O(n) \n        for (pos, spd) in cars:\n\n            # Calculate: time to target for new car\n            currTimeToTarget = (target - pos) / spd \n\n            # top of stack[-1]: represent the current fleet's time to target, which new cars will be compared to\n            \n            # Check: if stack is empty, new car automatically becomes first fleet -> push()\n            # Check: if stack is not empty, fleet exists -> compare time to targets\n            # Implication 2. if new car is slower (new time to target > stack top), it will never catch up and thus form a new fleet\n            if not stack or currTimeToTarget > stack[-1]:\n\n                # Create new fleet at top of stack\n                stack.append(currTimeToTarget)\n\n            # Implication 1. if new car is faster (new time to target <= stack top), it will catch up with fleet and merge\n            else:\n\n                # Do not change current fleet\n                continue\n        \n        # Total number of fleets represented by time to targets/fleets on stack\n        numOfFleets = len(stack)\n\n        # overall: tc O(n log n)\n        # overall: sc O(n)\n        return numOfFleets",
        "questionNumber": 853,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-monotonic-sorting-increasing-stack-of-slower-higher-fleet-times-tracking-monotonic-pattern-tc-opt---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 1,
        "name": "[Standard] [Monotonic] Imaginary Boundaries Surrounding Rectangles Game By Monotonic Stack Covering Heights Rule Implication",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def largestRectangleArea(self, heights: List[int]) -> int:\n\n        # README.md:\n\n        # Monotonic Stack: \n        # A stack that maintains monotonic increasing heights\n        # When monotonic increasing rule breaks, that implies the new height is smaller than at least 1 of the older heights.\n        # When monotonic increasing rule is true, that implies the new height is taller than all older heights.\n        # If stack is non empty, that means we have a stack full of tall bars that can serve to generating an area\n        # by covering new shorter walls.\n        # The width of the rectangle is determined by the distance between the index of the tall bar on top of the stack \n        # that is covering and the index of the new shorter bar.\n\n        # Diagram 1:\n        # All the areas generated by the bars that are taller than the new candidate\n        #               *                                  A                    *                    *       \n        #            *  *                               *  A                 A  A                 *  *       \n        #         *  *  *          *                 *  *  A  *           *  A  A  *           A  A  A  A \n        #      *  *  *  *     +    *       ==>    *  *  *  A  *   ==>  *  *  A  A  *   ==>  *  A  A  A  A  ?\n        #     ------------   new  ---             ---------------      ---------------      --------------- \n        #    older --> newer                      0  1  2  3  4        0  1  2  3  4        0  1  2  3  4      \n        #                                   area from 3-3            area from 2-3          area from 1-4 (NOT GENERATED NOW)\n        #                                                                                   (RIGHT BOUNDARY IS MISSING)\n\n        # Diagram 1: Notes\n        # Notice how, for some bar x on the stack, every bar in front of x is taller and thus 'covers' it\n        # All bars, except the new bar that breaks the monotonic rule\n        # We will use this 'stack covering' assumption to build areas, using the x bar as the left boundary\n        # and the new bar as the right boundary\n\n        # Diagram 1: Not Generated Notes\n        # Also notice how the last area is not generated.\n        # This is because areas are not generated until a smaller bar appears\n        # which serves as a right boundary.\n        # So that area is generated in Diagram 2 below\n\n        # Diagram 1: Pop() 1, Generating the walls while popping\n        #               *                                  *                    A                                      \n        #            *  *                               *  *                 *  A                           *          \n        #         *  *  *          *                 *  *  *  *           *  *  A  *                     *  *     * \n        #      *  *  *  *     +    *       ==>    *  *  *  *  *   ==>  *  *  *  A  *   ==> pop() ==>  *  *  *     * \n        #     ------------   new  ---  pop off   ---------------      ---------------                --------------- \n        #    older --> newer           taller walls               area generated by bounding \n        #                                                              via shorter bar\n\n        # Diagram 1: Pop() 2                                                                                                     \n        #            *                       A  A                                             \n        #         *  *     *              *  A  A  *                      *        *   \n        #      *  *  *     *    ==>    *  *  A  A  *   ==> pop() ==>   *  *        * \n        #     ---------------          ---------------                ---------------  \n        #    older --> newer   area generated by bounding  + using monotonic bar                \n        #                           via shorter bar          assumption \n\n        # Diagram 1: Final Result\n        #\n        #         *  *   \n        #      *  *  * \n        #     ---------------  \n        #    final result                          \n\n        # Diagram 1: Just the pop()'s                                                                                                                                                                   \n        #               *                                     *                                                \n        #            *  *                                  *  *                 *                             \n        #         *  *  *          *                    *  *  *   *          *  *   *          *   *          *  *\n        #      *  *  *  *    +     *        ==>      *  *  *  *   *   =>  *  *  *   *   =>  *  *   *  ==>  *  *  *\n        #     ------------   new  ---     pop off   ------------ ---     --------- ---     ------ ---     ---------\n        #    taller bars   shorter bar    taller walls                                                      final result\n\n        # Diagram 2: Pop() 1, Generating the walls while popping\n        #\n        #         *  *                           A  A \n        #      *  *  *         +    *    ==>  *  A  A  *  \n        #     ----------      new  ___       ------------\n        #    older --> newer                   (WE ARE MISSING THE CORRECT WIDTH)\n\n        # Diagram 2: Correcting the distance\n        # If you recall, the distance between these two walls is actually:\n        #\n        #       *        *                      *        *               A  A  A  A  \n        #    *  *        *    +    *    ==>  *  *        *  *   ==>   *  A  A  A  A  * \n        #   ---------------  new  ---       -----------------         -----------------\n\n        # Diagram 2: A Stack Of Indexes\n        # So to solve this problem, we keep the indexes on the stack not the heights,\n        # in order to save the distance between the walls for when the time comes\n        # to calculate the width of areas.\n\n        # Diagram 2: Indexes\n        #     A  A  A  A  \n        #  *  A  A  A  A  * \n        # -----------------\n        #  0  1  2  3  4  5                                \n\n        # Diagram 2: Width Calculation\n        # For any bar x\n        #   - Left boundary = the nearest bar to the left that is shorter\n        #   - Right boundary = the nearest bar to the right that is shorter\n        #   - Width = (right boundary index - left boundary index) - 1\n        # So for here: = (5 - 0) - 1 =  5 - 1 = 4 wide\n\n        # Summary Popping Rule:\n        # We keep popping as long as the stack has taller bars than the new smaller bar.\n        # A taller bar implies that previous bars on the stack are covered  the new smaller bar is covered and can generate an area.\n        # Once an area can be generated, we just need to calculate the width or the distance between the shorter bar and taller bar\n\n        # Popping Rule Implies either:\n        #\n        #  1. The stack gets completely popped:\n        #     Implies the new height candidate is the smallest height encountered so far \n        #     and was covered by all other previous tall bars.\n        #     This allows the area being generated to span from \n        #     0 -> new_candidate = 0 -> i = i - 0: so width = i\n        #     and the height to be the height of the new height candidate, so height = new height candidate\n        #\n        #  2. The stack does not get completely popped:\n        #     Implies the new height candidate is taller than at least 1 older bar\n        #     and is not covered by all other previous tall bars.\n        #     This creates a left bound for the area being generated to span from\n        #     left bound -> new candidate, left bound -> i = i - left_bound: so width = i - left_bound\n        #     The height \n        #     After the area is generated, the new height candidate becomes the new top of the stack, \n        #     and is compared against new walls, which may or may not be taller or shorter.\n        \n        # Sentinel: \n        # With the rule that area is not calculated until a smaller bar appears, \n        # we need to add a 0 to flush the remaining bars on the stack, \n        # so that every bar is eventually processed regardless of height\n\n        sentinel = 0\n        heights.append(sentinel)\n\n        # sc: stores indexes for up to n heights O(n)\n        stack = []\n        max_area = 0\n\n        # tc: iterate over n O(n)\n        for i in range(len(heights)):\n\n            # Monotonic increasing is broken: \n            # Check: if new bar breaks monotonic increasing order\n            # Implies: The new candidate is shorter than at least 1 bar on the stack\n            # Implies: We have found a right boundary\n            # Rule: The taller bar can generate an area, pop() height for taller bar,\n            # then check top of stack for the left boundary\n            while stack and heights[stack[-1]] > heights[i]:\n                \n                # Grab taller bar index and height\n                tallWallIndex = stack.pop()\n                tallWallHeight = heights[tallWallIndex]\n\n                # Check: if stack is empty after pop()\n                # Implies: the new wall is shorter than all previous heights,\n                # Implies: the left boundary goes up until an imaginary index -1 before the start\n                if not stack:\n                    # Actual rectangle is from 0 to i-1\n                    # So the surrounding boundaries are at -1 and i:\n                    # width = (right boundary) - (left boundary) - 1\n                    #       = i - (imaginary index -1 before the start) - 1\n                    #       = i - (-1) - 1\n                    width = i - (-1) - 1\n\n                # Check: Stack is not empty after pop()\n                # Implies: top of stack can serve as left boundary\n                else:\n                    # Grab left boundary\n                    leftWallIndex = stack[-1]\n\n                    # Actual rectangle is from (leftWallIndex + 1) to (i-1)\n                    # So the surrounding boundaries are at (leftWallIndex) and i\n                    # width = (right boundary) - (left boundary) - 1\n                    #       = i - (left wall on top of stack) - 1\n                    #       = i - stack[-1] - 1\n                    width = i - leftWallIndex - 1\n\n                # Check: new max area\n                max_area = max(max_area, tallWallHeight * width)\n\n            # Monotonic increasing is maintained: \n            # Curr height is taller than all walls on the stack, there is no area to generate, append to stack and grab next new wall\n            stack.append(i)\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return max_area",
        "questionNumber": 84,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-standard-monotonic-imaginary-boundaries-surrounding-rectangles-game-by-monotonic-stack-covering-heights-rule-implication---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "[Reverse] [Monotonic] Index Math Imaginary Boundaries Surrounding Rectangles Game By Monotonic Stack Covering Heights Rule Implication",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def largestRectangleArea(self, heights: List[int]) -> int:\n        \n        # Monotonic Stack: \n        # A stack that maintains monotonic increasing heights\n\n        # Stack popping off taller bars:                                                                                                                                                                    \n        #               *                                     *                                                \n        #            *  *                                  *  *                 *                             \n        #         *  *  *          *                    *  *  *   *          *  *   *          *   *          *  *\n        #      *  *  *  *    +     *        ==>      *  *  *  *   *   =>  *  *  *   *   =>  *  *   *  ==>  *  *  *\n        #     ------------   new  ---     pop off   ------------ ---     --------- ---     ------ ---     ---------\n        #    taller bars   shorter bar    taller walls                                                final result\n\n        # Reverse Iteration Notice:\n        # The diagram is the same for left to right iteration and right to left iteration\n        # even though we are grabbing the bars on the right vs the left.\n        # That is because the stack itself cannot tell the difference and just does the same algorithm.\n        # Thus, all that changes is the width calculation with the indexes\n\n        # Index Math:\n        # Follow the same approach as forward iteration of finding the imaginary boundaries\n\n        n = len(heights)\n        max_area = 0\n\n        stack = []\n\n        # tc: iterate over n O(n)\n        for i in range(n-1, -2, -1):\n\n            # Sentinel: append a sentinel index of -1, height of 0\n            curr_height = 0 if i == -1 else heights[i]\n\n            # Monotonic increasing is broken: \n            # Check: if new bar breaks monotonic increasing order\n            # Implies: The new candidate is shorter than at least 1 bar on the stack\n            # Implies: We have found a right boundary\n            # Rule: The taller bar can generate an area, pop() height for taller bar,\n            # then check top of stack for the left boundary\n            while stack and heights[stack[-1]] > curr_height:\n\n                # Grab taller bar index and height\n                index = stack.pop()\n                height = heights[index]\n\n                # Check: if stack is empty after pop()\n                # Implies: the new wall is shorter than all previous heights,\n                # Implies: the right boundary goes up until an imaginary index n after the end\n                if not stack:\n                    # Actual rectangle is from (i+1) to (n-1)\n                    # So the surrounding boundaries are at i and n:\n                    # width = (right boundary) - (left boundary) - 1\n                    #       = (imaginary index) - i - 1\n                    #       = n - i - 1\n                    width = n - i - 1\n\n                # Check: Stack is not empty after pop()\n                # Implies: top of stack can serve as right boundary\n                else:\n                    # Grab right boundary\n                    rightWallIndex = stack[-1]\n\n                    # Actual rectangle is from (i+1) to (rightWallIndex - 1)\n                    # So the surrounding boundaries are at i and rightWallIndex:\n                    # width = (right boundary) - (left boundary) - 1\n                    #       = (right wall on top of stack) - i - 1\n                    #       = stack[-1] - i - 1\n                    width = rightWallIndex - i - 1\n\n                # check new area\n                max_area = max(max_area, height * width)\n\n            # if non-sentinel index, append\n            if i >= 0:\n                stack.append(i)\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return max_area",
        "questionNumber": 84,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-reverse-monotonic-index-math-imaginary-boundaries-surrounding-rectangles-game-by-monotonic-stack-covering-heights-rule-implication---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 1,
        "name": "[Greedy] Push Lower Digits To Left Of Stack Then Slice Via Monotonic Increasing Digits Stack",
        "type": "stack",
        "application": "monotonic-property-maintenance",
        "code": "def removeKdigits(self, num: str, k: int) -> str:\n\n        # Monotonic Stack:\n        # A Stack that maintains increasing digits\n        # To create the smallest number possible, we want our stack to keep smaller numbers\n        # on the left side and larger numbers on the right:\n        \n        # Smaller number (left to right):\n        # stack = [ 1 2 3 4 5 ]\n        \n        # Instead of larger number (right to left):\n        # stack = [ 5 4 3 2 1 ]\n\n        # A monotonic increasing stack allows us to create the smallest number possible\n        # A monotonic decreasing stack allows us to create the largest number possible\n\n        # So with a monotonic increasing stack, by ordering left to right,\n        # we can slice at the end and grab as many numbers as we need or remove\n        # more numbers (if we still have k left)\n        \n        # Slicing Grabbing:\n        # \"12345\" [:3] -> \"123\"\n        # 3 grabs the leftmost digits, creates the smallest number possible\n        \n        # Slicing Removal:\n        # \"12345\" [:-2] -> \"123\"\n        # -2 removes rightmost 2 digits, creates the smallest number possible\n\n        # Greedy Summary:\n        # The greedy removal is ensuring monotonic stack, \n        # as we want the smaller numbers to be to the left as much as possible, \n        # and we want to keep removing from the stack as long as we can (have k left)\n        \n        # sc: stack holds increasing digits up to n digits O(n)\n        stack = []\n\n        # tc: iterate over n O(n)\n        for digit in num:\n            \n            # Check: if stack is non empty, we have a candidate for removal\n            # Check: if (k > 0) we still have digits to remove\n            # Implies: if monotonic increasing broken, there is a larger digit to remove\n            # Then: remove larger digit on stack to allow lower digit to be more to the left\n            while stack and k > 0 and stack[-1] > digit:\n                \n                # Top of stack is larger than new digit, remove\n                stack.pop()\n                # Decrease remaining digits to remove\n                k -= 1\n\n            # Monotonic increasing valid:\n            # New digit is as far to the left as possible\n            stack.append(digit)\n\n        # Building stack complete:\n        # Digits are now ordered left to right with smallest being on the left\n        # Check: if (k > 0) we still have digits to remove\n        # Then: remove larger digits from the right side, to produce final smallest answer\n        if k > 0:\n            stack = stack[:-k]\n\n        # Join all digits in the stack into a single string\n        smallerNumber = ''.join(stack)\n\n        # Clean answer:\n        # Remove leading zeros \"0000200\" -> \"200\"\n        result = smallerNumber.lstrip('0')\n\n        # 0 Check:\n        # if smallerNumber was all zeros, we will get an empty string after removing zeros\n        # \"0000\" -> \"\"  \n        # so check if empty and return \"0\"\n        if not result:\n            result = \"0\"\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return result",
        "questionNumber": 402,
        "solutionLink": "/Notes/leetcode-stacks#solution-1-greedy-push-lower-digits-to-left-of-stack-then-slice-via-monotonic-increasing-digits-stack---stackmonotonic-property-maintenance",
        "blog": "LeetCode: Stacks"
      }
    ],
    "algorithm": [
      {
        "number": 3,
        "name": "[Reverse] [Dynamic Programming] Reverse Iteration With Jump Traversal Using Dynamic Programming Building Future Warm Temperatures List [TC Opt]",
        "type": "stack",
        "application": "algorithm",
        "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Dynamic Programming:\n        # Uses a jump approach building a next hottest day hopping path as we compute hotter days.\n        # Avoids a stack of temperatures by iterating backwards and keeping \n        # track of the nearest hottest day, which can be used by other days to find \n        # their own hotter day.\n\n        # Jump Traversal:\n        # If we are trying to find the hottest day for index i, \n        # we know that our first candidate is the following day. \n        # If the following day is not the nearest hottest day, \n        # then we know that the first candidate needs a day hotter than this first candidate.\n        # That implies, that the day at index i and the first candidate share the nearest hottest day.\n        # By that logic, we can simply 'jump' to the candidate's own hotter day and use it as \n        # the next candidate for index i.\n        \n        # Essentially, days in the future help days in the past by building shortcuts to hotter days.\n        \n        # sc: result list for storing wait times o(n)\n        n = len(temperatures)\n        dp = [0] * n\n\n        # Setting first hottest day as the last element\n        hottest_day = n - 1\n\n        # Reverse iteration to build future temperature list\n        # tc: iterate over n O(n)\n        for i in range(n - 2, -1, -1):\n\n            # Check: current temperature is warmer than current hottest day\n            # Implies: no future hotter day exists, no need for wait days calculation\n            # Then: update the hottest day\n            if temperatures[i] >= temperatures[hottest_day]:\n                hottest_day = i\n\n            # Check: current temperature is colder than current hottest day\n            # Implies: current temperature has at least 1 hotter day in the future\n            # Then: calculate wait days for current temperature\n            else:\n\n                # Current temperatures' first hotter day candidate is the following day\n                tempCandidateIndex = i + 1\n\n                # Check: continue while the candidate is colder than the current temperature\n                while temperatures[tempCandidateIndex] <= temperatures[i]:\n                    \n                    # Implies: candidate is not hotter\n                    # Then: to avoid checking days that are colder than the current candidate, we can\n                    # skip to the candidates own hotter day, so we never decrease in temperature moving forward\n                    tempCandidateIndex += dp[tempCandidateIndex]\n\n                # Check: found a temperature hotter than current temperature\n                # Then: calculate distance between hotter day and current temperature\n                dp[i] = tempCandidateIndex - i \n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return dp",
        "questionNumber": 739,
        "solutionLink": "/Notes/leetcode-stacks#solution-3-reverse-dynamic-programming-reverse-iteration-with-jump-traversal-using-dynamic-programming-building-future-warm-temperatures-list-tc-opt---stackalgorithm",
        "blog": "LeetCode: Stacks"
      },
      {
        "number": 2,
        "name": "[Greedy] Track Current Fleet With Greedy Assumption [SC Opt]",
        "type": "stack",
        "application": "algorithm",
        "code": "def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        \n        # Pointer Value:\n        # The previous stack is doing 2 things:\n        #   1. keeping track of the current fleet (top of the stack)\n        #   2. keeping track of the number of total fleets (number of time to targets/fleets on the stack)\n        # We can do both of these without using a stack and save space\n\n        # Greedy:\n        # Strategy based on our arrival times implication\n        # When a new car is checked, we just compare it with the current slowest fleet.\n        # So all we need to do is keep track of the current slowest fleets and the number of fleets.\n\n        # Traffic Single Lane Road:\n        # If you think of a one lane road, a single car (the slowest) will block all traffic before it.\n        # So we only need to keep track of a single slowest fleet at a time, as this will be the limiting factor\n        # for the entire single lane, until a slower car is found, at which point that new slower car becomes \n        # the new limiting factor for the entire road\n\n        num_fleets = 0\n        slowest_fleet_time = 0\n\n        # Grabbing Info:\n        # Pair each car's position with its speed\n        cars = list(zip(position, speed))\n\n        # Sort cars by position descending (closer/higher to farther/lower): \n        # tc: timSort cars by starting position distance descending O(n log n)\n        cars.sort(reverse=True)\n\n        # Iterate by closer to farthest cars\n        # tc: iterate over n cars O(n) \n        for (pos, spd) in cars:\n            \n            # Calculate: time to target for new car\n            currCarTimeToTarget = (target - pos)/spd \n\n            # Implication 2. if new car is slower (higher) (new time to target > stack top), it will never catch up and thus form a new fleet\n            if currCarTimeToTarget > slowest_fleet_time: \n\n                # Create new fleet and update its slowest time\n                num_fleets += 1\n                slowest_fleet_time = currCarTimeToTarget\n\n            # Implication 1. if new car is faster (lower) (new time to target <= stack top), it will catch up with fleet and merge\n            else:\n\n                # Do not change current fleet\n                continue\n\n        # overall: tc O(n log n)\n        # overall: sc O(1)\n        return num_fleets",
        "questionNumber": 853,
        "solutionLink": "/Notes/leetcode-stacks#solution-2-greedy-track-current-fleet-with-greedy-assumption-sc-opt---stackalgorithm",
        "blog": "LeetCode: Stacks"
      }
    ]
  },
  "two-pointers": {
    "algorithm": [
      {
        "number": 1,
        "name": "Reverse Slicing [::-1] Comparison [TC Opt]",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def isPalindrome(self, s: str) -> bool:\n        \n        # Note:\n        # Appending to a list and joining once is more efficient than repeatedly\n        # appending to a string. Strings are immutable, so each concatenation\n        # creates a new string and copies all existing characters.\n        # tc: list append + join: O(m), repeated string concat: O(m^2)\n\n        # sc: cleaned version of string O(n)\n        cleaned = []\n\n        # tc: iterate string O(n)\n        for c in s:\n\n            # only grab alphaNum chars\n            if c.isalnum():\n                cleaned.append(c.lower())\n        \n        # tc: join alphaNum list O(n)\n        phrase = \"\".join(cleaned)\n\n        # Note:\n        # Slicing: [start:stop:step]\n        # if start and stop are omitted, slice includes the entire sequence\n        # if step is -1, indicates to traverse in reverse\n\n        # tc: single iteration over the two strings\n        # sc: creates new reversed string\n        res = phrase == phrase[::-1]\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return res",
        "questionNumber": 125,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-reverse-slicing-1-comparison-tc-opt---two-pointersalgorithm",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 2,
        "name": "[No Sorting] Grouping By Parity 4 Triplet Combinations [Time Limit Exceeded]",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \n        # Note:\n        # Two sum: finding two numbers whose sum equals a target is simple\n        # with hashmaps or two pointer approaches\n        # 3Sum: adds complexity with a third variable.\n        # Grouping techniques aim to narrow and organize the solution space\n        # reducing redundant checks while finding valid triplets\n\n        # group by parity: positive, negative, and zero sets\n        # sc: relative to input O(n)\n        p, n, z = [], [], []\n        \n        # set ensures no duplicate triplets\n        # sc: relative to input O(n)\n        res = set()\n\n        # tc: iterate n length O(n)\n        for i in nums:\n            if i < 0:\n                n.append(i)\n            elif i > 0:\n                p.append(i)\n            else:\n                z.append(i)\n\n        # sets ensures no duplicates\n        # tc: convert list into set O(n)\n        P, N = set(p), set(n)\n\n        # (0, 0, 0): at least 3 0's for a valid triplet\n        # tc: len operation constant O(1)\n        if len(z) >= 3:\n            res.add((0, 0, 0))\n\n        # (0, +, -): at least 1 additive inverse for a valid triplet with at least 1 0\n        if len(z) > 0:\n            # tc: iterate n positive numbers O(n)\n            for i in P:                \n                nTarget = -i\n                # tc: inverse lookup constant O(1)\n                if nTarget in N:\n                    # tc: put constant O(1)\n                    res.add((nTarget, 0, i))\n\n        # (-, -, +): negative pairs which are additive inverse of 1 positive number\n        # tc: iterate n negative numbers O(n)\n        for i in range(len(n)):\n            # tc: iterate n O(n)\n            for j in range(i+1, len(n)):\n                pTarget = -(n[i] + n[j])\n                # tc: inverse lookup constant O(1)\n                if pTarget in P:\n                    # tc: put constant O(1)\n                    res.add(tuple(sorted([n[i], n[j], pTarget])))\n        \n        # (-, +, +): positive pairs which are additive inverse of 1 negative number\n        # tc: iterate n positive numbers O(n)\n        for i in range(len(p)):\n            # tc: iterate n positive numbers O(n)\n            for j in range(i+1, len(p)):\n                nTarget = -(p[i] + p[j])\n                # tc: inverse lookup constant O(1)\n                if nTarget in N:\n                    # tc: put constant O(1)\n                    res.add(tuple(sorted([p[i], p[j], nTarget])))\n\n        # convert valid set of tuple triplets into valid list of tuple triplets\n\n        # overall: time complexity O(n^2) \n        # overall: space complexity O(n)\n        return list(res)",
        "questionNumber": 15,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-2-no-sorting-grouping-by-parity-4-triplet-combinations-time-limit-exceeded---two-pointersalgorithm",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 2,
        "name": "[Monotonic Stack] Dragging Right Wall Height Over The Array And Catching Water With Depth Candidates And Left Wall By Building Monotonic Stack",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def trap(self, height: List[int]) -> int:\n\n        # Monotonic Stack: \n        # A stack that maintains monotonic decreasing heights\n        # When monotonic decreasing rule breaks, curr height will serve as right wall,\n        # and if stack is non empty, top of stack will serve as depth, \n        # and second top of stack - 1 will serve as left wall\n        # we then pop off the top of the stack until the monotonic rule comes back into play,\n        # or the right wall becomes the new leftmost wall\n\n        # Stack:\n        #      *                                  *                    *                 *              *\n        #      *                   *              *            *       *         *       *  w   *       *  *\n        #      *  *                *              *  *         *       *  *  w   *       *  *   *       *  *\n        #      *  *                *              *  *         *       *  *  w   *       *  *   *       *  *\n        #      *  *  *             *              *  *  *  w   *       *  *  *   *       *  *   *       *  *\n        #      *  *  *  *     +    *       ==>    *  *  *  *   *   =>  *  *  *   *   =>  *  *   *  ==>  *  *\n        #     ------------   new  ---  pop off   ------------ ---     --------- ---     ------ ---     ------\n        #    older --> newer        left candidates                                                final result\n\n        # Monotonic stack to store indices\n        stack = []  \n        water = 0\n\n        # iterate over list while pushing and popping each bar only once\n        # tc: iterate over n O(n)\n        for i in range(len(height)):\n\n            # Check: if stack is non empty, depth candidate (still need to check if left wall candidate exists)\n            # Check: if current height[i] breaks monotonic decreasing order, its viable as a right wall\n            # implies: we keep appending while monotonic decreasing stays valid\n            # implies: stack is kept in monotonic decreasing order\n            # implies: when monotonic decreasing breaks, we have found right wall\n            # implies: we have a depth candidate\n            while stack and height[stack[-1]] < height[i]:\n                \n                # curr while loop iteration:\n                # height[i]: right wall\n                # pop stack[-1]: depth candidate\n                # peak stack[-2]: left wall\n\n                # Check if left wall candidate exists:\n                # remove depth candidate from stack, check if stack is non-empty\n                # If non-empty, we will essentially dragging the right wall over the monotonic stack, \n                # comparing it to all depth candidates, and adding the corresponding water.\n                # Continue until a depth candidate is taller than the current right wall,\n                # then we just add the right wall to the stack maintaining monotonic order.\n                # Or continue until we run out of left wall/depth candidates,\n                # then the right wall becomes the new leftmost wall.\n                depthCandidateIndex = stack.pop() \n\n                # Check: if stack empty after pop, no left wall exists (had 1 but not 2 elements)\n                # implies: cannot trap water, end while loop, add item to stack\n                if not stack:\n                    break\n\n                # Left wall exists:\n                # Check water between [Left Wall... Depth Candidate ...Dragged Right Wall] excluding walls\n                # width = (right - left - 1)\n\n                # After stack.pop():\n                # height[i]: right wall\n                # popped depthCandidate: depth\n                # peak stack[-1]: left wall\n                # while loop check implies: depthCandidate < height[i]\n                # monotonic stack check implies: depthCandidate < stack[-1]\n                # Thus the bucket is: [peak stack[-1]... depthCandidate ... height[i]]\n\n                # Distance:\n                rightWallIndex = i\n                leftWallIndex = stack[-1]\n                distance = rightWallIndex - leftWallIndex - 1\n\n                # Bucket Bounded Height:\n                rightHeight = height[rightWallIndex]\n                leftHeight = height[leftWallIndex]\n                bucketLowerHeight = min(rightHeight, leftHeight)\n\n                depthHeight = height[depthCandidateIndex]\n\n                # Water Caught:\n                # Smaller bucket wall height - depth = water getting caught\n                waterCaught = bucketLowerHeight - depthHeight\n\n                # add the trapped water for the current segment \n                # [5, 0, 0, 2]\n                # in this case, (0, 0, 2)\n                # left wall = 0, depth = 0, right wall = 2\n                # so no water captured\n                # but then due to pop, (5, 0, 2)\n                # left wall = 5, depth = 0, right wall = 2\n                # so water captured based on distance\n                \n                # Originally: [5, 0, 0, 2]\n                #              0  1  2  3\n                # So distance is: 3 - 0 - 1 = 2\n                \n                # So distance will always be 1 in\n                # unless we have a run of identical heights such as above\n                water += distance * waterCaught\n\n            # implies: monotonic decreasing is still valid\n            # thus: continue appending height to stack\n            stack.append(i)\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return water",
        "questionNumber": 42,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-2-monotonic-stack-dragging-right-wall-height-over-the-array-and-catching-water-with-depth-candidates-and-left-wall-by-building-monotonic-stack---two-pointersalgorithm",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 3,
        "name": "[Dynamic Programming] Creating Bucket Left Right Boundaries By Dynamic Programming Tracking Max Height Bucket Bounds Encountered L To R and R to L",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def trap(self, height: List[int]) -> int:\n        \n        # Dynamic Programming Concept:\n        # Left Maximum Array: Stores the maximum height encountered iterating from left to right (bucket left wall)\n        # Right Maximum Array: Stores the maximum height encountered iterating from right to left (bucket right wall)\n        # Avoid recomputing maximum heights repeatedly, so instead build the bucket walls as you go.\n\n        # Empty Check:\n        n = len(height)\n        if n == 0:\n            return 0\n\n        # Iteration Arrays:\n        # Store max heights from perspective of iterating left to right and right to left for all indexes\n        # leftMax[i]:  Maximum height from  0 -> i:    (iterating left to right)\n        # rightMax[i]: Maximum height from  i <- n-1:  (iterating right to left)\n        # sc: relative to input O(n)\n        leftMax = [0] * n\n        rightMax = [0] * n\n        water = 0\n\n        # First Max Left To Right:\n        leftMax[0] = height[0]\n\n        # Iterating Left To Right:\n        # Compare previous max to current height\n        # tc: iterate over n O(n)\n        for i in range(1, n):\n            previousMax = leftMax[i-1]\n            leftMax[i] = max(previousMax, height[i])\n\n        # First Max Right To Left:\n        rightMax[n-1] = height[n-1]\n\n        # Iterating Right To Left:\n        # Compare previous max to current height\n        # tc: iterate over n O(n)\n        for i in range(n-2, -1, -1):\n            previousMax = rightMax[i+1]\n            rightMax[i] = max(previousMax, height[i])\n\n        # Depth Calculation:\n        # tc: iterate over n O(n)\n        for i in range(n):\n\n            # Bucket Wall Height:\n            # The bucket is bounded by lower of 2 maxes (they represent the Left and Right bucket side heights)\n            # Just subtract the lower height against the height of the bottom of the bucket\n            water += min(leftMax[i], rightMax[i]) - height[i]\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return water",
        "questionNumber": 42,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-3-dynamic-programming-creating-bucket-left-right-boundaries-by-dynamic-programming-tracking-max-height-bucket-bounds-encountered-l-to-r-and-r-to-l---two-pointersalgorithm",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 1,
        "name": "Manacher's Algorithm (iterate, mirror radius optimization, and expand)",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def longestPalindrome(self, s: str) -> str:\n\n        # Note: \n        # Preprocessing with #, ^, and $:\n        # '#': ensures uniform expansion, for both odd and even length palindromes\n        # '^' and '$': sentinel characters don't match valid input characters, serve as true start and end markers\n        # '#': ensures all palindromes start and end with '#'\n        # '#': occur on odd indexes\n\n        # Mapping:\n        # we can map odd '#' indexes to their even character:\n        # mapping '#' at index 1 to char pair 'a' at index 2, to original 'a' at index 0\n        # [ ^ # a # b # a # $ ] -> [ a b a ]    via : originalStart = (expandedCenter - radius) / 2\n        #   0 1 2 3 4 5 6 7 8        0 1 2      thus: originalStart = (4 - 3) / 2 = 0\n        \n        # Boundary expansion: \n        # For any index i, center of palindrome at i can either be: \n        # - character from the original string\n        # - placeholder '#'\n        # Center definition allows even length palindromes such as \"abba\", see below,\n        # to have a single middle point, allowing the same expanding logic \n        # for even and odd strings for palindrome validation\n\n        # Ex:\n        # ^ # a # b # b # a # $    || new string len 11,\n        # 0 1 2 3 4 5 6 7 8 9 10   ||\n        #           ^              || index 5 center for even length \"abba\"\n\n        # index 1 palindrome: \"#\"\n        # index 2 palindrome: \"#a#\"\n        # index 5 palindrome: \"#a#b#b#a#\"\n        # etc...\n\n        expandedStr = \"#\".join(f\"^{s}$\")\n        n = len(expandedStr)\n\n        # Right Most Palindrome and Mirror Trick: \n        # Iteration tracks the right boundary for the current farthest right palindromic substring, \n        # which allows us to take advantage of the mirror radius trick.\n        # It speeds up palindrome expansion by starting the current palindrome radius\n        # at the radius value of its mirror\n\n        # p[i]: radius of palindrome centered at some index i\n        p = [0] * n\n\n        # mirror radius validation: tracking right boundary\n        # right: right boundary of the current right most palindrome\n        right = 0\n\n        # mirror radius validation: tracking center of right most in order to calculate mirror index\n        # center: center index of the current right most palindrome\n        center = 0 \n\n        # iteration range ignores sentinel indexes 0 and (n-1): ^ and $\n        # i: center of current palindrome\n        # time complexity: iterate over list of n length O(n)\n        for i in range(1, n - 1):\n\n            # mirror:\n            # i is current index being processed\n            # i is to the right of center and has a mirror to the left of center\n            # ex: center = 6, i = 7 => mirror = (2 * 6) - 7 = 5\n            mirror = (2 * center) - i \n\n            # mirror radius validation:\n            # if i lies within bounds of the right most palindrome,\n            # the right most palindrome symmetry guarantees that the palindrome radius\n            # for the mirror of i, is applicable to i as well,\n            # while within the bounds of the right most palindrome\n            if i < right:\n\n                # mirror radius is either:\n                # - less than the distance between i and right bound,\n                #   in which case all of the radius is valid\n                # - exceeds bounds and is farther than right bound,\n                #   in which case only the radius up until the right bound is valid\n                \n                # i radius is thus, bounded by minimum between: \n                # - mirror radius\n                # - distance from i to the right bound\n                p[i] = min(right - i, p[mirror])\n\n            # assumption: if valid mirror, we pre-set p[i] to p[mirror]\n            # now expand: expand radius p[i] until palindromic status is broken\n            while expandedStr[i + p[i] + 1] == expandedStr[i - p[i] - 1]:\n                p[i] += 1\n\n            # p[i]: radius for palindrome at i\n            # i: center for palindrome at i\n            # check: if we have a new right most boundary, update center and right \n            if i + p[i] > right:\n                right = i + p[i]\n                center = i\n\n        # expandedStr iteration complete:\n        # p[] stores radius of palindrome centered at each index\n\n        # scan p[] grabbing max palindrome radius alongside its center\n        maxRadius, centerIndex = max((palindromeRadius, i) for (i, palindromeRadius) in enumerate(p))\n\n        # Note:\n        # index and radius are relative to expandedStr, not the original string\n        # thus, we need to translate to original string indexes\n\n        # Notice, how in the expanded string, \n        #  - all original characters are on even index\n        #  - all original characters have matching # on the left odd index\n\n        # abba =>  ^ # a # b # b # a # $   | a=2, b=4, b=6, a=8\n        # 0123 =>  0 1 2 3 4 5 6 7 8 9 10  | #=1, #=3, #=5, #=7\n\n        # aba =>   ^ # a # b # a # $       | a=2, b=4, a=6\n        # 012 =>   0 1 2 3 4 5 6 7 8       | #=1, #=3, #=5\n\n        # any palindrome will always end with a '#'.\n        # so if we divide the starting odd position by 2, it will always map\n        # to an original character.\n        # so an easy translation formula is:\n\n        start = (centerIndex - maxRadius) // 2\n        \n        # splice longest substring\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return s[start: start + maxRadius]",
        "questionNumber": 5,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-manacher-s-algorithm-iterate-mirror-radius-optimization-and-expand---two-pointersalgorithm",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "Expand Around Center checking for Odd and Even palindromes (constant space)",
        "type": "two-pointers",
        "application": "algorithm",
        "code": "def longestPalindrome(self, s: str) -> str:\n\n        # expand from a given left and right while \n        # maintaining palindrome property\n        def expandAroundCenter(left, right):\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n\n            # curr iteration is not valid:\n            # ignore left: incrementing index\n            # ignore right: noninclusive right slicing\n            return s[left+1:right] \n         \n        n = len(s)\n        maxPalindrome = \"\"\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(n):\n            # odd expansion, centered at i\n            oddPalindrome = expandAroundCenter(i, i)      \n            # even expansion, centered at i and i + 1\n            evenPalindrome = expandAroundCenter(i, i+1)\n\n            # update longest\n            if len(oddPalindrome) > len(maxPalindrome):\n                maxPalindrome = oddPalindrome\n            if len(evenPalindrome) > len(maxPalindrome):\n                maxPalindrome = evenPalindrome\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(1)\n        return maxPalindrome",
        "questionNumber": 5,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-expand-around-center-checking-for-odd-and-even-palindromes-constant-space---two-pointersalgorithm",
        "blog": "1D Dynamic Programming"
      }
    ],
    "opposite-ends": [
      {
        "number": 2,
        "name": "Cleaned String Opposite Ends [TC Opt]",
        "type": "two-pointers",
        "application": "opposite-ends",
        "code": "def isPalindrome(self, s: str) -> bool:\n        \n        # sc: cleaned string O(n)\n        cleaned = []\n\n        # helper: check if isAlphaNum\n        def isAlphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        # helper: check if uppercase\n        def isUpper(c):\n            return ord('A') <= ord(c) <= ord('Z')\n\n        # Note:\n        # Ascii Table Unicode Value: A = 65, a = 97, difference of 32\n\n        # helper: shift upper to lowercase\n        def toLower(c):\n            return chr(ord(c) + 32)\n\n        # tc: iterate string O(n)\n        for c in s:\n\n            # Condition: only compare isAlphaNum\n            if isAlphaNum(c):\n                \n                # Condition: only compare lowercase\n                if isUpper(c):\n                    cleaned.append(toLower(c))\n                else:\n                    cleaned.append(c)\n\n        # sc: two pointers O(1)\n        left, right = 0, len(cleaned) - 1\n\n        # tc: iterate clean list O(n)\n        while left < right:\n\n            # Condition: validate palindrome\n            if cleaned[left] != cleaned[right]:\n                return False\n\n            # Left/Right: shrink pointers towards center\n            left += 1\n            right -= 1\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return True",
        "questionNumber": 125,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-2-cleaned-string-opposite-ends-tc-opt---two-pointersopposite-ends",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 3,
        "name": "In Place Opposite Ends [SC Opt]",
        "type": "two-pointers",
        "application": "opposite-ends",
        "code": "def isPalindrome(self, s: str) -> bool:\n\n        # helper: check if isAlphaNum\n        def isAlphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        # helper: check if uppercase\n        def isUpper(c):\n            return ord('A') <= ord(c) <= ord('Z')\n\n        # helper: shift upper to lowercase\n        def toLower(c):\n            return chr(ord(c) + 32)\n\n        # sc: no additional space used for storage O(1)\n\n        # tc: iterate string O(n)\n        left, right = 0, len(s) - 1\n        while left < right:\n            \n            # Condition: skip non-alphaNum, compare alphaNum\n            while left < right and not isAlphaNum(s[left]):\n                left += 1\n            while left < right and not isAlphaNum(s[right]):\n                right -= 1\n\n            # grab pointer values\n            leftChar = s[left]\n            rightChar = s[right]\n\n            # Condition: only compare lowercase\n            if isUpper(leftChar):\n                leftChar = toLower(leftChar)\n            if isUpper(rightChar):\n                rightChar = toLower(rightChar)\n\n            # Condition: compare alphaNum\n            if leftChar != rightChar:\n                return False\n\n            # Left/Right: shrink L/R towards center\n            left += 1\n            right -= 1\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return True",
        "questionNumber": 125,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-3-in-place-opposite-ends-sc-opt---two-pointersopposite-ends",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 2,
        "name": "Opposite Ends Pointer Shift by BinarySearch Modification for Target [TC Opt]",
        "type": "two-pointers",
        "application": "opposite-ends",
        "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n\n        # Set up BinarySearch Modification\n        # initialize outer pointers\n        # space complexity: left and right pointers constant O(1)\n        left, right = 0, len(numbers) - 1  \n\n        # BinarySearch Modification\n        # \"<\": working within subarray containing left and right\n        # cannot evaluate num at left == right, breaks constraints of index1 < index2\n        # Base Case: no more array remaining to search, \n        # return []\n        # time complexity: iterate over list of n length O(n)\n        while left < right:\n\n            # grab current sum\n            currSum = numbers[left] + numbers[right]  \n\n            # Note:\n            # BinarySearch Pattern (1)\n            # 3 Paths: check middle target, if left path, else right path\n\n            # check middle target: found sum\n            if currSum == target:\n                \n                # convert to 1-indexed array, per test cases\n                return [left + 1, right + 1]\n\n            # eheck left path: currSum is too low\n            elif currSum < target:\n                left += 1\n\n            # else right path: currSum is too high\n            else:\n                right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return []",
        "questionNumber": 167,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-2-opposite-ends-pointer-shift-by-binarysearch-modification-for-target-tc-opt---two-pointersopposite-ends",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 1,
        "name": "[Greedy] Opposite Ends Pointer With Greedy Shift by BinarySearch Modification [TC Opt]",
        "type": "two-pointers",
        "application": "opposite-ends",
        "code": "def maxArea(self, height: List[int]) -> int:\n        \n        # boundaries\n        left, right = 0, len(height)-1\n        maxWater = 0 \n\n        # tc: iteration n O(n)\n        while left < right:\n\n            # grab smaller height between outside pointers\n            smallerHeight = min(height[left], height[right])\n\n            # per test cases: width includes walls \n            # [1, 1] is 1 water, (rightIndex - leftIndex) = width\n            # thus, calculate curr water between outside pointers = (smallerHeight * width)\n            currWater = smallerHeight * (right-left)\n            \n            # compare to global max\n            maxWater = max(maxWater, currWater)\n\n            # Greedy Shift:\n            # As we move pointers inwards, width is guaranteed to shrink\n            # Thus, the only way to beat our currWater is with a taller height\n            # Thus, we can continue to move our pointers,\n            # until we hit a bigger height than our current smaller height\n            # Or conversely, we only need to stop and check at a bigger height\n\n            # tc: iteration n list O(n)\n            if height[left] < height[right]:\n                # step past current left/right wall combination\n                left += 1\n                # Greedy Shift:\n                while left < right and height[left] < smallerHeight:\n                    left += 1 \n            else:\n                # step past current left/right wall combination\n                right -= 1\n                # Greedy Shift:\n                while left < right and height[right] < smallerHeight:\n                    right -= 1\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return maxWater",
        "questionNumber": 11,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-greedy-opposite-ends-pointer-with-greedy-shift-by-binarysearch-modification-tc-opt---two-pointersopposite-ends",
        "blog": "LeetCode: Two Pointers"
      }
    ],
    "catchup": [
      {
        "number": 1,
        "name": "Splicing Delimiter With 2 Catchup pointers [TC Opt]",
        "type": "two-pointers",
        "application": "catchup",
        "code": "def encode(self, strs: List[str]) -> str:\n\n        # Note:\n        # Appending to a list and joining once is more efficient than repeatedly\n        # appending to a string. Strings are immutable, so each concatenation\n        # creates a new string and copies all existing characters.\n        # tc: list append + join: O(m), repeated string concat: O(m^2)\n\n        # sc: n strings with m chars O(n * m)\n        encoded = []\n\n        # tc: iterate list O(n)\n        for s in strs:\n            \n            # Note:\n            # custom delimiter to mark start of string \"{length}#\" -> \"5#\"\"\n\n            # tc: delimiter length proportional to log10(m) ~= O(1)\n            lenDelim = str(len(s)) + \"#\"\n            left = 0\n            while left < len(lenDelim):\n                encoded.append(lenDelim[left])\n                left += 1\n            \n            # tc: iterate string O(m)\n            left = 0\n            while left < len(s):\n            \n                # append each char\n                encoded.append(s[left])\n                left += 1\n        \n        # overall: tc O(n * m)\n        # overall: sc O(n * m)\n        return ''.join(encoded)\n\n\n    def decode(self, encoded: str) -> List[str]:\n\n        # sc: n strings with m chars O(n * m)\n        decoded = []\n        left = 0\n\n        # tc: iterate string encoding of list O(n * m)\n        while left < len(encoded):\n\n            # set right to start of length prefix\n            right = left\n\n            # tc: log 10 (m) ~= O(1)\n            # shift right until pointing to delimiter\n            while encoded[right] != \"#\":\n                right += 1\n\n            # after:\n            # [ 2 # h i ... ]\n            #   ^ ^\n            #   l r \n\n            # slice out string length\n            length = int(encoded[left:right])\n\n            # skip delimiter, point to start of string\n            right += 1\n\n            # after:\n            # [ 2 # h i ... ]\n            #   ^   ^\n            #   l   r \n\n            # tc: slice out substring of length m \n            decoded.append(encoded[right:right + length])\n           \n            # set left to start of next custom delimiter\n            left = right + length\n            \n            # after:\n            # [ 2 # h i 3 # b y e ...]\n            # [ 0 1 2 3 4 5 6 7 8 ...]\n            #       ^   ^\n            #       r   l\n\n        # overall: tc O(n * m)\n        # overall: sc O(n * m)\n        return decoded",
        "questionNumber": 271,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-splicing-delimiter-with-2-catchup-pointers-tc-opt---two-pointerscatchup",
        "blog": "LeetCode: Two Pointers"
      }
    ],
    "one-pointer-with-auxiliary-state": [
      {
        "number": 2,
        "name": "Base 10 Auxiliary Length Delimiter With 1 pointer [TC Opt]",
        "type": "two-pointers",
        "application": "one-pointer-with-auxiliary-state",
        "code": "def encode(self, strs: List[str]) -> str:\n\n        # Note:\n        # Appending to a list and joining once is more efficient than repeatedly\n        # appending to a string. Strings are immutable, so each concatenation\n        # creates a new string and copies all existing characters.\n        # tc: list append + join: O(m), repeated string concat: O(m^2)\n\n        # sc: for n strings O(n) store n characters O(n), leading to O(n^2)\n        encoded = []\n\n        # tc: iterate over list of strings n length O(n)\n        for s in strs:\n            \n            # lenDelim = len + delim\n            lenDelim = str(len(s)) + \"#\"\n\n            # append length and delimiter \"5#\"\n            left = 0\n            while left < len(lenDelim):\n                encoded.append(lenDelim[left])\n                left += 1\n            \n            # append string itself\n\n            # tc: iterate over string of n length O(n), for n iterations, leading to O(n^2)\n            left = 0\n            while left < len(s):\n                encoded.append(s[left])\n                left += 1\n        \n        # overall: tc O(n^2)\n        # overall: sc O(n^2)\n        return ''.join(encoded)\n\n\n    def decode(self, encoded: str) -> List[str]:\n\n        # sc: list of n strings O(n) each of n length O(n), leading to O(n^2)\n        decoded = []\n        left = 0\n\n        # tc: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)\n        while left < len(encoded):\n\n            # grab length prefix behind \"#\" delimiter\n            currLen = 0\n            while encoded[left] != \"#\":\n\n                # grabbing value while calculating base 10 of prev\n                currLen = currLen * 10 + int(encoded[left]) \n                left += 1\n\n            # skip delimiter, point to start of string\n            left += 1  \n\n            # after:\n            # [ 2 # h i ... ]\n            #       ^\n            #       l  \n\n            # tc: iterate string O(n) for n delimiters O(n), O(n^2)\n            substring = []\n            for _ in range(currLen):\n\n                # grab string of currLen\n                substring.append(encoded[left])\n                left += 1\n            \n            # left is set to start of next length\n\n            # after:\n            # [ 2 # h i 3 # b y e ...]\n            # [ 0 1 2 3 4 5 6 7 8 ...]\n            #           ^\n            #           l\n\n            # add string to decoded list of strings\n            decoded.append(''.join(substring))\n\n\n        # overall: tc O(n^2)\n        # overall: sc O(n^2)\n        return decoded",
        "questionNumber": 271,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-2-base-10-auxiliary-length-delimiter-with-1-pointer-tc-opt---two-pointersone-pointer-with-auxiliary-state",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 1,
        "name": "BinarySearch Per Element for Complement [Slow TC]",
        "type": "two-pointers",
        "application": "one-pointer-with-auxiliary-state",
        "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n        \n        # tc: iterate list O(n)\n        for i in range(len(numbers)): \n\n            # search for complement\n            currComplementSearch = target - numbers[i]\n            \n            # update boundaries\n            # tc: binarySearch O(log n) for n numbers O(n), O(n log n)\n            left, right = i + 1, len(numbers) - 1\n            \n            # Note:\n            # BinarySearch Pattern (1)\n            # 3 Paths: Check Middle Target, If Left Path, Else Right Path\n\n            # base case: no more array to search, numbers[i] complement not found, next iteration\n            while left <= right:\n                \n                # grab middle element\n                midIndex = (left + right) // 2\n                midNum = numbers[midIndex]\n\n                # check middle target: found sum\n                if midNum == currComplementSearch:\n\n                    # convert to 1-indexed array, per test cases\n                    return [i + 1, midIndex + 1]  \n\n                # if left path: currSum is too low\n                elif midNum < currComplementSearch:\n                    left = midIndex + 1\n\n                # else right path: currSum is too high\n                else:\n                    right = midIndex - 1\n\n        # overall: tc O(n log n)\n        # overall: sc O(1)\n        return []",
        "questionNumber": 167,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-binarysearch-per-element-for-complement-slow-tc---two-pointersone-pointer-with-auxiliary-state",
        "blog": "LeetCode: Two Pointers"
      }
    ],
    "k-pointer-variants": [
      {
        "number": 1,
        "name": "[Sorting] Two Sum Mimic By Per Element Opposite Ends Pointer Shift By BinarySearch Modification For 0 [TC Opt]",
        "type": "two-pointers",
        "application": "k-pointer-variants",
        "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n\n        # Note:\n        # Two sum: finding two numbers whose sum equals a target is simple\n        # with hashmaps or two pointer solutions being efficient\n        # 3Sum: adds complexity with a third variable,\n        # but adding constraints turns 3Sum into a two sum\n        # and allows the use of hashmap or two pointer solutions again\n\n        # set ensures no duplicate triplets\n        # sc: relative to input O(n)\n        results = set()\n        n = len(nums)\n\n        # tc: python (2.3-3.10) TimSort, Python (3.11+) PowerSort Worst/Avg: O(n log n), Best: O(n)\n        # sc: sorts in place, no extra memory O(1)\n        nums.sort()\n\n        # tc: iterate over list O(n)\n        for i in range(n - 2):\n\n            # skip iteration:\n            # i should only \"BinarySearch\" through any number once \n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            # early break: \n            # only allow negative numbers for i in (i, j, k)\n            if nums[i] > 0:\n                break\n\n            # Note:\n            # BinarySearch Pattern (1)\n            # 3 Paths: check middle target, if left path, else right path\n\n            # shift left boundary\n            # reset right boundary to rightmost  \n            left, right = i + 1, n - 1\n\n            # BinarySearch Modification (1)\n            # cannot evaluate num at left == right given constraint i != j, i != k, j != k\n            # thus, change to left < right instead of left <= right\n\n            # Base case: no more array remaining, numbers[i] complement not found,\n            # next iteration\n            \n            # tc: BinarySearch on n elements O(log n), for n iterations O(n), (n log n)\n            while left < right:\n                \n                # grab current sum (i, j, k)\n                currSum = nums[i] + nums[left] + nums[right]\n                \n                # check middle target: found sum\n                if currSum == 0:\n                    \n                    # add triplet to result set\n                    results.add((nums[i], nums[left], nums[right]))\n\n                    # complete pair skip:\n                    # only j and k can add to 0, we can step to next pair \n                    left += 1\n                    right -= 1\n\n                    # Early duplicates skip:\n                    # we already checked the combination of j and k, we can skip all duplicates\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n\n                # if left path: currSum is too low \n                elif currSum < 0:\n                    left += 1\n                \n                # else right path: currSum is too low\n                else:\n                    right -= 1\n\n        # convert set of tuple triplets into list\n\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        return list(results)",
        "questionNumber": 15,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-sorting-two-sum-mimic-by-per-element-opposite-ends-pointer-shift-by-binarysearch-modification-for-0-tc-opt---two-pointersk-pointer-variants",
        "blog": "LeetCode: Two Pointers"
      },
      {
        "number": 1,
        "name": "[Monotonic L/R Pointers] 2 Inner/Outer Pointers Traversal Creating Bound Buckets By Monotonic Opposite Ends Pointer Shift Modification",
        "type": "two-pointers",
        "application": "k-pointer-variants",
        "code": "def trap(self, height: List[int]) -> int:\n\n        # Bound Buckets:\n        # [4, 0, 2, 6, 3, 5]: Monotonic quality defines buckets \n        #                      1. Bucket from index 0-3 with heights of [4, 0, 2, 6]   (left to right monotonic increasing bucket)\n        #                      2. Bucket from index 3-5 with heights of [6, 3, 5]      (left to right monotonic decreasing bucket)\n        #\n        #    When we use 4 and 6 as the left and right bucket walls, the bucket will catch any water up to and including 4\n        #    When we use 6 and 5 as the left and right bucket walls, the bucket will catch any water up to and including 5\n\n        #   Bucket 1: w     Bucket 2: m\n        #       --------- ++++++\n        #                *     \n        #                *  m  *\n        #       *  w  w  *  m  *\n        #       *  w  w  *  *  *\n        #       *  w  *  *  *  *\n        #       *  w  *  *  *  *\n        #      ------------------\n        #       0  1  2  3  4  5\n\n        # Types Of Graphs\n        # case 1: [4, 0, 2, 1, 3, 5], left < right for entire array (bucket from 5 -> 6)\n        # case 2: [4, 0, 2, 6, 3, 5], left < right broken at some point (bucket from 5 -> 9, 9 -> 6)\n\n        #    case 1:                     case 2:\n        #        -------------              --------- ++++++\n        #                                            *     \n        #                      *                     *  m  *\n        #       *  w  w  w  w  *            *  w  w  *  m  *\n        #       *  w  w  w  *  *            *  w  w  *  *  *\n        #       *  w  *  w  *  *            *  w  *  *  *  *\n        #       *  w  *  *  *  *            *  w  *  *  *  *\n        #      ------------------          ------------------\n        #       0  1  2  3  4  5            0  1  2  3  4  5\n        #       ^              ^            ^              ^\n        #       L              R            L              R\n\n        # Creating Buckets: \n        # L/R Outer Pointers: serve as left and right most wall for buckets\n        # L/R Inner Pointers: traverse inward from both ends to determine if monotonic quality (bucket definition) as broken\n        # Water Trapping: using implications to know if left or right most wall for buckets determines water height\n\n        # Defining Bucket Depth Via Height Implications:\n        # case 1 implies: \n        #   1. while height[left] < height[right] \n        #   2. and while height[left] < outerLeftMax\n        #   3. we also know that height[right] < outerRightMax (same implication as 2. but for the right)\n        #   then (eventually), there is a bucket from [outerLeftMax ... left ... outerRightMax]\n\n        # outer pointers\n        outerLeftMax, outerRightMax = 0, 0\n        \n        # inner pointers\n        left, right = 0, len(height) - 1\n        \n        water = 0\n\n        # tc: iterate over n O(n)\n        while left < right:\n            \n            # We grab the lower height, so we know that at minimum, this height is bounded by the taller height\n\n            \n            # Check: Left wall is shorter than Right wall\n            # Implies: Left wall is covered by Right wall\n            if height[left] < height[right]:    \n                #                   *   \n                #                   *   \n                #             *     *   \n                #       ?     *     *   \n                #      ------------------\n                #      LM     L     R   \n\n                # Check: Left wall is taller than Left Max\n                # Implies: new tallest left wall found\n                # Then: Update     \n                if height[left] >= outerLeftMax:\n                    #                   *   \n                    #                   *   \n                    #             *     *   \n                    #       *     *     *   \n                    #      ------------------\n                    #      LM     L     R   \n                    outerLeftMax = height[left]\n\n                # Check: Left wall is shorter than left max\n                # Implies: Left wall is covered by left max\n                # Invariant: Left wall is already covered by Right Wall\n                # Implies: Left max is also lower than Right Wall\n                # Implies: Left max is limiting factor for this bucket\n                # Then: Water depth is just limiting factor - height = outerLeftMax - height[left]\n                else:\n\n                    #                   *   \n                    #       *     w     *   \n                    #       *     *     *   \n                    #       *     *     *   \n                    #      ----------------\n                    #      LM     L     R   \n                    water += outerLeftMax - height[left]\n\n                # shift pointer\n                left += 1\n\n            # Check: Right wall is shorter than Left wall\n            # Implies: Right wall is covered by Left Wall\n            else:\n                #       *              \n                #       *                \n                #       *     *         \n                #       *     *     ?   \n                #      ----------------\n                #       L     R     RM   \n\n                # Check: Right wall is taller than Right Max\n                # Implies: New tallest right wall found\n                # Then: update\n                if height[right] >= outerRightMax:\n                    #       *              \n                    #       *                \n                    #       *     *         \n                    #       *     *     *   \n                    #      ----------------\n                    #       L     R     RM   \n                    outerRightMax = height[right]\n\n                # Check: Right wall is shorter than Right Max\n                # Implies: Right Wall is covered by Right Max\n                # Invariant: Right Wall is already covered by Left Wall\n                # Implies: Right Max is also lower than Left Wall\n                # Implies: Right Max is the limiting factor for this bucket\n                # Then: Water depth is just limiting factor - height = outerRightMax - height[right]\n                else:\n                    #       *              \n                    #       *     w     *     \n                    #       *     *     *    \n                    #       *     *     *   \n                    #      ----------------\n                    #       L     R     RM   \n                    water += outerRightMax - height[right]\n\n                # shift pointer\n                right -= 1\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return water",
        "questionNumber": 42,
        "solutionLink": "/Notes/leetcode-two-pointers#solution-1-monotonic-l-r-pointers-2-inner-outer-pointers-traversal-creating-bound-buckets-by-monotonic-opposite-ends-pointer-shift-modification---two-pointersk-pointer-variants",
        "blog": "LeetCode: Two Pointers"
      }
    ]
  },
  "binary-search": {
    "searching": [
      {
        "number": 1,
        "name": "Recursive Function Call Binary Search",
        "type": "binary-search",
        "application": "searching",
        "code": "def search(self, nums: List[int], target: int) -> int:\n        \n        # Binary Search: Recursive\n        # Recursive function that checks a middle target,\n        # and depending on result searches the left or right subspace.\n        # The recursive function calls continue for O(log n) on\n        # smaller and smaller range determining the time complexity,\n        # and the recursive call stack creates a space complexity of O(log n)\n\n        # Invariant:\n        # Subarray nums[left:right] contains the target if it exists\n        # Search space halves on each iteration\n\n        # sc: setting up search space [0, n-1] O(1)\n        left, right = 0, len(nums)-1\n\n        # Binary Search 1: \n        # Target Binary Search Space: '<='\n        # Exits when left > right, as this means target was not found\n        # tc: binary search over n elements O(log(n))\n        def bs_recursive(left, right):\n\n            # Current Search Space:\n            # [left, mid, right]\n            \n            # End Case: out of search space, target not found\n            if !(left <= right):\n                return -1\n\n            # Middle Target:\n            mid = (left + right) // 2\n\n            # Base Case: target found\n            if nums[mid] == target:\n                return mid\n\n            # Target is greater than mid:\n            # Discard left side of search space [left, mid]\n            # Search right side of previous space, exclude mid: [mid+1, right]\n            elif nums[mid] < target:\n                return bs_recursive(mid + 1, right)\n\n            # Target is less than mid:\n            # Discard right side of search space [mid, right]\n            # Search left side of previous space, exclude mid: [left, mid-1]\n            else:\n                return bs_recursive(left, mid - 1)\n\n        # tc: each call halves the search space O(log n)\n        # sc: call stack grows with depth O(log n)\n        result = bs_recursive(left, right)\n\n        # overall: tc O(log n)\n        # overall: sc O(log n)\n        return result",
        "questionNumber": 704,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-recursive-function-call-binary-search---binary-searchsearching",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 2,
        "name": "Iterative Opposite Ends Two Pointer Binary Search",
        "type": "binary-search",
        "application": "searching",
        "code": "def search(self, nums: List[int], target: int) -> int:\n        \n        # Binary Search: Iterative\n        # Iterative function that checks a middle target,\n        # and depending on result searches the left or right subspace.\n        # The iterative function calls continue for O(log n) on\n        # smaller and smaller range determining the time complexity,\n        # and since we are using pointers there is no call stack \n        # leaving a space complexity of O(1)\n\n        # Invariant:\n        # Subarray nums[left:right] contains the target if it exists\n        # Search space halves on each iteration\n\n        # sc: setting up search space [0, n-1] O(1)\n        left, right = 0, len(nums)-1\n\n        # Binary Search 1: \n        # Target Search Search Space: '<='\n        # Exits when left > right, as this means target was not found\n        # tc: search space halves each iteration O(log n)\n        while left <= right:\n            \n            # Current Search Space:\n            # [left, mid, right]\n\n            # Middle Target:\n            mid = (left+right)//2\n            \n            # Base Case: target found\n            if nums[mid] == target:\n                return mid\n\n            # Target is greater than mid:\n            # Discard left side of search space [left, mid]\n            # Search right side of previous space, exclude mid: [mid+1, right]\n            elif nums[mid] < target:\n                left = mid + 1\n            \n            # Target is less than mid:\n            # Discard right side of search space [mid, right]\n            # Search left side of previous space, exclude mid: [left, mid-1]\n            else: \n                right = mid - 1\n\n        # End Case: out of search space, target not found\n\n        # overall: tc O(log n)\n        # overall: sc O(1)\n        return -1",
        "questionNumber": 704,
        "solutionLink": "/Notes/leetcode-binary-search#solution-2-iterative-opposite-ends-two-pointer-binary-search---binary-searchsearching",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 1,
        "name": "Iterative Opposite Ends Two Pointer Flattened Matrix by Index To Coordinates Binary Search",
        "type": "binary-search",
        "application": "searching",
        "code": "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \n        # Matrix Manipulation Flattening:\n        # Represent the 2D matrix as a sorted 1D array by flattening its indices.\n        # Then simply use binary search on the 1D index space,\n        # and converts indices back to the original 2D coordinates with a helper function.\n        \n        # Matrix =        \n        #    [                row\n        #    [ 1,  3,  5],     0\n        #    [ 7,  9, 11],     1\n        #    [13, 15, 17]      2\n        #    ]\n        # col  0   1   2\n\n        # Flattened:\n        # [ 1, 3, 5, 7, 9, 11, 13, 15, 17 ]\n        #   0  1  2  3  4  5   6   7   8\n\n        # Invariant:\n        # Target, if it exists, lies within subarray [left, right]\n        # Search space is reduced by half on each iteration.\n\n        # Helper:\n        # Revert 1D flat index to original 2D tuple coordinates (row, col)\n        # Flat Index 4 => (4//3, 4%3) = Matrix (1, 1)\n        # Flat Index 5 => (5//3, 5%3) = Matrix (1, 2)\n        def index_to_coords(index, cols) -> tuple[int, int]:\n            row = index // cols\n            col = index % cols\n            return (row, col)\n\n        # Empty Check: target not within matrix\n        if not matrix or not matrix[0]:\n            return False\n\n        # Flattened Representation:\n        # Calculate the 2D matrix representation as a single array\n        # sc: setting up search space [0, n-1] O(1)\n        rows, cols = len(matrix), len(matrix[0])\n        left, right = 0, (rows * cols) - 1\n\n        # Binary Search 1: \n        # Target Search Search Space: '<='\n        # Exits when left > right, as this means target was not found\n        # tc: binary search over m*n O(log(m*n))\n        while left <= right:\n            \n            # Current Search Space:\n            # [left, mid, right]\n\n            # Middle Target:\n            mid = (left + right) // 2\n            (row, col) = index_to_coords(mid, cols)\n            mid_value = matrix[row][col]\n\n            # Base Case: target found\n            if mid_value == target:\n                return True\n            \n            # Target is greater than mid:\n            # Discard left side of search space [left, mid]\n            # Search right side of previous space, exclude mid: [mid+1, right]\n            elif mid_value < target:\n                left = mid + 1\n            \n            # Target is less than mid:\n            # Discard right side of search space [mid, right]\n            # Search left side of previous space, exclude mid: [left, mid-1]\n            else:\n                right = mid - 1\n\n        # End Case: out of search space, target not found\n\n        # overall tc: O(log (m * n))\n        # overall sc: O(1)\n        return False",
        "questionNumber": 74,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-iterative-opposite-ends-two-pointer-flattened-matrix-by-index-to-coordinates-binary-search---binary-searchsearching",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 2,
        "name": "Two Layer Binary Search Outer Row Range Search And Inner Row Element Search",
        "type": "binary-search",
        "application": "searching",
        "code": "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \n        # Outer Inner Binary Search\n        # Performs two separate binary searches\n        #   - Binary Search over rows to locate potential row candidate\n        #   - Binary Search within that row candidate to verify target existence\n        \n        # Matrix =        \n        #    [                row\n        #    [ 1,  3,  5],     0\n        #    [ 7,  9, 11],     1\n        #    [13, 15, 17]      2\n        #    ]\n        # col  0   1   2\n\n        # Invariant (First Binary Search):\n        # Target, if it exists, lies within row range [matrix[row][0], matrix[row][-1]]\n        # Search space is reduced by half on each iteration.\n\n        # Invariant (Second Binary Search):\n        # Target, if it exists, lies within row elements [left, right]\n        # Search space is reduced by half on each iteration.\n\n        # Empty Check: target not within matrix\n        if not matrix or not matrix[0]:\n            return False\n\n        # Matrix Representation:\n        # Top is row 0 and bottom is row n-1 (refer to diagram)\n        # sc: setting up search space [0, n-1] O(1)\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom = 0, rows - 1\n\n        # Binary Search 1: \n        # Target Search Search Space: '<='\n        # Exits when left > right, as this means target was not found\n        # tc: binary search over n rows O(log n)\n        while top <= bottom:\n\n            # Middle Target:\n            mid_row = (top + bottom) // 2\n\n            # Base Case: target found\n            if matrix[mid_row][0] <= target <= matrix[mid_row][-1]:\n                break\n\n            # Target is greater than mid:\n            # Discard left side of search space [left, mid]\n            # Search right side of previous space, exclude mid: [mid+1, right]\n            elif matrix[mid_row][0] < target:\n                \n            # Target is less than mid:\n            # Discard right side of search space [mid, right]\n            # Search left side of previous space, exclude mid: [left, mid-1]\n            else:\n                bottom = mid_row - 1\n\n        # End Case: out of search space, target not found\n        else:\n            return False\n            \n        # row boundaries\n        row = mid_row\n        left, right = 0, cols - 1\n\n        # Binary Search 1: \n        # Target Search Search Space: '<='\n        # tc: binary search across m columns in row O(log m)\n        while left <= right:\n\n            # Middle Target:\n            mid_col = (left + right) // 2\n            \n            # Base Case: target found\n            if matrix[row][mid_col] == target:\n                return True\n            \n            # Target is greater than mid:\n            # Discard left side of search space [left, mid]\n            # Search right side of previous space, exclude mid: [mid+1, right]\n            elif matrix[row][mid_col] < target:\n                left = mid_col + 1\n            \n            # Target is less than mid:\n            # Discard right side of search space [mid, right]\n            # Search left side of previous space, exclude mid: [left, mid-1]\n            else:\n                right = mid_col - 1\n\n        # End Case: out of search space, target not found\n\n        # overall: tc O(log (m * n)) \n        # overall: sc O(1)\n        return False",
        "questionNumber": 74,
        "solutionLink": "/Notes/leetcode-binary-search#solution-2-two-layer-binary-search-outer-row-range-search-and-inner-row-element-search---binary-searchsearching",
        "blog": "LeetCode: Binary Search"
      }
    ],
    "optimization-search-min-max": [
      {
        "number": 1,
        "name": "Binary Search",
        "type": "binary-search",
        "application": "optimization-search-min-max",
        "code": "def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        import math\n\n        # Binary Search: Optimization Search\n        # Iterative function that checks if middle element is valid\n        # using some constraint, in this case under h minimum hours,\n        # and depending on result searches the left or right subspace\n        # but also includes the middle element if it was valid.\n        # The iterative function calls continue for O(log n) on\n        # smaller and smaller range determining the time complexity,\n        # and since we are using pointers there is no call stack \n        # leaving a space complexity of O(1)\n\n        # Banana Abstraction:\n        #   - k = minimum eating speed such that koko is able to eat all bananas \n        #     within the h hours deadline\n        #   - Piles = groups of bananas, piles vary in size, only positive integers\n        #   - h = hours deadline is at least greater than the number of piles: len(piles) <= h\n\n        # Setting Up Search Space:\n        #   - Left Speed: 1 banana per hour (slowest possible)       \n        #   - Right speed: max(piles) as no pile would need more than max(piles) eating per hour\n        left, right = 1, max(piles)\n\n        # Invariant:\n        # Min k eating speed is within the interval [left, right]\n        # Search space halves each iteration\n\n        # Helper:\n        # Finds the h number of hours needed for some k eating speed to finish piles\n        # overall tc: iterate over n piles O(n)\n        def hours_needed(speed):\n            \n            # time counter for candidate k\n            total_hours = 0\n\n            # Koko iterates over piles to eat\n            # tc: iterate over n piles O(n)\n            for pile in piles:\n\n                # Round up time:\n                # We cannot stop eating in middle of hour, example:\n                # p = 3 bananas, k = 9 eating speed, bananas / eating speed, \n                # will still take 1 full hour, so we must round the result up\n                total_hours += math.ceil(pile / speed)\n\n            # total h hours needed for k eating speed for all piles\n            return total_hours\n        \n        # Binary Search 2: \n        # Optimization Search Space: '<'\n        # Exits when left == right, as this mean answer has been optimized\n        # tc: binary search over speeds 1 -> max(piles) speeds O(log(max(piles)))\n        while left < right:\n\n            # Middle Target:\n            mid = (left + right) // 2\n\n            # Hours needed for candidate k eating speed\n            required_hours = hours_needed(mid)\n            \n            # Candidate is valid eating speed (below h hours)\n            # Discard faster speeds on right side [mid, right]\n            # Search left side of previous space, and include mid => [left, mid]\n            if required_hours <= h:\n                right = mid\n            \n            # Candidate is not valid eating speed (above h hours)\n            # Discard slower speeds on left side [left, mid]\n            # Search right side of previous space, and exclude mid => [mid+1, right]\n            else:\n                left = mid + 1\n        \n        # Optimization Exit:\n        # left == right, answer has been optimized\n        # The space of valid speeds, [left, right], has been reduced to one speed\n        # This final speed is the optimized speed\n\n        # overall: tc O(n * log(max(piles)))\n        # overall: sc O(1)\n        return left",
        "questionNumber": 875,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-binary-search---binary-searchoptimization-search-min-max",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 2,
        "name": "[Greedy] [Networking] Networking Router Analogy, Greedy Heuristic Hybrid Target Optimization Monotonic Search with Exponential Speed Doubling",
        "type": "binary-search",
        "application": "optimization-search-min-max",
        "code": "def minEatingSpeed(self, piles: List[int], h: int) -> int:\n\n        # README.md\n        # Koko eats bananas is a cleverly disguised networking problem!\n        # This problem is a system design exercise regarding networking packets:\n\n        # -----------------------------------------------------\n        # Network Router Analogy:\n        # Router = Koko\n        # Incoming Data Packets = Banana Piles\n        # Data In Packet To Be Process = Bananas In Pile\n        # Maximum Allowed Latency = h deadline\n        # Throughput = k eating speed\n        # -----------------------------------------------------\n\n        # Greedy Choosing K Speed Start:\n        #   - Start with the highest reasonable lower bound to speed up search efficiently\n        #   - Different system perspectives for lower bound, use at least 3 perspectives\n        #   - Use the networking analogy to determine the perspectives\n\n        # Review Networking Analogy To Choose Perspectives:\n        #   - Packets (piles)\n        #   - Data size (bananas in pile)\n        #   - Time Constraint (h)\n        #   A perspective should take into account at least two or all three \n        #  (packets, data size, and time) in order to generate a good lower bound k\n\n        # 3 Perspectives:\n        #\n        #   1. Throughput/Global Bandwidth\n        #       - Total bananas being processed (total data to be processed)\n        #\n        #   2. Quick Packet Bursts\n        #       - Speed based on smallest pile\n        #       - To avoid having excessively large speed \n        #       - Smallest Pile Consideration With Fair Time Allocation\n        #\n        #   3. Bottleneck Prevention\n        #       - Speed based on largest pile\n        #       - Avoid having small speed that gets stuck on largest pile\n        #       -Unfair Time Allocation: \n        #            Give every pile 1 hour of time, and the rest of time to the largest pile\n        #            (Largest Pile Consideration With Unfair Time Allocation)\n\n        # Why these 3 perspectives?\n        #   - Determined the perspectives by constraints:\n        #   1. Throughput => Close to real answer in order to minimize search time\n        #   2. smallest packet =>  Must be lower bound and never overestimate\n        #   3. largest packet => avoid too lower of a lower bound  \n        #   - Computable in O(n) time in order to scalable = simple perspectives\n        #   - Multiple heuristics to take into account different system perspectives = at least 3 perspectives\n\n        # Why not other perspectives?\n        #   - Other perspectives only take into account 1 aspect of the analogy\n        #     (packets, data size, time constraint), and are thus not good lower bounds\n        #\n        #   1. Average between all piles\n        #       - Does not consider the time constraint, assumes infinite time\n        #\n        #   2. Max pile divided over h hours\n        #       - Does not factor rest of pile size, if max pile is much larger, \n        #         we would waster k speed on the smaller piles\n\n        # Overall Pros:\n        # Can outperform binary search in practice for some input with high k speeds.\n        \n        # Overall Cons: \n        # Lacks worst case guarantees, binary search has O(log n) worst case,\n        # this does not have a worst case guarantee\n    \n        # ------------------------\n        # Perspective 1: Total Data Volume + Required Processing/Throughput\n        #       - Compute total workload (total bananas)\n        #       - Determine minimum average processing rate (throughput) needed to finish within h hours\n        #       - Provides a baseline lower bound for the eating speed\n        \n        # Throughput Constraint Summary:\n        #   - Speed needed to process largest pile while spending most of time on largest pile\n\n        # Solution Idea:\n        # Spread all bananas evenly over h available hours\n        # All bananas / hours -> baseline average k speed\n\n        # Lower Bound: \n        # No matter how time is spent between small or large piles,\n        # if k is less than totalBananas/h, all bananas will not get finished\n\n        # Creates Small k:\n        # Underestimates when bananas are skewed into a few large piles\n        # by assuming bananas are even across piles\n        \n        totalBananas = sum(piles)\n        speedCheck1 = math.ceil(totalBananas / h)\n\n        # ------------------------\n        # Perspective 2: Smallest Packet Processing + Even Time\n        #       - Assume time is evenly split among all piles\n        #       - Focus on the smallest pile\n        #       - Determine a minimum speed to finish the smallest pile using evenly split time\n        #       - Prevents overestimating speed due to small piles, giving a realistic lower bound\n\n        # Quick Packet Bursts Constraint Summary:\n        #   - The minimum speed needed to finish the smallest pile while splitting the time evenly between piles\n\n        # Solution Idea:\n        # Part 1: Split Time Evenly Between Piles (Fair time Sharing) = Hour Per Pile Based Average, \n        # Part 2: Minimum Speed to Finish Smallest Pile using Split Even Time = Minimum Speed Needed For Fair Time Sharing\n\n        # Lower Bound: \n        # If each pile gets equal time, find the minimum speed \n        # required to finished with the smallest pile have the same time as all other piles.\n        # Since we are determining k based on the smallest pile, which does not need much time, \n        # this produces a small k:\n        numPiles = len(piles)\n        splittingTimeEvenly = int(h/numPiles)\n        smallestPile = min(piles)\n        speedCheck2 = math.ceil(smallestPile / splittingTimeEvenly)\n\n        # ------------------------\n        # Perspective 3: Largest Pile + Bottleneck Time Simulation\n        #       - Assume bottleneck scenario, most time is spent on largest pile\n        #       - Focus on the largest pile\n        #       - Ensures chosen speed process largest pile under h deadline\n        #       - Provides another lower bound to prevent underestimating speed\n\n        # Bottleneck Constraint Summary:\n        #   - Spend the majority of time on the largest pile, to simulate a bottleneck\n        #     and determine a speed that will work within that constraint\n\n        # Solution Idea:\n        # Part 1: Simulate a bottleneck, by assuming we will spend little time on smaller piles, giving them all 1 hour\n        # Part 2: Simulate a bottleneck, by assuming we will spend most of our time on the largest pile, giving it the rest of the time\n\n        # Lower Bound: \n        # As the largest pile has a large number of hours to finish,\n        # this allows the k eating speed to be lower,\n        # this produces a small k:\n        remainingTime = h - (numPiles - 1)\n        speedCheck3 = math.ceil(max(piles) / remainingTime)\n            \n        # ------------\n        # Greedy Starting Speed k: highest lower bound\n        #   - We have created 3 lower bounds between the 3 perspectives \n        #   - We will pick the highest lower bound between the 3\n        #   - Avoids wasting time on speeds below k\n        speed = max(speedCheck1, speedCheck2, speedCheck3)\n\n        # -----------------------------------------------------\n        # Greedy Aggressive Monotonic Time Search Optimization: \n        # - If the total time needed for k eating speed is double the h deadline,\n        #   we will aggressively increase k by doubling it\n        # - If total eating time less than double the h deadline,\n        #   we will increment speed k slowly by 1.\n\n        # -----------------------------------------------------\n\n        # Invariant:\n        # min valid speed k lies in [speed, +inf]\n        # speed is monotonically increased during search\n        # first valid time h: speed is guaranteed to be the min \n        #                     due to our Greedy Aggressive Monotonic Time Search Optimization\n\n        # tc doubling x2: exponential doubling O(log max(piles))\n        # tc iterating +1: linear scan O(max(piles))\n        # overall: worst case linear scan O(max(piles)/2) => O(max(piles))\n        while (True):\n\n            # time counter for candidate k\n            smallKTotalTime = 0\n\n            # Koko iterates over piles to eat\n            # tc: iterate over n piles O(n)\n            for pile in piles:\n\n                # Round up time:\n                # We cannot stop eating in middle of hour, example:\n                # p = 3 bananas, k = 9 eating speed, bananas / eating speed, \n                # will still take 1 full hour, so we must round the result up\n                smallKTotalTime += math.ceil(pile / speed)\n\n            # Greedy Aggressive Monotonic Time Search Optimization: \n\n            # Check: if valid k speed found\n            # Implies: we were iterating and found the first valid k, the is the min\n            if smallKTotalTime <= h:\n                return speed\n\n            # Check: if h is double the deadline\n            # Implies: k is at least half as slow as it should be\n            # Then: aggressively double k speed,\n            # tc: search space halves each iteration [speed*2, +inf]: O(log n)\n            elif smallKTotalTime >= 2 * h:\n                speed *= 2\n\n            # Check: if h is below double the deadline\n            # Implies: k is close to its min speed\n            # Then: iterate by 1 until we find the first valid k speed\n            # tc: search space decreases by 1 each iteration [speed+1, +inf]: O(n)\n            else:\n                speed += 1\n\n        # overall: tc best: O(n * log(max(piles))), worst: O(n * max(piles))\n        # overall: sc O(1)",
        "questionNumber": 875,
        "solutionLink": "/Notes/leetcode-binary-search#solution-2-greedy-networking-networking-router-analogy-greedy-heuristic-hybrid-target-optimization-monotonic-search-with-exponential-speed-doubling---binary-searchoptimization-search-min-max",
        "blog": "LeetCode: Binary Search"
      }
    ],
    "condition-adapted-binary-search": [
      {
        "number": 1,
        "name": "Find Min by Determining if Smaller Numbers on Left or Right of Middle Binary Search",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "def findMin(self, nums: List[int]) -> int:\n\n        # Property of rotated sorted array:\n        # At some point, there will be an element that is splitting the array\n\n        # ------------------------\n\n        # T/F Function: compare mid to right\n\n        # Example 1:\n        # arr = [4, 5, 6, 7, 0, 1, 2]\n        # mid < right => 7 < 2 ==> false ==> smaller nums on right half of mid (excluding mid)\n\n        # Example 2:\n        # arr = [10, 1, 2, 3, 6, 7, 8] \n        # mid < right => 3 < 8 ==> true ==> smaller nums on left half of mid (including mid) \n\n        # ------------------------\n\n        # Invariant:\n        # The target min value is always in the search space [left, right]\n        # At each iteration we discard half of search space\n\n        # Defining search space\n        left, right = 0, len(nums) - 1\n        \n        # Check: if array is in original correct order\n        if nums[left] < nums[right]:\n            return nums[left]\n        \n        # Binary Search 2: \n        # Optimization Search Space: '<'\n        # Exits when left == right, as this mean answer has been optimized\n        # tc: binary search over k speeds O(log(n))\n        while left < right:\n\n            # Middle Target:\n            mid = (left + right) // 2\n            \n            # Mid is less than right\n            # Smaller elements are on the left of mid\n            # Discard higher elements on right side [mid, right]\n            # Include lower elements on left side, include lower mid element [left, mid]\n            if nums[mid] < nums[right]:\n                right = mid\n\n            # Mid is greater than right\n            # Smaller elements are on the right of mid\n            # Discard higher elements on left side with mid [left, mid]\n            # Include lower elements on right side, exclude larger mid element [mid+1, right]\n            else:\n                left = mid+1\n        \n        # Optimization Loop Termination:\n        # left == right\n        # The space of smaller elements, [left, right], has been reduced to one element\n        # This final element is the minimum element\n        \n        # overall: tc O(log n)\n        # overall: sc O(1)\n        return nums[left]",
        "questionNumber": 153,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-find-min-by-determining-if-smaller-numbers-on-left-or-right-of-middle-binary-search---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 1,
        "name": "Inequality Boundaries Discard Mid Binary Search",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "def search(self, nums: List[int], target: int) -> int:\n\n        # Property of rotated sorted array:\n        # At some point, there will be an element that is splitting the array\n\n\n        # Invariant:\n        # target, if exists, is in interval [left, right]\n        # interval [left, right] is always either \n        #   a) entirely sorted\n        #   b) contains a rotation\n        # search space halves each iteration\n\n        # Defining search space\n        left, right = 0, len(nums) - 1\n\n        # Binary Search 1: \n        # Target Binary Search Space: '<='        \n        # tc: binary search over list n length O(log n)\n        while left <= right:\n\n            # Current Search Space:\n            # [left, mid, right]\n\n            # Middle Target:\n            mid = (left + right) // 2 \n\n            # Base Case: target found\n            if nums[mid] == target:\n                return mid\n\n            # Check: if mid less than right\n            # Implies: right half of search space is sorted\n            # Implies: we have a guaranteed ascending range of: [mid, right]\n            if nums[mid] <= nums[right]:\n                \n                # Check: if target within ascending range of [mid, right]\n                # Implies: target is within right section\n                # Discard left side of search space: [left, mid]\n                # Search right side of previous space,\n                # exclude middle: [mid+1, right]\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1 \n                \n                # Check: if target not within ascending range of [mid, right]\n                # Implies: target is not with range (mid, right]\n                # Discard right side of search space: [mid, right] \n                # Search left side of previous space\n                # exclude middle: [left, mid-1]\n                else:\n                    right = mid - 1      \n\n            # Check: if mid is greater than right \n            # Implies: left half of search space is sorted\n            # Implies: we have a guaranteed ascending range of [left, mid]\n            else:\n\n                # Check: if target is within ascending range of [left, mid]\n                # Implies: target is within left section\n                # Discard right side of search space: [mid, right]\n                # Search left side of previous space,\n                # exclude middle: [left, mid-1]\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1 \n                \n                # Check: if target is not within ascending range of [left, mid]\n                # Implies: target is within right section\n                # Discard left side of search space: [left, mid]\n                # Search right side of previous space,\n                # exclude middle: [mid+1, right]\n                else:\n                    left = mid + 1\n\n        # End Case: out of search space, target not found\n\n        # overall: tc O(log n)\n        # overall: sc O(1)\n        return -1",
        "questionNumber": 33,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-inequality-boundaries-discard-mid-binary-search---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 1,
        "name": "Reverse Linear Scan",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "class TimeMap:\n\n        # TimeMap:\n        # We need to track \n\n        # Note:\n        # Stores multiple (value, timestamp) tuples per key in insertion order\n        # The 'get' function performs a reverse linear scan to find \n        # the latest time <= the query timestamp.\n        # 'get' can be slow if many timestamps per key O(m)\n\n        # sc: n is the total set calls across all keys O(n)\n        def __init__(self):\n            # key -> [(value, timestamp)]\n            self.store = {}\n\n        # overall: tc O(1) amortized\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            \n            # append to key list:  (value, timestamp)\n            if key not in self.store:\n                self.store[key] = []\n            self.store[key].append((value, timestamp))\n\n        # Reverse linear scan:\n        # overall: tc where m is number of timestamps for this key O(m)\n        def get(self, key: str, timestamp: int) -> str:\n            \n            # if key list does not exist\n            if key not in self.store:\n                return ''\n            \n            # grab key list: [(value, timestamp)]\n            values = self.store[key]\n\n            # outer boundaries\n            i = len(values) - 1\n            \n            # Reverse linear scan:\n            # grab first valid highest timestamp <= query\n            while 0 <= i and values[i][1] > timestamp:\n                i -= 1\n\n            # not found case: index -1\n            # or\n            # timestamp is now <= query\n            return values[i][0] if i != -1 else ''\n\n        # overall: tc O(m)\n        # overall: sc O(n)",
        "questionNumber": 981,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-reverse-linear-scan---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 1,
        "name": "Modified Binary Search over Towards Higher Slope",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "def findPeakElement(self, nums: List[int]) -> int:\n        \n        # Precondition:\n        # len(nums) >= 1\n        # nums[i] != nums[i+1] for all valid i\n\n        # Postcondition:\n        # returns index i such that nums[i] is a peak:\n        # nums[i] > nums[i-1] (if i > 0)\n        # nums[i] > nums[i+1] (if i < n-1)\n\n        left, right = 0, len(nums) - 1\n\n        # Invariant:\n        # At least one peak exists within interval [left, right]\n        # Half of search space removed per iteration\n\n        # Binary Search 2: \n        # Optimization Search Space: '<'\n        # Exits when left == right, as this mean answer has been optimized\n        # tc: binary search over O(log(n))\n        while left < right:\n            \n            # Current Search Space:\n            # [left, mid, right]\n\n            # Middle Target:\n            mid = (left + right) // 2\n\n            # Check: ii mid less than its following element\n            # Implies: peak is on the right side of mid\n            # Discard lower speeds on left side [left, mid]\n            # Search right side of previous space,\n            # and exclude mid: [mid+1, right]\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n\n            # Check: if mid greater than its following element\n            # Implies: peak is on left side of mid\n            # Discard lower speeds on right side [mid+1, right]\n            # Search left side of previous space,\n            # and include mid: [left, mid]\n            else:\n                right = mid\n\n        # Optimization Exit:\n        # left == right, answer has been optimized\n        # The space of larger elements, [left, right], \n        # has been reduced to one element\n        # This final element is the highest peak\n         \n        # overall: tc O(log n)\n        # overall: sc O(1)\n        return left",
        "questionNumber": 162,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-modified-binary-search-over-towards-higher-slope---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 1,
        "name": "Two Pointer Merge Until Median",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "def findMedianSortedArrays(self, nums1, nums2):\n        \n        # Precondition:\n        # nums1 and nums2 are sorted in non-decreasing order\n        # 0 <= len(nums1), len(nums2) <= 10^6\n\n        # Postcondition:\n        # Returns the median value of the merged sorted array\n        # If merged length is odd: median is the middle value\n        # If merged length is even: median is the average of the two middle values\n        \n        # Lengths of the two arrays\n        m, n = len(nums1), len(nums2)\n\n        # Pointers to the current index in nums1 and nums2\n        p1, p2 = 0, 0\n\n        # Helper function:\n        # simulating one step of merge by returning the smallest\n        # of the current elements pointed to by p1 and p2\n        def get_min():\n            nonlocal p1, p2\n\n            # Case 1: Both pointers in bounds\n            # Return the smaller element and advance the pointer\n            if p1 < m and p2 < n:\n\n                # p1 smaller\n                if nums1[p1] < nums2[p2]:\n                    ans = nums1[p1]\n                    p1 += 1\n                # p2 smaller\n                else:\n                    ans = nums2[p2]\n                    p2 += 1\n\n            # Case 2: One of the pointers is out of range\n            # Return the smaller element in the other pointer and advance\n            \n            # p2 out of bounds\n            elif p2 == n:\n                ans = nums1[p1]\n                p1 += 1\n            # p1 out of bounds\n            else:\n                ans = nums2[p2]\n                p2 += 1\n\n            # current smallest value between p1 and p2\n            return ans\n\n        # Invariant:\n        # At call i to get_min() (0 based indexing):\n        #   Returns (i+1)th smallest element\n        # After i calls to get_min():\n        #   i smallest elements have been discarded\n\n        # Note:\n        # Instead of merging the arrays fully, \n        # simulate merge only up to the median index.\n\n        # Note:\n        # For length k = m + n:\n        # If Odd: median is the k//2 element\n        #   k = 5 -> k // 2 = 2 (3rd smallest)\n\n        # If Even: median is average of (k//2)-1 and k//2\n        #   k = 6 -> (k // 2)-1 = 2   k//2 = 3  (3rd and 4th smallest)\n\n        # For odd length merged array\n        if (m+n)%2 == 1:\n\n            # Discard the first k//2 smallest elements\n            for i in range((m + n) // 2):\n                get_min()\n\n            # Return the k//2 smallest element\n            return get_min()\n\n        # For even length merged array\n        else:\n\n            # Discard the first (k//2 - 1) elements \n            for i in range((m + n) // 2 - 1):\n                get_min()\n\n            # Grab (k//2)-1\n            # Grab (k//2) \n            # Return average\n            return (get_min() + get_min()) / 2\n\n    # overall: time complexity O(m + n)\n    # overall: space complexity O(1)",
        "questionNumber": 4,
        "solutionLink": "/Notes/leetcode-binary-search#solution-1-two-pointer-merge-until-median---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 2,
        "name": "Binary Search Partition",
        "type": "binary-search",
        "application": "condition-adapted-binary-search",
        "code": "def findMedianSortedArrays(self, nums1, nums2):\n\n        # --------------------------------------------------\n        # Median of merged sorted array:\n        #   - If Odd: return the middle value = [o o * o o]\n        #   - If Even: return average of two middle values = [o * * o]\n\n        # nums1 = [1, 3, 8]\n        # nums2 = [7, 9, 10, 11]\n\n        # [1, 3, 7, 8, 9, 10, 11]\n        # odd Length => median = 8,\n        # --------------------------------------------------\n \n        # Partition Step:\n        # nums1: [1, 3 | 8]          => left max = 3, right min = 8 \n        # nums2: [7 | 9, 10, 11]     => left max = 7, right min = 9\n\n        # left: [1, 3, 7]\n        # right: [8, 9, 10, 11]\n\n        # --------------------------------------------------\n\n        # The Final Partition Must Pass These Conditions:\n        #\n        #   - left side has equal or more elements than right side:\n        #       odd: left side has 1 more element than right\n        #       even: left side has same number of elements than right\n        #\n        #   - every element on left is <= than every element on the right\n        #\n\n        # The Final Partition Will Point To The Median:\n        #   - Odd total length, median = max(left side)\n        #   - Even total length, median = (max(left side) + min(right side)) / 2\n\n        # Final Partition:\n        # nums1: [1, 3, 8 | ]       => left max = 8, right min = -\n        # nums2: [7 | 9, 10, 11]    => left max = 7, right min = 9\n\n        # odd Length => median = 8,\n    \n        # --------------------------------------------------\n        # Invariant:\n        # At each iteration, we maintain a partition (cut point) in nums1 (partitionX)\n        # and implicit partition (cut point) in nums2 (partitionY) such that:\n        #\n        #   1. Right Number Count <= Left num count\n        #\n        #   2. max left <= min right \n        #       & a left <= min right:\n        #\n        #   3. all left elements <= all right elements\n        \n        # --------------------------------------------------\n        # Ensures: nums1 is the smaller or equal array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        # Len of two arrays        \n        num1Len, num2Len = len(nums1), len(nums2)\n        \n        # Preparing for nums2 determination\n        totalLen = num1Len + num2Len\n        leftSize = (totalLen + 1) // 2   # how many elements should be on the left\n\n        # Search space for nums1 cut point: [0, len(nums1)]\n        nums1Left, nums1Right = 0, num1Len\n\n        # Binary Search 1:\n        # Target Binary Search Space: '<='\n        # Each iteration is a 'guess' in smaller array that partitions it,\n        # this 'guess' implicitly creates a second 'guess' in the the larger array as well\n        while nums1Left <= nums1Right:\n\n            # Current Search Space nums1 Cut:\n            # [low, mid, high]\n           \n            # nums1 Cut:\n            # guess cut point in nums1, and computer cut point in nums2 accordingly\n            nums1Guess = (nums1Left + nums1Right) // 2\n\n            # Invariant 1: Left num count >= Right num count\n            #\n            #   - nums1 cut grabs a certain number of elements from nums1 and assigns them to the\n            #     left or right side\n            #  \n            #   - this determines how many elements we need from nums2 for the left and right side\n            #     to keep invariant 1 true\n\n            # Examples:\n            #   nums1 = [1, 3, 8]        # num1Len = 3\n            #   nums2 = [7, 9, 10, 11]  # num2Len = 4\n            #   nums1Guess = 1 \n            # (6+1)//2 -> 3\n            nums2Determined = leftSize - nums1Guess\n\n            # Grab values for partitions\n            # Allow for our invariant condition to be possible\n            # after reaching out of bounds of array\n            # if num1MaxLeft <= num2MinRight and num2MaxLeft <= num1MinRight:\n\n            # If the left part of nums1 is empty (partitionX == 0), then the maximum of an empty set should not restrict the comparison.\n            # Setting num1MaxLeft = -inf ensures the condition num1MaxLeft <= num2MinRight is always satisfied in this case.\n            num1MaxLeft = float('-inf') if nums1Guess == 0 else nums1[nums1Guess - 1]\n            \n            # If the right part of nums1 is empty (partitionX == m), then there are no values to compare in the right half.\n            # Setting num1MinRight = +inf ensures the condition num2MaxLeft <= num1MinRight is always satisfied in this case.\n            num1MinRight = float('inf') if nums1Guess == num1Len else nums1[nums1Guess]\n\n            # If the left part of nums2 is empty (partitionY == 0), then the maximum of an empty set should not restrict the comparison.\n            # Setting num2MaxLeft = -inf ensures the condition num2MaxLeft <= num1MinRight is always satisfied in this case.\n            num2MaxLeft = float('-inf') if nums2Determined == 0 else nums2[nums2Determined - 1]\n            \n            # If the right part of nums2 is empty (partitionY == n), then the minimum of an empty set should not restrict the comparison.\n            # Setting num2MinRight = inf ensures the condition num1MaxLeft <= num2MinRight is always satisfied in this case.\n            num2MinRight = float('inf') if nums2Determined == num2Len else nums2[nums2Determined]\n\n            # Discard Mid via Partitions Rule:\n            # max of left partition nums1 < min of right partition of nums2\n            # max of left partition nums2 < min of right partition of nums1\n            # we have successfully split 'merged' array into halves\n            if num1MaxLeft <= num2MinRight and num2MaxLeft <= num1MinRight:\n\n                # Even Merged Array\n                if (nums1Len + nums2Len) % 2 == 0:\n                    return (max(num1MaxLeft, num2MaxLeft) + min(num1MinRight, num2MinRight)) / 2\n                \n                # Odd Merged Array:\n                else:\n                    return max(num1MaxLeft, num2MaxLeft)\n            \n            # Continue Split Monotonic Increasing Shift\n\n            # If num1MaxLeft > num2MinRight:\n            # Means largest element on the left side of nums1 partition is greater\n            # than the smallest element on the right side of nums2 partition\n            # Implies: our partitionX is too far right -> too many elements from nums1\n            # are in the left half\n\n            # Condition Breaks Invariant: num1MaxLeft <= num2MinRight\n\n            # Discard right half of [low, partitionX, high]\n            # new search interval: [low, partitionX - 1]\n            elif num1MaxLeft > num2MinRight:\n                nums1Right = nums1Guess - 1\n\n            # If num2MaxLeft > num1MinRight\n            # Means largest element on the left side of nums2 partition is greater\n            # than the smallest element on the right side of nums1 partition\n            # Implies: our partitionX is too far left -> not enough elements from nums1\n            # are in the left half\n\n            # Condition Breaks Invariant: num2MaxLeft <= num1MinRight\n\n            # Discard left half of [low, partitionX, high]\n            # new search interval: [partition + 1, high] \n            elif num2MaxLeft > num1MinRight:\n                nums1Left = nums1Guess + 1 \n\n\n        # overall: time complexity O(log (min(m, n)))\n        # overall: space complexity O(1)",
        "questionNumber": 4,
        "solutionLink": "/Notes/leetcode-binary-search#solution-2-binary-search-partition---binary-searchcondition-adapted-binary-search",
        "blog": "LeetCode: Binary Search"
      }
    ],
    "upper-ceiling-or-lower-floor-trick-based-on-target-binary-search": [
      {
        "number": 2,
        "name": "Upper Ceiling to Find First Invalid TimeStamp",
        "type": "binary-search",
        "application": "upper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
        "code": "class TimeMap:\n\n        # Note:\n        # Upper Ceiling Trick:\n        # We cannot directly optimize for 'timestamp <= target' using '<=' via this binary search.\n        # Instead, optimize for the condition 'timestamp < target' (strictly greater than).\n        # The search finds the index of the first timestamp greater than the target.\n        # After, we shift the pointer by one (left - 1) to get the largest timestamp <= target.\n\n        # Note:\n        # Stores (value, timestamp) tuples per key in insertion order (sorted by timestamp)\n        # 'get' uses binary search to find the largest timestamp <= the query timestamp.\n        # 'get' more efficient O(log m)\n\n        # space complexity: n is the total set calls across all keys O(n)\n        def __init__(self):\n            # key -> [(value, timestamp)]\n            self.store = {}\n\n        # overall: time complexity amortized O(1)\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            \n            # append to key list:  (value, timestamp)\n            if key not in self.store:\n                self.store[key] = []\n            self.store[key].append((value, timestamp))\n\n        # overall: time complexity where m is number of timestamps for this key O(log m)\n        def get(self, key: str, timestamp: int) -> str:\n\n            # Precondition:\n            # self.store[key] contains (value, timestamp) pairs sorted ascending by timestamp\n            # timestamp is an integer >= 1\n\n            # Postcondition:\n            # returns value with largest timestamp <= given timestamp\n            # returns '' if none exists\n\n            # Empty Check\n            if key not in self.store:\n                return ''\n            \n            values = self.store[key]\n            \n\n            # Upper Ceiling Binary Search Shift Trick: \n            # In order to find: highest timestamp <= query\n            # First first: query < min timestamp \n            # Then shift index: find highest timestamp <= query\n            \n            # outer boundaries\n            # intentionally start right at len(values)\n            left, right = 0, len(values)\n            \n            # Loop invariant:\n            # 1. 0 <= left <= right <= len(values)\n            # 2. forall i :: 0 <= i < left ==> values[i][1] <= timestamp\n            # 3. forall j :: right <= j < len(values) ==> values[j][1] > timestamp\n            \n            # Interpretation:\n            # all indices before 'left' are valid timestamps <= query\n            # all indices after 'right' are invalid timestamps > query\n\n            # When loop exits (left == right)\n            # left points to first invalid timestamp > query (if any)\n            # left-1 points to largest valid timestamp <= query or -1 if none exists\n\n            # time complexity: binary search over time stamps O(log(m))\n            while left < right:\n                \n                mid = (left + right) // 2\n\n                # If timestamp is greater than query timestamp -> valid\n                if values[mid][1] > timestamp:\n                    right = mid\n                \n                # If timestamp is less than or equal to query timestamp -> invalid\n                else:\n                    left = mid + 1\n\n            # Found smallest timestamp > query:\n            # If we shift index by 1 -> largest timestamp <= query:\n            # Or ''\n            return values[left - 1][0] if left != 0 else ''      \n\n        # overall: time complexity O(log m)\n        # overall: space complexity O(n)",
        "questionNumber": 981,
        "solutionLink": "/Notes/leetcode-binary-search#solution-2-upper-ceiling-to-find-first-invalid-timestamp---binary-searchupper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
        "blog": "LeetCode: Binary Search"
      },
      {
        "number": 3,
        "name": "Floor Search Tracking Largest Valid Index With Right Pointer",
        "type": "binary-search",
        "application": "upper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
        "code": "class TimeMap:\n\n        def __init__(self):\n            self.mp = {}\n            \n\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            # put a key: val -> to a timestamp\n            item = (timestamp, value)\n            if key not in self.mp:\n                self.mp[key] = []\n            \n            self.mp[key].append(item)\n\n\n        def get(self, key: str, timestamp: int) -> str:\n            \n            # Precondition:\n            # self.map[key] contains sorted (timestamp, value) pairs by ascending timestamp\n            # timestamp is an int >= 1\n\n            # Postcondition:\n            # returns value with largest timestamp <= given timestamp\n            # returns empty string if no such timestamp exists\n\n            # Empty Case\n            if key not in self.mp:\n                return ''\n\n            values = self.mp[key]\n            \n            # Edge Case:\n            # If timestamp >= end of array timestamp, return last value\n            if timestamp >= values[-1][0]:\n                return values[-1][1]\n\n            left, right = 0, len(values)-1\n\n            # Loop invariant:\n            # 1. 0 <= left <= right + 1 <= len(values)\n            # 2. All values before 'left' have timestamp <= query timestamp\n            # 3. All values after 'right' have timestamp > query timestamp\n\n            # Ensures:\n            # When left > right, right points to \n            # the largest timestamp <= query or -1 if none exists            \n            while left <= right:\n                mid = (left + right) // 2\n                time, val = values[mid]\n\n                # found target\n                if time == timestamp:\n                    return val\n\n                # if time larger than query: reduce right side\n                elif time > timestamp:\n                    right = mid - 1\n\n                # if time smaller than request: reduce left side\n                else:\n                    left = mid + 1\n                    \n            # refer to postcondition\n            return value_list[right][1] if right != -1 else ''",
        "questionNumber": 981,
        "solutionLink": "/Notes/leetcode-binary-search#solution-3-floor-search-tracking-largest-valid-index-with-right-pointer---binary-searchupper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
        "blog": "LeetCode: Binary Search"
      }
    ]
  },
  "sliding-window": {
    "variable-size-window": [
      {
        "number": 1,
        "name": "Explicit Sliding Window Tracking Min Price and Max Profit",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # Variable Size Sliding Window => [left, right]\n        # 1. left points to day we buy (lowest price so far)\n        # 2. right scans forward best profit day (highest sell price -> highest profit)\n        # 3. Get profit:\n        #    if prices[left] < prices[right]: profit possible, update max_profit\n        #    if prices[left] > prices[right]: lower buy found, update left\n        # Result: finds lowest buy and highest profit\n\n        n = len(prices)\n\n        # Lowest buy price day index, curr sell price day index\n        left, right = 0, 1\n\n        # max profit so far\n        max_profit = 0\n\n        # time complexity: iterate over list of n days\n        while right < n:\n\n            # curr day higher than min\n            if prices[left] < prices[right]:\n                \n                # calculate possible profit, update max_profit\n                profit = prices[right] - prices[left]\n                max_profit = max(max_profit, profit)\n\n            # Curr day lower than min\n            else:\n                left = right\n\n            # iterate curr day\n            right += 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
        "questionNumber": 121,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-sliding-window-tracking-min-price-and-max-profit---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 2,
        "name": "Implicit Sliding Window Tracking Min Price and Max Profit",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n        \n        # Note:\n        # Variable Size Sliding Window => [left, right]\n        # 1. left points to day we buy (lowest price so far)\n        # 2. right scans forward for best profit day (highest sell price -> highest profit)\n        # 3. Get profit:\n        #    if prices[left] < prices[right]: profit possible, update max_profit\n        #    if prices[left] > prices[right]: lower buy found, update left\n        # Result: finds lowest buy and highest profit\n        \n        # Lowest Buy Day so far (+inf)\n        left = float('inf')\n        \n        # max profit so far\n        max_profit = 0\n\n        # time complexity: iterate over list of n prices O(n)\n        for right in prices:\n\n            # profit possible\n            if left < right:\n                profit = right - left\n                max_profit = max(max_profit, profit)\n\n            # new min buy day found\n            else:\n                left = right\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
        "questionNumber": 121,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-2-implicit-sliding-window-tracking-min-price-and-max-profit---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 3,
        "name": "Table Dynamic Programming",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # 1. DP[i][0] = highest profit so far\n        #    DP[i][1] = lowest buy price so far\n        # 2. At each day update [0] and [1]:\n        #    [0] = max(highest profit so far, profit from using lowest buy price so far against today sell price)\n        #    [1] = min(lowest buy price so far, todays buy price)\n    \n        # Empty check\n        if not prices:\n            return 0\n\n        n = len(prices)\n\n        # 2D array of n rows with 2 columns\n        # [i][0] -> max profit at day i\n        # [i][1] -> min buying price at day i\n        dp = [[0]*2 for _ in range(n)]\n\n        # set up dynamic programming table first iteration:\n\n        # min price up to day 0\n        dp[0][0] = -prices[0]\n        # max profit up to day 0\n        dp[0][1] = 0\n\n\n        # time complexity: iterate across n days for prices O(n)\n        for i in range(1, n):\n\n            # update min price\n            dp[i][0] = max(dp[i-1][0], -prices[i])            \n            # update max profit\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return dp[-1][1]",
        "questionNumber": 121,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-3-table-dynamic-programming---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 4,
        "name": "State Compression Dynamic Programming",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # 1.  Compress DP O(n) table to O(1)\n        #     min_price = min price up to day i\n        #     max_profit = max profit up to day i\n        # # 2. At each day update min and max:\n        #     min_price = min(lowest price so far vs todays buy price)\n        #     max_profit = max(highest profit so far vs profit from todays sell price - lowest buy price)\n        # Result: Max profit at day n\n\n        n = len(prices)\n\n        # set up compressed dynamic programming table first iteration:        \n        # [i][0] -> min buying price up to day i\n        # [i][1] -> max profit up to day i\n\n        # min price up to day 0\n        min_price = -prices[0]\n        # max profit up to day 0\n        max_profit = 0\n\n\n        # time complexity: iterate over n day prices O(n)\n        for i in range(1, n):\n            \n            # update compressed dp table, (for up to day i)\n          \n            # update min price\n            min_price = max(min_price, -prices[i])\n            # update max profit\n            max_profit = max(max_profit, min_price + prices[i])  \n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
        "questionNumber": 121,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-4-state-compression-dynamic-programming---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 1,
        "name": "Enumerate Char Most Recent Index Within Window Validation Two Pointer Sliding Window",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def lengthOfLongestSubstring(self, s: str) -> int:\n\n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> most recent index\n        # 1. move right pointer forward while no duplicates, \n        # 2. If duplicate found, move left to index after oldest duplicate\n        # 3. Update max length after processing each character.\n        # Result: max length without repeating characters\n\n        # char -> most recent index\n        char_MRI = {} \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # time complexity: iterate over string n length O(n)\n        for right, new_char in enumerate(s):\n\n            # check if char already found and within curr window\n            if new_char in char_MRI and left <= char_MRI[new_char]:\n                \n                # duplicate exists, move left -> oldest index + 1\n                left = char_MRI[new_char] + 1\n            \n            # update most recent index for curr char\n            char_MRI[new_char] = right\n\n            # get new length\n            new_length = right - left + 1\n\n            # update string length\n            max_len = max(max_len, new_length)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
        "questionNumber": 3,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-enumerate-char-most-recent-index-within-window-validation-two-pointer-sliding-window---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 2,
        "name": "Explicit Loop Char Most Recent Index Within Window Validation Two Pointer Sliding Window",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def lengthOfLongestSubstring(self, s: str) -> int:\n\n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> most recent index\n        # 1. move right pointer forward while no duplicates, \n        # 2. If duplicate found, move left to index after oldest duplicate\n        # 3. Update max length after processing each character.\n        # Result: max length without repeating characters\n\n        # char -> most recent index\n        char_MRI = {} \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # total prices\n        n = len(s)\n\n        # time complexity: iterate over string n length O(n)\n        for right in range(n):\n\n            new_char = s[right]\n\n            # check if new_char already found\n            if new_char in char_MRI:\n\n                # check if new_char within current window\n                if left <= char_MRI[new_char]:\n                \n                    # duplicate found,\n                    # move left: oldest index + 1\n                    left = char_MRI[new_char] + 1\n            \n            # update most recent index for curr new_char\n            char_MRI[new_char] = right\n            new_length = right - left + 1\n\n            # update string length\n            max_len = max(max_len, new_length)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
        "questionNumber": 3,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-2-explicit-loop-char-most-recent-index-within-window-validation-two-pointer-sliding-window---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 1,
        "name": "Explicit Two Pointer Sliding Window",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def characterReplacement(self, s: str, k: int) -> int:\n        \n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> count\n\n        # Note:\n        # Idea: extend window via right,\n        # keep count of chars within the window,\n        # keep count of highest count char within window,\n        # shrink the window via left shift.\n\n        # needed replacements:\n        # (window size - count of most frequent char within window),\n        # is higher than available replacements: k\n        # then we shrink the window from the left.\n\n        # char -> count\n        count = defaultdict(int)\n\n        # max_freq: max count across all chars in count hashmap\n        max_freq = 0  \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # time complexity: iterate right pointer over string n length O(n)\n        for right in range(len(s)):\n\n            # intake new char, increase count\n            count[s[right]] = count.get(s[right], 0) + 1\n\n            # update max_freq\n            max_freq = max(max_freq, count[s[right]])\n\n            # check if window shrink required:\n            # needed replacements > available replacements\n            if (right - left + 1) - max_freq > k:\n\n                # decrease char count and shrink window\n                count[s[left]] -= 1\n                left += 1  \n\n            # update max_len\n            max_len = max(max_len, right - left + 1)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
        "questionNumber": 424,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-two-pointer-sliding-window---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 1,
        "name": "Classic Sliding Window with Two Hashmaps",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def checkInclusion(self, s1: str, s2: str) -> bool:\n\n        # Note:\n        # 1. Uses two hashmaps:\n        # 2. Expands right pointer until all required chars are included\n        # 3. Shifts left pointer to shrink window while maintaining validity\n        # 4. Tracks smallest valid window found so far\n        # Result: returns smallest substring containing all chars of t or \"\"\n\n        # t len > s len: substring not possible\n        if len(t) > len(s):\n            return \"\"\n\n        # t char count\n        target_freq = defaultdict(int)\n        for char in t:\n            target_freq[char] += 1\n\n        # sliding window char count\n        window_freq = defaultdict(int)\n\n        # Number of unique chars from t needed  \n        need = len(target_freq)     \n\n        # Number of chars from t that meet the required count\n        have = 0                          \n\n        # min substring\n        min_len = float(\"inf\")\n\n        # Variable Sliding Window => [left, right]\n        left = 0\n\n        # \n        res_start = 0\n\n        # time complexity: iterate right over list s of n length O(n)\n        for right in range(len(s)):\n\n            # extending window, update char count\n            char = s[right]\n            window_freq[char] += 1\n\n            # Check if this character satisfies the required t frequency\n            if char in target_freq and window_freq[char] == target_freq[char]:\n                have += 1\n\n            # shrink window while frequencies are valid\n            while have == need:\n                \n                # curr window\n                window_len = right - left + 1\n                \n                # update min length, mark start of min window\n                if window_len < min_len:\n                    min_len = window_len\n                    res_start = left\n\n                # reduce char count and shrink window\n                left_char = s[left]\n                window_freq[left_char] -= 1\n                \n                # check if frequencies are valid\n                if left_char in target_freq and window_freq[left_char] < target_freq[left_char]:\n                    have -= 1\n\n                # iterate\n                left += 1\n\n        # if at least one valid sub string exists, return\n        if min_len != float(\"inf\"):\n            res = s[res_start:res_start + min_len]\n\n        # no sub string found, return \"\"\n        else: \n            res = \"\"\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 76,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-classic-sliding-window-with-two-hashmaps---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 2,
        "name": "Single Hashmap + Remaining Required Tracker",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def minWindow(self, s1: str, s2: str) -> bool:\n\n        # Note:\n        # 1. Single hashmap to track remaining required chars\n        # 2. Expands right pointer while decreasing count of matched chars\n        # 3. When all chars matches, contracts left pointer\n        # 4. Tracks smallest window\n        # 5. Returns smallest substring containing all chars of t (or \"\" if none)\n\n        # t len > s len: substring not possible\n        if len(s) < len(t):\n            return \"\"\n\n        # t char count\n        char_count = defaultdict(int)\n        for ch in t:\n            char_count[ch] += 1\n\n        # Total num of characters (with duplicates) still needed\n        target_chars_remaining = len(t)         \n\n        # (start_index, end_index)\n        min_window = (0, float(\"inf\"))          \n\n        # Left pointer\n        start_index = 0                         \n\n        # time complexity: iterate right over s2 of n length O(n)\n        for end_index, ch in enumerate(s):\n\n            # Expand right\n            if char_count[ch] > 0:\n                # One needed character matched\n                target_chars_remaining -= 1     \n\n            # Always decrement (can go negative)\n            char_count[ch] -= 1                 \n\n            # Once we have matched all characters\n            if target_chars_remaining == 0:\n                # Shrink from left as much as possible\n                while True:\n                    char_at_start = s[start_index]\n                    if char_count[char_at_start] == 0:\n                        break                   # Cannot remove this char without breaking\n                    char_count[char_at_start] += 1\n                    start_index += 1\n\n                # Check if current window is smaller\n                if end_index - start_index < min_window[1] - min_window[0]:\n                    min_window = (start_index, end_index)\n\n                # Shrink window by 1 to move forward\n                char_count[s[start_index]] += 1\n                target_chars_remaining += 1\n                start_index += 1\n\n        # Extract window if found\n        if min_window[1] > len(s):\n            res = \"\"\n        else: \n            res = s[min_window[0]:min_window[1]+1]\n\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 76,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-2-single-hashmap-remaining-required-tracker---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 1,
        "name": "Heap (Priority Queue) Approach",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Use a max heap (negative value min heap), to keep track of\n        #    potential max values in the current window\n        # 2. Each heap entry is (-value, index) so max is at top\n        # 3. Before taking max from heap, pop all elements that are outside of \n        #    of the current window (index <= i - k)\n        # 4. Append the top of the heap (largest value) to the result for each window\n\n        # Empty check\n        if not nums or k == 0:\n            return []\n\n        # list of max values for each window\n        result = []\n\n        # max heap (min heap with negative values)\n        # (-value, index)\n        heap = []  \n\n        # Initialize the first window:\n        # push all elements to the max heap\n        for i in range(k):\n            heapq.heappush(heap, (-nums[i], i))\n\n        # append curr window max to result list, after k values added to queue\n        peek_max = -heap[0][0]\n        result.append(peek_max)\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(k, len(nums)):\n\n            # Push new element: (-value, index)\n            heapq.heappush(heap, (-nums[i], i))\n\n            # we only care about elements affecting the current max\n            # so we pop the top of the heap,\n            # while elements are out of the current window range\n            while heap[0][1] <= i - k:\n                # removes top stale element\n                heapq.heappop(heap)\n\n            # max is guaranteed to be within current window range\n            # append curr window max to result list\n            peek_max = -heap[0][0]\n            result.append(peek_max)\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(k)\n        return result",
        "questionNumber": 239,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-heap-priority-queue-approach---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 2,
        "name": "Sliding Window + Monotonic Queue",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Use a dequeue to store elements in decreasing order to track max\n        # 2. Maintain the dequeue such that front has max element for current window\n        # 3. When sliding the window:\n        #    Remove elements smaller than incoming element from back of dequeue\n        #    Remove outgoing element from the front if it equals element leaving the window\n        # 4. Append the front element of the dequeue (curr max) to results after each slide\n\n        # Empty check\n        if not nums or k == 0:\n            return []\n\n        res = []\n\n        # stores elements in decreasing order\n        dq = deque([])\n\n        # put k element in the dequeue and make sure the max is at the front\n        for i in range(k):\n            while (dq and nums[i] > dq[-1]):\n                dq.pop()\n            dq.append(nums[i])\n\n        # append current max for first window\n        res.append(dq[0])\n\n        # slide window from k to end\n        for i in range(k, len(nums)):\n\n            # remove element leaving the window from front if it matches\n            if (nums[i - k] == dq[0]):\n                dq.popleft()\n\n            # \n            while (dq and nums[i] > dq[-1]):\n                dq.pop()\n\n            # append new elem max\n            dq.append(nums[i])\n            \n            # append current max\n            res.append(dq[0])\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 239,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-2-sliding-window-monotonic-queue---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 3,
        "name": "Block Partition Precomputed Maxes",
        "type": "sliding-window",
        "application": "variable-size-window",
        "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Precompute max in fixed-size blocks:\n        #    - left_max[i]: max from block start to i\n        #    - right_max[i]: max from block end to i (scanned backwards)\n        # 2. For window starting at i, max = max(right_max[i], left_max[i+k-1])\n        #    - right_max[i] covers block starting at i\n        #    - left_max[i+k-1] covers block ending at i+k-1\n        # 3. Eliminates need for deque by reusing block maxima\n\n        n = len(nums)\n        if not nums or k == 0:\n            return []\n\n        left_max = [0] * n\n        right_max = [0] * n\n\n        # Fill left_max: scanning forward\n        for i in range(n):\n            if i % k == 0:\n                left_max[i] = nums[i]  # Block start\n            else:\n                left_max[i] = max(left_max[i-1], nums[i])\n\n        # Fill right_max: scanning backward\n        for i in range(n-1, -1, -1):\n            if (i+1) % k == 0 or i == n-1:\n                right_max[i] = nums[i]  # Block end\n            else:\n                right_max[i] = max(right_max[i+1], nums[i])\n\n        # Compute sliding window max\n        res = []\n        for i in range(n-k+1):\n            res.append(max(right_max[i], left_max[i+k-1]))\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 239,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-3-block-partition-precomputed-maxes---sliding-windowvariable-size-window",
        "blog": "LeetCode: Sliding Window"
      }
    ],
    "fixed-size-window": [
      {
        "number": 1,
        "name": "Explicit Two Pointer Sliding Window",
        "type": "sliding-window",
        "application": "fixed-size-window",
        "code": "def checkInclusion(s1: str, s2: str) -> bool:\n\n        # Note:\n        # Fixed Sliding Window => [left, right] of len (s1)\n\n        # Note:\n        # 1. Track char count in s1 and sliding window\n        # 2. right extends to fit len(s1)\n        # 3. shift left and right to fit len(s1)\n        # 4. If char count match, permutation exist\n\n        # s1 len > s2 len: permutation not possible\n        len_s1, len_s2 = len(s1), len(s2)\n        if len_s1 > len_s2:\n            return False\n\n        # s1 char count\n        freq_s1 = {}\n        for ch in s1:\n            freq_s1[ch] = freq_s1.get(ch, 0) + 1\n\n        # sliding window char count\n        window_freq = {}\n        \n        # Fixed sliding window [left, right]\n        left = 0\n\n        # time complexity: iterate right over string s2 n length O(n)\n        for right in range(len_s2):\n\n            # extend sliding window, update char count\n            window_freq[s2[right]] = window_freq.get(s2[right], 0) + 1\n\n            # reduce sliding window if size > s1\n            if right - left + 1 > len_s1:\n\n                # decrease char count and shift left\n                left_char = s2[left]\n                window_freq[left_char] -= 1\n\n                # remove if frequency reaches 0\n                if window_freq[left_char] == 0:\n                    del window_freq[left_char]\n\n                # iterate left pointer\n                left += 1\n\n            # counts match, permutation exists\n            if window_freq == freq_s1:\n                return True\n\n        # no permutation found\n\n        # overall: time complexity O(n) \n        # overall: space complexity O(n)\n        return False",
        "questionNumber": 567,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-two-pointer-sliding-window---sliding-windowfixed-size-window",
        "blog": "LeetCode: Sliding Window"
      },
      {
        "number": 2,
        "name": "Explicit Two Pointer Sliding Window",
        "type": "sliding-window",
        "application": "fixed-size-window",
        "code": "def checkInclusion(s1: str, s2: str) -> bool:\n        \n        # Note:\n        # 1. Fixed sliding window of len(s1)\n        # 2. Two Count arrays size 26 for s1 and window\n        # 3. Track chars arrays between arrays that match with count\n        # 4. Window slides:\n        #    Add new char and update matches\n        #    Remove old char and updates matches\n        # 5. If matches == 26, permutation s1 exists in window and s2\n        # Results: validate if permutation of s1 exists in s2\n\n        # s1 len > s2 len: permutation not possible\n        len_s1, len_s2 = len(s1), len(s2)\n        if len_s1 > len_s2:\n            return False\n\n        # s1 and window counts\n        freq_s1 = [0] * 26\n        freq_window = [0] * 26\n\n        # char count for s1\n        for ch in s1:\n            freq_s1[ord(ch) - ord('a')] += 1\n        \n        # char count for first window in s2\n        for ch in s2[:len_s1]:\n            freq_window[ord(ch) - ord('a')] += 1\n\n        # Matches: \n        # number of positions between s1 and window counts where count matches\n        matches = sum(1 for i in range(26) if freq_s1[i] == freq_window[i])\n\n        # Fixed Size Window => [left, right] for len(s1)\n        left = 0\n\n        # time complexity: iterate right over list of n length O(n)\n        for right in range(len_s1, len_s2):\n            \n            # if count arrays match between s1 and window: permutation exists\n            if matches == 26:\n                return True\n\n            # Add new char to window\n            index_add = ord(s2[right]) - ord('a')\n            freq_window[index_add] += 1\n\n            # update matches for added char\n            if freq_window[index_add] == freq_s1[index_add]:\n                matches += 1\n            elif freq_window[index_add] == freq_s1[index_add] + 1:\n                matches -= 1\n\n            # Remove char going out of window\n            index_remove = ord(s2[left]) - ord('a')\n            freq_window[index_remove] -= 1\n\n            # update matches for removed char\n            if freq_window[index_remove] == freq_s1[index_remove]:\n                matches += 1\n            elif freq_window[index_remove] == freq_s1[index_remove] - 1:\n                matches -= 1\n            left += 1\n\n        # overall: time complexity \n        # overall: space complexity \n        return matches == 26",
        "questionNumber": 567,
        "solutionLink": "/Notes/leetcode-sliding-window#solution-2-explicit-two-pointer-sliding-window---sliding-windowfixed-size-window",
        "blog": "LeetCode: Sliding Window"
      }
    ]
  },
  "linked-list": {
    "simple-traversal": [
      {
        "number": 1,
        "name": "Recursive Linked List Building",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseList(self, node: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To reverse a linked list, we simply have to update the parents to\n        # point to their children,\n        # and to have the original head to point to None:\n        #   None <- () <- () <- ()\n        #   None <- (1) <- (3) <- (7)\n\n        # head = [1,2,3,4,5]\n        # head = [5,4,3,2,1]\n\n        # Base case: \n        # reached tail of original list, start to pass tail node as the new head\n        if node == None or node.next == None:\n            return node\n\n        # Recursion: \n        # call reverse list on the rest of the list (head.next to end)\n        # once we hit base case, we will pass back the new head (tail of original)\n        final_head = self.reverseList(node.next)\n\n        # Grab current nodes next element:\n        parent = node.next\n\n        # Recursion Note: \n        # Due to recursion, the parent is currently pointing to None \n        # (updated in previous call)\n        # Now we just update parent to point to child node (finish reversing the flow):\n        parent.next = node\n\n        # Recursion Note:\n        # This node may or may not be the new tail, or a parent to a node\n        # For now we point it to None, and either:\n        #   - it gets updated in the previous recursion call, and gets pointed to its child\n        #   - it was the original head, and it stays pointing to None, as it becomes the new tail\n        node.next = None\n\n        # Continue passing back new head (tail of original), \n        # passed from the deepest recursive call\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return final_head",
        "questionNumber": 206,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive-linked-list-building---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Recursive Clean Learning Not Linked List Building",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseList(self, node: Optional[ListNode]) -> Optional[ListNode]:\n                \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To reverse a linked list, we simply have to update the parents to\n        # point to their children,\n        # and to have the original head to point to None:\n        #   None <- () <- () <- ()\n        #   None <- (1) <- (3) <- (7)\n\n        # head = [1,2,3,4,5]\n        # head = [5,4,3,2,1]\n\n        # See Solution 1 Notes:\n        # Same as previous, just simplified with 'not'\n        if not node or not node.next:\n            return node\n\n        new_head = self.reverseList(head.next)\n        \n        parent = node.next\n        parent.next = node\n\n        node.next = None\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return new_head",
        "questionNumber": 206,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-recursive-clean-learning-not-linked-list-building---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 3,
        "name": "Iterative Linked List Building",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To reverse a linked list, we simply have to update the parents to\n        # point to their children,\n        # and to have the original head to point to None:\n        #   None <- () <- () <- ()\n        #   None <- (1) <- (3) <- (7)\n\n        # head = [1,2,3,4,5]\n        # head = [5,4,3,2,1]\n\n        # Creating a 'None' so the new tail can point at it\n        prev = None\n\n        # Curr will point to the previous element\n        curr = head\n\n        # Until we have reached past the tail of the original list,\n        # keep updating the current node to point to the previous node\n        # tc: iterate over n O(n)\n        while curr != None:\n\n            # Grab next node before disconnecting current nodes link,\n            # and updating to previous.\n            # We need the next node in order to iterate forward\n            next_node = curr.next  \n\n            # Disconnect current element, and point to previous node: \n            # <- prev    curr -> next \n            # <- prev <- curr    next \n            curr.next = prev      \n\n            # Advance both prev and curr using our saved next node\n            prev = curr            \n            curr = next_node       \n\n        # Loop exits: \n        # curr has passed the original tail\n        # prev is at the original tail\n        # original tail becomes the new head\n        # so just return original tail (prev)\n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return prev",
        "questionNumber": 206,
        "solutionLink": "/Notes/leetcode-linked-list#solution-3-iterative-linked-list-building---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 4,
        "name": "Iterative Clean Learning Not Linked List Building",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To reverse a linked list, we simply have to update the parents to\n        # point to their children,\n        # and to have the original head to point to None:\n        #   None <- () <- () <- ()\n        #   None <- (1) <- (3) <- (7)\n\n        # head = [1,2,3,4,5]\n        # head = [5,4,3,2,1]\n\n        prev = None\n        curr = head\n\n        # See Solution 1 Notes:\n        # Same as previous, just simplified with an implied 'not'\n        while curr:\n\n            next_node = curr.next  \n\n            curr.next = prev      \n\n            prev = curr            \n            curr = next_node       \n\n        # overall: tc O(n)\n        # overall: sc O(1)\n        return prev",
        "questionNumber": 206,
        "solutionLink": "/Notes/leetcode-linked-list#solution-4-iterative-clean-learning-not-linked-list-building---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Recursive",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To merge two linked lists, we simply iterate through both at the same time,\n        # and link the lower value as the child:\n        #   (1) -> (3) -> (7) -> None\n        #   (2) -> (9) -> (10) -> None\n        #   (1) -> (2) -> (3) -> (7) -> (9) -> (10) -> None\n\n        # head = [1, 3, 7]\n        # head = [2, 9, 10]\n        # head = [1, 2, 3, 7, 9, 10]\n      \n        # Base case: \n        # Implies: at least 1 list is empty\n        # Then: point list to the rest of the non empty list\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n\n        # Recursive Call:\n        # Check: Find smaller value between list1 and list2\n        # Implies: list1 node is smaller\n        if list1.val < list2.val:\n\n            # Grab next list1 node for iteration\n            nextList1 = list1.next\n            # Append smaller node from list1, point to following element\n            # that will be returned from recursive call\n            list1.next = self.mergeTwoLists(nextList1, list2)\n            # return current node to previous recursive call\n            return list1\n        else:\n\n            # Grab next list2 node for iteration\n            nextList2 = list2.next\n            # Append smaller node from list2, point to following element\n            # that will be returned from recursive call\n            list2.next = self.mergeTwoLists(list1, nextList2)\n            # return current node to previous recursive call\n            return list2\n\n        # overall: tc O(n)\n        # overall: sc O(n)",
        "questionNumber": 21,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Sentinel Anchor Iterative Building Linked List",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To merge two linked lists, we simply iterate through both at the same time,\n        # and link the lower value as the child:\n        #   (1) -> (3) -> (7) -> None\n        #   (2) -> (9) -> (10) -> None\n        #   (1) -> (2) -> (3) -> (7) -> (9) -> (10) -> None\n\n        # head = [1, 3, 7]\n        # head = [2, 9, 10]\n        # head = [1, 2, 3, 7, 9, 10]\n\n        # Linked List 2:\n        # Sentinel Anchor: 'ListNode(-1)'\n        # DummyHead is used to:\n        #   - Enter the iterative loop cleanly\n        #     without handling first node assigning case.\n        #   - Exit with a node pointing to new head\n        dummyHead = ListNode(-1)  \n\n        # Curr node of list\n        tail = dummyHead\n\n        # Check: if both lists have nodes\n        # Implies: need to do comparison between nodes\n        # Implies will traverse both lists until at least 1 runs out of nodes\n        # tc: iterate over both lists O(m + n)\n        while list1 and list2:\n\n            # Check: Find smaller value between list1 and list2\n            # Implies: list1 node is smaller\n            if list1.val < list2.val:\n                # Append smaller node from list1\n                tail.next = list1   \n                # Iterate list1  \n                list1 = list1.next  \n\n            # Check: Find smaller value between list1 and list2\n            # Implies: list2 node is smaller\n            else:\n                # Append smaller node from list2\n                tail.next = list2\n                # Iterate list2\n                list2 = list2.next    \n\n            # Iterate tail to node we just added\n            tail = tail.next          \n\n        # Implies: at least 1 list is empty\n        # Then: point list to the rest of the non empty list\n        if list1:\n            tail.next = list1\n        else:\n            tail.next = list2\n\n        # DummyHead is still pointing to new head, \n        # grab and return the new head\n        original_head = dummyHead.next\n\n        # overall: tc O(m + n)\n        # overall: sc O(1)\n        return original_head",
        "questionNumber": 21,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-sentinel-anchor-iterative-building-linked-list---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Track Visited Notes",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def hasCycle(self, head: Optional[ListNode]) -> bool:\n        \n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To check if a linked list, we simply keep track of nodes we\n        # have visited, and see if we see them again as we iterate \n        #   (1) -> (3) -> (7) -> (9)\n        #                  ^      |     (cycle)\n        #                  |      v\n        #                 (11)<- (10)\n                \n        # Nodes are stored by obj reference\n        visited = set()\n\n        # Start iteration\n        curr = head\n        \n\n        # Check: if we have passed tail of list\n        # tc: iterate over n O(n)\n        while curr:\n\n            # Check: is current node in seen list\n            # Implies: we have passed through as cycle\n            if curr in visited:\n                return True\n\n            # Implies: have not seen current node\n            # Then: add to seen list, continue iteration\n            visited.add(curr)\n            \n            # Iterate\n            curr = curr.next\n        \n        # Implies: have passed tail of list, no cycles encountered\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return False",
        "questionNumber": 141,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-track-visited-notes---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Floyd Cycle Detection Tortoise and Hare [SC Opt]",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def hasCycle(self, head: Optional[ListNode]) -> bool:\n        \n        # Tortoise And Hare:\n        # We will iterate the linked list using 2 pointers\n        #   - a pointer going 2x speed (slow/tortoise)\n        #   - a pointer going 1x speed (fast/hare)\n\n        # Cycle Detection:\n        # If there is a cycle:\n        #   - fast pointer will catch up with slow pointer\n        # If there is no cycle:\n        #   - fast pointer will reach end of list\n\n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (3) -> (7) -> None\n\n        # To check if a linked list, we simply keep track of nodes we\n        # have visited, and see if we see them again as we iterate \n        #   (1) -> (3) -> (7) -> (9)\n        #                  ^      |     (cycle)\n        #                  |      v\n        #                 (11)<- (10)\n\n        # tortoise and hare pointers\n        slow, fast = head, head\n        \n        # Check: has fast pointer reached end of list\n        # Implies: fast pointer still valid node, check if cycle detected\n        # tc: iterate over n O(n) \n        while fast and fast.next:\n\n            # Iterate slow pointer by 1x and fast by 2x\n            slow = slow.next\n            fast = fast.next.next\n            \n            # Check: did fast catch up with slow\n            # Implies: fast went through a cycle\n            if slow == fast:\n                return True\n\n        # Implies: fast has reached end of list, never caught up with slow\n        # Implies: no cycle in list\n        \n        # overall: tc O(n)\n        # overall: sc O(1)\n        return False",
        "questionNumber": 141,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-floyd-cycle-detection-tortoise-and-hare-sc-opt---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Slow.next Explicit Set Tail of Final List Two Way Disconnect Iteration Reversal",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Recursive Linked Lists:\n        # A linked list is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #   () -> () -> () -> None\n        #   (1) -> (2) -> (3) -> (4) -> (5) None\n\n        # To reorder the linked list, we simply have to define the pattern to reorder:\n        #   (1) -> (2) -> (3) -> (4) -> (5) None\n        #   (1) -> (5) -> (2) -> (4) -> (3) None\n\n        # Is actually just:\n        # list1 =>   (1) -> (2) -> (3) -> None\n        # list2 =>      (5) -> (4) -> None     (+)\n        # -----------------------------------------\n\n        # So we need to create:\n        #   - First half of the list\n        #   - Reversed second half of list\n        # And then join them together\n\n        # First Half Of List \n        #   - keep pointing to original head\n        #   - stop iteration at half\n        #   - point middle to None to split list in half\n\n        # Reversed Second Half Of List\n        #   - stop iteration at half\n        #   - keep pointing at middle element\n        #   - reverse list starting at middle element\n\n        # Join the two elements\n        #   - iterate over forward and reversed list\n        #   - add in correct order \n \n\n        # 1. Finding Half Point Of Original List And Split List\n        slow = fast = head\n        while fast and fast.next:\n            # slow travels half distance vs fast pointer\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # prev for reverse tail\n        prev = None\n        \n        # Set Curr:\n\n        # Odd List:\n        # curr = slow.next, (mid.next)\n        # left will be 1 element longer (keeps mid element), right does not\n\n        # Even List:\n        # curr = slow.next, (mid2.next)\n        # left will be 2 elements longer (keeps mid1 and mid2), right does not\n\n        curr = slow.next\n\n        # Explicit Disconnect:\n        # Set slow (belonging solely to left list)\n        # to slow -> None\n        slow.next = None \n\n        # 2. Reverse Second Half Of List\n        while curr:\n            # grab next\n            next_node = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate \n            prev = curr\n            curr = next_node\n\n        # iterate over left half and right half\n        left, right = head, prev\n\n\n        # 3. Connect First Half And Reversed Second Half:\n\n        # Explicit Termination:\n        # right half is always than the left half (by 1 or 2 nodes)\n        # when we terminate right,\n        # right.next = next_left guarantees that \n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Explicit Disconnect'\n        # our merged list will terminate\n        while right:\n            # grab next before disconnect\n            next_left, next_right = left.next, right.next\n            # alternate flow\n            left.next = right\n            right.next = next_left\n            # iterate left and right half -> connect next_nodes\n            left, right = next_left, next_right\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
        "questionNumber": 143,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-slow-next-explicit-set-tail-of-final-list-two-way-disconnect-iteration-reversal---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Shared Slow Between Left and Right List Implicit Disconnect",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note\n        # 1. Use Tortoise and Hare to find midpoint.\n        # 2. Reverse the second half in place (without disconnecting manually)\n        # 3. Merge first and reversed second half alternating nodes\n        # Result: Fully in place reordering\n\n        slow = fast = head\n        while fast and fast.next:\n            # slow travels half distance vs fast pointer: iterate references in memory\n            fast = fast.next.next\n            slow = slow.next\n        \n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # prev for reverse tail\n        prev = None\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow, (mid)\n        # left and right will be even (both keep mid element)\n\n        # Even List:\n        # curr = slow, (mid2)\n        # left will be 1 element longer (keeps mid1 and mid2), (right keeps mid2)\n\n        curr = slow\n\n        # Implicit Disconnect:\n        # Both left and right contain slow (either odd mid or mid2) in their list\n        # during the first modification of slow, we point it to prev (None)\n        # now, both lists have a slow.next -> None\n\n        # Reverse second half of list:\n        while curr:\n            # grab next before disconnect\n            next_node = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate reference in memory\n            prev = curr\n            curr = next_node\n\n        # iterate over left and right lists\n        left, right = head, prev\n\n        # Implicit Termination:\n        # Now since:\n        # left equal or longer by 1,\n        # slow -> None is contained by both lists,\n        # we will reach right's copy of slow\n        # at the same time or earlier by 1 iteration.\n        # However, when we reach right's copy,\n        # right.next = next_left guarantees that\n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Implicit Disconnect'\n        # our merged list will terminate\n        while right != slow:\n            next_left, next_right = left.next, right.next\n            left.next = right\n            right.next = next_left\n            left, right = next_left, next_right\n\n        # brain teaser:\n        # why does this work:\n        right.next = None\n        # but right.next.next = None \n        # does not work\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
        "questionNumber": 143,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-shared-slow-between-left-and-right-list-implicit-disconnect---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 3,
        "name": "Stack",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note:\n        # 1. Use Tortoise Hare to find the middle\n        # 2. Iterate over right half in order and store elements in stack\n        # 3. Pop all elements (in reverse order) and place in between left elements:\n        # left -> right -> left.next\n        # Result: Fully reordered\n\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n        \n        # store right half list in order\n        # space complexity: store half list of n length O(n)\n        stack = []\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow.next, (mid.next)\n        # left will be 1 element longer (keeps mid element), right does not\n\n        # Even List:\n        # curr = slow.next, (mid2.next)\n        # left will be 2 elements longer (keeps mid1 and mid2), right does not\n\n        curr = slow.next \n\n        # Explicit Disconnect:\n        # Set slow (belonging solely to left list)\n        # to slow -> None      \n        slow.next = None  \n\n        # time complexity: iterate over list of n length O(n)\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        # forward iteration over list \n        left = head\n\n        # Odd List Len: left will be 1 element longer (keeps mid element)\n        # Even List Len: left is 2 elements longer (keeps 1st and 2nd mid elements)\n\n        # Explicit Termination:\n        # right half stack is always than the left half (by 1 or 2 nodes)\n        # when we terminate right,\n        # right.next = next_left guarantees that \n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Explicit Disconnect'\n        # our merged list will terminate\n        # time complexity: iterate over stack O(n)\n        while stack:\n\n            # iterate over right half\n            right = stack.pop()\n\n            # set: left -> right -> left.next \n            right.next = left.next\n            left.next = right\n\n            # iterate left list\n            left = right.next\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)",
        "questionNumber": 143,
        "solutionLink": "/Notes/leetcode-linked-list#solution-3-stack---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 4,
        "name": "Brain Teaser slow longer or equal Right list Stack",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note:\n        # 1. Use Tortoise Hare to find the middle\n        # 2. Iterate over right half in order and store elements in stack\n        # 3. Pop all elements (in reverse order) and place in between left elements:\n        # left -> right -> left.next\n        # Result: Fully reordered\n\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # store right half list in order\n        # space complexity: store list of n length O(n)\n        stack = []\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow, (mid)\n        # left and right will be even (both keep mid element)\n\n        # Even List:\n        # curr = slow, (mid2)\n        # left will be 1 element longer (keeps mid1 and mid2), (right keeps mid2)\n    \n        curr = slow \n\n        # No Implicit Disconnect:\n        # (deal with that later)\n        \n        # time complexity: iterate over list of n length O(n)\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        # iterate over left list \n        left = head\n\n        # time complexity: iterate over stack O(n)\n        while stack:\n\n            # grab right half node element\n            right = stack.pop()\n\n            # place right half node in between left half curr and curr.next: \n            # curr -> tail -> curr.next \n            right.next = left.next\n            left.next = right\n\n            # iterate left half of list\n            left = right.next\n\n        # brain teaser:\n        # why does this work:\n        # Odd/Even Case:\n        # left is equal or longer by 1 node\n        # Odd: \n        # left and right are equal in length, both share 'slow'\n        # so at the last iteration, left -> right -> left.next\n        # but we never disconnected, so left slow -> right slow\n        # and since they share the same object in memory\n        # this does not matter since it is pointing to itself\n        # Even:\n        # left is longer by 1, both share 'slow'\n        # last iteration, right slow -> left slow\n        # but we never disconnected, so left slow -> right slow\n        # and since they share the same object in memory\n        # this does not matter since it is pointing to itself\n        right.next.next.next.next.next = None\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)",
        "questionNumber": 143,
        "solutionLink": "/Notes/leetcode-linked-list#solution-4-brain-teaser-slow-longer-or-equal-right-list-stack---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Two Pass Get Length and Stop Prev to Removal Index",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Traverse list once to calculate total length\n        # 2. Use a dummy node to handle edge cases (like removing head)\n        # 3. Traverse again, stop at node prior to removal index\n        # 4. point prior.next = prior.next.next, disconnecting removal node\n        # Result: removed node at distance n from end of list\n\n        # First pass: get length of list\n        listLen = 0\n        curr = head\n        while curr:\n            listLen += 1\n            curr = curr.next\n\n        # Second pass: find the node behind target index\n\n        remove = listLen - n\n\n        # we adding an element to the list\n        dummy = ListNode(0, head)\n        curr = dummy\n\n        # this stops at the Node before the target remove index\n        # thus we can disconnect it\n        index = 0\n        while index != remove:\n            index += 1\n            curr = curr.next\n        \n        # remove nth node from end by skipping it\n        curr.next = curr.next.next\n\n        # Return head dummy is pointing to (may be different from original)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return dummy.next",
        "questionNumber": 19,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-two-pass-get-length-and-stop-prev-to-removal-index---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "One Pass Fast Slow with HeadStart of N+1",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Use two pointers spaced n+1 apart (fast and slow)\n        # 2. Move both pointers until fast hits end\n        # 3. Slow pointer will be right before the node to remove\n        # 4. Remove node by skipping it\n       \n        dummy = ListNode(-1, head)\n        slow = fast = dummy\n        \n        # Set fast pointer: \n        # head start of n + 1 step,\n        # in order to create a gap of n between fast and slow\n        # (taking dummy node into account)\n        index = 0\n        while index != n+1:\n            index += 1\n            fast = fast.next\n        \n        # When fast reaches end:\n        # n + 1 gap between slow (within list) and fast (end of list)\n        while fast:\n            fast = fast.next\n            slow = slow.next\n        \n        # skip nth node\n        slow.next = slow.next.next\n\n        # Return head dummy is pointing to (may be different from original)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return dummy.next",
        "questionNumber": 19,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-one-pass-fast-slow-with-headstart-of-n-1---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Two Pass Hashmap Create Nodes and Set Next and Random Deep References",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # .get() returns 'None' if nothing exists,\n        # so perfect for our use case\n\n        # Note:\n        # 1. Traverse once: create all nodes (no wiring of next/random yet)\n        # 2. Use a dictionary to map old nodes -> new nodes\n        # 3. Traverse Twice: wire up both next and random using the map\n        # 4. Return deep copy of head\n\n        # Empty Check\n        if not head:\n            return None\n\n        # Orig node -> deep node copy\n        orig_to_deepCopy = {}\n\n        # Iteration 1: \n        # Copy all nodes values (no next/random pointers yet)\n        curr = head\n        while curr:\n            # create\n            copy = Node(curr.val)\n            # insert\n            orig_to_deepCopy[curr] = copy\n            # iterate\n            curr = curr.next\n\n        # Iteration 2:\n        # All nodes created, now assign next and random pointers\n        curr = head\n        while curr:\n            # grab curr deepCopy\n            copy = orig_to_deepCopy[curr]\n            # grab and set next and random deepCopy (value could be None, .get() returns None by default if no answer exists)\n            copy.next = orig_to_deepCopy.get(curr.next)\n            copy.random = orig_to_deepCopy.get(curr.random)\n            # iterate\n            curr = curr.next\n\n        # Return deep copy of the head node\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return orig_to_deepCopy[head]",
        "questionNumber": 138,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-two-pass-hashmap-create-nodes-and-set-next-and-random-deep-references---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Memoization Lazy Construction One Pass Hashmap",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # 1. Maintain a memo dictionary to store mapping on the fly\n        # 2. Iterate once through original list while building the copy\n        # 3. Create each copy node only whe first encountered (lazy construction)\n        # 4. Maintain a pointer to build out the next chain\n\n        # Empty check\n        if not head:\n            return None\n        \n        # dummy node head trick\n        dummy = Node(-1)\n\n        # prev allows deepCopy to connect once we create them lazily\n        # for the entire deepCopy list as we go\n        prev = dummy\n        curr = head\n\n        # orig -> deepCopy\n        memo = {}\n        \n        # time complexity: iterate over list of n length\n        while curr:\n            \n            # grab or create and grab curr deepCopy\n            if curr not in memo:\n                memo[curr] = Node(curr.val)\n            currDeepCopy = memo[curr]\n            \n            # validate curr.random\n            if curr.random:\n                # grab or create and grab curr.random deepCopy\n                if curr.random not in memo:\n                    memo[curr.random] = Node(curr.random.val)\n                currDeepCopy.random = memo[curr.random]\n            \n            # First iteration: dummy points to deepCopy head\n            # next iteration: previous deepCopy node points to current deepCopy node \n            # after termination: entire deepCopy list is now connected\n            prev.next = currDeepCopy\n\n            # iterate to current deepCopy node connect next node\n            # iterate over original list\n            prev = prev.next\n            curr = curr.next\n        \n        # Return deepCopy head\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n\n        return memo[head]\n        # or\n        # return dummy.next",
        "questionNumber": 138,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-memoization-lazy-construction-one-pass-hashmap---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 3,
        "name": "Three Pass In Place Interleaving Technique",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # 1. First interleave copy and paste nodes between original nodes O(1) space\n        #    A -> B -> C ===> A -> A' -> B -> B' -> C -> C'\n        \n        # 2. Assign random pointers to the copy nodes using original's .random\n\n        # 3. Detach copy list from original (restoring original list) \n        #    and setting valid .next for deepCopy list\n        #    A -> A' -> B -> B' -> C -> C' ===> A' -> B' -> C'\n        \n        # 4. Return deepCopy head\n        # Result: constant space within original list, but requires 3 passes \n        \n        # Empty Check\n        if not head:\n            return None\n\n        # Interleave deepCopy nodes\n        # A -> A' -> B -> B' -> C -> C'\n        curr = head\n        while curr:\n            # create and interweave\n            deepCopy = Node(curr.val)\n            deepCopy.next = curr.next\n\n            # link A -> A' and iterate to next orig\n            curr.next = deepCopy\n            curr = deepCopy.next\n\n        # Assign random pointers\n        curr = head\n        while curr:\n            # grab intertwined deepCopy\n            deepCopy = curr.next\n\n            # assign random from orig if non None\n            if curr.random:\n                deepCopy.random = curr.random.next\n\n            # iterate to next orig\n            curr = deepCopy.next\n\n        # Split orig and deepCopy list\n        # (A) orig head: A -> A' -> B -> ...\n        curr = head\n        # (A') deepCopy head: A -> A' -> B -> ...\n        deepCopyHead = head.next\n\n        # time complexity: iterate over list of 2n length O(n)\n        while curr:\n            # grab deepCopy\n            deepCopy = curr.next\n            \n            # link orig to next orig node, iterate to next orig\n            # A -> A' -> B -> ...\n            # A -> B\n            curr.next = deepCopy.next\n            curr = curr.next\n\n            # if new orig is non None \n            # (B' -> C -> ...) vs (B' -> None)\n            # there will exists a new deepCopy\n            # iterate to deepCopy\n            if curr:\n                deepCopy.next = curr.next\n\n        # return deepCopy head\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return deepCopyHead",
        "questionNumber": 138,
        "solutionLink": "/Notes/leetcode-linked-list#solution-3-three-pass-in-place-interleaving-technique---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Recursive",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        \n        # Note:\n        # 1. Recursion to simulate digit addition with carry\n        # 2. Add Corresponding digits with carry passed to recursive call\n        # 3. Current node created with .next -> recursively created node\n        # 4. Base case: both lists empty and carry is 0\n        # Result: new sum list created recursively\n        \n        # time complexity: iterate over two lists of m and n length O(max(m, n))\n        # space complexity: recursive call over two lists of m and n length O(max(m, n))\n        def recursiveSum(l1, l2, carry):\n            \n            # Base Case:\n            # Both lists and carry are empty\n            if not l1 and not l2 and carry == 0:\n                return None\n\n            # grab values if exist\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            # sum\n            sum = val1 + val2 + carry\n            carry = sum//10\n\n            # iterate lists if exist\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n            # new node and attach\n            newNode = ListNode(sum % 10)\n            newNode.next = recursiveSum(l1, l2, carry)\n\n            # return: curr node -> rest of list\n            return newNode\n\n        # calculate new sum list over two lists\n\n        # overall: time complexity O(max(m, n))\n        # overall: space complexity O(max(m, n))\n        return recursiveSum(l1, l2, 0)",
        "questionNumber": 2,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Iterative",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        \n        # Note:\n        # 1. Dummy node to create a sum list\n        # 2. Iterate over both lists until complete\n        # 3. Added values node by node, and pass the carry\n        # Result: sum of two lists\n\n        # dummy trick to return curr head\n        dummy = ListNode(-1)\n        prev = dummy\n        carry = 0\n\n        # Traverse while either list or carry is non empty\n        while l1 or l2 or carry:\n            \n            # grab if value exists\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # add values and carry\n            sum = v1 + v2 + carry\n            carry = sum // 10\n\n            # create new Node for new value  \n            newNode = ListNode(sum % 10)\n            prev.next = newNode\n            prev = prev.next\n\n            # iterate list\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n\n        # return new head of sum list\n\n        # overall: time complexity O(max(m, n))\n        # overall: space complexity O(1)\n        return dummy.next",
        "questionNumber": 2,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-iterative---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Max Bit Length Duplicate Flips",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def findDuplicate(self, nums: List[int]) -> int:\n        \n        # Note:\n        # 1. Idea: Compare bit counts between full nums list and range [1..n]\n        # 2. Duplicate number will cause extra set bits in some positions\n        # 3. Identify bits where counts mismatch, reconstruct duplicate from bits\n\n        n = len(nums) - 1\n        bit_reconstruction = 0\n\n        # max_bits = how many binary bits needed to represent the largest number\n        # determines how many bit positions we need to check\n        # [1, 3, 4, 2, 2] -> 4 bit_length is 3 bits (100 binary) \n        # we will check bit positions 0, 1, 2\n        max_bit = max(num.bit_length() for num in nums)\n\n        # building duplicate number by iterating over each available bit position\n        # bit = 0 -> mask = 1 (binary 001)\n        # bit = 1 -> mask = 2 (binary 010)\n        # bit = 2 -> mask = 3 (binary 100)\n        for bit in range(max_bit):\n\n            # current mask\n            # 0 -> 1 << 0 = 0001\n            # 1 -> 1 << 1 = 0010\n            # 2 -> 1 << 2 = 0100\n            # 3 -> 1 << 3 = 1000\n            mask = 1 << bit\n\n            # for each num in array, count if bit is set\n            # &: bitwise AND\n            # sets current bit to 1 if both mask and bit are set to 1\n            # else sets current bit to 0,\n            # determines if current num has the bit set\n            curr_bit_set_count = sum((num & mask) > 0 for num in nums)\n\n            # across expected range [1..n], sum if bit is expected to be set\n            # &: bitwise AND\n            # checks how many numbers within range [1..n]\n            # are expected to have current bit set.\n            expected_bit_set_count = sum((i & mask) > 0 for i in range(1, n + 1))\n\n            # compare bit set to expected bit set,\n            # if bit is set more times than expected\n            # duplicate number must have that bit set:\n            # add it to bit reconstruction\n            if curr_bit_set_count > expected_bit_set_count:\n                bit_reconstruction |= mask\n        \n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return bit_reconstruction",
        "questionNumber": 287,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-max-bit-length-duplicate-flips---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Pigeonhole Over Range 1 to N Then Count Array Binary Search",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def findDuplicate(self, nums: List[int]) -> int:\n\n        # Note:\n        # Idea: Duplicate number must satisfy pigeonhole principle:\n        #   With n+1 numbers range [1..n], at least one value is duplicated\n        #  (n containers, n+1 pigeons -> at least one container has two pigeons)\n        \n        # 1. Binary search on value range [1..n]\n        # 2. For mid value:\n        #    mid = number of containers in lower half (including mid)\n        #    count = numbers of pigeons (nums <= mid) in lower half\n        # 3. Decision:\n        #   If count <= mid -> equal or lesser pigeons to containers -> duplicate is in upper half\n        #   Else count > mid -> more pigeons than containers -> duplicate is in lower half\n\n        # smallest value 1\n        # largest value n (but we have n+1) n+1 - 1 -> n (the largest value)\n        left, right = 1, len(nums) - 1\n\n        # [ 1 4 3 5 2 ], for some n,\n        # there must be n-1 numbers below:\n        # for 2, there is 1 number below\n        # for 5, there are 4 numbers below\n        # Binary optimization search: '<'\n        while left < right:\n            \n            mid = (left + right) // 2\n\n            # count how many numbers <= mid\n            curr_count = sum(num <= mid for num in nums)\n\n            # if count <= mid, there are no extra numbers in lower half:\n            # duplicate must be in upper half\n            if curr_count <= mid:\n                left = mid + 1\n\n            # if count > mid, there are too many numbers in lower half:\n            # duplicate must be in lower half\n            else:\n                right = mid\n\n        # Loop exit: left == right\n        # left and right are pointing at duplicate number\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return left",
        "questionNumber": 287,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-pigeonhole-over-range-1-to-n-then-count-array-binary-search---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 3,
        "name": "Head to Start of Cycle Proof Floyd Tortoise and Hare",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def findDuplicate(self, nums: List[int]) -> int:\n\n        # Note:\n        # 1. definitions\n        # L = distance from head to start of cycle\n        # C = length of the cycle (number of nodes in the cycle)\n        # x = distance from the start of the cycle to the meeting point inside the cycle\n        # k = number of full cycles the fast pointer has completed by the time of the first meeting\n\n        # 2. setup\n        # When slow and fast pointers first meet inside the cycle:\n        \n        # Slow pointer has traveled: L + x steps:\n        #    L steps to reach the start of the cycle\n        #    x steps inside the cycle to the meeting pointer\n\n        # Fast pointer has traveled L + x + (k * C) steps:\n        #    L steps to reach the start of the cycle\n        #    x steps inside the cycle to the meeting point\n        #    k full extra loops around the cycle (each length C)\n\n        # Fast Substitute:\n        # By definition, fast pointer speed is double slow pointer, so substitute\n        #     L + x + (k * C) = 2(L + x)\n        \n        # Solve for L:\n        #     L + x + kC = 2L + 2x\n        #     kX = L + x\n        #     L = kC - x \n\n        # Rewrite Rule Context:\n        # Traveling x steps inside cycle of length C =\n        # to traveling C - x steps backwards, due to wrap around\n        # x steps forward = C - x backwards\n\n        # 3. Rearrange\n        #    L = kC - x\n        #    L = kC + (C - x)\n\n        #    L = kC + (C - x)   <-- this proves moving slow to right will cover\n\n        # once we move slow to the head:\n        # L -> distance from head to start of cycle\n\n        # fast will stay at the meeting point:\n        # kC + (C - x)\n\n        # kC -> number of cycles (we can ignore this)\n        # (C - x) -> steps remaining to get to the start (since we have traveled x steps already)\n\n        # L = (C - x)\n        # so both slow and fast will travel the same amount of steps \n        # to get to the start of the cycle\n\n\n        # The above math proves the below algorithm:\n\n        # Note:\n        # Idea: Treat array as linked list: index -> nums[index]\n        #    Problem set up with duplicate guarantees cycle in linked list representation\n        \n        # 1. Detect cycle (slow = nums[slow], fast = nums[nums[fast]])\n        # 2. Move slow to head, advance both one step at a time to find cycle start (duplicate)\n\n        # Find meeting point in cycle\n        slow = nums[0]\n        fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # Move slow to head, move fast and slow one step at time,\n        # fast and slow will meet at start of cycle\n        slow = nums[0]\n        while True:\n            if slow == fast:\n                break\n            slow = nums[slow]\n            fast = nums[fast]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return slow",
        "questionNumber": 287,
        "solutionLink": "/Notes/leetcode-linked-list#solution-3-head-to-start-of-cycle-proof-floyd-tortoise-and-hare---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Doubly Linked List with Hashmap",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "class Node:\n    def __init__(self, key: int, val: int):\n\n        # key -> value node\n        self.key = key\n        self.val = val\n        # doubly linked prev and next\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n\n        # list capacity\n        self.capacity = capacity\n\n        # key -> Node\n        self.cache = {} \n\n        # MRU head\n        self.head = Node(0, 0)\n        # LRU tail\n        self.tail = Node(0, 0)\n\n        # set dummy head and tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def _remove_node(self, node: Node):\n\n        # Remove node from doubly linked list by linked neighbors\n        prev, next = node.prev, node.next\n        prev.next = next\n        next.prev = prev\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def _push_MRU(self, node: Node):\n\n        # Insert node between dummy head and MRU \n        node.next = self.head.next\n        node.prev = self.head\n\n        # Update head and 2nd MRU\n        self.head.next = node\n        node.next.prev = node\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def get(self, key: int) -> int:       \n\n        # if node does not exist, return -1\n        if key not in self.cache:\n            return -1\n\n        # grab node\n        node = self.cache[key]\n\n        # Move node and update MRU\n        self._remove_node(node)\n        self._push_MRU(node)\n\n        # return val\n        return node.val\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def put(self, key: int, value: int) -> None:\n\n        # If key exists, remove to avoid duplicates,\n        # need to grab node to update prev and next nodes\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove_node(node)\n\n            # update existing node\n            node.val = value\n\n        # If key does not exist, create new node set to new value\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n\n        # push updates node to top of MRU\n        self._push_MRU(node)\n\n        # Remove LRU if capacity broken\n        if len(self.cache) > self.capacity:\n            lruNode = self.tail.prev\n            self._remove_node(lruNode)\n            self.cache.pop(lruNode.key)\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(1)",
        "questionNumber": 146,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-doubly-linked-list-with-hashmap---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Python Implementation OrderedDict a Doubly Linked List with Hashmap",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "class LRUCache:\n    def __init__(self, capacity: int):\n        \n        # OrderedDict in Python is implemented internally\n        # as a doubly linked list + hashmap (same as our solution):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    # time complexity: O(1) \n    # space complexity: O(1)\n    def get(self, key: int) -> int:\n\n        # Check if key exists, else return -1\n        if key not in self.cache:\n            return -1\n\n        # Update MRU\n        self.cache.move_to_end(key)\n\n        # return value\n        return self.cache[key]\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def put(self, key: int, value: int) -> None:\n\n        # If key exists, remove to avoid duplicates\n        if key in self.cache:\n            self.cache.pop(key)\n        \n        # Insert new value, automatically updates MRU,\n        # automatically updates doubly linked list\n        self.cache[key] = value\n        \n        # capacity exceeded, remove LRU\n        if len(self.cache) > self.capacity:\n            \n            # last=True -> pops MRU\n            # last=False -> pops LRU\n            self.cache.popitem(last=False)\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(1)",
        "questionNumber": 146,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-python-implementation-ordereddict-a-doubly-linked-list-with-hashmap---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Min Heap Priority Queue",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. minHeap stores current head for each sorted list\n        # 2. minHeap sorted by value, list_index breaking ties: \n        #    (value, list_index, node)\n        # 3. smallest value across heads added to list\n        # 4. push to minHeap to replaced added node\n        # Result: merge list in O(n log k)\n\n        # minHeap of: (val, list index, node)\n        min_heap = []\n\n        # Push the head of each non-empty list into the heap\n        for i_list, head_list in enumerate(lists):\n            if head_list:\n                # minHeap sorted by node.val,\n                # i_list index used to break ties\n                heappush(min_heap, (head_list.val, i_list, head_list))  \n\n        dummy = ListNode(-1)\n        prev = dummy\n\n        # Pop smallest node, attach to merged list, push from same list if min.next\n        while min_heap:\n\n            # grab min value\n            minVal, i_list, node = heappop(min_heap)\n            prev.next = node\n            prev = prev.next\n\n            # valid node.next for current i_list\n            if node.next:\n                # grab next node from i_list\n                heappush(min_heap, (node.next.val, i_list, node.next))\n\n        # minHeap empty -> all lists empty\n        # return head of merged list\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(k)\n        return dummy.next",
        "questionNumber": 23,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-min-heap-priority-queue---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Merge Pair of List at a Time with Standard Merge Two Sorted Linked List",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Merge lists in pairs with standard merge two sorted lists\n        # 2. Each round halves the total number of lists -> O(log k) rounds\n        # 3. Each round processes all nodes (across all merges) -> O(n) work per round\n        # Result: Merging k lists in place\n        \n        # Empty check\n        if not lists: \n            return None\n\n        # Merge two sorted linked lists\n        # time complexity: iterate over lists of n length O(n)\n        def mergeTwo(l1, l2):\n\n            # dummy node trick\n            dummy = ListNode(-1)\n            prev = dummy\n\n            # merge while both lists non empty\n            while l1 and l2:\n                # grab smaller head\n                if l1.val < l2.val:\n                    prev.next = l1\n                    l1 = l1.next\n                else:\n                    prev.next = l2\n                    l2 = l2.next\n                # iterate\n                prev = prev.next\n\n            # attach remaining list \n            if not l1:\n                prev.next = l2 \n            else:\n                prev.next = l1\n\n            # return merged new merged list\n            return dummy.next\n\n        # iteratively merge lists in pairs until one list remains\n        # time complexity: log(len(list)) total merges\n        while len(lists) > 1:\n            merged = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                merged.append(mergeTwo(l1, l2))\n            lists = merged\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(1)\n        return lists[0]",
        "questionNumber": 23,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-merge-pair-of-list-at-a-time-with-standard-merge-two-sorted-linked-list---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 1,
        "name": "Recursive",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Check if there are at least k nodes ahead (otherwise return head)\n        # 2. Reverse the first k nodes\n        # 3. Recurse and process sub list\n        # 4. Connect reversed head with resulting sub list\n        # Result: original lists with reversed groups of k length\n\n        # Base case: check if at least k nodes remain\n        kLen = 0\n        node = head\n        while node and kLen < k:\n            kLen += 1\n            node = node.next\n\n        # Base case: less than k nodes, return head\n        if kLen < k:\n            return head  \n\n        # ----\n        # standard reverse linked list\n\n        # Reverse current sub list up to k\n        prev = None\n        curr = head\n        for _ in range(k):\n            # grab next\n            next = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate\n            prev = curr\n            curr = next\n        \n        # curr -> start of next sub list\n        # prev -> new head of curr sub list\n        # head -> new tail of curr sub list\n        # connect head (new tail) via head.next to next reversed sub list\n        head.next = self.reverseKGroup(curr, k)\n        \n        # return prev (new head) of curr sub list\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n/k) ~ O(n) recursive stack\n        return prev",
        "questionNumber": 25,
        "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      },
      {
        "number": 2,
        "name": "Iterative",
        "type": "linked-list",
        "application": "simple-traversal",
        "code": "def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Dummy node handles head swaps cleanly\n        # 2. For each sub list:\n        #    Find the kth node\n        #    Reverse the group in place\n        #    Connect previous reverse group's tail to head of new reversed group\n        # 3. Continue until remaining nodes < k, then return\n\n        # dummy node trick for head of overall list\n        dummy = ListNode(0, head)\n\n        # group_prev_tail points to tail of the previous reverse group,\n        # where group.next points to head of next list\n        group_prev_tail = dummy\n\n        # while remaining sub list is greater than k\n        while True:\n\n            # last item in previous reversed sub list\n            kth_elem = group_prev_tail\n            # check if k more elements exist\n            for _ in range(k):\n                kth_elem = kth_elem.next\n\n                # less than k nodes remain, return head of entire list\n                if not kth_elem:\n                    return dummy.next \n\n            # next sub list start\n            group_next = kth_elem.next\n\n            # ----\n            # standard reverse linked list\n\n            # Reverse group [group_prev_tail.next, kth]\n            prev = group_next\n            curr = group_prev_tail.next\n\n            # Reverse group in place for nodes [0, k):\n            for _ in range(k):\n                # grab next\n                next = curr.next\n                # reverse flow\n                curr.next = prev\n                # iterate\n                prev = curr\n                curr = next\n\n            # group_prev_tail -> (new tail) of prev sub list\n            # curr -> head of next sub list\n            # prev -> (new head) of curr sub list\n            # group_prev_tail.next -> (new tail) of curr sub list\n\n            # ----\n            # connect new tail of previous sub list \n            # to new head of curr sub list\n\n            # last node of previous group, still pointing to original head,\n            # which is now the tail \n            curr_tail = group_prev_tail.next\n            \n            # point last node of previous group, to new head of curr sub list\n            group_prev_tail.next = prev\n            # update last node of previous group, to last node of curr sub list\n            group_prev_tail = curr_tail\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
        "questionNumber": 25,
        "solutionLink": "/Notes/leetcode-linked-list#solution-2-iterative---linked-listsimple-traversal",
        "blog": "LeetCode: Linked List"
      }
    ]
  },
  "tree": {
    "dfs-post-order-recursive-two-sided-bottom-up": [
      {
        "number": 1,
        "name": "Recursive DFS Post Order Pass Up Inverted Subtrees",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To invert a tree, we simply have to swap \n        # the L and R children nodes at each node:\n        #       1\n        #      / \\\n        #     3   2\n        #    / \\\n        #   4   5\n\n        # DFS PostOrder: \n        # left -> right -> root\n        #   1. Process left node: invert children nodes\n        #   2. Process right node: invert children nodes\n        #   3. Process root node: invert left and right nodes\n\n        # Base case: reached leaf of tree, no swap, return None\n        if not root:\n            return None\n\n        # Recursive call to process left subtrees\n        left_inverted = self.invertTree(root.left)\n\n        # Recursive call to process right subtrees\n        right_inverted = self.invertTree(root.right)\n\n        # Could have also been: right -> left subtrees\n        # right_inverted = self.invertTree(root.right)\n        # left_inverted = self.invertTree(root.left)\n\n        # Process Root: \n        # Invert left and right nodes\n        root.left = right_inverted\n        root.right = left_inverted\n\n        # Return invert to previous recursive call\n\n        # overall: tc O(n)\n        # overall: sc O(h), O(log n) for balanced tree\n        return root",
        "questionNumber": 226,
        "solutionLink": "/Notes/leetcode-trees#solution-1-recursive-dfs-post-order-pass-up-inverted-subtrees---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "Iterative DFS Post Order Carry Up Inverted Subtrees",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To invert a tree, we simply have to swap \n        # the L and R children nodes at each node:\n        #       1\n        #      / \\\n        #     3   2\n        #    / \\\n        #   4   5\n\n        # DFS PostOrder: \n        # left -> right -> root\n        #   1. Process left node: invert children nodes\n        #   2. Process right node: invert children nodes\n        #   3. Process root node: invert left and right nodes\n\n        # Empty Case: tree is a leaf, no swap, return None\n        if not root:\n            return None\n\n        # Stack to hold:\n        stack = []\n\n        # Starting Iteration:\n        curr = root\n\n        # Tracking Last Visited:\n        lastVisited = None \n\n        # Check: if we still have nodes to process\n        # tc: iterate over n O(n)\n        while stack or curr:\n\n            # Process Left Node: \n            # iterate as far down the left subtree line as we can,\n            # by as many left subtree nodes to stack as we can\n            while curr: \n                # push root node to stack\n                stack.append(curr)\n                # iterate to left node\n                curr = curr.left\n\n            # Implies: reached the last node on the left subtree line\n\n            # Grab: root node we just placed on stack (root of last left subtree)\n            peek = stack[-1]\n\n            # Check: if root node of the last left subtree has a right subtree\n            # Check: if right subtree has not been visited\n            # Then: iterate to right subtree and in next while loop, \n            #       the left subtree of the right subtree will be explored fully\n            if peek.right and lastVisited != peek.right:\n                curr = peek.right\n            \n            # Implies: no right subtree exists\n            # Implies: finished processing left and right subtree\n            # Then: process root \n            else:\n                # Remove And Process: pop root node from stack\n                stack.pop()\n\n                # Process Root Node:\n                # Invert left and right nodes\n                peek.left, peek.right = peek.right, peek.left\n\n                # Mark Root Node:\n                # Set last visited to current to avoid revisiting\n                lastVisited = peek\n\n        # tc: \n        # sc:\n        return root",
        "questionNumber": 226,
        "solutionLink": "/Notes/leetcode-trees#solution-2-iterative-dfs-post-order-carry-up-inverted-subtrees---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "Recursive DFS Post Order Pass Up Subtree Depth",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n                \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To find the height of a tree, we simply have to compare\n        # the max height of each subtree at each root node, \n        # and keep track of the max height found, while adding +1\n        # to account for the current root node\n\n        # DFS PostOrder: \n        # left -> right -> root\n        #   1. Process left node: get height of tree\n        #   2. Process right node: get height of tree\n        #   3. Process root node: compare max height between left and right, add +1\n        \n        # Empty Case: tree is a leaf, no height, return 0\n        if not root:\n            return 0\n        \n        # Recursive call to process left subtrees\n        left_depth = self.maxDepth(root.left)\n\n        # Recursive call to process right subtrees\n        right_depth = self.maxDepth(root.right)\n        \n        # Could have also been: right -> left subtrees\n        # right_depth = self.maxDepth(root.right)\n        # left_depth = self.maxDepth(root.left)\n\n        # Process Root:\n        # compare max height between left and right, add 1\n        root_depth = 1 + max(left_depth, right_depth)\n\n        # Return max height of tree\n\n        # overall: tc O(n)\n        # overall: sc O(n)\n        return root_depth",
        "questionNumber": 104,
        "solutionLink": "/Notes/leetcode-trees#solution-1-recursive-dfs-post-order-pass-up-subtree-depth---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "Recursive DFS Post Order Global Max Diameter + (Tree Length) Pass Up",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To find the width of a tree, we simply have to compare\n        # the max width of each subtree at each root node, \n        # and keep track of the max width found, while adding +1\n        # to account for the current root node\n\n        # DFS PostOrder: \n        # left -> right -> root\n        #   1. Process left node: get width of tree\n        #   2. Process right node: get width of tree\n        #   3. Process root node: compare max width between left and right, add +1\n\n        globalDiameter = 0\n        \n        def dfs(node):\n            nonlocal globalDiameter\n\n            # Empty check\n            if not node:\n                return 0\n            \n            # Process left -> right ->\n            left_len = dfs(node.left)\n            right_len = dfs(node.right)\n            \n            # Process -> root : connect left and right subtrees\n            connected_at_root = left_len + right_len\n\n            # Update max diameters: \n            globalDiameter = max(globalDiameter, connected_at_root)\n\n            # Process -> root: add edge between root -> parent\n            root_len = 1 + max(left_len, right_len)\n\n            return root_len\n        \n        # recursive process root\n        dfs(root)\n\n        # overall: time complexity\n        # overall: space complexity\n        return globalDiameter",
        "questionNumber": 543,
        "solutionLink": "/Notes/leetcode-trees#solution-1-recursive-dfs-post-order-global-max-diameter-tree-length-pass-up---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "Recursive DFS Post Order (Tree Max Diameter, Tree Length) Tuple Pass Up",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right :\n        # 2. Process -> root : connect left and right subtrees, get root max diameter\n        # Result: longest path of edges\n\n        def dfs(node):\n\n            # Empty check\n            if not node:\n                return (0, 0)\n            \n            # process left -> right -> :\n            (left_len, left_max_diameter) = dfs(node.left)\n            (right_len, right_max_diameter) = dfs(node.right)\n            \n            # process -> root : connect left and right subtrees\n            connected_at_root = left_len + right_len\n            \n            # Update max diameters\n            root_max_diameter = max(connected_at_root, left_max_diameter, right_max_diameter)\n            \n            # Process -> root: add edge between root -> parent\n            root_len = 1 + max(left_len, right_len)\n            \n            return (root_len, root_max_diameter)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return dfs(root)[1]",
        "questionNumber": 543,
        "solutionLink": "/Notes/leetcode-trees#solution-2-recursive-dfs-post-order-tree-max-diameter-tree-length-tuple-pass-up---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 3,
        "name": "Iterative DFS Post Order Global Max Diameter + Dictionary (Tree Length) Lookup",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \n        # Empty check\n        if not root:\n            return 0\n        \n        max_diameter = 0\n        \n        # iterative stack\n        stack = []\n\n        # store results \n        depth_map = defaultdict(int)\n        last_visited = None\n        node = root\n\n        while stack or node:\n            \n            # process left -> \n            # \n            while node:\n                stack.append(node)\n                node = node.left\n            \n            # check if right subtree exists\n            peek = stack[-1]\n\n            # process -> right -> \n            # if right subtree exists and not visited yet:\n            if peek.right and last_visited != peek.right:\n                node = peek.right\n            \n            # process -> root : (after subtrees)\n            else:\n                # remove from stack\n                stack.pop()\n\n                # results from subtrees\n                left_depth = depth_map[peek.left]\n                right_depth = depth_map[peek.right]\n\n                # process -> root : Update diameter with path through current node\n                max_diameter = max(max_diameter, left_depth + right_depth)\n\n                # process -> root : get diameter of root\n                depth_map[peek] = 1 + max(left_depth, right_depth)\n\n                # update last visited to current\n                last_visited = peek\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_diameter",
        "questionNumber": 543,
        "solutionLink": "/Notes/leetcode-trees#solution-3-iterative-dfs-post-order-global-max-diameter-dictionary-tree-length-lookup---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 4,
        "name": "Iterative DFS Post Order Dictionary (Tree Max Diameter, Tree Length) Lookup",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n\n        # Empty check\n        if not root:\n            return 0\n\n        # dictionary: node -> (tree max diameter, tree length)\n        node_data = defaultdict(lambda: (0, 0))\n\n        # iterative stack\n        stack = []\n\n        curr = root\n        last_visited = None\n\n        while stack or curr:\n            \n            # Process left -> : \n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            # Check if right subtree exists\n            peek = stack[-1]\n\n            # Process -> right -> \n            # if right subtree exists and had not been visited:\n            if peek.right and last_visited != peek.right:\n                curr = peek.right\n\n            # Process -> root\n            else:\n                # remove root from stack\n                stack.pop()\n\n                # grab results from subtrees\n                left_edges, left_bridge = node_data[peek.left]\n                right_edges, right_bridge = node_data[peek.right]\n\n                # bridge by connecting left and right edges\n                connected_bridge = left_edges + right_edges\n\n                # max bridge between new bridge, max left bridge, and max right bridge\n                root_max_bridge = max(connected_bridge, left_bridge, right_bridge)\n\n                # length/edges at current root\n                root_edges = 1 + max(left_edges, right_edges)\n\n                # update data for current root\n                node_data[peek] = (root_edges, root_max_bridge)\n\n                # update last visited\n                last_visited = peek\n                \n        return node_data[root][1]",
        "questionNumber": 543,
        "solutionLink": "/Notes/leetcode-trees#solution-4-iterative-dfs-post-order-dictionary-tree-max-diameter-tree-length-lookup---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Post Order Recursive Height or Error Pass Up",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right -> :\n        # 2. Process -> root : validate if balanced, throw -1 imbalance error\n        # Results: detect imbalance\n\n        def dfs(node):\n\n            # Base case: pass height upwards\n            if not node:\n                return 0\n            \n            # process left -> right ->\n            left_height = dfs(node.left)\n            right_height = dfs(node.right)\n\n            # pass thrown error upwards\n            if left_height == -1 or right_height == -1:\n                return -1         \n            \n            # process -> root : validate balanced left and right subtrees\n            if abs(left_height - right_height) > 1:\n                return -1\n            \n            root_height = 1 + max(left_height, right_height)\n\n            # process -> root : add to height and pass to root's parent\n            return root_height\n        \n        # overall: time complexity\n        # overall: space complexity\n        return dfs(root) != -1",
        "questionNumber": 110,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-height-or-error-pass-up---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS Post Order Recursive Tuple (Height, Bool) Pass Up",
        "type": "tree",
        "application": "dfs-post-order-recursive-two-sided-bottom-up",
        "code": "def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right ->\n        # 2. Process -> root : validate if balanced, pass invalid tuple error\n        # Results: detect imbalance\n        \n        def dfs(node):\n\n            # Base case: leaf -> (balanced:True, height:0)\n            if not node:\n                return (0, True)\n            \n            # Process left -> right -> (is_balanced, height)\n            (left_height, left_bal) = dfs(node.left)\n            (right_height, right_bal) = dfs(node.right)\n\n            # pass thrown error upwards\n            if not left_bal or not right_bal:\n                return (-1, False)\n            \n            # process -> root : validate balanced left and right subtrees\n            is_root_balanced = abs(left_height - right_height) <= 1\n\n            # process -> root : add to height and pass to root's parent\n            root_height = 1 + max(left_height, right_height)\n\n            return (root_height, is_root_balanced)\n        \n        # overall: time complexity\n        # overall space complexity\n        return dfs(root)[1]",
        "questionNumber": 110,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-post-order-recursive-tuple-height-bool-pass-up---treedfs-post-order-recursive-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      }
    ],
    "bfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down": [
      {
        "number": 3,
        "name": "Iterative BFS Pre Order Full Level Node Inversion",
        "type": "tree",
        "application": "bfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
        "code": "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To invert a tree, we simply have to swap \n        # the L and R children nodes at each node:\n        #       1\n        #      / \\\n        #     3   2\n        #    / \\\n        #   4   5\n\n        # BFS Iterative Level By Level: \n        # Process root level -> process left and right level\n        #   1. Process Root: iterate over roots level\n        #        - swap left and right subtrees\n        #   2. Process Left And Right: append left and right nodes to process them\n        #        - left and right will be process along with all nodes in their level\n        \n        # Empty Case: tree is a leaf, no swap, return None\n        if not root:\n            return None\n        \n        # Iterative level stack:\n        queue = deque([root])\n        \n        # Check: if we still have nodes to process\n        # tc: iterate over n O(n)\n        while queue:\n\n            # Number Of Nodes In Current Level Of Tree:\n            size = len(queue)\n\n            # Process The full Level Before Iterating To Next Level:\n            for _ in range(size):\n\n                # Remove And Process:\n                # Pop root node from left most of stack,\n                # processing each level from left to right\n                node = queue.popleft()\n                \n                # Process Root Node:\n                # Invert left and right nodes\n                node.left, node.right = node.right, node.left\n                \n                # Prepare Next Level:\n                # Append the next level of nodes to the stack,\n                # will not affect the current level processing \n                # as we have previously determined the number of nodes in the level \n                # and thus the number of nodes to be process\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        # overall: tc O(n)\n        # overall: sc O(n)\n        return root",
        "questionNumber": 226,
        "solutionLink": "/Notes/leetcode-trees#solution-3-iterative-bfs-pre-order-full-level-node-inversion---treebfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 3,
        "name": "Iterative BFS Pre Order Full Level Global Depth + Completed Level Adds to Depth",
        "type": "tree",
        "application": "bfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
        "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n       \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To find the height of a tree, we simply have to swap compare\n        # the max height of each subtree at each root node, \n        # and keep track of the max height found\n\n        # BFS Iterative Level By Level: \n        # Process root level -> process left and right level\n        #   1. Process Root: iterate over roots level \n        #       - no action needed, when finished iteration over nodes in \n        #         level, added 1 to global depth counter\n        #   2. Process Left And Right: append left and right nodes to process them\n        #        - left and right will be process along with all nodes in their level\n        \n        # Empty Case: tree is a leaf, no height, return = 0\n        if not root:\n            return 0\n        \n        # Iterative level stack:\n        stack = [(root, 1)]\n\n        # Global depth\n        globalDepth = 0\n        \n        # Check: if we still have nodes to process\n        # tc: iterate over n O(n)\n        while queue:\n\n            # Number Of Nodes In Current Level Of Tree:\n            size = len(queue)\n\n            # Process The full Level Before Iterating To Next Level:\n            for _ in range(size):\n\n                # Remove And Process:\n                # no action needed on root node\n                node = queue.popleft()\n\n                # Prepare Next Level:\n                # Append the next level of nodes to the stack,\n                # will not affect the current level processing \n                # as we have previously determined the number of nodes in the level \n                # and thus the number of nodes to be process\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            # level complete, add +1 to depth counter to account for this level\n            globalDepth += 1\n        \n        # overall: tc O(n)\n        # overall: sc O(n)\n        return globalDepth",
        "questionNumber": 104,
        "solutionLink": "/Notes/leetcode-trees#solution-3-iterative-bfs-pre-order-full-level-global-depth-completed-level-adds-to-depth---treebfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      }
    ],
    "dfs-post-order-iterative-two-sided-bottom-up": [
      {
        "number": 2,
        "name": "Iterative DFS Post Order Dictionary (Lookup Subtree Depth)",
        "type": "tree",
        "application": "dfs-post-order-iterative-two-sided-bottom-up",
        "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \n        # Tree:\n        # A tree is made up of nodes which point to other nodes\n        # They must have pointers and they may or may not have values:\n        #      ()             1\n        #      / \\           / \\\n        #    ()   ()        2   3 \n        #         / \\           / \\\n        #       ()   ()        4   5\n\n        # To find the height of a tree, we simply have to swap compare\n        # the max height of each subtree at each root node, \n        # and keep track of the max height found\n        \n        # DFS PostOrder: \n        # left -> right -> root\n        #   1. Process left node: get height of tree\n        #   2. Process right node: get height of tree\n        #   3. Process root node: compare max height between left and right\n        \n        # Empty Case: tree is a leaf, no height, return = 0\n        if not root:\n            return 0\n\n        # Stack to hold:\n        stack = []\n\n        # Starting Iteration:\n        curr = root\n\n        # Tracking Last Visited:\n        lastVisited = None\n\n        # Iterative Height Map Tracking:\n        # Since we are using a stack, we will not have access to\n        # the children left and right at the same time, so we need to\n        # keep track of the heights in the hashmap\n        heightMap = defaultdict(int)\n\n        # Check: of we still have nodes to process\n        # tc: iterate over n O(n)\n        while stack or curr:\n            \n            # Process Left Node: \n            # iterate as far down the left subtree line as we can,\n            # by as many left subtree nodes to stack as we can\n            while curr:\n                # push root node to stack\n                stack.append(curr)\n                # iterate to left node\n                curr = curr.left\n            \n            # Implies: reached the last node on the left subtree line\n\n            # Grab: root node we just placed on stack (root of last left subtree)\n            peek = stack[-1]\n\n            # Check: if root node of the last left subtree has a right subtree\n            # Check: if right subtree has not been visited\n            # Then: iterate to right subtree and in next while loop, \n            #       the left subtree of the right subtree will be explored fully\n            if peek.right and lastVisited != peek.right:\n                curr = peek.right\n\n            # Implies: no right subtree exists\n            # Implies: finished processing left and right subtree\n            # Then: process root \n            else:\n                # Remove And Process: pop root node from stack\n                stack.pop()\n                \n                # Grab left and right height result from hashmap \n                left_depth = heightMap[peek.left]\n                right_depth = heightMap[peek.right]\n\n                # Process Root Node:\n                # compare max height between left and right, add 1\n                currentDepth = 1 + max(left_depth, right_depth)\n\n                # Track Root Node:\n                # Add this nodes height to the dictionary\n                heightMap[peek] = currentDepth\n\n                # Mark Root Node:\n                # Set last visited to current to avoid revisiting\n                lastVisited = peek\n\n        # final height of tree\n        heightOfTree = heightMap[root]\n\n        # overall: tc \n        # overall: sc \n        return heightOfTree",
        "questionNumber": 104,
        "solutionLink": "/Notes/leetcode-trees#solution-2-iterative-dfs-post-order-dictionary-lookup-subtree-depth---treedfs-post-order-iterative-two-sided-bottom-up",
        "blog": "LeetCode: Trees"
      }
    ],
    "dfs-pre-order-recursive-one-sided-top-down": [
      {
        "number": 1,
        "name": "DFS Pre Order Recursive Early Root Stop or Subtree Match Pass Up",
        "type": "tree",
        "application": "dfs-pre-order-recursive-one-sided-top-down",
        "code": "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #    if both nodes are 'None' -> trees match\n        #    if only one node is 'None' -> trees differ\n        #    if values mismatch -> trees differ\n        # 3. Process -> left -> right :\n        # Result: validate tree match \n        \n        # Note: this is 'process root' instead of 'base case'\n        # because it leads to an early termination, instead of being a regular base case\n        # thus, this solution is pre order\n\n        # Process root -> : both nodes are 'None'\n        if not p and not q:\n            return True\n\n        # Process root -> : only one node is 'None' \n        if not p or not q:\n            return False\n\n        # Process root -> : values differ\n        if p.val != q.val:\n            return False\n        \n        # Process left -> right\n        left_match = self.isSameTree(p.left, q.left)\n        right_match = self.isSameTree(p.right, q.right)\n\n        # Process left -> right : pass left and right results up\n        subTreeMatch = left_match and right_match\n        \n        # overall: time complexity\n        # overall: space complexity\n        return subTreeMatch",
        "questionNumber": 100,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-early-root-stop-or-subtree-match-pass-up---treedfs-pre-order-recursive-one-sided-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Pre Order Recursive Abstraction Call Over Root Tree",
        "type": "tree",
        "application": "dfs-pre-order-recursive-one-sided-top-down",
        "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> : \n        #    validate subtree matches\n        # 2. Process -> left -> right :\n        # Result: validate if subtree is subtree of tree\n\n        # helper func \n        def isSameTree(s, t):\n\n            # process root -> : \n            if not s and not t:\n                return True\n\n            # process root -> :\n            if not s or not t:\n                return False\n\n            # process root -> :\n            if s.val != t.val:\n                return False\n            \n            # process -> left -> right :\n            left_match = isSameTree(s.left, t.left)\n            right_match = isSameTree(s.right, t.right)\n\n            # process -> left -> right:\n            subTreeMatch = left_match and right_match\n\n            return subTreeMatch\n        \n\n        # Empty check\n        if not subRoot:\n            return True\n\n        # Empty check\n        if not root:\n            return False\n        \n        # process root -> : \n        if isSameTree(root, subRoot):\n            return True\n        \n        # process -> left -> right :\n        tree_left_subtree_match = self.isSubtree(root.left, subRoot)\n        tree_right_subtree_match = self.isSubtree(root.right, subRoot) \n\n        # process -> left -> right :\n        tree_match = tree_left_subtree_match or tree_right_subtree_match\n\n        # overall: time complexity\n        # overall: space complexity\n        return tree_match",
        "questionNumber": 572,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-abstraction-call-over-root-tree---treedfs-pre-order-recursive-one-sided-top-down",
        "blog": "LeetCode: Trees"
      }
    ],
    "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down": [
      {
        "number": 2,
        "name": "BFS Iterative Early Root Stop or Subtree Match Pass Up",
        "type": "tree",
        "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "code": "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # Note:\n        # BFS Iterate: level by level\n        # 1. Process root -> : \n        #    if both nodes are 'None' -> trees match\n        #    if only one node is 'None' -> trees differ\n        #    if values mismatch -> trees differ\n        # 2. Process -> left -> right : \n        # Result: validate tree match \n        \n        # iterative stack\n        queue = deque([(p, q)])\n        \n        while queue:\n\n            # process root -> :\n            root1, root2 = queue.popleft()\n            \n            # Note: early termination during process root -> : \n\n            # Process root -> : both nodes are 'None'\n            if not root1 and not root2:\n                continue\n            \n            # Process root -> : only one node is 'None' \n            if not root1 or not root2\n                return False\n            \n            # Process root -> : values differ\n            if root1.val != root2.val:\n                return False\n            \n            # process -> left -> right\n            queue.append((root1.left, root2.left))\n            queue.append((root1.right, root2.right))\n        \n        # overall: time complexity\n        # overall: space complexity\n        return True",
        "questionNumber": 100,
        "solutionLink": "/Notes/leetcode-trees#solution-2-bfs-iterative-early-root-stop-or-subtree-match-pass-up---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "BFS Pre Order Iterative Root Match Then Call isSameTree",
        "type": "tree",
        "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # BFS order: level by level : root -> left -> right\n        # 1. For each level:\n        # 2. Process root -> : \n        #    if root values match, run isSameTree\n        # 3. Process -> left -> right :\n        # Result: validate if subtree is subtree of tree\n\n        def isSameTree(s, t):\n\n            # Process root -> :\n            if not s and not t:\n                return True\n\n            # Process root -> : \n            if not s or not t:\n                return False  \n\n            # Process root -> : \n            if s.val != t.val:\n                return False\n            \n            # Process -> left -> right :\n            left_match = isSameTree(s.left, t.left)\n            right_match = isSameTree(s.right, t.right)\n\n            # Process -> left -> right :\n            subtree_match = left_match and right_match\n\n            return subtree_match\n\n        # Empty check:\n        if not subRoot:\n            return True\n\n        # Empty check:\n        if not root:\n            return False\n        \n        # iterative queue\n        queue = deque([root])\n\n        while queue:\n\n            # Process root -> :\n            root_node = queue.popleft()\n\n            # Process root -> : if match, test with isSameTree\n            if root_node.val == subRoot.val and isSameTree(root_node, subRoot):\n                return True\n\n            # Process -> left -> right :\n            if root_node.left:\n                queue.append(root_node.left)\n            if root_node.right:\n                queue.append(root_node.right)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return False",
        "questionNumber": 572,
        "solutionLink": "/Notes/leetcode-trees#solution-2-bfs-pre-order-iterative-root-match-then-call-issametree---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 3,
        "name": "DFS Pre Order Tree Serialization Comparison",
        "type": "tree",
        "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #      serialize values with leading comma\n        #      (\"2\" in \"12\" would match incorrectly without boundaries, so comma needed)\n        #      \",2\"\n        # 2. Process -> left -> right :\n        # Result: validate if subtree is subtree of tree\n\n        def serialize(node):\n            \n            # process root -> :\n            if not node:\n                return \",N\"\n\n            # process root -> :\n            root_serial = node.val\n\n            # process -> left -> right :\n            left_serial = serialize(node.left)\n            right_serial = serialize(node.right)\n\n            # process root -> :\n            subTree_serial = f\",{node.val}{left_serial}{right_serial}\" \n\n            return subTree_serial\n\n        # process root -> :\n        serializedSubRoot = serialize(subRoot)\n        serializedRoot = serialize(root)\n\n        # process root -> :\n        subTree_match = serializedSubRoot in serializedRoot\n\n        # overall: time complexity\n        # overall: space complexity\n        return subTree_match",
        "questionNumber": 572,
        "solutionLink": "/Notes/leetcode-trees#solution-3-dfs-pre-order-tree-serialization-comparison---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 4,
        "name": "DFS In Order Tree Serialization Comparison",
        "type": "tree",
        "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        \n        def serialize(node):\n            if not node:\n                return \",N\"\n\n            # In-order: left -> root -> right\n            left_serial = serialize(node.left)\n            root_val = f\",{node.val}\"\n            right_serial = serialize(node.right)\n            \n            subtree_serial = f\"#{left_serial}@{root_val}${right_serial}^\"\n            return subtree_serial\n\n        \n        serializedSubRoot = serialize(subRoot)\n        serializedRoot = serialize(root)\n        \n        # Check if serializedSubRoot is a substring of serializedRoot\n        match = serializedSubRoot in serializedRoot\n\n        # overall: time complexity\n        # overall: space complexity\n        return match",
        "questionNumber": 572,
        "solutionLink": "/Notes/leetcode-trees#solution-4-dfs-in-order-tree-serialization-comparison---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 5,
        "name": "DFS Post Order Tree Serialization Comparison",
        "type": "tree",
        "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def serialize(node):\n            # Base case: null marker for missing child\n            if not node:\n                return \",N\"\n            \n            # Postorder: left -> right -> root\n            \n            left_serial = serialize(node.left)\n            right_serial = serialize(node.right)\n            \n            # Append root after left and right serialization\n            subTree_serial = f\"#{left_serial}@{right_serial},{node.val}^\"            \n            return subTree_serial\n        \n        serializedSubRoot = serialize(subRoot)\n        serializedRoot = serialize(root)\n        \n        # Check if serializedSubRoot is a substring of serializedRoot\n        match = serializedSubRoot in serializedRoot \n\n        # overall: time complexity\n        # overall: space complexity\n        return match",
        "questionNumber": 572,
        "solutionLink": "/Notes/leetcode-trees#solution-5-dfs-post-order-tree-serialization-comparison---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
        "blog": "LeetCode: Trees"
      }
    ],
    "bst-guided-recursive-traversal": [
      {
        "number": 1,
        "name": "BST Recursive Traversal",
        "type": "tree",
        "application": "bst-guided-recursive-traversal",
        "code": "def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        \n        # Note:\n        # BST traversal: root -> either -> left or -> right\n        # 1. Process -> root : \n        #    determine if LCA is in left or right\n        # 2. Process -> left or -> right :\n        # Result: find LCA node\n        \n        # process root -> :\n        # p and q are smaller, LCA in left subtree \n        if p.val < root.val and q.val < root.val:\n\n            # process -> left :\n            return self.lowestCommonAncestor(root.left, p, q)\n\n        # process root -> :\n        # p and q are larger, LCA in right subtree\n        elif p.val > root.val and q.val > root.val:\n\n            # process -> right :\n            return self.lowestCommonAncestor(root.right, p, q)\n        \n        # process root -> :\n        # p and q are in different subtrees, root is LCA\n        else:\n            return root\n\n        # overall: time complexity\n        # overall: space complexity",
        "questionNumber": 235,
        "solutionLink": "/Notes/leetcode-trees#solution-1-bst-recursive-traversal---treebst-guided-recursive-traversal",
        "blog": "LeetCode: Trees"
      }
    ],
    "bst-guided-iterative-traversal": [
      {
        "number": 2,
        "name": "BST Iterative Traversal",
        "type": "tree",
        "application": "bst-guided-iterative-traversal",
        "code": "def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        \n        # Note:\n        # BST traversal: root -> either -> left or -> right\n        # 1. Process -> root : \n        #    determine if LCA is in left or right\n        # 2. Process -> left or -> right :\n        # Result: find LCA node\n\n        # iterative root\n        while root:\n\n            # process root -> :\n            # p and q are smaller, LCA in left subtree \n            if p.val < root.val and q.val < root.val:\n\n                # process -> left :\n                root = root.left\n\n            # process root ->\n            # p and q are larger, LCA in right subtree\n            elif p.val > curr.val and q.val > curr.val:\n\n                # process -> right :\n                curr = curr.right\n\n            # process root -> :\n            # p and q are in different subtrees, root is LCA\n            else:\n                return curr\n        \n        # overall: time complexity\n        # overall: space complexity",
        "questionNumber": 235,
        "solutionLink": "/Notes/leetcode-trees#solution-2-bst-iterative-traversal---treebst-guided-iterative-traversal",
        "blog": "LeetCode: Trees"
      }
    ],
    "dfs-pre-order-traversal": [
      {
        "number": 1,
        "name": "BFS Iterative",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Empty check\n        if not root:\n            return []\n        \n        groups = []\n        queue = deque([root])  # start with root\n        \n        while queue:\n            # grab size of current level\n            size = len(queue)\n            level = []\n            \n            # process each node in this level\n            for _ in range(size):\n                node = queue.popleft()\n                level.append(node.val)\n                \n                # enqueue children for next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            groups.append(level)\n        \n        return groups",
        "questionNumber": 102,
        "solutionLink": "/Notes/leetcode-trees#solution-1-bfs-iterative---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS Pre Order Recursive",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #    append root to corresponding depth group\n        # 2. Process -> left -> right :\n        # Results: nodes grouped by depth level\n        \n        # depth level groups\n        groups = []\n        \n        def dfs(node, depth):\n\n            # Empty check\n            if not node:\n                return\n            \n            # Process root -> :\n            # add group if new depth reached\n            if len(groups) == depth:\n                groups.append([])\n            \n            # Process root -> : \n            # add node to corresponding depth group\n            groups[depth].append(node.val)\n            \n            # Process -> left -> right : update depth\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n        \n        dfs(root, 0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return groups",
        "questionNumber": 102,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-recursive---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "BFS Pre Order Iterative Grab Last Element Per Level",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \n        # Note:\n        # BFS pre order: process level : root -> left -> right\n        # 1. For each level\n        # 2. Process root -> :\n        #    grab length of level, if root is last element in group, add to res\n        # 3. Process -> left -> right :\n        # Result: right most element of each level added\n        \n        # Empty check\n        if not root:\n            return []\n        \n        # right most elements of each level\n        result = []\n        \n        # iterative queue\n        queue = deque([root])\n        \n        while queue:\n\n            # process entire level\n            level_size = len(queue)\n            for i in range(level_size):\n\n                # Process root -> : \n                node = queue.popleft()\n\n                # Process root -> : \n                # if this is last element in level, add to res\n                if i == level_size - 1:\n                    result.append(node.val)\n\n                # Process -> left -> right : \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return result",
        "questionNumber": 199,
        "solutionLink": "/Notes/leetcode-trees#solution-1-bfs-pre-order-iterative-grab-last-element-per-level---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS Pre Order Recursive Right Subtree Search With New Depth Trigger",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \n        # Note:\n        # DFS pre order: root -> right -> left\n        # 1. Process root -> : \n        # 2. Process -> right -> left\n        #    we are exploring right subtree first,\n        #    first time we hit a new depth, we must be at right most node,\n        #    add node to res\n        # Result: right most element of each level added\n\n        # right most elements of each level\n        result = []\n        \n        def dfs(node, depth):\n\n            # Empty check\n            if not node:\n                return\n\n            # Process root -> :\n            # if hit new depth, must be at right most node\n            if depth == len(result):\n                result.append(node.val)\n\n            # Process -> right -> left\n            dfs(node.right, depth + 1)\n            dfs(node.left, depth + 1)\n        \n        # recursive call on root\n        dfs(root, 0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return result",
        "questionNumber": 199,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-recursive-right-subtree-search-with-new-depth-trigger---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Pre Order Recursive Pass Down Max Value Seen So Far",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def goodNodes(self, root: TreeNode) -> int:\n\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #    check if root pass max seen so far, if so + 1 good node\n        # 2. Process -> left -> right :\n        # Result: good nodes counted\n\n        def dfs(node, max_so_far):\n\n            # Empty check\n            if not node:\n                return 0\n            \n            # Process root -> : \n            # if root >= max_so_far, + 1 good\n            good = 1 if node.val >= max_so_far else 0\n            \n            # Process root -> : update max\n            new_max = max(max_so_far, node.val)\n            \n            # Process -> left -> right :\n            good += dfs(node.left, new_max)\n            good += dfs(node.right, new_max)\n            \n            # Process root -> : pass good nodes\n            return good\n        \n        good_nodes = dfs(root, root.val)\n\n        # overall: time complexity\n        # overall: space complexity\n        return good_nodes",
        "questionNumber": 1448,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-pass-down-max-value-seen-so-far---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS Pre Order Iterative Pass (Root, Max_So_Far) Tuple Down",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def goodNodes(self, root: TreeNode) -> int:\n        \n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #    check if root pass max seen so far, if so + 1 good node\n        # 2. Process -> left -> right :\n        # Result: good nodes counted\n\n        # global good count\n        count = 0\n\n        # iterative stack\n        queue = deque([(root, root.val)])\n        \n        while queue:\n\n            # Process root -> : \n            (root, max_so_far) = queue.popleft()\n            \n            # Process root -> : check if good node\n            if root.val >= max_so_far:\n                count += 1\n            \n            # Process root -> : update max\n            new_max = max(max_so_far, root.val)\n            \n            # Process -> left -> right :\n            if root.left:\n                queue.append((root.left, new_max))\n            if root.right:\n                queue.append((root.right, new_max))\n        \n        # overall: time complexity\n        # overall: space complexity\n        return count",
        "questionNumber": 1448,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-iterative-pass-root-max-so-far-tuple-down---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Pre Order Recursive Passing Range Limits",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        \n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process root -> :\n        #    validate order\n        # 2. Process -> left -> right : \n        # Result: validated BST\n        \n        def dfs(node, low, high):\n\n            # Process root -> : \n            if not node:\n                return True\n\n            # Process root -> : validate order\n            if not (low < node.val < high):\n                return False\n\n            # Process -> left -> right :\n            left_valid = dfs(node.left, low, node.val)\n            right_valid = dfs(node.right, node.val, high)\n\n            # Process -> left -> right :\n            subtreeValid = left_valid and right_valid\n\n            return subtreeValid\n\n        # Start with infinite bounds\n        treeValid = dfs(root, float('-inf'), float('inf'))\n\n        # overall: time complexity\n        # overall: space complexity\n        return treeValid",
        "questionNumber": 98,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-passing-range-limits---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "BFS Pre Order Iterative Passing Queuing Range Limits",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n\n        # Note:\n        # BFS pre order: process level: root -> left -> right\n        # 1. Process level: \n        #      Process root -> :\n        #        validate range limits\n        # 2. Process -> left -> right : \n        # Result: validated BST\n\n        # iterative queue\n        queue = deque([(root, float('-inf'), float('inf'))])\n\n        while queue:\n\n            # Process root -> :\n            node, low, high = queue.popleft()\n\n            # Process root -> : \n            if not node:\n                continue\n\n            # Process root -> : validate order\n            if not (low < node.val < high):\n                return False\n\n            # Process -> left -> right :\n            queue.append((node.left, low, node.val))\n            queue.append((node.right, node.val, high))\n\n        # overall: time complexity\n        # overall: space complexity\n        return True",
        "questionNumber": 98,
        "solutionLink": "/Notes/leetcode-trees#solution-2-bfs-pre-order-iterative-passing-queuing-range-limits---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS In Order Recursive Early Stop with Global Element Counter",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n\n        # Note:\n        # DFS in order: left -> root -> right\n        # 1. Process left -> : \n        # 2. Process -> root -> :\n        #    if reached kth node, return\n        # 3. Process -> right :\n        # Result: kth smallest found\n\n        # global counter\n        k = k\n        # global pointer\n        result = None\n        \n        def inorder(node):\n            nonlocal k\n            nonlocal result\n\n            # Process left -> :\n            if not node or result is not None:\n                return\n            \n            # Process left -> :\n            inorder(node.left)\n            \n            # Process root -> : \n            # if kth node, return\n            k -= 1\n            if k == 0:\n                result = node.val\n                return\n            \n            # Process right -> : \n            inorder(node.right)\n        \n        inorder(root)\n\n        # overall: time complexity\n        # overall: space complexity\n        return result",
        "questionNumber": 230,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-in-order-recursive-early-stop-with-global-element-counter---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS In Order Iterative with Element Counter",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n\n        # Note:\n        # DFS in order: left -> root -> right\n        # 1. Process left -> : \n        # 2. Process -> root -> :\n        #    if reached kth node, return\n        # 3. Process -> right :\n        # Result: kth smallest found\n\n        # iterative stack\n        stack = []\n        \n        while True:\n\n            # Process left -> :\n            while root:\n                stack.append(root)\n                root = root.left\n            \n            # Process -> root -> :\n            root = stack.pop()\n\n            # Process -> root -> : \n            # if kth node, return\n            k -= 1\n            if k == 0:\n                return root.val\n            \n            # Process -> right :\n            root = root.right\n\n        # overall: time complexity\n        # overall: space complexity",
        "questionNumber": 230,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-in-order-iterative-with-element-counter---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Pre Order Recursive In Order Hash Map",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n\n        # Tree:\n        #        1\n        #       / \\\n        #      2   3\n        #     / \\   \\\n        #    4   5   6\n        #             \\\n        #              7\n    \n        # Pre order: root -> left -> right\n        # [1, 2, 4, 5, 3, 6, 7]\n\n        # In order: left -> root -> right \n        # [4, 2, 5, 1, 3, 6, 7]\n\n        # Note:\n        # Pre order: current root supplier\n        # by iterating over this: root -> left -> right\n\n        # In order: recursive range provider\n        # due to Invariant from: left -> root -> right\n        # for all roots -> [ leftSubtree, root, rightSubtree ]\n\n        # val -> in order array index\n        inorder_index_map = {val: idx for idx, val in enumerate(inorder)}\n\n        # iterating over pre order: the current root supplier, \n        # will determine which tree we are currently building\n        pre_idx = 0\n\n\n        # recurse over in order list \n        def array_to_tree(left, right):\n            nonlocal pre_idx\n\n            # Base case: no elements to construct subtree\n            if left > right:\n                return None\n\n            # 1. curr 'root': root -> left -> right\n            root_val = preorder[pre_idx]\n            \n            # prepare next root ('left'): above becomes -> left -> right\n            pre_idx += 1\n\n            # Create root node\n            root = TreeNode(root_val)\n\n            # 2: Find root's index for in order \n            #    to trigger invariant [leftSubtree, root, rightSubtree]\n            root_index = inorder_index_map[root_val]\n\n            # 3: given invariant, \n            #    trigger left subtree range for in order array\n            left_subtree_left = left\n            left_subtree_right = root_index - 1\n\n            # 4: given invariant, \n            #    trigger right subtree range for in order array\n            right_subtree_left = root_index + 1\n            right_subtree_right = right\n\n            # 5: pass left subtree range\n            root.left = array_to_tree(left_subtree_left, left_subtree_right)\n\n            # 5: pass] right subtree range\n            root.right = array_to_tree(right_subtree_left, right_subtree_right)\n\n            # root with subtrees\n            return root\n\n        # initialize bounds for topmost root\n        left_start = 0 \n        right_start = len(inorder)-1\n\n        # recurse starting at topmost root, \n        # rest of tree created by recursion (magic)\n        orig_tree = array_to_tree(left_start, right_start)\n\n        # overall: time complexity\n        # overall: space complexity \n        return array_to_tree(left_start, right_start)",
        "questionNumber": 105,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-in-order-hash-map---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 2,
        "name": "DFS Pre Order Iterative Build Using Stack",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n\n        # Tree:\n        #        1\n        #       / \\\n        #      2   3\n        #     / \\   \\\n        #    4   5   6\n        #             \\\n        #              7\n    \n        # Pre order: root -> left -> right\n        # [1, 2, 4, 5, 3, 6, 7]\n\n        # In order: left -> root -> right \n        # [4, 2, 5, 1, 3, 6, 7]\n\n        # Empty check\n        if not preorder or not inorder:\n            return None\n        \n        # 1: topmost root -> preorder[0]\n        #.   iterate over preorder, create and connect with parent\n        root = TreeNode(preorder[0])\n\n        # 2: stack: \n        #    filled by iterative preorder root -> left -> right\n        #    holds roots that are waiting for subtrees\n        stack = [root]\n\n        # 2: inorder_index:\n        #  start at bottom left most subtree 0\n        inorder_index = 0\n\n        # In order invariant -> [leftSubtree, root, rightSubtree]\n        # when inorder index pointing to some root:\n        #   1) root has no left subtrees\n        #   2) root's left subtrees have been created and assigned\n\n        # 3: iterate over preorder: root -> left -> right\n        for i in range(1, len(preorder)):\n\n            # peek top of stack:\n            # previous node waiting for subtrees\n            top = stack[-1]\n\n            # pre order: subtree of top\n            preorder_val = preorder[i]\n            \n            # in order: left most complete root\n            inorder_val = inorder[inorder_index]\n\n            # if top of stack is not complete\n            # preorder is the tops left subtree\n            if top.val != inorder_val:\n\n                # connect and push to stack,\n                # to find left subtrees subtrees\n                top.left = TreeNode(preorder_val)\n                stack.append(top.left)\n                        \n            # if top of stack is complete\n            # preorder is the tops right subtree\n            else:\n                \n                # now we have arrive to top most root,\n                # if in order marks as complete, that means there ar\n                while stack and stack[-1].val == inorder[inorder_index]:\n                    top = stack.pop()\n                    inorder_index += 1\n                \n                # process -> right :\n                # preorder_val is a right child, connect and push to stack\n                top.right = TreeNode(preorder_val)\n                stack.append(top.right)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return root",
        "questionNumber": 105,
        "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-iterative-build-using-stack---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Post Order Recursive Global Max Tracker",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        \n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right -> :\n        # 2. Process -> root :\n        #     \n\n        # global max\n        max_sum = float('-inf')\n\n        def dfs(node):\n            nonlocal max_sum\n\n            # Empty check\n            if not node:\n                return 0\n\n            # Process left -> right -> \n            left_gain = max(dfs(node.left), 0)\n            right_gain = max(dfs(node.right), 0)\n\n            # Process -> root :\n            connected_at_root = node.val + left_gain + right_gain\n\n            # Process -> root : check global max\n            max_sum = max(max_sum, connected_at_root)\n\n            # Process -> root : get max path at root\n            root_max_path = node.val + max(left_gain, right_gain)\n\n            return root_max_path\n\n        dfs(root)\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_sum",
        "questionNumber": 124,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-global-max-tracker---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      },
      {
        "number": 1,
        "name": "DFS Pre Order Recursive",
        "type": "tree",
        "application": "dfs-pre-order-traversal",
        "code": "class Codec:\n\n    def serialize(self, root):\n\n        # Note: \n        # DFS pre order: root -> left -> right:\n        # 1. Process root -> :\n        #    if val, append val \n        #    if None, append marker\n        # 2. Process -> left -> right :\n        # Result: serialized pre order tree \n\n        vals = []\n\n        def dfs(node):\n\n            # Process root -> :\n            if not node:\n                vals.append(\"N\")\n                return\n\n            # Process root -> :\n            vals.append(str(node.val))\n\n            # Process -> left -> right :\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n\n        # overall: time complexity\n        # overall: time complexity\n        return \",\".join(vals)\n        \n\n    def deserialize(self, data):\n        \n        # Note:\n        # DFS pre order: root -> left -> right :\n        # 1. Process root :\n        #.   if val\n\n        # deserialize string into queue\n        vals = deque(data.split(\",\"))\n\n        def dfs():\n            \n            # Process root -> :\n            if not vals:\n                return None\n\n            # Process root -> :\n            val = vals.popleft()\n            if val == \"N\":\n                return None\n\n            # Process root -> :\n            node = TreeNode(int(val))\n\n            # Process -> left -> right :\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        # new root of tree\n        return dfs()",
        "questionNumber": 297,
        "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive---treedfs-pre-order-traversal",
        "blog": "LeetCode: Trees"
      }
    ]
  },
  "trie": {
    "trie-insert-and-search-recursive": [
      {
        "number": 1,
        "name": "Recursive Trie Implementation",
        "type": "trie",
        "application": "trie-insert-and-search-recursive",
        "code": "class TrieNode:\n\n    def __init__(self):\n        # list of continuing letters (subtrees) for node: char -> TrieNode\n        self.subtrees = {}\n        # marks current node as valid end of word\n        self.is_end = False\n\n\nclass Trie:\n\n    def __init__(self):\n        # Root node does not store any chars itself\n        self.root = TrieNode()\n\n    # Recursive Insert\n    # tc: O(n), word length\n    # sc: O(n), node creation\n    def insert(self, word: str) -> None:\n\n        def dfs_insert(node: TrieNode, i: int):\n            # Base case: finished word\n            if i == len(word):\n                node.is_end = True\n                return\n\n            c = word[i]\n            if c not in node.subtrees:\n                node.subtrees[c] = TrieNode()\n            \n            # Recurse to next letter\n            dfs_insert(node.subtrees[c], i + 1)\n\n        dfs_insert(self.root, 0)\n\n    # Recursive Search\n    # tc: O(n), word length\n    # sc: O(n), recursion stack\n    def search(self, word: str) -> bool:\n\n        def dfs_search(node: TrieNode, i: int) -> bool:\n            # Base case: finished word\n            if i == len(word):\n                return node.is_end\n\n            c = word[i]\n            if c not in node.subtrees:\n                return False\n\n            # Recurse to next letter\n            return dfs_search(node.subtrees[c], i + 1)\n\n        return dfs_search(self.root, 0)\n\n    # Recursive StartsWith\n    # tc: O(n), prefix length\n    # sc: O(n), recursion stack\n    def startsWith(self, prefix: str) -> bool:\n\n        def dfs_startsWith(node: TrieNode, i: int) -> bool:\n            # Base case: finished prefix\n            if i == len(prefix):\n                return True\n\n            c = prefix[i]\n            if c not in node.subtrees:\n                return False\n\n            # Recurse to next letter\n            return dfs_startsWith(node.subtrees[c], i + 1)\n\n        return dfs_startsWith(self.root, 0)\n\n    # overall: tc O(n) per operation\n    # overall: sc O(n) per operation (recursion stack)",
        "questionNumber": 208,
        "solutionLink": "/Notes/leetcode-tries#solution-1-recursive-trie-implementation---trietrie-insert-and-search-recursive",
        "blog": "LeetCode: Tries"
      },
      {
        "number": 2,
        "name": "Iterative Trie Implementation",
        "type": "trie",
        "application": "trie-insert-and-search-recursive",
        "code": "class TrieNode:\n\n    # TrieNode:\n    # We need to track \n    #   - subtrees for current node (letters current letter can continue to)\n    #   - if current node represents the valid end of a node\n\n    # For our functions, they may need to update the above 2 details\n    \n    # Insert():\n    #   - Insert a new word into the trie tree\n    #   - Add letters to existing trie nodes\n\n    # Search():\n    #   - Check if a word exists in the trie tree\n    #   - Travel down trie nodes to verify word exists\n\n    # StartsWith():\n    #   - Check if a word exists in the trie tree that has a prefix\n    #   - Travel down trie node to verify prefix, and then continue to \n    #     verify if any word uses it\n\n    def __init__(self):\n\n        # list of continuing letters (subtrees) for node: char -> TrieNode\n        self.subtrees = {}\n        # marks current node as valid end of word\n        self.is_end = False\n\n\nclass Trie:\n\n    def __init__(self):\n        # Root node:\n        # Does not store any chars itself,\n        # only points to its child char nodes\n        self.root = TrieNode()\n\n    # tc: iterate over word of length n O(n)\n    # sc: subtree node creation for n nodes O(n)\n    def insert(self, word: str) -> None:\n        \n        # start search at root\n        node = self.root\n\n        # Insert each letter of word into trie tree in correct order\n        for c in word:\n\n            # if subtree does not exist for current letter, add to list\n            if c not in node.subtrees:\n                node.subtrees[c] = TrieNode()\n\n            # iterate to next letter node\n            node = node.subtrees[c]\n\n        # finished adding all chars to trie tree, mark last char \n        # as valid end to a word\n        node.is_end = True\n\n    # tc:\n    # sc:\n    def search(self, word: str) -> bool:\n        \n        #   Return True only if final node is valid end\n        \n        # start at root\n        node = self.root\n\n        # Traverse the trie using words char\n        # tc: iterate over word length n O(n)\n        for c in word:\n\n            # if subtree does not exist, word path is not in trie\n            if c not in node.subtrees:\n                return False\n\n            # iterate to next letter node\n            node = node.subtrees[c]\n        \n        # check if last char is valid end of a word\n        return node.is_end\n\n    # tc:\n    # sc:\n    def startsWith(self, prefix: str) -> bool:\n        \n        # Note:\n        #   Similar to search(), but only checks if prefix path exists\n        #   No need to check is_end flag\n        \n        # start at root\n        node = self.root\n\n        # for each char\n        for c in prefix:\n\n            # if subtree does not exist, false\n            if c not in node.subtrees:\n                return False\n            \n            # iterate to subtree\n            node = node.subtrees[c]\n\n        # entire prefix exists, true\n        return True\n\n    # overall: tc\n    # overall: sc",
        "questionNumber": 208,
        "solutionLink": "/Notes/leetcode-tries#solution-2-iterative-trie-implementation---trietrie-insert-and-search-recursive",
        "blog": "LeetCode: Tries"
      },
      {
        "number": 1,
        "name": "Trie Implementation",
        "type": "trie",
        "application": "trie-insert-and-search-recursive",
        "code": "class TrieNode:\n    def __init__(self):\n        # list of char subtrees for current node: char -> TrieNode\n        self.subtrees = {}\n        # Indicates end of a valid word\n        self.is_end = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        \n        # Note:\n        # root node does not store any chars itself,\n        # it only points to child chars\n        self.root = TrieNode()\n\n    # tc:\n    # sc: \n    def addWord(self, word: str) -> None:\n        \n        # Note:\n        #   Inserts a word into the trie character-by-character.\n        #   Creates new TrieNodes if a character path does not exist.\n        \n        # start at root\n        node = self.root\n\n        # for each char\n        for c in word:\n\n            # if subtree does not exist, create\n            if c not in node.subtrees:\n                node.subtrees[c] = TrieNode()\n\n            # iterate to subtree\n            node = node.subtrees[c]\n\n        # mark valid end of word\n        node.is_end = True\n\n\n    # tc:\n    # sc:\n    def search(self, word: str) -> bool:\n        \n        # Note:\n        #   In previous trie, all searches are deterministic\n        #   Here due to wildcard '.', we must try all possible subtree paths\n        #   and stop early if a match is found.\n        \n        def dfs(index: int, node: TrieNode) -> bool:\n            \n            # Base case: check if valid end of word\n            if index == len(word):\n                return node.is_end\n\n            # grab curr char\n            c = word[index]\n\n            # non deterministic: search all subtrees\n            if c == '.':\n\n                # try all subtree paths\n                for child_node in node.subtrees.values():\n\n                    # early exit if match is found\n                    if dfs(index + 1, child_node):\n                        return True\n\n                # explored all paths, string does not exist\n                return False\n\n            # deterministic: check if subtree exists\n            else:\n                # char subtree does not exist\n                if c not in node.subtrees:\n                    return False\n\n                # continue down char subtree\n                return dfs(index + 1, node.subtrees[c])\n\n        return dfs(0, self.root)\n\n    \n    # overall: tc\n    # overall: sc",
        "questionNumber": 211,
        "solutionLink": "/Notes/leetcode-tries#solution-1-trie-implementation---trietrie-insert-and-search-recursive",
        "blog": "LeetCode: Tries"
      },
      {
        "number": 1,
        "name": "Trie Implementation",
        "type": "trie",
        "application": "trie-insert-and-search-recursive",
        "code": "class TrieNode:\n\n    def __init__(self):\n        # list of char subtrees for current node: char -> TrieNode\n        self.subtrees = {}\n        # Indicates end of a valid word\n        self.isWord = False\n\n    # time complexity:\n    # space complexity:\n    def addWord(self, word):\n        # updated current node\n        node = self\n\n        # for each char\n        for c in word:\n\n            # if subtree does not exist, create\n            if c not in node.subtrees:\n                node.subtrees[c] = TrieNode()\n            \n            # iterate to subtree \n            node = node.subtrees[c]\n        \n        # set as valid end of word\n        node.isWord = True\n\n\nclass Solution:\n\n    # time complexity:\n    # space complexity:\n    def findWords(self, board, words):\n\n        # Note:\n        # 1. We build a Trie from the provided word list for O(1) prefix checking\n        # 2. DFS from each cell to explore all possible words\n        # 3. Mark visited cells in place by temporarily replacing char with '#'\n        #    to avoid using extra memory for tracking visited cells\n        # 4. Once word is found, add to results and remove from Trie (set node.Word=None)\n        #    to prevent duplicate matches\n        # 5. Prune Trie nodes by removing leaf nodes to reduce unnecessary DFS branches \n\n        # build Trie for provided words\n        root = TrieNode()\n        for word in words:\n            root.addWord(word)\n\n        # board boundaries\n        rows, cols = len(board), len(board[0])\n\n        # tracking \n        res, visit = set(), set()\n\n        def dfs(r, c, node, path):\n\n            # Boundary check and pruning:\n            \n            #   check board boundaries\n            if r < 0 or c < 0 or r >= rows or c >= cols:\n                return   \n            \n            # curr board char exists in Trie subtrees of node\n            if board[r][c] not in node.subtrees: \n                return\n\n            # curr cell has already been visited to avoid reuse\n            if (r, c) in visit:\n                return\n \n            # Not yet visited, continue dfs\n\n            # add to visited \n            visit.add((r, c))\n            \n            # grab subtrees\n            node = node.subtrees[board[r][c]]\n            # track char path\n            path += board[r][c]\n\n            # check if valid end of word\n            if node.isWord:\n                res.add(path)\n\n            # dfs: up, down, left, and left from current node\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                dfs(r + dr, c + dc, node, path)\n\n            # remove from curr node from visited\n            visit.remove((r, c))\n\n        # explore each cell in grid\n        for r in range(rows):\n            for c in range(cols):\n                # explore current cell\n                dfs(r, c, root, \"\")\n\n        # overall: time complexity\n        # overall: space complexity\n        return list(res)",
        "questionNumber": 212,
        "solutionLink": "/Notes/leetcode-tries#solution-1-trie-implementation---trietrie-insert-and-search-recursive",
        "blog": "LeetCode: Tries"
      },
      {
        "number": 2,
        "name": "Trie Implementation Optimal",
        "type": "trie",
        "application": "trie-insert-and-search-recursive",
        "code": "class TrieNode:\n    def __init__(self):\n        # list of char subtrees for current node: char -> TrieNode\n        self.subtrees = {}\n        # store complete word at end node, None if not end\n        self.word = None\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        \n        # Note:\n        # 1. Build a Trie from the given word list for O(1) prefix checking.\n        # 2. DFS from each cell to explore all possible words\n        # 3. Mark visited cells in place by temporarily replacing char with '#'\n        # 4. Once word is found, add to results and remove from Trie (set node.Word=None)\n        #    to prevent duplicate matches\n        # 5. Prune Trie nodes by removing leaf nodes to reduce unnecessary DFS branches \n        \n        # build Trie for provided words\n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                \n                # if subtree does not exist, create\n                if c not in node.subtrees:\n                    node.subtrees[c] = TrieNode()\n                # iterate to subtree\n                node = node.subtrees[c]\n\n            # add word to end of list \n            node.word = word\n\n        # grid boundaries\n        rows, cols = len(board), len(board[0])\n\n        # res\n        result = []\n\n        def backtrack(r: int, c: int, parent: TrieNode):\n            \n            # grab curr char\n            letter = board[r][c]\n\n            # grab node for curr char\n            curr_node = parent.subtrees[letter]\n\n            # if valid end of word\n            if curr_node.word:\n                result.append(curr_node.word)\n                # remove word to avoid duplicates\n                curr_node.word = None  \n\n            # mark the cell as visited\n            board[r][c] = \"#\"\n\n            # dfs: up, down, left, and right from curr node\n            for (dr, dc) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                \n                # new rows and columns\n                (nr, nc) = r + dr, c + dc\n                \n                # ignore dfs if invalid\n                if (0 <= nr < rows and \n                    0 <= nc < cols and \n                    board[nr][nc] in curr_node.subtrees):\n                    backtrack(nr, nc, curr_node)\n\n            # restore cell (unvisited)\n            board[r][c] = letter\n\n            # Optimization: \n            # Remove leaf node to prune search space\n            # if char has no more subtrees, remove from search space\n            # (which will prune as we return recursively)\n            if not curr_node.subtrees:\n                parent.subtrees.pop(letter)\n\n        # dfs from all cells\n        for r in range(rows):\n            for c in range(cols):\n                # for curr cell\n                if board[r][c] in root.subtrees:\n                    backtrack(r, c, root)\n\n        # overall: time complexity\n        # overall: space complexity\n        return result",
        "questionNumber": 212,
        "solutionLink": "/Notes/leetcode-tries#solution-2-trie-implementation-optimal---trietrie-insert-and-search-recursive",
        "blog": "LeetCode: Tries"
      }
    ]
  },
  "heap": {
    "heap": [
      {
        "number": 1,
        "name": "Min Heap Of Size K Tracks The Kth Largest Element",
        "type": "heap",
        "application": "heap",
        "code": "class KthLargest:\n\n    # MinHeap:\n    # We need to track 2 things\n    #   - The root min item currently in the stack, which represents kth highest\n    #   - Number of items in the stack\n\n    # For our functions, they may need to update the above 2\n\n    # KthLargest():\n    #   - Initializes the minHeap\n    #   - Starts adding more numbers\n\n    # Add():\n    #   - Adds a number to the minHeap\n    #   - Returns the kth largest element up to that point\n\n    def __init__(self, k: int, nums: list[int]):\n        \n        # MinHeap of size k:\n        # will contain the k largest elements seen so far,\n        # lowest top score at root which represents the kth highest number\n\n        # limiting size of minHeap to be size k    \n        self.k = k\n\n        # minHeap\n        self.minHeap = []\n        \n        # mimic 'streaming' input data into minHeap\n        for num in nums:\n            self.add(num)\n    \n    # tc:\n    # sc: \n    def add(self, val: int) -> int:\n\n        # Attempt to add element to stack\n        #   - if minHeap has less elements than k, simply add new element\n        #   - if minHeap is out of space, push only if new score is higher than \n        #     current lowest score at the root\n\n        # Heap still has space, add element\n        if len(self.minHeap) < self.k:\n            heapq.heappush(self.minHeap, val)\n\n        # Heap is out of space, check against min element\n        else:\n            # Grab min element\n            smallestTopScore = self.minHeap[0]\n\n            # Add score if its higher than current lowest element\n            if val > smallestTopScore:\n                # Replace root element\n                heapq.heapreplace(self.minHeap, val)\n        \n        # return top k score\n        return self.minHeap[0]\n\n    # overall: tc\n    # overall: sc",
        "questionNumber": 703,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-min-heap-of-size-k-tracks-the-kth-largest-element---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "Inverted MinHeap Is A MaxHeap Of Size K Tracking The Kth Smallest Element",
        "type": "heap",
        "application": "heap",
        "code": "def lastStoneWeight(self, stones: list[int]) -> int:\n        \n        # MaxHeap:\n        # We use a max heap to always extract the two largest stones efficiently.\n        # Since Python only provides a min heap, we simulate a max heap\n        # by inserting negative values.\n\n        # Heap Strategy:\n        # 1. Build a max heap from the input stones.\n        # 2. Repeatedly remove the two largest stones.\n        # 3. Smash them together and, if a remainder exists, push it back into the heap.\n        # 4. Continue until at most one stone remains.\n        # Result: return the final stone weight or 0 if all stones are destroyed.\n\n\n        # MaxHeap List:\n        # Turn positive stone weights into negative weights\n        # tc:\n        # sc:\n        maxHeap = [-stone for stone in stones]\n\n        # MaxHeap:\n        # Transform negative list into heap in place in linear time\n        # MinHeap with negative numbers is a MaxHeap\n        # tc:\n        # sc:\n        heapq.heapify(maxHeap)\n\n        # remove top two stones until one stone left\n        # tc:\n        while len(maxHeap) > 1:\n\n            # Grab two heaviest stones\n            heaviest = -(heapq.heappop(maxHeap))\n            second_heaviest = -(heapq.heappop(maxHeap))\n\n            # If remainder stone\n            if heaviest != second_heaviest:\n\n                # Get remainder stone\n                remainingStoneWeight = -(heaviest - second_heaviest)\n\n                # Push remaining stone back to MaxHeap\n                heapq.heappush(maxHeap, remainingStoneWeight)\n\n        # Check: if any stone remains\n        # Grab the heaviest stone\n        res = -maxHeap[0] if maxHeap else 0\n\n        # overall: tc\n        # overall: sc\n        return res",
        "questionNumber": 1046,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-inverted-minheap-is-a-maxheap-of-size-k-tracking-the-kth-smallest-element---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "Max Heap of size k",
        "type": "heap",
        "application": "heap",
        "code": "def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n        \n        # Note:\n        # 1. We want the k points with the smallest Euclidean distances from (0, 0).\n        # 2. Instead of computing sqrt(x^2 + y^2), we can use the squared distance x^2 + y^2\n        #    because sqrt is monotonic and doesn't change order.\n        # 3. Approach:\n        #    - Use a max-heap (store negative distances) of size k.\n        #    - Iterate over points:\n        #         if heap size < k: push (-distance, point)\n        #         else if current distance < largest distance in heap: pop and push\n        #    - This ensures we always keep k closest points in O(n log k) time.\n\n        # (-distance, [x, y])\n        maxHeap = []\n\n        # add all distances to maxHeap\n        for x, y in points:\n\n            # square distance\n            dist = x * x + y * y \n\n            # if maxHeap has space, simply push\n            if len(maxHeap) < k:\n                heapq.heappush(maxHeap, (-dist, [x, y]))\n\n            # if maxHeap is full, check if push is required\n            else:\n\n                # if closer than farthest point\n                if dist < -maxHeap[0][0]:\n                    heapq.heapreplace(maxHeap, (-dist, [x, y]))\n        \n        # grab list of coords\n        res = [xy for (_, xy) in maxHeap]\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 973,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-max-heap-of-size-k---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 2,
        "name": "QuickSelect",
        "type": "heap",
        "application": "heap",
        "code": "def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n        \n        # Note:\n        # Classic Quick Select but with square distance\n        # sqrt() is monotonic so we can ignore it\n        \n        # squared distance to origin\n        def dist(i: int) -> int:\n            return points[i][0] ** 2 + points[i][1] ** 2\n        \n        def partition(left, right, randPivotIndex) -> int:\n\n            # prepare partition\n            randPivotDist = dist(randPivotIndex)\n            points[randPivotIndex], points[right] = points[right], points[randPivotIndex]\n            leftPartition = left\n            \n            # partition all closer points to left\n            for i in range(left, right):\n\n                # if point is closer to origin (lower)\n                if dist(i) < randPivotDist:\n                    points[leftPartition], points[i] = points[i], points[leftPartition]\n                    leftPartition += 1\n            \n            # restore pivot\n            points[right], points[leftPartition] = points[leftPartition], points[right]\n\n            # return\n            return leftPartition\n        \n        def quickselect(left, right, finalIndex):\n            \n            # Base case:\n            if left >= right:\n                return\n            \n            # random pivot and result\n            randPivotIndex = random.randint(left, right)\n            resPivot = partition(left, right, randPivotIndex)\n            \n            # target check\n            if resPivot == finalIndex:\n                return\n            \n            elif resPivot < finalIndex: \n                quickselect(resPivot + 1, right, finalIndex)\n\n            else:\n                quickselect(left, resPivot - 1, finalIndex)\n            \n        \n        # boundary\n        n = len(points)\n\n        # quickSelect on bounds\n        quickselect(0, n - 1, k)\n\n        # grab lowest k points\n        res = points[:k]\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 973,
        "solutionLink": "/Notes/leetcode-heaps#solution-2-quickselect---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "Min Heap of Size k",
        "type": "heap",
        "application": "heap",
        "code": "def findKthLargest(self, nums: list[int], k: int) -> int:\n        # Note:\n        # 1. MinHeap of size k\n        # Result: root of minHeap contains kth largest element\n        \n        # heap\n        minHeap = []\n        \n        # for each element\n        for num in nums:\n\n            # if heap has space, simply push\n            if len(minHeap) < k:\n                heapq.heappush(minHeap, num)\n\n            # if heap has no space, check if push is necessary\n            else:\n                # push if new num is larger than smallest in minHeap,\n                # this will force a new kth largest element\n                if num > minHeap[0]:\n                    heapq.heapreplace(minHeap, num)\n        \n        # kth largest is at the root of the minHeap\n        kth = minHeap[0]\n\n        # overall: time complexity\n        # overall: space complexity\n        return kth",
        "questionNumber": 215,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-min-heap-of-size-k---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 2,
        "name": "Modified Ignore Duplicates Quick Select",
        "type": "heap",
        "application": "heap",
        "code": "def findKthLargest(self, nums: List[int], k: int) -> int:\n        \n        # Note:\n        # Optimized Quick Select which will remove 1 subList of duplicates per iteration \n        # 1. RandPivot\n        # 2. Partition nums by creating larger, equal, or smaller than pivot subLists\n        # 3. Recurse into the correct subList\n        # Result: kth largest found while accounting for potential stream of duplicates\n\n        # Empty check\n        if not nums: \n            return\n        \n        # random pivot\n        pivot = random.choice(nums)\n        \n        # Partition nums into three parts:\n        # bigger: elements greater than pivot\n        bigger = [num for num in nums if num > pivot]\n        \n        # if kth is within bigger, recurse\n        if k <= len(bigger):\n            return self.findKthLargest(bigger, k)\n        \n        # Duplicate Optimization \n        # equal: elements equal to pivot\n        equal = [num for num in nums if num == pivot]\n        \n        # If kth largest is within biggest + equal count,\n        # kth will be within partition duplicate list\n        if k <= len(bigger) + len(equal):\n            return equal[0]\n        \n        # kth must be within smaller list, recurse\n        # update k to ignore length of bigger and equal list\n        smaller = [num for num in nums if num < pivot]\n        return self.findKthLargest(smaller, k-len(bigger)-len(equal))",
        "questionNumber": 215,
        "solutionLink": "/Notes/leetcode-heaps#solution-2-modified-ignore-duplicates-quick-select---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "Highest Occurring Tasks into Greedy Math Formula",
        "type": "heap",
        "application": "heap",
        "code": "def leastInterval(self, tasks: list[str], n: int) -> int:\n\n        # Note:\n        # 1. Highest occurring tasks + idle time determine the min scheduling\n        # 2. Total number of tasks determine the min scheduling\n        # Result: min scheduling for list of tasks \n\n        # Count frequency of each task (A-Z)\n        freq = defaultdict(int)\n        for task in tasks:\n            freq[task] += 1\n        \n        # highest number of occurrences for single task\n        maxFreq = max(freq.values())\n        \n        # number of tasks with highest number of occurrences\n        maxCount = sum(1 for count in freq.values() if count == maxFreq)\n        \n        # The minimum time is based on arranging the most frequent tasks spaced by n:\n        # ex:\n        # A, B, C share freq count of 9\n        # idle interval n = 5\n        # \n        # so:\n        # [A -> B -> C -> idle -> idle...] * 8 times\n        # + [A -> B -> C] last group (notice no idles needed)\n\n        # (maxFreq-1) -> 8 times = groups\n        # (n+1) = length of group (n idle time + 1 for task occurrence\n\n        # + maxCount for last group\n        intervals = (maxFreq - 1) * (n + 1) + maxCount\n        \n        # if totalTasks is higher than intervals, totalTasks is the lower bound\n        # ie: A,B,C combo takes 51 \n        #     however, rest of alphabet all has 4 count, leading to 119\n        # we will take the 119\n        # (in this case, we wont have to use idle)\n        res = max(intervals, len(tasks))\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 621,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-highest-occurring-tasks-into-greedy-math-formula---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 2,
        "name": "Max Heap Tick by Tick Simulation For Count Occurrences",
        "type": "heap",
        "application": "heap",
        "code": "def leastInterval(self, tasks: list[str], n: int) -> int:\n\n        # Note:\n        # Simulates task scheduling process \n        # 1. MaxHeap picks current most frequent remaining task first\n        # 2. Queue (FIFO) simulates cool down to store tasks that have been run\n        # but must wait 'n' intervals before they can be scheduled again\n        # 3. Each iteration represents 1 unit of CPU time\n        # 4. Iterate until both MaxHeap and Queue are empty\n        # Result: time is total CPU time needed, including idle intervals\n\n        # counts\n        freq = Counter(tasks)\n        \n        # MaxHeap with negative counts\n        maxHeap = [-count for count in freq.values()]\n        heapq.heapify(maxHeap)\n        \n        # total CPU time simulated\n        time = 0\n        \n        # Queue to hold cooldown tasks: (ready_time, count)\n        cooldown = deque()\n        \n        # until both are empty\n        while maxHeap or cooldown:\n\n            # 1 CPU tick\n            time += 1\n            \n            # grab most frequent task\n            if maxHeap:\n                \n                # remove most freq task from root, and decrement by 1 \n                cnt = heapq.heappop(maxHeap) + 1\n                if cnt != 0:\n                    # put task into cool down,\n                    # and calculate time until next available use\n                    cooldown.append((time + n, cnt))\n            \n            # check if any task in cool down is ready to be added back to maxHeap\n            if cooldown and cooldown[0][0] == time:\n\n                # pop FIFO\n                _, cnt = cooldown.popleft()\n\n                # push task occurrence count back to maxHeap\n                heapq.heappush(maxHeap, cnt)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return time",
        "questionNumber": 621,
        "solutionLink": "/Notes/leetcode-heaps#solution-2-max-heap-tick-by-tick-simulation-for-count-occurrences---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 3,
        "name": "Max Heap Time Jump Optimization Simulation for Count Occurrences",
        "type": "heap",
        "application": "heap",
        "code": "def leastInterval(self, tasks: List[str], n: int) -> int:\n\n        # Note:\n        # Simulates task scheduling with a MaxHeap + cool down queue\n        # 1. MaxHeap picks current most frequent remaining task first\n        # 2. Queue (FIFO) simulates cool down to store tasks that have been run\n        # but must wait 'n' intervals before they can be scheduled again\n        # 3. if MaxHeap is empty but cool down queue is not, we 'jump' \n        #    directly to the next ready task instead of simulating idle ticks,\n        #.   skipping over unnecessary +1 increments and speeds up simulation\n        # Result: time is total CPU time needed, including idle intervals,\n        #         with fewer iterations\n        \n        \n        # counts\n        freq = Counter(tasks)\n        \n        # MaxHeap with negative counts\n        maxHeap = [-count for count in freq.values()]\n        heapq.heapify(maxHeap)\n\n        # total CPU time simulated\n        time = 0\n\n        # Queue to hold cooldown tasks: (-cnt, idleTime)\n        q = deque()  \n\n        # until both are empty\n        while maxHeap or q:\n\n            # CPU tick\n            time += 1\n\n            # if maxHeap is empty\n            if not maxHeap:\n                # time 'jump' to next cool down\n                time = q[0][1]\n\n            # maxHeap is non empty\n            else:\n\n                # remove most freq task from root, and decrement by 1 \n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    # put task into cool down,\n                    # and calculate time until next available use \n                    q.append([cnt, time + n])\n\n            # check if any task in cool down is ready to be added back to maxHeap\n            if q and q[0][1] == time:\n                \n                # pop FIFO\n                (cnt, idleTime) = q.popleft()\n\n                heapq.heappush(maxHeap, cnt)\n\n        # overall: time complexity\n        # overall: space complexity\n        return time",
        "questionNumber": 621,
        "solutionLink": "/Notes/leetcode-heaps#solution-3-max-heap-time-jump-optimization-simulation-for-count-occurrences---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "Store Tweets as Lists + Min Heap Merge",
        "type": "heap",
        "application": "heap",
        "code": "class Twitter:\n\n    def __init__(self):\n\n        # IRL Use Case: \n        # Balanced usage scenario users follow moderate number of accounts, tweet counts are not huge.\n\n        # Note:\n        # Tweets: Stores tweets as deques (lists) per user.\n        # News Feed: Merges k sorted lists using a maxHeap to always pick the most\n        #            recent tweet across the user and their followees.\n\n        # Pros: Simple implementation, efficient for moderate tweet counts.\n        # Cons: Heap merge has some overhead; memory grows with many tweets per user.\n\n        self.followees = defaultdict(set)\n        self.tweets = defaultdict(deque)\n        self.time = 0\n        self.FEED_SIZE = 10\n\n    # time complexity:\n    # space complexity:\n    def postTweet(self, userId: int, tweetId: int) -> None:\n\n        # Note:\n        #\n\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n\n        if len(self.tweets[userId]) > 100:\n            self.tweets[userId].popleft()\n\n    # time complexity:\n    # space complexity:\n    def follow(self, followerId: int, followeeId: int) -> None:\n\n        # Note:\n        #\n\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    # time complexity:\n    # space complexity:\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n\n        # Note:\n        #\n\n        self.followees[followerId].discard(followeeId)\n\n    # time complexity:\n    # space complexity:\n    def getNewsFeed(self, userId: int) -> list[int]:\n\n        # Note:\n        #\n\n        # heap stores (-timestamp, tweetId, userId, index_in_user_tweets)\n        heap = []\n\n        # The list of users to fetch tweets from: self + followees\n        users = self.followees[userId] | {userId}\n        \n        # Init pointers for each user tweet list (start from newest)\n        for u in users:\n\n            if self.tweets[u]:\n\n                # Index of last tweet in deque (newest)\n                idx = len(self.tweets[u]) - 1\n                timestamp, tweetId = self.tweets[u][idx]\n                heapq.heappush(heap, (-timestamp, tweetId, u, idx))\n        \n        result = []\n\n        while heap and len(result) < self.FEED_SIZE:\n\n            neg_time, tweetId, u, idx = heapq.heappop(heap)\n            result.append(tweetId)\n\n            # Move pointer to next newest tweet if available\n            if idx > 0:\n                idx -= 1\n                timestamp, tweetId = self.tweets[u][idx]\n                heapq.heappush(heap, (-timestamp, tweetId, u, idx))\n        \n        return result\n\n    # overall: time complexity\n    # overall: space complexity",
        "questionNumber": 355,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-store-tweets-as-lists-min-heap-merge---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 2,
        "name": "Store Tweets as Linked Lists + Merge K Sorted Lists",
        "type": "heap",
        "application": "heap",
        "code": "class TweetNode:\n   \n    # IRL Use Case: \n    # 'Celebrity' users with many tweets; avoids indexing overhead when fetching top 10.    \n    \n\n    # Note:\n    # Tweets: Linked list node for tweets, storing tweetId, timestamp, and next pointer\n    # News Feed: MaxHeap merges the heads of k linked lists, picking the newest tweet each time to produce top 10.\n\n    # Pros: Handles users with very large tweet histories efficiently.\n    # Cons: Pointer overhead; more complex than simple list implementation.\n\n    def __init__(self, tweetId, time):\n        self.tweetId = tweetId\n        self.time = time\n        self.next = None\n\nclass Twitter:\n    def __init__(self):\n\n        # Note:\n        # Stores tweets as linked lists.\n        # News feed built by max-heap merging list heads.\n        # Pros/Cons as above.\n\n        # Map userId to head of linked list of tweets\n        self.tweets = {}\n\n        # Map userId to set of followed userIds\n        self.followees = defaultdict(set)\n        self.time = 0\n        self.FEED_SIZE = 10\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \n        # Note:\n        # \n\n        self.time += 1\n        node = TweetNode(tweetId, self.time)\n        node.next = self.tweets.get(userId, None)\n        self.tweets[userId] = node\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n\n        # Note:\n        # \n\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n\n        # Note:\n        #\n\n        self.followees[followerId].discard(followeeId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n\n        # Note:\n        #\n\n        # Users to consider: self + followees\n        users = self.followees[userId] | {userId}\n        \n        # Build a max heap of (-time, TweetNode) for heads of all tweet lists\n        heap = []\n\n        for u in users:\n\n            if self.tweets.get(u):\n                heapq.heappush(heap, (-self.tweets[u].time, self.tweets[u]))\n        \n        result = []\n\n        while heap and len(result) < self.FEED_SIZE:\n\n            neg_time, node = heapq.heappop(heap)\n            result.append(node.tweetId)\n\n            if node.next:\n                heapq.heappush(heap, (-node.next.time, node.next))\n        \n        return result\n\n    # overall: time complexity\n    # overall: space complexity",
        "questionNumber": 355,
        "solutionLink": "/Notes/leetcode-heaps#solution-2-store-tweets-as-linked-lists-merge-k-sorted-lists---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 3,
        "name": "Store Tweets as Arrays/Deques + Dynamic Heap Merge",
        "type": "heap",
        "application": "heap",
        "code": "class Twitter:\n\n    def __init__(self):\n\n        # IRL Use Case: \n        # Most practical for IRL apps where MOST users have few tweets and follow a manageable number of accounts.\n        # Slightly more efficient than Solution 1 due to index-based access for news feed construction.\n\n        # Note:\n        # Tweets: Stores tweets as deques per user, uses indices to access latest tweets.\n        # News Feed: Max-heap merges the most recent tweets from each user for news feed.\n        \n        # Pros: Simple, practical, low overhead, works well with typical usage.\n        # Cons: Slightly more complex than naive list append-only approach; still has heap overhead.\n\n        # Map userId to list of (timestamp, tweetId)\n        self.tweets = defaultdict(deque)\n        \n        # Map userId to set of followed userIds\n        self.followees = defaultdict(set)\n        \n        # Global timestamp for ordering\n        self.time = 0\n        self.FEED_SIZE = 10\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        # Increment timestamp\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # Optional: limit stored tweets to last 100 per user\n        if len(self.tweets[userId]) > 100:\n            self.tweets[userId].popleft()\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.followees[followerId].discard(followeeId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Users to pull tweets from: self + followees\n        users = self.followees[userId] | {userId}\n        heap = []\n\n        # Initialize heap with most recent tweet of each user\n        for u in users:\n            if self.tweets[u]:\n                idx = len(self.tweets[u]) - 1\n                ts, tid = self.tweets[u][idx]\n                heapq.heappush(heap, (-ts, tid, u, idx))\n\n        result = []\n\n        while heap and len(result) < self.FEED_SIZE:\n            neg_ts, tid, u, idx = heapq.heappop(heap)\n            result.append(tid)\n            if idx > 0:\n                idx -= 1\n                ts, tid = self.tweets[u][idx]\n                heapq.heappush(heap, (-ts, tid, u, idx))\n\n        return result",
        "questionNumber": 355,
        "solutionLink": "/Notes/leetcode-heaps#solution-3-store-tweets-as-arrays-deques-dynamic-heap-merge---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 1,
        "name": "MaxHeap + MinHeap Median Finder",
        "type": "heap",
        "application": "heap",
        "code": "class MedianFinder:\n\n    # Note:\n    # Two\n\n    def __init__(self):\n        \n        # MaxHeap stores smaller half,\n        # all numbers less than or equal to the median\n        self.maxHeap = []\n\n        # MinHeap stores larger half,\n        # all numbers greater than or equal to the median\n        self.minHeap = []\n\n    # time complexity:\n    # space complexity: \n    def addNum(self, num: int) -> None:\n\n        # Note:\n        # Two heaps track lower and upper half\n        # \n\n        # Add new number to maxHeap\n        heapq.heappush(self.maxHeap, -num)\n        \n        # Ensure all elements in maxHeap greater than every element in minHeap\n        # move smallest  largest from maxHeap to minHeap if out of order\n        if (self.minHeap and (-self.maxHeap[0] > self.minHeap[0])):\n            val = -heapq.heappop(self.maxHeap)\n            heapq.heappush(self.minHeap, val)\n        \n        # Balance heaps:\n        # MaxHeap should have 1 more element than minHeap\n\n        # if minHeap is larger, move minHeap root to maxHeap\n        if len(self.maxHeap) < len(self.minHeap):\n            \n            #\n            val = heapq.heappop(self.minHeap)\n            #\n            heapq.heappush(self.maxHeap, -val)\n\n        # if maxHeap is larger by more than 1, move maxHeap root to minHeap\n        elif len(self.maxHeap) > len(self.minHeap) + 1:\n            \n            #\n            val = -heapq.heappop(self.maxHeap)\n            #\n            heapq.heappush(self.minHeap, val)\n\n\n    # time complexity:\n    # space complexity:\n    def findMedian(self) -> float:\n\n        # Note:\n        # Median retrieval logic:\n        # 1. if odd -> root of MaxHeap (largest in smaller half)\n        # 2. if even -> average of roots from both heaps\n\n        # odd\n        if len(self.maxHeap) > len(self.minHeap):\n            return -self.maxHeap[0]\n       \n        # even\n        average = (-self.maxHeap[0] + self.minHeap[0]) / 2\n\n        return average",
        "questionNumber": 295,
        "solutionLink": "/Notes/leetcode-heaps#solution-1-maxheap-minheap-median-finder---heapheap",
        "blog": "LeetCode: Heaps"
      },
      {
        "number": 2,
        "name": "Balanced BST",
        "type": "heap",
        "application": "heap",
        "code": "class MedianFinder:\n    def __init__(self):\n\n        # Note:\n        # balanced binary tree \n        self.sl = SortedList()\n\n    # time complexity:\n    # space complexity:\n    def addNum(self, num: int) -> None:\n\n        # insert in sorted order\n        self.sl.add(num)\n\n    # time complexity:\n    # space complexity:\n    def findMedian(self) -> float:\n        \n        # len\n        n = len(self.sl)\n\n        # odd\n        if n % 2 == 1:\n            return self.sl[n // 2]\n\n        # even\n        average = (self.sl[n // 2 - 1] + self.sl[n // 2]) / 2\n\n        return average\n\n    \n    # overall: time complexity\n    # overall: space complexity",
        "questionNumber": 295,
        "solutionLink": "/Notes/leetcode-heaps#solution-2-balanced-bst---heapheap",
        "blog": "LeetCode: Heaps"
      }
    ]
  },
  "backtracking": {
    "generate-all-combinations-or-subsets": [
      {
        "number": 1,
        "name": "Recursive DFS Backtracking on Global Path to Generate All Subsets",
        "type": "backtracking",
        "application": "generate-all-combinations-or-subsets",
        "code": "def subsets(self, nums: List[int]) -> List[List[int]]:\n\n        # Backtracking 1: Hit All Path Max Depths\n        # Recursive function that builds a solution incrementally,\n        # exploring all possible choices at each step.\n\n        # Determining Backtracking Complexity:\n        # For backtracking, we can determine the complexity by seeing how many choices \n        # we have at a branch,\n        # for this we have the 2 options of 1. adding or 2. not adding a number to the path,\n        # and we have this choice for n numbers, so we get 2^n \n\n        # Shallow Copy:\n        # A shallow copy means that the top level object is copied, but the elements inside\n        # are not duplicated, they are still references to the same objects.\n        # if a an object like school, had inner student objects, if we copied the school object, \n        # the new object would still refer to the original student objects\n        # Since we are dealing with integers, a deep copy is not required, shallow is fine,\n        # but it is interesting to note that different path objects will be sharing the same\n        # reference to integer objects, but again, this is fine since in python integers are immutable\n        # tc: copy in O(n), since path can have up to n elements\n        # sc: copy in O(n), list of n elements added to the result list\n        \n        # Backtracking Path:\n        # Follows the standard choose -> explore -> unchoose pattern:\n        #   1. Choose: add a number to the current path\n        #   2. Explore: recurse to build further subsets from the next index\n        #   3. Unchoose (Backtrack): remove the last number to restore state\n        # The recursion continues until all valid subsets are generated.\n\n        # sc: O(n * 2^n) 2^n subsets each length up to n\n        res = []\n\n        # sc: O(n), holds current subset during recursion of max length n\n        path = []  \n\n        # tc: O(n * 2^n)  2^n subsets, each copied (length <= n)\n        # sc: O(n * 2^n)  2^n subsets, each stores (length <= n) + recursion stack O(n) overruled\n        def dfs_backtrack(start: int):\n            \n            # Process Root: Check 1 Base Case\n\n            # Base Case 1: add subset\n            # add current subset (shallow copy) to full subset list\n            # tc: O(n) for copy of path (max length n)\n            # sc: O(n) added to result\n            res.append(path[:])\n\n            # Process Choices:\n            # tc: iterate over n\n            for i in range(start, len(nums)):\n                \n                # Choose:\n                # build next path, append number to current path\n                # tc: O(1), sc: O(1)\n                path.append(nums[i])\n\n                # Explore:\n                # recurse to build further subsets\n                # use next index to avoid reusing current number candidate\n                # tc: O(2^n) total recursive calls (all possible subsets)\n                dfs_backtrack(i+1)\n\n                # Unchoose: Backtrack \n                # remove last number to explore next choice\n                # tc: O(1), sc: O(1)\n                path.pop()\n\n        # Initial call, no path passed\n        dfs_backtrack(0)\n\n        # overall: tc O(n * 2^n)\n        # overall: sc O(n * 2^n)\n        return res",
        "questionNumber": 78,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-dfs-backtracking-on-global-path-to-generate-all-subsets---backtrackinggenerate-all-combinations-or-subsets",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 2,
        "name": "Yield Recursive DFS Backtracking On Global Path to Generate All Subsets",
        "type": "backtracking",
        "application": "generate-all-combinations-or-subsets",
        "code": "def subsets(self, nums: List[int]) -> Iterable[List[int]]:\n\n        # Backtracking 1: Hit All Path Max Depths\n        # Recursive function that builds a solution incrementally,\n        # exploring all possible choices at each step.\n\n        # Generator / Yield vs Result List:\n        # In traditional backtracking (like Solution 1 and 3), we store all subsets\n        # in a list 'res'. Each valid subset is copied and added to 'res', so memory\n        # usage grows proportional to the total number of subsets (O(n * 2^n)).\n        #\n        # Using 'yield', we generate subsets one at a time instead of storing them all.\n        # The generator pauses at each 'yield' and resumes when the next subset is requested.\n        # As a result, only the current path and recursion stack are kept in memory,\n        # reducing auxiliary space to O(n), independent of the total number of subsets.\n        # The caller may still store the subsets if desired, but inside the function\n        # itself, no large list of all subsets is maintained.\n\n        # Generator / Yield Auxiliary space (not counting the output):\n        # Only the current path and recursion stack are in memory, O(n) instead of O(n * 2^n)\n        # yield reduces memory used inside the function itself, because it doesn't \n        # have to store all results within res.\n        # Usually, all paths would exist at the same time, however 'yield' allows us to produce subsets\n        # one at a time instead of storing them all in a list that gets passed around\n\n        # Mutable path list used to build subsets\n        # sc: O(n) holds the current path (max depth = n)\n        path = []\n\n        def dfs_backtrack(start: int):\n\n            # Process Root:\n            # Yield the current subset (shallow copy of path)\n            # tc: O(n) to copy path\n            # sc: O(n) for copy, added to output by caller if collected\n            yield path[:]\n\n            # Explore All Choices:\n            # Iterate over remaining elements starting from index `start`\n            # tc: O(n) per level, total recursive calls = 2^n\n            for i in range(start, len(nums)):\n\n                # Build New Path:\n                # Append current number to path\n                # tc: O(1), sc: O(1)\n                path.append(nums[i])\n\n                # Recurse New Path:\n                # Recurse with next index to avoid duplicates and reuse\n                # tc: O(2^n) total recursive calls\n                # sc: recursion stack O(n)\n                yield from dfs_backtrack(i + 1)\n\n                # Backtrack To Current Path:\n                # Remove last number to explore alternative paths\n                # tc: O(1), sc: O(1)\n                path.pop()\n\n        # Initial call, no path passed\n        # tc: O(1) to create generator\n        # sc: O(1) auxiliary for the generator object itself\n        res = dfs_backtrack(0)\n\n        # At this point:\n        # - res is NOT a list of subsets\n        # - res is a generator object (think of it like a paused function)\n        # - no subsets have been stored yet\n        # - only the dfs_backtrack function definition exists and can produce values\n\n        # To get subsets, we need to consume the generator:\n        #\n        # 1. Iterate over it directly:\n        #   for subset in res:\n        #         print(subset)        ->   subsets are generated one by one\n        #\n        # 2. Convert to list to store all subsets in memory:\n        #   all_subsets = list(res)    ->   now all subsets are generated and stored\n\n        # overall: tc O(n * 2^n)          # must generate all subsets, each copied\n        # overall: sc O(n)                # auxiliary, recursion stack + path\n        # overall: sc O(n * 2^n)          # including storing all subsets (if caller stores them)\n        return res",
        "questionNumber": 78,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-yield-recursive-dfs-backtracking-on-global-path-to-generate-all-subsets---backtrackinggenerate-all-combinations-or-subsets",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 3,
        "name": "Iterative Append to Existing Subsets",
        "type": "backtracking",
        "application": "generate-all-combinations-or-subsets",
        "code": "def subsets(self, nums: List[int]) -> List[List[int]]:\n\n        # Backtracking 1: Hit All Path Max Depths\n        # Iterative function that builds a solution incrementally,\n        # exploring all possible choices at each step.\n\n        # Determining Backtracking Complexity:\n        # For backtracking, we can determine the complexity by seeing how many choices \n        # we have at a branch,\n        # for this we have the 2 options of 1. adding or 2. not adding a number to the path,\n        # and we have this choice for n numbers, so we get 2^n \n\n        # Backtracking Path:\n        # Follows the standard choose -> explore -> unchoose pattern:\n        #   1. Choose: add a number to the current path\n        #   2. Explore: form new subsets by including this number in all existing subsets\n        #   3. Unchoose: implicit, as original subsets remain unchanged\n        # Continues until all valid subsets are generated.\n\n        # Process Root: Check 1 Base Case\n\n        # Base Case: Empty Subset\n        # first valid subset is the empty subset\n        # sc: O(n * 2^n) 2^n subsets each length up to n\n        res = [[]]\n\n        # Process Choices: \n        # tc: iterate over n O(n)\n        for n in nums:\n\n            # Grab all current paths:\n            # New paths will be build upon current paths, grab current paths\n            currentSubsetNum = len(res)\n            # tc: iterate over 2^n subsets O(2^n)\n            for i in range(currentSubsetNum):\n\n                # Choose:\n                # build new path, new subset by adding number to an existing subset\n                # tc: O(n) for copy of path length n\n                # sc: O(n) for new string of length n\n                newSubset = res[i] + [n]\n\n                # Incorrect String Copying:\n                # new = res[i].append(n) \n                # as .append() always returns None for in-place modification\n\n                # Explore:\n                # append new subset to result list, will be explored in future iterations\n                # tc: O(n) for copy of path (max length n)\n                # sc: O(n) added to result                \n                res.append(newSubset)\n\n                # Unchoose (backtrack):\n                # implicit, original smaller subsets remain unchanged in res list,\n                # will be used in future iterations \n\n        # overall: tc O(n * 2^n)\n        # overall: sc O(n * 2^n)\n        return res",
        "questionNumber": 78,
        "solutionLink": "/Notes/leetcode-backtracking#solution-3-iterative-append-to-existing-subsets---backtrackinggenerate-all-combinations-or-subsets",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 1,
        "name": "Late Pruning Recursive Unsorted Forward Backtracking On Global Path",
        "type": "backtracking",
        "application": "generate-all-combinations-or-subsets",
        "code": "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        # Backtracking 2: Pruning Invalid Solutions\n        # Recursive function that builds a solution incrementally,\n        # exploring only choices that can still lead to a valid solution.\n        \n        # When a partial solution violates constraints (in this case, sum > target),\n        # the recursion stops immediately and prunes the branch\n        # instead of continuing to explore further.\n        # This reduces the search space compared to full backtracking,\n        # improving practical runtime while preserving correctness.\n        # Time complexity remains exponential in the worst case,\n        # where all paths end up being valid,\n        # but pruning lowers the effective branching factor.\n        # Space complexity is O(depth) due to the recursion call stack.\n\n        # Late Pruning:\n        # Candidates are added first, and only then pruned within the branch itself.\n        # This creates more branches than early pruning solutions, as invalid branches\n        # are explored first and only pruned after exceeding constraints.\n\n        # Backtracking (DFS) with Late Pruning:\n        # Recursive function that builds solutions incrementally using a global path.\n        # Follows the standard choose -> explore -> unchoose pattern:\n        #   1. Choose: add a candidate to the current path\n        #   2. Explore: recurse to build further choices from the current index (reuse allowed)\n        #       - Process current root:\n        #       - Check if the current sum equals the target\n        #       - Late Pruning: stop recursion if the current sum exceeds the target\n        #   3. Unchoose (Backtrack): remove the last candidate to restore state\n        # Result: all valid combinations are appended to the result list\n\n        # sc: O(1) initially, grows as valid combinations are added\n        res = []\n\n        # sc: O(depth), holds the current path during recursion\n        path = []\n\n        def dfs_backtrack(start, currSum):\n\n            # Process Root: Check 2 Base Cases\n\n            # Base Case 1: target found\n            if currSum == target:\n\n                # tc: O(depth) for shallow copy\n                # sc: O(depth) added to result\n                res.append(path[:])\n                return\n\n            # Base Case 2: late branch pruning\n            # Check: if sum is exceeds the target\n            # Then: prune future branches and return\n            # tc: O(1)\n            # sc: O(1)\n            if currSum > target:\n                return\n\n            # Process Choices:\n\n            # Process Choices -> explore candidates from current index forward\n            for i in range(start, len(candidates)):\n\n                # tc: O(1), sc: O(1)\n                candidate = candidates[i]\n\n                # Choose: \n                # build next path\n                # tc: O(1), sc: O(1)\n                path.append(candidate)\n\n                # Explore:\n                # recurse with same index (allowing reuse of current candidate)\n                # tc: up to n recursive calls per level, max depth ~ target / min_cand\n                # tc: O(n^(target/min_cand)) in worst case\n                dfs_backtrack(i, currSum + candidate)\n\n                # Unchoose: backtrack:\n                # remove last candidate\n                # tc: O(1), sc: O(1)\n                path.pop()\n\n        # Start recursion from index 0 with sum 0\n        # tc: O(n^(target/min_cand)), sc: O(target/min_cand) recursion stack\n        dfs_backtrack(0, 0)\n\n        # overall: tc O(n^(target/min_cand))\n        # overall: sc O(target/min_cand + output size)\n        return res",
        "questionNumber": 39,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-late-pruning-recursive-unsorted-forward-backtracking-on-global-path---backtrackinggenerate-all-combinations-or-subsets",
        "blog": "LeetCode: Backtracking"
      }
    ],
    "generate-while-constraint-satisfaction": [
      {
        "number": 2,
        "name": "Early Pruning Recursive Sorted Forward Backtracking On Global Path",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        # Note:\n        # Sort candidates for early pruning\n        # 1. Process Root -> check if remaining sum equals zero\n        # 2. Process Choices -> try candidates <= remaining\n        # 3. Backtrack -> remove last choice after recursion\n        # Result: all valid combinations appended to res\n        \n        # \"Early Pruning\": we can skip adding candidates that exceed \n        # the remaining sum, pruning branches from the root itself. \n        # Avoids creating unnecessary branches\n\n        res = []\n        path = []\n\n        # Sort ascending so pruning works\n        candidates.sort()\n\n        def dfs_backtrack(start, remaining):\n\n            # Process Root -> check if sum reached target, shallow copy\n            if remaining == 0:\n                res.append(path[:])\n                return\n\n            # Process -> Choices : prune invalid candidates\n            for i in range(start, len(candidates)):\n\n                # grab candidate\n                candidate = candidates[i]\n\n                # Early Candidate Pruning -> : skip early if candidate exceeds remaining,\n                if candidate > remaining:\n                    break\n\n                # Build: include candidate in path\n                path.append(candidate)\n\n                # Explore: recurse with same index (allow reuse)\n                dfs_backtrack(i, remaining - candidate)\n\n                # Backtrack: remove last element for next iteration\n                path.pop()\n\n        dfs_backtrack(0, target) \n        return res",
        "questionNumber": 39,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-early-pruning-recursive-sorted-forward-backtracking-on-global-path---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 3,
        "name": "Early Pruning Recursive Sorted Backward Backtracking On Global Path",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n                \n        # Note:\n        # Sort candidates ascending for effective early pruning\n        # Recursive DFS backwards: Track global path and remaining sum\n        # 1. Process Root -> check if remaining sum equals zero\n        # 2. Early Pruning -> skip \"include\" branch if candidate > remaining sum\n        # 3. Process Choices -> try each candidate from current index backwards\n        # 4. Backtrack -> remove last choice after recursion\n        # Result: all valid combinations appended to res\n        \n        # \"Early Pruning\" +  \"Backward DFS\": largest candidates are considered first,\n        # branches exceeding target are skipped immediately, \n        # allows unnecessary branches than forward early pruning.\n\n        res = []\n        path = []\n\n        # Sort ascending so pruning works (largest candidates explored first)\n        candidates.sort()\n\n        def dfs_backtrack(i, remaining):\n\n            # Process Root -> : check if remaining sum equals zero, shallow copy\n            if remaining == 0:\n                res.append(path[:])\n                return\n\n            # For Loop Exit: no more candidates\n            if i < 0:\n                return\n\n            # grab candidate\n            candidate = candidates[i]\n\n            # Early Candidate Pruning -> if candidate too large, skip\n            if candidate > remaining:\n                dfs_backtrack(i - 1, remaining)\n                return\n\n            # Build: add candidate into path\n            path.append(candidate)\n\n            # Explore: recurse with same index (reuse allowed), update remaining\n            dfs_backtrack(i, remaining - candidate)\n\n            # Backtrack: remove last included candidate\n            path.pop()\n\n            # For Loop Iteration: next candidate\n            dfs_backtrack(i - 1, remaining)\n\n        # recursion from last index\n        dfs_backtrack(len(candidates) - 1, remaining)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 39,
        "solutionLink": "/Notes/leetcode-backtracking#solution-3-early-pruning-recursive-sorted-backward-backtracking-on-global-path---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 4,
        "name": "Early Pruning Iterative DFS Sorted Forward Backtracking With Explicit Stack",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n                \n        # Note:\n        # Iterative DFS using explicit stack to simulate recursion\n        # 1. Process Root -> push initial state\n        # 2. Process Choices -> expand from current index forward\n        # 3. Build -> include candidate into new path\n        # 4. Explore -> push new state with reduced remaining sum\n        # 5. Backtrack -> implicit when stack pops, no in-place undo needed\n        # Result: collect all valid paths where remaining == 0\n\n        res = []\n\n        # Sort candidates ascending for pruning\n        candidates.sort()\n\n        # tuples (start, path, remaining)\n        stack = [(0, [], target)]\n\n        # Iterative DFS expansion\n        while stack:\n\n            # Pop last state (DFS order FIFO)\n            (start, path, remaining) = stack.pop()\n\n            # Process Root -> if remaining == 0, valid combination found\n            if remaining == 0:\n                res.append(path)\n                continue\n\n            # Process Choices -> try each candidate from current index forward\n            for i in range(start, len(candidates)):\n\n                # grab candidate\n                candidate = candidates[i]\n\n                # Early Candidate Pruning -> skip if candidate exceeds remaining\n                if candidate > remaining:\n                    break\n\n                # Build -> include candidate into path (need new path obj, order not guaranteed in iterative)\n                new_path = path + [candidate]\n\n                # Explore -> push new state, allow reuse of same candidate i\n                stack.append((i, new_path, remaining - candidate))\n\n                # Backtrack -> implicit, no need to pop since previous path objs still exit\n\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 39,
        "solutionLink": "/Notes/leetcode-backtracking#solution-4-early-pruning-iterative-dfs-sorted-forward-backtracking-with-explicit-stack---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 1,
        "name": "Recursive Sorted Early Pruning Forward Backtracking on Current Combination",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        # Note:\n        # Sort candidates ascending to align duplicates for pruning\n        # Recursive DFS backtracking: Track current path and remaining sum\n        # 1. Process Root -> check if remaining == 0 to record valid combination\n        # 2. Process Choices -> explore each candidate from current index onward\n        # 3. Early Pruning -> skip candidates larger than remaining sum\n        # 4. Duplicate Pruning -> skip candidates equal to previous at same level\n        # 5. Backtrack -> remove last choice to try next candidate\n        # Result: all valid combinations appended to res\n\n        res = []\n        path = []\n\n        # Sort for duplicate and early candidate pruning\n        candidates.sort() \n\n        def dfs_backtrack(start: int, remaining: int):\n\n            # Process Root -> : check if valid combination, shallow copy\n            if remaining == 0:\n                res.append(path[:])\n                return\n            \n            # Process Choices -> : explore numbers from current index onward\n            for i in range(start, len(candidates)):\n                \n                # Duplicate Pruning -> : matching values only allowed when i == start,\n                # ex: candidates = [1, 1, 1, 2, 3], target = 3\n                #\n                # Root call: dfs(start=0, remain=3, path=[])\n                # i = 0 -> 1 recurse dfs(start=1, remain=2, path=[1])\n                # i = 1 -> 1 skipped (i > start and dup of i=0)\n                # i = 2 -> 1 skipped (dup of i=1)\n                # i = 3 -> 2 recurse dfs(start=4, remain = 1, path=[2])\n                # i = 4 -> 3 recurse dfs(start=5, remain = 0, path=[3])\n                \n                # Forward rule: 'allow the first copy in a group, i == start'\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n\n                # Early Pruning -> : candidate exceeds remaining sum\n                if candidates[i] > remaining:\n                    break\n\n                # Build: include candidate[i]\n                path.append(candidates[i])\n                \n                # Explore -> move to next index (cannot reuse same element)\n                dfs_backtrack(i + 1, remaining - candidates[i])\n\n                # Backtrack -> remove last included candidate\n                path.pop()\n\n        dfs_backtrack(0, target)\n\n        # overall: time complexity\n        # overall: space complexity \n        return res",
        "questionNumber": 40,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-sorted-early-pruning-forward-backtracking-on-current-combination---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 2,
        "name": "Recursive Sorted Early Pruning Backwards Backtracking on Current Combination",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        # Note:\n        # Sort ascending for duplicates and pruning\n        # Recursive DFS backwards: Track path and remaining sum\n        # 1. Process Root -> check if remaining == 0 to record valid combination\n        # 2. Process Choices -> explore each candidate from current index backwards\n        # 3. Early Pruning -> skip candidates larger than remaining\n        # 4. Duplicate Pruning -> skip duplicates at same decision level\n        # 5. Backtrack -> remove last choice after recursion\n        # Result: all valid combinations appended to res\n\n        res = []\n        path = []\n\n        candidates.sort()\n\n        def dfs_backtracking(i, remaining):\n\n            # Process Root -> remaining sum zero\n            if remaining == 0:\n                res.append(path[:])\n                return\n\n            # No more candidates\n            if i < 0:\n                return\n\n            # Early Pruning -> candidate too large\n            if candidates[i] > remaining:\n                dfs_backtracking(i - 1, remaining)\n                return\n\n            # Duplicate Pruning -> : matching values only allowed when i == len(candidates)-1,\n            # ex: candidates = [1, 1, 1, 2, 3], target = 3\n            #\n            # Root call: dfs(i=4, remain=3, path=[])\n            # i = 4 -> 3 recurse dfs(i=3, remain=0, path=[3])\n            # i = 3 -> 2 recurse dfs(i=2, remain=1, path=[2])\n            # i = 2 -> 1 recurse dfs(i=1, remain=0, path=[1])\n            # i = 1 -> 1 skipped (i < len-1 and dup of i=2)\n            # i = 0 -> 1 skipped (i < len-1 and dup of i=1)\n\n            # Backwards rule: 'allow the last copy in a group, i == len(candidates)-1'\n            if i < len(candidates) - 1 and candidates[i] == candidates[i + 1]:\n                dfs_backtracking(i - 1, remaining)\n                return\n\n            # Build -> include candidate[i]\n            path.append(candidates[i])\n\n            # Explore -> move backward without reusing same element\n            dfs_backtracking(i - 1, remaining - candidates[i])\n\n            # Backtrack -> remove last\n            path.pop()\n\n            # Explore -> skip candidate[i], move to next smaller index\n            dfs_backtracking(i - 1, remaining)\n\n        # Start recursion from last index\n        dfs_backtracking(len(candidates) - 1, target)\n        return res",
        "questionNumber": 40,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-recursive-sorted-early-pruning-backwards-backtracking-on-current-combination---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 1,
        "name": "Recursive DFS Backtracking on Current Permutation Path with Element Usage Tracking",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def permute(self, nums: List[int]) -> List[List[int]]:\n\n        # Note:\n        # Recursive DFS backtracking: Track current permutation path\n        # 1. Process Root -> : check if path length == n to record full permutation\n        # 2. Process Choices -> : grab remaining unused elements\n        # 3. Early Pruning -> skip used elements\n        # 4. Backtrack -> remove last choice from path and mark as unused\n        # Result: all valid permutations appended to res\n\n        res = []\n        path = []\n\n        # Track elements in the current path\n        used = [False] * len(nums) \n\n        def backtrack():\n\n            # Process Root -> : check if valid permutation\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            \n            # Process -> Choices : grab remaining unused number\n            for i in range(n):\n                \n                # Early Candidate Pruning -> : skip used elements\n                if used[i]:          \n                    continue\n                \n                # Build -> : add nums[i] to path and used tracker\n                path.append(nums[i])\n                used[i] = True\n\n                # Explore: recurse new path\n                backtrack()\n\n                # Backtrack: remove last choice\n                path.pop()\n                used[i] = False\n\n        backtrack()\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 46,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-dfs-backtracking-on-current-permutation-path-with-element-usage-tracking---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 1,
        "name": "Recursive DFS Backtracking on Current Subset Path with Duplicate Skipping",
        "type": "backtracking",
        "application": "generate-while-constraint-satisfaction",
        "code": "def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n\n        # Note:\n        # Recursive DFS backtracking: Track current subset path\n        # 1. Process Root -> : record current subset path\n        # 2. Process Choices -> : iterate elements from current index onward\n        # 3. Prune Duplicates -> skip duplicates at same recursion level\n        # 4. Backtrack -> remove last element before next choice\n        # Result: all unique subsets appended to res \n\n        res = []\n        path = []\n\n        # Sort to bring duplicates together\n        nums.sort()\n\n        def backtrack(start):\n\n            # Process Root -> : record current subset\n            res.append(path[:])\n\n            # Process -> Choices : explore elements from current index onward\n            for i in range(start, len(nums)):\n\n                # Early Candidate Pruning -> : skip duplicates\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                \n                # Build -> : include nums[i] in path\n                path.append(nums[i])\n\n                # Explore -> : recurse to next index\n                backtrack(i + 1)\n\n                # Backtrack -> : remove last element before trying next choice\n                path.pop()\n\n        backtrack(0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 90,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-dfs-backtracking-on-current-subset-path-with-duplicate-skipping---backtrackinggenerate-while-constraint-satisfaction",
        "blog": "LeetCode: Backtracking"
      }
    ],
    "path-finding-in-search-space": [
      {
        "number": 1,
        "name": "DFS Backtracking on Current Path",
        "type": "backtracking",
        "application": "path-finding-in-search-space",
        "code": "def exist(self, board: List[List[str]], word: str) -> bool:\n        \n        # Note:\n        # Recursive DFS backtracking: Track current path matching word\n        # 1. Process Root : check if current path matches word\n        # 2. Process Choices -> : explore all 4 directions from current cell\n        # 3. Prune -> : skip cells out of bounds, mismatched letters, or previously visited\n        # 4. Backtrack -> : restore cell after recursion\n        # Result: return True if any path matches the word\n\n        rows, cols = len(board), len(board[0])\n        \n        def backtrack(r, c, i):\n\n            # Process Root -> : full word matched\n            if i == len(word):\n                return True\n            \n            # Early Candidate Prune -> : out of bounds\n            if r < 0 or c < 0 or r >= rows or c >= cols:\n                return False\n\n            # Early Candidate Prune -> : letter mismatch\n            if board[r][c] != word[i]:\n                return False\n            \n            # Build -> : mark current cell as visited\n            tmp, board[r][c] = board[r][c], \"#\"\n            \n            # Explore -> : recurse in all 4 directions\n            found = (backtrack(r+1, c, i+1) or\n                     backtrack(r-1, c, i+1) or\n                     backtrack(r, c+1, i+1) or\n                     backtrack(r, c-1, i+1))\n            \n            # Backtrack -> : restore cell as unvisited\n            board[r][c] = tmp\n            return found\n\n        # Try starting DFS from each cell\n        for r in range(rows):\n            for c in range(cols):\n                if backtrack(r, c, 0):\n                    return True\n        return False",
        "questionNumber": 79,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-dfs-backtracking-on-current-path---backtrackingpath-finding-in-search-space",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 2,
        "name": "Word Reversal Optimization DFS Backtracking on Current Path",
        "type": "backtracking",
        "application": "path-finding-in-search-space",
        "code": "def exist(self, board: List[List[str]], word: str) -> bool:\n        \n        # Note:\n        # Recursive DFS backtracking with search pruning:\n        # 1. Count letters on board and work to prune impossible searches\n        # 2. Reverse word if last letter is rarer than first\n        # 3. Process Root -> : check if current path matches word\n        # 4. Process Choices -> : explore all 4 directions\n        # 5. Prune -> : skip out of bounds, mismatched letters, previously visited\n        # 6. Backtrack -> : restore board cell after recursion\n        # Result: return True if any valid path matches word\n\n        rows, cols = len(board), len(board[0])\n        word_count = Counter(word)\n        \n        # counter for optimization\n        board_count = Counter(c for row in board for c in row)\n        \n        # Early Word Prune -> : board doesn't contain enough letters for word\n        for char, count in word_count.items():\n            if board_count[char] < count:\n                return False\n        \n        # Early Recurse Optimization -> : reverse word if last letter rarer than first\n        if board_count[word[0]] > board_count[word[-1]]:\n            word = word[::-1]\n        \n        def backtrack(r, c, i):\n\n            # Process Root -> : reached end of word\n            if i == len(word):\n                return True\n            \n            # Early Candidate Prune -> : out of bounds\n            if r < 0 or c < 0 or r >= rows or c >= cols:\n                return False\n\n            # Early Candidate Prune : letter mismatch\n            if board[r][c] != word[i]:\n                return False\n            \n            # Build -> : mark cell as visited\n            tmp, board[r][c] = board[r][c], \"#\"\n\n            # Explore -> : recurse in 4 directions\n            found = (backtrack(r+1, c, i+1) or\n                     backtrack(r-1, c, i+1) or\n                     backtrack(r, c+1, i+1) or\n                     backtrack(r, c-1, i+1))\n\n            # Backtrack -> : restore cell\n            board[r][c] = tmp\n            return found\n        \n        # Process -> Choices : start DFS only from cells matching first letter\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == word[0]:\n                    if backtrack(r, c, 0):\n                        return True\n\n\n        return False",
        "questionNumber": 79,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-word-reversal-optimization-dfs-backtracking-on-current-path---backtrackingpath-finding-in-search-space",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 1,
        "name": "DFS Backtracking on Current Path to Match Word",
        "type": "backtracking",
        "application": "path-finding-in-search-space",
        "code": "def partition(self, s: str) -> List[List[str]]:\n\n        # Note:\n        # Recursive DFS backtracking: Track current partition path\n        # 1. Process Root -> : check if end of string reached, record valid partition\n        # 2. Process Choices -> : try all substrings starting from current index\n        # 3. Prune -> : skip substring if not palindrome\n        # 4. Backtrack -> : remove last substring before next choice\n        # Result: all possible palindrome partitions appended to res\n\n        res = []\n        path = []\n\n        # Check if s[l:r+1] substring is a palindrome\n        def is_palindrome(l, r) -> bool:\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        def backtrack(start):\n\n            # Process Root -> : reached end of string, valid partition\n            if start == len(s):\n                res.append(path[:])\n                return\n\n            # Process -> Choices : try all substrings starting from current index\n            for end in range(start, len(s)):\n\n                # Prune -> : skip if substring is not palindrome\n                if is_palindrome(start, end):\n\n                    # Build -> : add palindromic substring\n                    path.append(s[start:end+1])\n\n                    # Explore -> : recurse to next starting index\n                    backtrack(end+1)\n\n                    # Backtrack -> : remove last substring and try next partition\n                    path.pop()\n\n        backtrack(0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 131,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-dfs-backtracking-on-current-path-to-match-word---backtrackingpath-finding-in-search-space",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 2,
        "name": "DFS Backtracking on Current Path to Match Word",
        "type": "backtracking",
        "application": "path-finding-in-search-space",
        "code": "def partition(self, s: str) -> List[List[str]]:\n\n        # Note:\n        # Recursive DFS backtracking with precomputed palindrome table:\n        # 1. Precompute palindromes in O(n^2) to avoid repeated checks\n        # 2. Process Root -> : check if end of string reached\n        # 3. Process Choices -> : explore all substring end positions\n        # 4. Prune -> : skip substrings that are not palindromes\n        # 5. Backtrack -> : remove last substring before next choice\n        # Result: all palindrome partitions appended to res\n\n        n = len(s)\n        res = []\n        path = []\n\n        # Palindrome Table:  palindromes: True if s[i:j+1] is palindrome, False if\n        is_pal = [[False]*n for _ in range(n)]\n\n        # backwards -> forwards:\n        # To compute is_pal[0][4], we need is_pal[1][3].\n        # Since we loop i backwards, by the time we get to i = 0, \n        # the row i = 1 (all substrings starting at index 1) is already \n        # filled in.\n\n        # iterate backwards\n        for i in range(n-1, -1, -1):\n            # iterate forward \n            for j in range(i, n):\n\n                # substring length:\n                # j - i + 1 <= 3 : if substring length is <= 3\n                # ex: \"a\", \"aa\", \"aba\"\n\n                # inner substrings:\n                # is_pal[i+1][j-1] : relying on inner substrings\n                # If the inside s[i+1:j] is a palindrome, and the outer chars match, then s[i:j+1] is also a palindrome.\n                if s[i] == s[j] and ((j - i + 1) <= 3 or is_pal[i+1][j-1]):\n                    is_pal[i][j] = True\n\n        def backtrack(start):\n            \n            # Process Root -> : reached end of string\n            if start == n:\n                res.append(path[:])\n                return\n\n            # Process -> Choices : explore all substring end positions\n            for end in range(start, n):\n\n                # Prune -> : skip if not palindrome\n                if is_pal[start][end]:\n\n                    # Build -> : append substring\n                    path.append(s[start:end+1])\n\n                    # Explore -> : move to next index\n                    backtrack(end+1)\n\n                    # Backtrack -> : remove last substring\n                    path.pop()\n\n        backtrack(0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 131,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-dfs-backtracking-on-current-path-to-match-word---backtrackingpath-finding-in-search-space",
        "blog": "LeetCode: Backtracking"
      }
    ],
    "generate-all-combinations": [
      {
        "number": 1,
        "name": "Recursive DFS Backtracking on Current Letter Path",
        "type": "backtracking",
        "application": "generate-all-combinations",
        "code": "def letterCombinations(self, digits: str) -> List[str]:\n        \n        # Note:\n        # Recursive DFS backtracking: Track current letter path\n        # 1. Process Root -> : path length equals digits length, record combination\n        # 2. Process Choices -> : letters corresponding to current digit\n        # 3. Build -> : append letter to path\n        # 4. Explore -> : recurse to next digit\n        # 5. Backtrack -> : remove last letter before trying next option\n        # Result: all possible letter combinations appended to res\n\n        # Empty check\n        if not digits:\n            return []\n\n        # Map digits to letters\n        digit_map = {\n            \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n            \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"\n        }\n\n        res = []\n        path = []\n\n        def backtrack(index):\n\n            # Process Root -> : current path has full length\n            if index == len(digits):\n                res.append(\"\".join(path))\n                return\n            \n            # Process -> Choices : letters corresponding to current digit\n            for char in digit_map[digits[index]]:\n\n                # Build -> : choose current letter\n                path.append(char)\n\n                # Explore -> : move to next digit\n                backtrack(index + 1)\n\n                # Backtrack -> : remove last letter to try next option \n                path.pop()\n\n        backtrack(0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 17,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-dfs-backtracking-on-current-letter-path---backtrackinggenerate-all-combinations",
        "blog": "LeetCode: Backtracking"
      }
    ],
    "combinatorial-optimization": [
      {
        "number": 1,
        "name": "Recursive DFS Backtracking on Current Row with Column/Diagonal Tracking",
        "type": "backtracking",
        "application": "combinatorial-optimization",
        "code": "def solveNQueens(self, n: int) -> List[List[str]]:\n\n        # Note:\n        # Recursive DFS backtracking: Track current row placement\n        # 1. Process Root -> : all rows filled, record board configuration\n        # 2. Process Choices -> : iterate columns in current row\n        # 3. Prune -> : skip if column or diagonals threatened\n        # 4. Build -> : place queen\n        # 5. Explore -> : recurse to next row\n        # 6. Backtrack -> : remove queen, free column/diagonals\n        # Result: all valid board configurations appended to res\n\n        res = []\n\n        # n x n size board\n        board = [[\".\"] * n for _ in range(n)]\n        \n        # 3 Sets to track threatened positions:\n        \n        # Columns occupied\n        cols = set()\n        # Rows occupied\n        # rows = set() <- inherently tracked by recursion, no need for this\n\n        # r - c diagonals: all cells on this diagonal have same value of row - col\n        diag1 = set()\n        # r + c diagonals: all cells on this diagonal have same value of row + col\n        diag2 = set()\n\n        def dfs_backtrack(row: int):\n\n            # Process Root -> : all queens placed successfully, append board\n            if row == n:\n                res.append([\"\".join(r) for r in board])\n                return\n            \n            # Process -> Choices : columns in current row\n            for col in range(n):\n\n                # Prune -> : skip if column or diagonals threatened\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                \n                # Build -> : place queen at (row, col)\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                \n                # Explore -> : move to next row\n                # due to (row+1), we will never have overlapping rows\n                dfs_backtrack(row + 1)\n                \n                # Backtrack -> : remove queen and free column/diagonals\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n\n        dfs_backtrack(0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 51,
        "solutionLink": "/Notes/leetcode-backtracking#solution-1-recursive-dfs-backtracking-on-current-row-with-column-diagonal-tracking---backtrackingcombinatorial-optimization",
        "blog": "LeetCode: Backtracking"
      },
      {
        "number": 2,
        "name": "Recursive DFS Backtracking Using Bitmasking for Columns/Diagonals",
        "type": "backtracking",
        "application": "combinatorial-optimization",
        "code": "def solveNQueens(self, n: int) -> List[List[str]]:\n\n        # Note:\n        # Recursive DFS with bitmasking: Track available columns/diagonals\n        # 1. Process Root -> : all rows filled, convert path to board\n        # 2. Process Choices -> : available positions using bitmask\n        # 3. Build -> : pick rightmost available position\n        # 4. Explore -> : recurse with updated masks and path\n        # 5. Backtrack -> : implicit via new path list\n        # Result: all valid board configurations appended to res\n\n        res = []\n        path = []\n\n        def backtrack(row, cols, diag1, diag2):\n            \n            # Process Root -> : all queens placed successfully\n            if row == n:\n                board = []\n                for r in path:\n                    row_str = [\".\" for _ in range(n)]\n                    row_str[r] = \"Q\"\n                    board.append(\"\".join(row_str))\n                res.append(board)\n                return\n            \n            # Process -> Choices : calculate available positions with bitmasking\n            available = ((1 << n) - 1) & (~(cols | diag1 | diag2))\n            \n            while available:\n                \n                # Build -> : pick rightmost available position\n                pos = available & -available\n                available &= available - 1        # Remove chosen position\n                col = (pos - 1).bit_length()\n                \n                path.append(col)\n\n                # Explore -> : recurse to next row with updated masks\n                backtrack(\n                    row + 1,\n                    cols | pos,\n                    (diag1 | pos) << 1,\n                    (diag2 | pos) >> 1\n                )\n\n                # Backtrack -> :  remove last\n                path.pop()\n\n        backtrack(0, 0, 0, 0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 51,
        "solutionLink": "/Notes/leetcode-backtracking#solution-2-recursive-dfs-backtracking-using-bitmasking-for-columns-diagonals---backtrackingcombinatorial-optimization",
        "blog": "LeetCode: Backtracking"
      }
    ]
  },
  "graph": {
    "something": [
      {
        "number": 1,
        "name": "Recursive DFS with Visited Set",
        "type": "graph",
        "application": "something",
        "code": "def numIslands(self, grid: List[List[str]]) -> int:\n\n        # Graph Representation:\n        # This problem is equivalent to finding out the number of connected components in a graph\n\n        # Grid Graph (Implicit Adjacency Matrix Via Coordinates And Directions):\n        \n        #     A  B  C\n        # A [ 0  1  0 ]\n        # B [ 1  0  1 ]\n        # C [ 0  1  0 ]\n\n        # Each cell is connected up to 4 neighbors (up, down, left, right)\n        # Edges are implicit, based on grid position\n        # Each cell in a node\n\n        # Recursive DFS traversal: \n        # Mark visited cells to avoid re-processing\n        # 1. Process Root -> check if current cell is '1'\n        # 2. Process Choices -> explore four neighbors (up, down, left, right)\n        # 3. Backtrack -> recursion returns after marking all connected land\n        # Result: increment island count per root land cell\n        \n        # Empty Check: no islands, grid is empty\n        if not grid:\n            return 0\n        \n        # boundaries\n        rows, cols = len(grid), len(grid[0])\n\n        # tracking\n        visited = set()\n\n        # count\n        islands = 0\n\n        # visits any land touching (r, c)\n        def dfs(r, c):\n\n            # Late Pruning -> skip if out-of-bounds, water, or already visited\n            if (r < 0 or r >= rows or \n                c < 0 or c >= cols or \n                grid[r][c] == \"0\" or \n                (r, c) in visited):\n                return\n\n            # Process Root -> mark current cell as visited land\n            visited.add((r, c))\n\n            # Explore -> visit all 4 neighbors\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n            # Backtrack -> implicit, no undo needed\n\n        # iterate over grid\n        for r in range(rows):\n            for c in range(cols):\n\n                # Process Root -> unvisited land found\n                if grid[r][c] == '1' and (r, c) not in visited:\n                    islands += 1\n                    dfs(r, c)\n\n        # overall: time complexity\n        # overall: space complexity\n        return islands",
        "questionNumber": 200,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs-with-visited-set---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Recursive DFS with In Place Flood Fill",
        "type": "graph",
        "application": "something",
        "code": "def numIslands(self, grid: List[List[str]]) -> int:\n        # Note:\n        # Recursive DFS flood fill: mark visited land in-place\n        # 1. Process Root -> check if current cell is '1'\n        # 2. Process Choices -> explore four neighbors\n        # 3. Backtrack -> recursion returns after marking all connected land\n        # Result: increment island count per root land cell\n        \n        # Empty check\n        if not grid:\n            return 0\n        \n        # boundaries\n        rows, cols = len(grid), len(grid[0])\n\n        # count\n        islands = 0\n\n        # visits any land touching (r, c)\n        def dfs(r, c):\n\n            # Late Pruning -> skip out-of-bounds or water\n            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':\n                return\n\n            # Build / Mark -> sink current land\n            grid[r][c] = '0'\n\n            # Explore -> visit all 4 neighbors\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n            # Backtrack -> implicit, no undo needed\n\n        for r in range(rows):\n            for c in range(cols):\n\n                # Process Root -> unvisited land found\n                if grid[r][c] == '1':\n                    islands += 1\n                    dfs(r, c)\n\n        # overall: time complexity O(m * n)\n        # overall: space complexity O(m * n) worst-case recursion depth\n        return islands",
        "questionNumber": 200,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-recursive-dfs-with-in-place-flood-fill---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "Iterative BFS with In Place Flood Fill",
        "type": "graph",
        "application": "something",
        "code": "def numIslands(self, grid: List[List[str]]) -> int:\n\n        # Note:\n        # Iterative BFS flood fill: explore entire island per root land\n        # 1. Process Root -> enqueue starting land cell\n        # 2. Process Choices -> explore neighbors iteratively\n        # 3. Backtrack -> implicit by queue processing\n        # Result: increment island count per root land cell\n\n        # Empty check\n        if not grid:\n            return 0\n\n        # boundaries\n        rows, cols = len(grid), len(grid[0])\n        islands = 0\n\n        # visits any land touching (r, c)\n        def bfs(r, c):\n\n            # iterative queue\n            queue = deque()\n\n            # start iteration\n            queue.append((r, c))\n\n            # Build -> sink root island\n            grid[r][c] = '0'\n\n            while queue:\n\n                # grab \n                cr, cc = queue.popleft()\n\n                # Explore -> neighbors in 4 directions\n                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = cr + dr, cc + dc\n\n                    # Late Pruning -> skip out-of-bounds or water\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':\n                        grid[nr][nc] = '0'\n                        queue.append((nr, nc))\n\n        # iterate over grid\n        for r in range(rows):\n            for c in range(cols):\n\n                # Process Root -> unvisited land found\n                if grid[r][c] == '1':\n                    islands += 1\n                    bfs(r, c)\n\n        # overall: time complexity O(m * n)\n        # overall: space complexity O(m * n) worst-case queue\n        return islands",
        "questionNumber": 200,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-iterative-bfs-with-in-place-flood-fill---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 4,
        "name": "Union Find",
        "type": "graph",
        "application": "something",
        "code": "def numIslands(self, grid: List[List[str]]) -> int:\n\n        # Note:\n        # Union-Find approach: treat each land cell as a node\n        # 1. Process Root -> initialize parent and rank for each land\n        # 2. Process Choices -> union adjacent lands (right and down)\n        # 3. Backtrack -> implicit via union\n        # Result: number of connected components = number of islands\n\n        # Empty check\n        if not grid:\n            return 0\n        \n        # boundaries\n        rows, cols = len(grid), len(grid[0])\n\n        # parent and rank (size)\n        parent = {}\n        rank = {}\n\n        # initialize unions -> set parent to self rank to 0\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == '1':\n                    parent[(r, c)] = (r, c)\n                    rank[(r, c)] = 0\n\n        # Find Path compression\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # Union between sets\n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX == rootY:\n                return\n\n            # union by rank (height based)\n            if rank[rootX] > rank[rootY]:\n               parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                # height of tree only increases by 1 on equal size trees\n                # A=3, B=2 -> B will point to Root A, leading to height of 3\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n            # union by size (weight based)\n            # if rank[rootX] > rank[rootY]:\n            #     rank[rootX] += rank[rootY]\n            #     parent[rootY] = rootX\n            # else rank[rootX] < rank[rootY]:\n            #     rank[rootY] += rank[rootX]\n            #     parent[rootX] = rootY\n\n        # iterate over grid\n        for r in range(rows):\n            for c in range(cols):\n\n                # island found\n                if grid[r][c] == '1':\n\n                    # Process Choices -> \n                    # Union only down and right to avoid double union\n                    for dr, dc in [(1,0), (0,1)]:\n                        nr, nc = r + dr, c + dc\n\n                        # Early Candidate Pruning -> boundaries\n                        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':\n                            union((r, c), (nr, nc))\n\n        # Unique root count -> Unique Island Counts\n        roots = set(find(cell) for cell in parent)\n\n        # overall: time complexity\n        # overall: space complexity\n        return len(roots)",
        "questionNumber": 200,
        "solutionLink": "/Notes/leetcode-graphs#solution-4-union-find---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Recursive DFS with Flood Fill",
        "type": "graph",
        "application": "something",
        "code": "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        # Note:\n        # 1. Treat grid as a graph: 1 = land node, edges = 4-direction adjacency\n        # 2. DFS flood fill sinks land in-place to mark visited cells\n        # 3. Track area of each island during DFS\n        # 4. Return the maximum island area\n\n        # Empty check\n        if not grid:\n            return 0\n\n        # Boundaries\n        m, n = len(grid), len(grid[0])\n\n        # max\n        max_area = 0\n\n        def dfs(r: int, c: int) -> int:\n            # Late Candidate Prune -> : out of bounds or water\n            if r < 0 or c < 0 or r >= m or c >= n:\n                return 0\n\n            # Late Candidate Prune -> : water\n            if grid[r][c] == 0:\n                return 0\n\n            # Process Root -> sink land\n            grid[r][c] = 0\n\n            # Process Root -> count land from root\n            area = 1\n\n            # Process Choices -> explore neighbors, add to land count\n            area += dfs(r + 1, c)\n            area += dfs(r - 1, c)\n            area += dfs(r, c + 1)\n            area += dfs(r, c - 1)\n\n            # Backtrack -> return root land count to parent\n            return area\n    \n        # iterate over grid\n        for r in range(m):\n            for c in range(n):\n\n                # Process Root -> unvisited land found\n                if grid[r][c] == 1:\n\n                    # grab area of new island, check with max\n                    island_area = dfs(r, c)\n                    max_area = max(max_area, island_area)\n\n        # overall: time complexity O(m * n)\n        # overall: space complexity O(m * n) worst-case (DFS recursion stack)\n        return max_area",
        "questionNumber": 695,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs-with-flood-fill---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS with Flood Fill",
        "type": "graph",
        "application": "something",
        "code": "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        # Note:\n        # 1. Treat grid as a graph: 1 = land, edges = 4-direction adjacency\n        # 2. BFS explores each island iteratively using a queue\n        # 3. Sink land cells in-place to mark visited\n        # 4. Track area of each island, return maximum\n\n        # Empty check\n        if not grid:\n            return 0\n\n        # Boundaries\n        m, n = len(grid), len(grid[0])\n\n        # max\n        max_area = 0\n\n        def bfs(r, c):\n            # start BFS for this island\n            area = 0\n            queue = deque([(r, c)])\n            grid[r][c] = 0  # mark visited\n\n            while queue:\n                cr, cc = queue.popleft()\n                area += 1\n\n                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = cr + dr, cc + dc\n                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                        grid[nr][nc] = 0  # mark visited\n                        queue.append((nr, nc))\n\n            return area\n\n\n        # iterate over grid \n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 1:\n                    island_area = bfs(r, c)\n                    max_area = max(max_area, island_area)\n\n\n        # overall: time complexity O(m * n)\n        # overall: space complexity O(m * n) worst-case (queue holds all land cells)\n        return max_area",
        "questionNumber": 695,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs-with-flood-fill---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "Union Find",
        "type": "graph",
        "application": "something",
        "code": "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        \n        # Note:\n        # Union-Find approach to track connected components by size\n        # 1. Process Root -> initialize parent and size for each land cell\n        # 2. Process Candidates -> union adjacent land cells (down/right)\n        # 3. Early Prune -> skip out-of-bounds\n        # 4. Late Prune -> skip water cells\n        # Result: max size among all connected components = max island area\n\n        # Empty check\n        if not grid:\n            return 0\n\n        # Boundaries\n        m, n = len(grid), len(grid[0])\n\n        # Union find info\n        parent = {}\n        size = {}\n\n        # Find Path Compression\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # Union two sets\n        def union(x, y):\n            \n            rootX, rootY = find(x), find(y)\n            if rootX == rootY:\n                return\n            \n            # Union by size\n            if size[rootX] >= size[rootY]:\n                parent[rootY] = rootX\n                size[rootX] += size[rootY]\n            else:\n                parent[rootX] = rootY\n                size[rootY] += size[rootX]\n\n        # Init Union Find,\n        # set parent to self and size to 0\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 1:\n                    parent[(r, c)] = (r, c)\n                    size[(r, c)] = 1\n\n        # Iterate over grid and Union adjacent \n        # bottom and right land cells (to avoid double union)\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 1:\n\n                    # Process Choices -> \n                    # Union only down and right to avoid double union\n                    for dr, dc in [(1,0), (0,1)]:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                            union((r, c), (nr, nc))\n\n        # grab the largest union size\n        largestIsland = max(size.values(), default=0)\n\n        # overall: time complexity\n        # overall: space complexity\n        return largestIsland",
        "questionNumber": 695,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-union-find---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Recursive DFS",
        "type": "graph",
        "application": "something",
        "code": "def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        # Note:\n        # 1. Use DFS to traverse the graph\n        # 2. Use a hashmap to store already cloned nodes\n        # 3. For each node, recursively clone its neighbors\n        # 4. Return the cloned node corresponding to the input\n        \n        # Empty check\n        if not node:\n            return None\n\n        # original -> deep copy\n        cloned = {}\n\n        def dfs(n) -> Node:\n\n            # Early Prune -> node already cloned\n            if n in cloned:\n                return cloned[n]\n\n            # Process Root -> clone current node\n            copy = Node(n.val)\n            cloned[n] = copy\n\n            # Process Candidates -> recursively clone all neighbors\n            for neighbor in n.neighbors:\n                copy.neighbors.append(dfs(neighbor))\n\n            # Backtrack -> return cloned node\n            return copy\n\n        # grab root of cloned graph\n        cloneRoot = dfs(node)\n\n        # overall: time complexity O(V + E), visit each node and edge once\n        # overall: space complexity O(V), for hashmap + recursion stack\n        return cloneRoot",
        "questionNumber": 133,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS",
        "type": "graph",
        "application": "something",
        "code": "def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        \n        # Note:\n        # 1. Iterative BFS traversal to clone graph nodes\n        # 2. Use hashmap to track original -> cloned node\n        # 3. Process Root -> start with input node in queue\n        # 4. Process Candidates -> clone neighbors iteratively\n        # 5. Early Prune -> skip already cloned neighbors\n        # 6. Backtrack -> queue ensures all reachable nodes are processed\n\n        # Empty check\n        if not node:\n            return None\n\n        # clone root\n        cloned = {node: Node(node.val)}\n\n        # iterative queue\n        queue = deque([node])\n\n        # iterate over all nodes\n        while queue:\n\n            # get previous roots neighbor\n            current = queue.popleft()\n\n            # iterate over neighbors\n            for neighbor in current.neighbors:\n\n                # Early Prune -> neighbor already cloned\n                if neighbor not in cloned:\n                    cloned[neighbor] = Node(neighbor.val)\n                    queue.append(neighbor)\n\n                # Process Candidate -> connect cloned neighbor\n                cloned[current].neighbors.append(cloned[neighbor])\n\n        # overall: time complexity O(V + E), each node and edge visited once\n        # overall: space complexity O(V), for hashmap + queue\n        return cloned[node]",
        "questionNumber": 133,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Multi Source BFS",
        "type": "graph",
        "application": "something",
        "code": "def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        if not grid:\n            return\n\n        m, n = len(grid), len(grid[0])\n        INF = 2147483647\n        q = deque()\n\n        # Step 1: Collect all treasure chests (multi-source roots)\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 0:\n                    q.append((r, c))\n\n        # Step 2: BFS flood fill\n        while q:\n            r, c = q.popleft()\n\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                nr, nc = r + dr, c + dc\n\n                # Late Candidate Prune: out of bounds or not INF\n                if not (0 <= nr < m and 0 <= nc < n):\n                    continue\n                if grid[nr][nc] != INF:\n                    continue\n\n                # Process Root: update distance from nearest treasure\n                grid[nr][nc] = grid[r][c] + 1\n\n                # Process Choices: explore neighbor\n                q.append((nr, nc))\n\n        # overall: time O(m * n), space O(m * n) (queue worst-case)",
        "questionNumber": 286,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-multi-source-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Iterative BFS Rotten Multi Source with Global Minutes Overwrite",
        "type": "graph",
        "application": "something",
        "code": "def orangesRotting(self, grid: List[List[int]]) -> int:\n        # Note:\n        # 1. Start BFS from all initially rotten oranges (multi-source BFS)\n        # 2. Each BFS level = 1 minute of rotting spread\n        # 3. Track fresh oranges count, decrement when they rot\n        # 4. Return minutes if all fresh rot, else -1\n\n        # Empty check\n        if not grid:\n            return -1\n\n        # boundaries\n        m, n = len(grid), len(grid[0])\n\n        # count\n        fresh = 0\n\n        # time\n        minutes = 0\n\n        # iterative queue\n        queue = deque()\n\n        # set up multi source BFS\n        for r in range(m):\n            for c in range(n):\n\n                # Append Rotten Source to BFS\n                if grid[r][c] == 2:\n                    # (row, col, minute)\n                    queue.append((r, c, 0))\n                \n                # Add to fresh count\n                elif grid[r][c] == 1:\n                    fresh += 1\n\n        # iterate over rotten sources\n        while queue:\n\n            # next rotten orange\n            # minutes will be overwritten by pop,\n            # last pop will have the longest and final minute count\n            r, c, minutes = queue.popleft()\n\n            # Process Choices -> \n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                nr, nc = r + dr, c + dc\n\n                # Early Prune -> : valid boundary and fresh orange\n                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    \n                    # add to time and pass down\n                    queue.append((nr, nc, minutes + 1))\n\n        # total time taken if no oranges remain, else fresh orange remain so -1\n        res = minutes if fresh == 0 else -1\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 994,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-iterative-bfs-rotten-multi-source-with-global-minutes-overwrite---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS Rotten Multi Source with Level Processing Minutes Trigger",
        "type": "graph",
        "application": "something",
        "code": "def orangesRotting(self, grid: List[List[int]]) -> int:\n        \n        # Note:\n        # 1. Instead of storing time in queue, process BFS by levels\n        # 2. Each level of queue expansion corresponds to +1 minute\n        # 3. Track number of fresh oranges, ensure all rot or return -1\n\n        # Empty check\n        if not grid:\n            return -1\n\n        # boundaries\n        m, n = len(grid), len(grid[0])\n\n        # count\n        fresh = 0\n\n        # time\n        minutes = 0\n\n        # iterative\n        queue = deque()\n\n        # set up multi source BFS\n        for r in range(m):\n            for c in range(n):\n\n                # append rotten source to queue\n                if grid[r][c] == 2:\n                    queue.append((r, c))\n\n                # add to fresh count\n                elif grid[r][c] == 1:\n                    fresh += 1\n\n        # iterate over rotten sources\n        while queue and fresh > 0:\n\n            # Process roots -> process all sources at this level\n            for _ in range(len(queue)):\n\n                # next candidate\n                r, c = queue.popleft()\n\n                # Process Choices -> : visit neighbors\n                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = r + dr, c + dc\n\n                    # Early Pruning -> valid bounds and fresh fruit\n                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                        grid[nr][nc] = 2\n                        fresh -= 1\n\n                        # add next rotten source to queue\n                        queue.append((nr, nc))\n\n            # iterate tick for next source level\n            minutes += 1\n\n        # total time taken if no oranges remain, else fresh orange remain so -1\n        res = minutes if fresh == 0 else -1\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 994,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs-rotten-multi-source-with-level-processing-minutes-trigger---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Recursive DFS Reverse Flow",
        "type": "graph",
        "application": "something",
        "code": "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        \n        # Note:\n        # 1. Instead of simulating water flow forward (downhill), reverse the process:\n        #    Start from the oceans and \"climb uphill\" (to neighbors with height >= current).\n        # 2. Perform DFS from Pacific edges and Atlantic edges separately.\n        # 3. Any cell visited in both traversals can reach both oceans.\n        # 4. Collect intersection of visited sets.\n\n        # Empty check\n        if not heights:\n            return []\n\n        # boundaries\n        m, n = len(heights), len(heights[0])\n\n        # seen\n        pacific = set()\n        atlantic = set()\n\n        def dfs(r: int, c: int, visited: set, prev_height: int) -> None:\n            \n            # Early Prune -> out of bounds, visited, or downhill\n            if ((r, c) in visited or r < 0 or c < 0 or r >= m or c >= n \n                or heights[r][c] < prev_height):\n                return\n\n            # Process Root -> mark as visited\n            visited.add((r, c))\n\n            # Process Candidates -> explore 4 directions\n            dfs(r + 1, c, visited, heights[r][c])\n            dfs(r - 1, c, visited, heights[r][c])\n            dfs(r, c + 1, visited, heights[r][c])\n            dfs(r, c - 1, visited, heights[r][c])\n\n        # Process Roots -> start from Pacific and Atlantic edges\n        # These are the edge cells adjacent to each ocean from which water can \"flow uphill\"\n        # just collecting outermost edge calls\n\n        for i in range(m):\n            # left column\n            dfs(i, 0, pacific, heights[i][0])\n            # right column\n            dfs(i, n - 1, atlantic, heights[i][n - 1])\n        for j in range(n):\n            # top row\n            dfs(0, j, pacific, heights[0][j])\n            # bottom row\n            dfs(m - 1, j, atlantic, heights[m - 1][j])\n\n        # Late Prune -> intersection: cells reachable to both oceans\n        intersection = list(pacific & atlantic)\n\n        # overall: time complexity\n        # overall: space complexity\n        return intersection",
        "questionNumber": 417,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs-reverse-flow---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS Reverse Flow",
        "type": "graph",
        "application": "something",
        "code": "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        \n        # Note:\n        # 1. Same reverse flow idea, but BFS is used instead of DFS.\n        # 2. BFS avoids recursion depth issues and may be easier to reason about.\n        # 3. Initialize queues with Pacific and Atlantic edges separately.\n        # 4. Traverse \"uphill\" from oceans, track visited cells for each.\n        # 5. Answer = intersection of both visited sets.\n\n        # Empty check\n        if not heights:\n            return []\n\n        # boundaries\n        m, n = len(heights), len(heights[0])\n\n        #\n        def bfs(starts: List[Tuple[int,int]]) -> set:\n            visited = set(starts)\n            queue = deque(starts)\n\n            while queue:\n                # Process Root -> current cell\n                r, c = queue.popleft()\n\n                # Process Choices -> explore neighbors\n                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = r + dr, c + dc\n\n                    # Early Prune -> bounds, visited, uphill condition\n                    if (0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited\n                        and heights[nr][nc] >= heights[r][c]):\n                        visited.add((nr, nc))\n                        queue.append((nr, nc))\n            return visited\n\n        # Process Roots -> edge cells for each ocean\n        # These are the edge cells adjacent to each ocean from which water can \"flow uphill\"\n        # just collecting outermost edge calls\n\n        # pacific_starts = all cells on the top row (0, j) and all cells on the left column (i, 0)\n        pacific_starts = [(0, j) for j in range(n)] + [(i, 0) for i in range(m)]\n        \n        # atlantic_starts = all cells on the bottom row (m-1, j) and all cells on the right column (i, n-1)\n        atlantic_starts = [(m - 1, j) for j in range(n)] + [(i, n - 1) for i in range(m)]\n\n        pacific = bfs(pacific_starts)\n        atlantic = bfs(atlantic_starts)\n\n        # return intersection between\n        intersection = list(pacific & atlantic)\n\n        # overall: time complexity\n        # overall: space complexity\n        return intersection",
        "questionNumber": 417,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs-reverse-flow---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Recursive DFS with Flood Fill from Borders",
        "type": "graph",
        "application": "something",
        "code": "def solve(self, board: List[List[str]]) -> None:\n        \n        # Note:\n        # 1. Any 'O' connected to the border cannot be captured.\n        # 2. Mark all border-connected 'O's with DFS (temporary marker 'T').\n        # 3. After traversal:\n        #    Flip all remaining 'O' to 'X' (they are surrounded).\n        #    Flip all 'T' back to 'O'.\n        # 4. Mutates board in-place, no return required.\n\n        # Empty check\n        if not board:\n            return\n\n        # boundaries\n        m, n = len(board), len(board[0])\n\n        def dfs(r, c):\n\n            # Early Prune -> : out of bounds or not a 'O'\n            if r < 0 or c < 0 or r >= m or c >= n or board[r][c] != 'O':\n                return\n\n            # Process Root -> mark as safe\n            board[r][c] = 'T'\n\n            # Process Candidates -> explore neighbors\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n        # Process Roots -> start DFS from border cells\n        for i in range(m):\n            # left column\n            dfs(i, 0)\n            # right column\n            dfs(i, n - 1)\n        for j in range(n):\n            # top row\n            dfs(0, j)\n            # bottom row\n            dfs(m - 1, j)\n\n        # Late Prune -> Flip surrounded 'O' -> 'X', safe 'T' -> 'O'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'\n\n        \n        # overall: time complexity\n        # overall: space complexity",
        "questionNumber": 130,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs-with-flood-fill-from-borders---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS with Flood Fill from Borders",
        "type": "graph",
        "application": "something",
        "code": "def solve(self, board: List[List[str]]) -> None:\n        \n        # Note:\n        # 1. Same idea as DFS, but BFS is used to avoid recursion depth issues.\n        # 2. Traverse from border 'O's, mark as 'T'.\n        # 3. After BFS, flip surrounded 'O' -> 'X' and 'T' -> 'O'.\n\n        # Empty Check\n        if not board:\n            return\n\n        # Boundaries\n        m, n = len(board), len(board[0])\n\n        def bfs(r, c):\n\n            # Process Root -> initialize BFS from this cell\n            queue = deque([(r, c)])\n            board[r][c] = 'T'\n            \n            while queue:\n                cr, cc = queue.popleft()\n                # Process Candidates -> explore neighbors\n                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = cr + dr, cc + dc\n\n                    # Early Prune -> valid bounds and 'O'\n                    if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == 'O':\n                        board[nr][nc] = 'T'\n                        queue.append((nr, nc))\n\n        # Process Roots -> start BFS from border 'O's\n        for i in range(m):\n            if board[i][0] == 'O':\n                bfs(i, 0)\n            if board[i][n - 1] == 'O':\n                bfs(i, n - 1)\n        for j in range(n):\n            if board[0][j] == 'O':\n                bfs(0, j)\n            if board[m - 1][j] == 'O':\n                bfs(m - 1, j)\n\n        # Late Prune -> Flip surrounded 'O' -> 'X', safe 'T' -> 'O'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'",
        "questionNumber": 130,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs-with-flood-fill-from-borders---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "Union Find Disjoint Set Union",
        "type": "graph",
        "application": "something",
        "code": "def solve(self, board: List[List[str]]) -> None:\n        # Note:\n        # 1. Use Union Find (Disjoint Set Union).\n        # 2. Create a dummy node representing the border.\n        # 3. Union all 'O's on the border with the dummy node.\n        # 4. Union all adjacent 'O's with each other.\n        # 5. After unions, any 'O' connected to dummy is safe.\n        # 6. Flip all other 'O' to 'X'.\n\n        # Empty check\n        if not board:\n            return\n\n        # Boundaries\n        m, n = len(board), len(board[0])\n\n        # \n        parent = {}\n\n        # Find Path Compression\n        def find(x: int) -> int:\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # Union two Sets\n        def union(x: int, y: int) -> None:\n            parent[find(x)] = find(y)\n\n        # Special node for border\n        dummy = m * n \n\n        # Process Roots and Candidates -> Union Border 'O's and neighbors\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    idx = i * n + j\n\n                    # Union border cells with dummy\n                    if i in (0, m - 1) or j in (0, n - 1):\n                        union(idx, dummy)\n\n                    # Union neighbors\n                    for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 'O':\n                            union(idx, ni * n + nj)\n\n        # Late Prune -> flip 'O' not connected to dummy to 'X'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and find(i * n + j) != find(dummy):\n                    board[i][j] = 'X'\n\n        # overall: time complexity\n        # overall: space complexity",
        "questionNumber": 130,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-union-find-disjoint-set-union---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "Recursive DFS Cycle Detection",
        "type": "graph",
        "application": "something",
        "code": "def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        \n        # Note:\n        # 1. Build a graph from prerequisites (course -> list of courses depending on it).\n        # 2. Use DFS to detect cycles.\n        #    visited[course] = 0: unvisited\n        #    visited[course] = 1: visiting (currently in recursion stack)\n        #    visited[course] = 2: visited (safe, no cycles in this path)\n        # 3. If a cycle is found, return False (cannot finish all courses).\n        # 4. Otherwise, all courses can be completed.\n\n        # Build graph\n        graph = {i: [] for i in range(numCourses)}\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n\n        # State array\n        # 0 = unvisited, 1 = visiting, 2 = visited\n        visited = [0] * numCourses\n\n        def dfs(course):\n            # Early Prune -> cycle detected\n            if visited[course] == 1:\n                return False\n            # Late Prune -> already processed\n            if visited[course] == 2:\n                return True\n\n            # Process Root -> mark as visiting\n            visited[course] = 1\n\n            # Process Candidates -> traverse neighbors\n            for nei in graph[course]:\n                if not dfs(nei):\n                    return False\n            \n            # LAte Prune -> mark as visited\n            visited[course] = 2\n            return True\n\n        # Process Roots -> traverse all courses\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n\n        # All courses processed, no cycles\n\n        # overall: time complexity\n        # overall: space complexity\n        return True",
        "questionNumber": 207,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-recursive-dfs-cycle-detection---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Iterative BFS Topological Sort",
        "type": "graph",
        "application": "something",
        "code": "def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        \n        # Note:\n        # 1. Build graph (course -> list of dependent courses) and indegree array.\n        # 2. BFS from courses with indegree 0 (no prerequisites).\n        # 3. Reduce indegree of neighbors; add to queue when indegree becomes 0.\n        # 4. Count processed courses; if count == numCourses, return True.\n\n        # Init graph and indegree\n        indegree = [0] * numCourses\n        graph = {i: [] for i in range(numCourses)}\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            indegree[course] += 1\n\n        # Process Roots -> start with courses without prerequisites (0 indegree)\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        count = 0\n\n        # Process Candidates -> BFS topological sort\n        while queue:\n            curr = queue.popleft()\n            count += 1\n            for nei in graph[curr]:\n                indegree[nei] -= 1\n                # Early Prune -> neighbor ready to process\n                if indegree[nei] == 0:\n                    queue.append(nei)\n\n        # Late Prune -> if all courses processed, no cycles\n        return count == numCourses",
        "questionNumber": 207,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-iterative-bfs-topological-sort---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "DFS Topological Sort with Cycle Detection",
        "type": "graph",
        "application": "something",
        "code": "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \n        # Note:\n        # 1. Build graph (prereq -> list of courses that depend on it).\n        # 2. Use DFS to perform topological sort and detect cycles.\n        #    visited[course] = 0: unvisited\n        #    visited[course] = 1: visiting\n        #    visited[course] = 2: visited\n        # 3. Append course to result post DFS (postorder).\n        # 4. If a cycle is detected, return [].\n        # 5. Reverse postorder to get valid course order.\n        \n        # Graph setup\n        graph = {i: [] for i in range(numCourses)}\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n\n        # Status array\n        visited = [0] * numCourses  # 0 = unvisited, 1 = visiting, 2 = visited\n        res = []\n        self.is_possible = True\n\n        def dfs(course):\n            # Early Prune -> cycle detected\n            if visited[course] == 1:\n                self.is_possible = False\n                return\n\n            # Late Prune -> already processed\n            if visited[course] == 2:\n                return\n\n            # Process Root -> mark as visited\n            visited[course] = 1\n\n            # Process Choices -> neighbors and dependent courses\n            for nei in graph[course]:\n                dfs(nei)\n\n                # Early exit if cycle\n                if not self.is_possible:\n                    return\n\n            # Post order append\n            visited[course] = 2\n            res.append(course)\n\n        # Iterate over all Roots\n        for c in range(numCourses):\n            if visited[c] == 0:\n                dfs(c)\n                if not self.is_possible:\n                    return []\n\n        # Reverse post order to get correct order\n        return res[::-1]",
        "questionNumber": 210,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-dfs-topological-sort-with-cycle-detection---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "BFS Topological Sort",
        "type": "graph",
        "application": "something",
        "code": "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \n        # Note:\n        # 1. Build graph (prereq -> dependent courses) and indegree array.\n        # 2. BFS from courses with indegree 0 (roots).\n        # 3. For each root, decrement indegree of neighbors.\n        # 4. Add neighbor to queue if indegree becomes 0.\n        # 5. Return order if all courses processed, else [] (cycle detected).\n        \n        # Graph and indegree setup\n        indegree = [0] * numCourses\n        graph = {i: [] for i in range(numCourses)}\n\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            indegree[course] += 1\n\n        # Process Roots -> courses with no prerequisites\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        res = []\n\n        while queue:\n            curr = queue.popleft()\n            res.append(curr)\n\n            # Early Choices -> decrement indegree of neighbors \n            for nei in graph[curr]:\n                indegree[nei] -= 1\n\n                # Early Prune -> add to queue when indegree is 0\n                if indegree[nei] == 0:\n                    queue.append(nei)\n\n        # Check for cycles -> if all courses processed\n        return res if len(res) == numCourses else []",
        "questionNumber": 210,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-bfs-topological-sort---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "DFS Cycle Detection + Connectivity Check",
        "type": "graph",
        "application": "something",
        "code": "def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        \n        # Note:\n        # 1. A valid tree must have exactly n-1 edges.\n        # 2. Use DFS to check for cycles and connectivity.\n        # 3. visited set tracks nodes we've seen.\n        # 4. parent parameter prevents backtracking to previous node.\n        \n        # Early Prune -> must have n-1 edges\n        if len(edges) != n - 1:\n            return False\n\n        # Graph setup\n        graph = {i: [] for i in range(n)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        # seen\n        visited = set()\n\n        def dfs(node, parent):\n            # Early Prune -> cycle detected\n            if node in visited:\n                return False\n\n            # Process Root -> mark as visited\n            visited.add(node)\n\n            # Process Choices -> neighbors\n            for nei in graph[node]:\n                if nei == parent:\n                    continue\n                if not dfs(nei, node):\n                    return False\n            return True\n\n        # Start DFS from node 0 and check connectivity\n        return dfs(0, -1) and len(visited) == n",
        "questionNumber": 261,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-dfs-cycle-detection-connectivity-check---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "BFS Cycle Detection + Connectivity Check",
        "type": "graph",
        "application": "something",
        "code": "def validTree(self, n: int, edges: List[List[int]]) -> bool:\n\n        # Note:\n        # 1. A valid tree must have exactly n-1 edges.\n        # 2. Use BFS to check for cycles and connectivity.\n        # 3. visited set tracks nodes we've seen.\n        # 4. parent in queue prevents revisiting previous node.\n\n        # Early prune -> must have n-1 edges\n        if len(edges) != n - 1:\n            return False\n\n        # Graph setup\n        graph = {i: [] for i in range(n)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        # seen\n        visited = set()\n        queue = deque([(0, -1)])\n\n        while queue:\n            node, parent = queue.popleft()\n\n            # Early Prune -> cycle detected\n            if node in visited:\n                return False\n\n            # Process Root -> mark as visited\n            visited.add(node)\n\n            # Process Choices -> neighbors\n            for nei in graph[node]:\n                if nei != parent:\n                    queue.append((nei, node))\n\n        # Check connectivity\n        return len(visited) == n",
        "questionNumber": 261,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-bfs-cycle-detection-connectivity-check---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "Union Find Disjoint Set Union",
        "type": "graph",
        "application": "something",
        "code": "def validTree(self, n: int, edges: List[List[int]]) -> bool:\n\n        # Note:\n        # 1. A valid tree must have exactly n-1 edges.\n        # 2. Union Find detects cycles efficiently.\n        # 3. Path compression + union by rank for optimization.\n        # 4. If union fails, cycle detected -> return False.\n\n        # Early Prune -> must have n-1 edges\n        if len(edges) != n - 1:\n            return False\n\n        parent = [i for i in range(n)]\n        rank = [1] * n\n\n        # Find with Path Compression\n        def find(x):\n            while x != parent[x]:\n                parent[x] = parent[parent[x]]  # path compression\n                x = parent[x]\n            return x\n\n        # Union by Rank\n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            # Early Prune -> cycle detected\n            if rootX == rootY:\n                return False\n\n            # Merge trees\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n            return True\n\n        # Process all edges\n        for u, v in edges:\n            if not union(u, v):\n                return False\n\n        # overall: time complexity\n        # overall: space complexity\n        return True",
        "questionNumber": 261,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-union-find-disjoint-set-union---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "DFS",
        "type": "graph",
        "application": "something",
        "code": "def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        \n        # Note:\n        # 1. Build adjacency list for graph representation.\n        # 2. DFS explores all nodes in a connected component.\n        # 3. Track visited nodes in a set.\n        # 4. Increment components count when starting DFS from unvisited node.\n        \n        # build adjacency list, graph setup\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def dfs(node):\n            for nei in graph[node]:\n                if nei not in visited:\n                    visited.add(nei)\n                    dfs(nei)\n        \n        components = 0\n        for i in range(n):\n            if i not in visited:\n                visited.add(i)\n                dfs(i)\n                components += 1\n        return components",
        "questionNumber": 323,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-dfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "BFS",
        "type": "graph",
        "application": "something",
        "code": "def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def bfs(start):\n            queue = deque([start])\n            while queue:\n                node = queue.popleft()\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append(nei)\n        \n        components = 0\n        for i in range(n):\n            if i not in visited:\n                visited.add(i)\n                bfs(i)\n                components += 1\n        return components",
        "questionNumber": 323,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "BFS",
        "type": "graph",
        "application": "something",
        "code": "def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        parent = [i for i in range(n)]\n        rank = [1] * n\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])   # path compression\n            return parent[x]\n        \n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX == rootY:\n                return 0  # no merge\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n            return 1  # successful merge\n        \n        components = n\n        for u, v in edges:\n            if union(u, v):\n                components -= 1\n        return components",
        "questionNumber": 323,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "DFS",
        "type": "graph",
        "application": "something",
        "code": "def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        \n        def dfs(u, target, visited):\n            if u == target:\n                return True\n            visited.add(u)\n            for v in graph[u]:\n                if v not in visited and dfs(v, target, visited):\n                    return True\n            return False\n        \n        for u, v in edges:\n            visited = set()\n            if u in graph and v in graph and dfs(u, v, visited):\n                return [u, v]\n            graph[u].append(v)\n            graph[v].append(u)",
        "questionNumber": 684,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-dfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "BFS",
        "type": "graph",
        "application": "something",
        "code": "def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        \n        def bfs(u, target):\n            visited = set([u])\n            queue = deque([u])\n            while queue:\n                node = queue.popleft()\n                if node == target:\n                    return True\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append(nei)\n            return False\n        \n        for u, v in edges:\n            if u in graph and v in graph and bfs(u, v):\n                return [u, v]\n            graph[u].append(v)\n            graph[v].append(u)",
        "questionNumber": 684,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 3,
        "name": "Union Find Disjoint Set Union",
        "type": "graph",
        "application": "something",
        "code": "def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        parent = [i for i in range(n + 1)]\n        rank = [1] * (n + 1)\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX == rootY:\n                return False\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n            return True\n        \n        for u, v in edges:\n            if not union(u, v):\n                return [u, v]",
        "questionNumber": 684,
        "solutionLink": "/Notes/leetcode-graphs#solution-3-union-find-disjoint-set-union---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 1,
        "name": "BFS",
        "type": "graph",
        "application": "something",
        "code": "def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        L = len(beginWord)\n        all_combo_dict = defaultdict(list)\n        for word in wordSet:\n            for i in range(L):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                all_combo_dict[pattern].append(word)\n\n        queue = deque([(beginWord, 1)])\n        visited = set([beginWord])\n\n        while queue:\n            current_word, level = queue.popleft()\n            for i in range(L):\n                pattern = current_word[:i] + \"*\" + current_word[i+1:]\n                for neighbor in all_combo_dict[pattern]:\n                    if neighbor == endWord:\n                        return level + 1\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, level + 1))\n                all_combo_dict[pattern] = []  # mark pattern visited\n        return 0",
        "questionNumber": 127,
        "solutionLink": "/Notes/leetcode-graphs#solution-1-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      },
      {
        "number": 2,
        "name": "Bidirectional BFS",
        "type": "graph",
        "application": "something",
        "code": "def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        L = len(beginWord)\n        all_combo_dict = defaultdict(list)\n        for word in wordSet:\n            for i in range(L):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                all_combo_dict[pattern].append(word)\n\n        begin_set = {beginWord}\n        end_set = {endWord}\n        visited = set([beginWord, endWord])\n        level = 1\n\n        while begin_set and end_set:\n            if len(begin_set) > len(end_set):\n                begin_set, end_set = end_set, begin_set  # expand smaller frontier\n\n            temp = set()\n            for word in begin_set:\n                for i in range(L):\n                    pattern = word[:i] + \"*\" + word[i+1:]\n                    for neighbor in all_combo_dict[pattern]:\n                        if neighbor in end_set:\n                            return level + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            temp.add(neighbor)\n            begin_set = temp\n            level += 1\n\n        return 0",
        "questionNumber": 127,
        "solutionLink": "/Notes/leetcode-graphs#solution-2-bidirectional-bfs---graphsomething",
        "blog": "LeetCode: Graphs"
      }
    ]
  },
  "1d-dynamic-programming": {
    "dfs-with-caching-padded-n-1-top-down-with-memoization": [
      {
        "number": 1,
        "name": "i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-padded-n-1-top-down-with-memoization",
        "code": "def climbStairs(self, n: int) -> int:\n\n        # Note:\n        # Top Down DP (memoized recursion)\n        # 0. Direct Length -> no need for len == n check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Pad Boundaries -> overshot case case\n        # 3. Padded Boundary -> last element n\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Memo Return -> return ways, calculated once\n        # Result: Ways to climb from 0 to nth step\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n            \n            # Pad Boundaries -> overshot case case\n            if i > n:\n                return 0\n\n            # Padded Boundary -> last element n\n            if i == n:\n                return 1\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            memo[i] = dfs(i + 1) + dfs(i + 2)\n\n            # Memo return: return ways, calculated once\n            return memo[i]\n\n        # res -> ways to get from 0 to nth step\n        res = dfs(0)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 70,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-padded-n-1-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-padded-n-1-top-down-with-memoization",
        "code": "def climbStairs(self, n: int) -> int:\n\n        # Note:\n        # Top Down DP (memoized recursion)\n        # 0. Direct Length -> no need for len == 1 check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Pad Boundaries -> 0 ground case\n        # 3. Padded Boundary -> 1st element\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Memo return -> return ways, calculated once\n        # Result: Ways to climb from 0 to nth step\n\n        # Ways to climb from 0 to ith step\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n            \n            # Pad Boundaries -> 0 ground case\n            if i == 0:\n                return 1\n\n            # Padded Boundary -> 1st element\n            if i == 1:\n                return 1\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            memo[i] = dfs(i - 1) + dfs(i - 2)\n\n            # Memo return -> return ways, calculated once\n            return memo[i]\n\n        # res -> ways to climb from 0 to nth step\n        res = dfs(n)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 70,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-padded-n-1-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Explicit Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-padded-n-1-top-down-with-memoization",
        "code": "def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \n        # Note:\n        # Top Down DP (memoized recursion)\n        # 0. Direct Length -> no need for len == 1 check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Padding Boundary -> ground step 0\n        # 3. Padded Boundary -> first element\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Memo return -> return ways, calculated once\n        # Result: min cost to reach n from last or 2nd to last step\n\n        n = len(cost)\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Padding Boundary -> ground step 0\n            if i == 0:\n                return 0\n\n            # Padded Boundary -> first element\n            if i == 1:\n                return cost[0]\n\n            # Build From Previous -> min cost to reach current step\n            memo[i] = cost[i-1] + min(dfs(i-1), dfs(i-2))\n            return memo[i]\n\n        # res -> reach step n by coming from last two steps\n        res = min(dfs(n), dfs(n-1))\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursive stack)\n        return res",
        "questionNumber": 746,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-explicit-memoization-top-down---1d-dynamic-programmingdfs-with-caching-padded-n-1-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      }
    ],
    "iterative-tabulation-padded-n-1-bottom-up": [
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-padded-n-1-bottom-up",
        "code": "def climbStairs(self, n: int) -> int:\n        \n        # Note:\n        # Iterative Bottom Up Tabulation\n        # 1. Pad Array -> 0 ground case, dp size (N+1)\n        # 2. Padded -> grab 1st element\n        # 3. Iterate -> 2 to n\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # Result: ways to climb to nth step\n\n        # Pad Array -> 0 ground case, dp size (N+1)\n        dp = [0] * (n + 1)   # padding:\n        dp[0] = 1            # padding: ground case, does not exist in array\n        dp[1] = 1            # padded: first step\n\n        # Iterate -> 2 to nth\n        for i in range(2, n+1):\n            # Build From Previous -> grab from previous two steps and sum paths\n            dp[i] = dp[i-1] + dp[i-2]\n\n        # res -> nth step\n        res = dp[n]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 70,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-padded-n-1-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "optimal-iterative-padded-n-1-rolling-state-variables-bottom-up": [
      {
        "number": 4,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-padded-n-1-rolling-state-variables-bottom-up",
        "code": "def climbStairs(self, n: int) -> int:\n        \n        # Note:\n        # Iterative Bottom Up Variables\n        # 1. Pad Variables -> 0 ground case\n        # 2. Padded -> grab 2st element\n        # 3. Iterate -> 2 to n\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Roll Variables -> Iterate Variables\n        # Result: ways to climb to nth step\n\n        # Pad Variables -> 0 ground case\n        TwoPrev = 1  # padding:\n        OnePrev = 1  # padded: 1st element\n\n        # Iterate -> 2 to n\n        for i in range(2, n+1):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            curr = TwoPrev + OnePrev\n\n            # Slide Window -> Roll Variables\n            TwoPrev, OnePrev = OnePrev, curr\n        \n        # res -> ways to climb to n step\n        res = OnePrev\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 70,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-4-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-padded-n-1-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "dfs-with-caching-direct-n-top-down-with-memoization": [
      {
        "number": 2,
        "name": "i to N Recursive with Explicit Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \n        # Note:\n        # Top Down DP (memoized recursion)\n        # 0. Direct Length -> no need for len == 1 check, recursive direct boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> 1st element\n        # 3. Direct Boundary -> 2nd element\n        # 4. Direct Build From Previous -> grab from previous two steps and sum paths\n        # 5. Memo return -> return ways, calculated once\n        # Result: min cost to reach n from last or 2nd to last step\n\n        n = len(cost)\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Direct Boundary -> 1st element\n            if i == 0:\n                return cost[0]\n\n            # Direct Boundary -> 2nd element\n            if i == 1:\n                return cost[1]\n\n            # Build -> min cost to reach + cost to continue\n            memo[i] = cost[i] + min(dfs(i-1), dfs(i-2))\n            return memo[i]\n\n        # res -> reach n by continuing from nth or nth-1 step (since we step 1 or 2 steps)\n        res = min(dfs(n-1), dfs(n-2))\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursive stack)\n        return res",
        "questionNumber": 746,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-i-to-n-recursive-with-explicit-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Explicit Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def tribonacci(self, n: int) -> int:\n\n        # Note:\n        # Top Down DP (memoized recursion)\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> 1st element\n        # 3. Direct Boundary -> 2nd element\n        # 4. Direct Boundary -> 3rd element\n        # 5. Build From Previous -> grab from previous two steps and sum paths\n        # 6. Memo return -> return ways, calculated once\n        # Result: T_i in Tribonacci sequence\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Boundary -> 1st element\n            if i == 0:\n                return 0\n            # Boundary -> 2nd element\n            if i == 1:\n                return 1\n            # Boundary -> 3rd element\n            if i == 2:\n                return 1\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            memo[i] = dfs(i-1) + dfs(i-2) + dfs(i-3)\n            return memo[i]\n\n        # res -> T_n value\n        res = dfs(n)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 1137,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-explicit-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Explicit Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def rob(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Top down recursive with memoization\n        # 0. Direct Length -> no need for len == 1 check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> 1st element\n        # 3. Direct Boundary -> 2nd element\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # Result: max loop from first to last house\n\n        n = len(nums)\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Direct Boundary -> 1st element\n            if i == 0:\n                return nums[0]\n\n            # Direct Boundary -> 2nd element\n            if i == 1:\n                return max(nums[0], nums[1])\n            \n            # Direct Build From Previous -> grab from previous two steps and sum paths\n            # choose max between rob or skipping current house\n            memo[i] = max(nums[i] + dfs(i-2), dfs(i-1))\n            return memo[i]\n\n        # res -> max loot for nth house\n        res = dfs(n-1)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 198,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-explicit-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def rob(self, nums: List[int]) -> int:\n\n        # Note:\n        # Top down (recursive with memoization)\n        # 0. Direct Length -> need for len == 1 check, 2nd element may not exist\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> 1st + 2nd element\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 4. Handle circular constraint -> cannot rob both first and last\n        # Result: max loot for circular house array\n\n        n = len(nums)\n\n        # Direct Length -> need for len == 1 check, 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        def rob_range(start, end):\n\n            memo = {}\n\n            def dfs(i):\n\n                # Memo Check -> computed previously\n                if i in memo:\n                    return memo[i]\n\n                # Direct Boundary -> i == 0 (in subarray)\n                if i == start:\n                    return nums[i]\n\n                # Direct Boundary -> i == 1 (in subarray)\n                if i == start + 1:\n                    return max(nums[i], nums[i - 1])\n\n                # Build From Previous -> grab from previous two steps and sum paths\n                memo[i] = max(nums[i] + dfs(i-2), dfs(i-1))\n                return memo[i]\n\n            # res -> max loot at last house in subarray\n            return dfs(end)\n\n        # Handle circular constraint -> cannot rob both first and last\n        res1 = rob_range(0, n-2)\n        res2 = rob_range(1, n-1)\n\n        # res -> max loot from circular houses\n        res = max(res1, res2)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 213,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def numDecodings(self, s: str) -> int:\n\n        # Note:\n        # Top Down DP (recursive with memoization)\n        # 0. Direct Length -> no need for len == 1 check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> 1st element: empty string\n        # 3. Direct Boundary -> 2nd element: first char\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # Result: total decode ways from start (0) to end (n-1)\n\n        n = len(s)\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Direct Boundary -> 1st element: empty string\n            if i < 0:\n                return 1\n\n            # Direct Boundary -> 2nd element: first char\n            if i == 0:\n                return 1 if s[0] != '0' else 0\n\n            count = 0\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            \n            # 'How many total ways can I decode up to here if I decide to treat \n            # the current group as a valid single or valid double digit?'\n            # Add corresponding counts from single: i-1 and double: i-2\n\n            # check previous char, if single is valid\n            if s[i] != '0':\n                count += dfs(i-1)\n            \n            # check double via previous char, if double is valid\n            two_digit = int(s[i-1:i+1])\n            if 10 <= two_digit <= 26:\n                count += dfs(i-2)\n\n            memo[i] = count\n            return memo[i]\n\n        # res -> number of decode ways for nth\n        res = dfs(n-1)\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 91,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def coinChange(self, coins: List[int], amount: int) -> int:\n\n        # Note:\n        # Top down (recursive with memoization)\n        # 0. Direct Length -> no need for len == 1 check, recursive padding boundary covers it\n        # 1. Memo Check -> computed previously\n        # 2. Boundary Check -> exact match\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 4. Early Prune -> check if current coin leads to possible, else skip\n        # Result: min coins to reach amount if possible \n\n        sentinel = float('inf')\n\n        memo = {}\n\n        def dfs(curr_amount) -> int:\n\n            # Memo Check -> computed previously\n            if curr_amount in memo:\n                return memo[curr_amount]\n            \n            # Boundary Check -> exact match\n            if curr_amount == 0:\n                return 0\n\n            curr_min = sentinel\n            \n            # Build From Previous -> grab from previous two steps and sum paths\n            for coin in coins:\n\n                # Early Prune -> check if current coin leads to possible, else skip\n                new_remaining = curr_amount - coin\n                if new_remaining >= 0:\n\n                    # check if new min coin beats previous\n                    use_coin = dfs(new_remaining)\n                    curr_min = min(curr_min, use_coin+1)\n\n            # res -> min coins to reach current amount\n            memo[curr_amount] = curr_min\n            return memo[curr_amount]\n\n        # Result -> remaining amount set to full, grab min number of coins\n        res = dfs(amount)\n\n        # overall: time complexity \n        # overall: space complexity\n        return -1 if res == float('inf') else res",
        "questionNumber": 322,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "(Modified Kadane) i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def maxProduct(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Top Down (recursive with memoization)\n        # 0. Direct Length -> empty check\n        # 1. Memo Check -> computed previously\n        # 1. Direct Boundary -> 1st element\n        # 2. Build From Previous -> grab previous max/min and calculate new max/min at i\n        # 3. Three Possibilities -> infer max subarray\n        # Result -> track overall maximum from all dfs calls\n\n        n = len(nums)\n\n        # Direct Length -> empty array check\n        if n == 0:\n            return 0\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Direct Boundary -> 1st element\n            if i == 0:\n                memo[0] = (nums[0], nums[0])\n                return memo[0]\n\n            # Build From Previous -> grab previous max/min and calculate new max/min at i\n            prev_max, prev_min = dfs(i-1)\n            \n            # three possibilities\n            # 1. start new subarray at i -> num\n            # 2. extend previous max subarray -> num * prev_max\n            # 3. extend previous min subarray -> num * prev_min\n            num = nums[i]\n            curr_max = max(num, num * prev_max, num * prev_min)\n            curr_min = min(num, num * prev_max, num * prev_min)\n\n            # res -> max decision/subarray up to index i\n            memo[i] = (curr_max, curr_min)\n            return memo[i]\n\n        # start with max subarray at 0\n        result = nums[0]\n\n        for i in range(n):\n            \n            # max subarray at i\n            curr_max, curr_min = dfs(i)\n\n            # res -> overall max subarray\n            result = max(result, curr_max)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return result",
        "questionNumber": 152,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-modified-kadane-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n\n        # Note:\n        # Top Down DP (recursive with memoization)\n        # 0. Direct Length -> empty string boundary covered by recursion\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> empty string is valid segmentation\n        # 2. Iterate -> 0 to i, try every partition ending at i\n        # 3. Build From Previous -> if s[j:i] in dict and dfs(j) is True\n        # 4. Backtrack -> store False if no valid segmentation\n        # Result: can full string be segmented\n\n        n = len(s)\n\n        # int -> bool\n        memo = {}\n\n        # lookup\n        word_set = set(wordDict)\n\n        def dfs(i) -> bool:\n\n            # Direct Boundary -> empty string is valid segmentation\n            if i == 0:\n                return True\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Iterate -> 0 to i, try every partition ending at i\n            for j in range(i):\n\n                # Build From Previous -> valid segmentation\n                # check if s[j:i] is valid dictionary word\n                # checks if remaining substring before segment (start to j) can be segmented\n                if s[j:i] in word_set and dfs(j):\n                    memo[i] = True\n                    return True\n\n            # Backtrack -> no valid segmentation\n            memo[i] = False\n            return False\n\n        # res -> can segment full string\n        res = dfs(n)\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 139,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "Optimized i to N Recursive with Memoization Top Down",
        "type": "1d-dynamic-programming",
        "application": "dfs-with-caching-direct-n-top-down-with-memoization",
        "code": "def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n\n        # Note:\n        # Optimized Top Down DP (recursive with memoization)\n        # 0. Direct Length -> empty string boundary covered by recursion\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> empty string is valid segmentation\n\n        # 2. Explore Choices -> iterate only over words in wordDict\n        # 3. Build From Previous -> if s[i-len(word):i] matches and dfs(i-len(word)) is True\n        # 4. Backtrack -> store False if no valid segmentation\n        # Result: can full string be segmented\n\n        n = len(s)\n\n        memo = {}\n\n        # lookup\n        word_set = set(wordDict)\n\n        def dfs(i) -> bool:\n\n            # Direct Boundary -> empty string is valid segmentation\n            if i == 0:\n                return True\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Iterate -> try every word in dictionary\n            for word in word_set:\n\n                # Build From Previous -> valid segmentation\n                # i >= len(word) -> avoid nonsense negative slice: i = 3 -> substring = \"app\" -> s[i - len(word):i] == s[-2:3] == \"pp\"\n                # s[] -> check if word matches\n                if i >= len(word) and s[i - len(word):i] == word:\n                    # check if left side after word is segmentable\n                    if dfs(i - len(word)):\n                        memo[i] = True\n                        return True\n\n            # Backtrack -> no valid segmentation\n            memo[i] = False\n            return False\n\n        # res -> can segment full string\n        res = dfs(n)\n\n        # overall: time complexity O(n * m)  (m = #words)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 139,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-optimized-i-to-n-recursive-with-memoization-top-down---1d-dynamic-programmingdfs-with-caching-direct-n-top-down-with-memoization",
        "blog": "1D Dynamic Programming"
      }
    ],
    "iterative-tabulation-direct-n-bottom-up": [
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \n        # Note:\n        # Bottom Up Tabulation\n        # 0. Direct Length -> no need for len == 1 check, description says min length == 2\n        # 1. Direct Array -> 1st + 2nd element\n        # 3. Iterate -> 2 to n-1\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # Result: min cost to reach n via continuing from step n-1 or n-2\n\n        # 0. Direct Length -> no need for len == 1 check, description says min length == 2\n\n        n = len(cost)\n\n        # Direct Array -> 1st + 2nd element\n        dp = [0] * n\n        dp[0], dp[1] = cost[0], cost[1]\n\n        # Iterate -> steps 2 to n-1\n        for i in range(2, n):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n\n        # res -> min cost to reach n\n        res = min(dp[n-1], dp[n-2])\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 746,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def tribonacci(n: int) -> int:\n\n        # Note:\n        # this is a unique case where Direct/N, requires an array of (N+1)\n        # since we have 0 -> N fib solutions\n\n        # Note:\n        # Iterative Bottom Up Tabulation\n        # 1. Direct Boundary -> need for len == 0, len == 1, and len == 2, as 3rd element may not exist\n        # 2. Direct Array -> 1st, 2nd, and 3rd element\n        # 3. Iterate -> 2 to n-1\n        # 4. Iterate -> 3 to n\n        # 5. Build From Previous -> sum previous three DP entries\n        # Result: T_n in Tribonacci sequence\n\n        # Direct Boundary -> len == 0, len == 1, and len == 2, as 3rd element may not exist\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        # Direct Array -> 1st, 2nd, and 3rd element\n        dp = [0] * (n+1)\n        dp[0], dp[1], dp[2] = 0, 1, 1\n\n        # Iterate -> 3 to n\n        for i in range(3, n+1):\n\n            # Build From Previous -> sum of last three\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n\n        # res -> nth tribonacci\n        res = dp[n]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (memo + recursive stack)\n        return res",
        "questionNumber": 1137,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def rob(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Bottom Up Tabulation\n        # 0. Direct Length -> need for len == 1 check, 2nd element may not exist\n        # 1. Direct Array -> 1st + 2nd element\n        # 2. Iterate -> 2 to n-1\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # Result: max loot from nth house\n\n        n = len(nums)\n\n        # Direct Length -> need for len == 1 check, 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        # Direct Array -> 1st + 2nd element\n        dp = [0] * n\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # Iterate -> 2 to n-1\n        for i in range(2, n):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            # choose max between rob or skipping current house\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n        # res -> max loot at nth house\n        res = dp[n-1]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 198,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def rob(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Bottom up array\n        # 0. Direct Length -> need for len == 1 check, 2nd element may not exist\n        # 1. Direct Length (subarray) -> need for len == 1 check, 2nd element may not exist\n        # 2. Direct Array -> 1st + 2nd element\n        # 3. Iterate -> 2 to numHouses-1\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Handle circular constraint -> 2 subsets to break circular array\n        # Result: max loot from circular houses array\n\n        n = len(nums)\n\n        # Direct Length -> need for len == 1 check, 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        def rob_range(start, end):\n\n            # Direct Length -> need for len == 1 check, 2nd element may not exist\n            m = end - start + 1\n            if m == 1:\n                return nums[start]\n\n            # Direct Array -> 1st + 2nd element\n            dp = [0] * m\n            dp[0] = nums[start]\n            dp[1] = max(nums[start], nums[start + 1])\n\n            # Iterate -> 2 to m-1\n            for i in range(2, m):\n                j = start + i\n                # Build From Previous -> grab from previous two steps and sum paths\n                # choose max between rob or skipping current house\n                dp[i] = max(nums[j] + dp[i-2], dp[i-1])\n\n            # res -> max loot at last house in subarray\n            return dp[m-1]\n\n\n        # Handle circular constraint -> cannot rob both first and last\n        res1 = rob_range(0, n-2)\n        res2 = rob_range(1, n-1)\n\n        # res -> max loot from circular houses\n        res = max(res1, res2)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 213,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def numDecodings(self, s: str) -> int:\n\n        # Note:\n        # Iteration here is unique here because we cant initialize/skip i = 1, \n        # because it introduces the first valid two digit choice. \n        # If we jumped directly to i = 2, we’d miss the case where the answer \n        # depends entirely on that first double digit decode.\n\n        # Note:\n        # Bottom Up DP\n        # 0. Direct Length -> need for len == 1 check, 2nd element/first char may not exist\n        # 1. Direct Array -> 1st element\n        # 2. Iterate -> 1 to n-1\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # Result: total decode ways nth\n\n        n = len(s)\n\n        # Direct Length -> need for len == 0 check, 2nd element/first char may not exist\n        if not s:\n            return 0\n\n        # Direct Array -> 1st element\n        dp = [0] * n\n        dp[0] = 1 if s[0] != '0' else 0\n\n        # Iterate -> 1 to n-1\n        for i in range(1, n):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n\n            # 'How many total ways can I decode up to here if I decide to treat \n            # the current group as a valid single or valid double digit?'\n            # Add corresponding counts from single: i-1 and double: i-2\n\n            # check previous char, if single is valid\n            if s[i] != '0':\n                dp[i] += dp[i-1]\n\n            # check double via previous char, if double is valid\n            two_digit = int(s[i-1:i+1])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i-2] if i >= 2 else 1\n\n        # res -> number of decode ways for nth\n        res = dp[n-1]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 91,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        # Note:\n        # Bottom Up Array\n        # 0. Direct Length -> amount=0 check, needs no coins\n        # 1. Direct Array -> dp[0] = 0\n        # 3. Iterate -> 1 to amount\n        # 4. Explore Choices -> try each coin (coin multiple times possible)\n        # 5. Build -> min between \n        # Result: min coins to reach amount if possible\n\n        sentinel = float('inf')\n\n        # Direct Array -> 1st element\n        dp = [0] * (amount + 1)\n        dp[0] = 0 \n\n        # Iterate -> 1 to amount\n        for amount in range(1, amount + 1):\n\n            curr_min = sentinel\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            for coin in coins:\n\n                # Early Prune -> check if current coin leads to possible, else skip\n                new_remaining = amount - coin\n                if new_remaining >= 0:\n\n                    # check if new min coin beats previous\n                    use_coin = dp[new_remaining] + 1\n                    curr_min = min(curr_min, use_coin)\n\n            dp[amount] = curr_min\n\n        # \n        res = dp[amount] if dp[amount] != sentinel else -1\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 322,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "(Modified Kadane) 0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "iterative-tabulation-direct-n-bottom-up",
        "code": "def maxProduct(self, nums: List[int]) -> int:\n\n        # Note:\n        # Bottom Up DP with arrays\n        # 0. Direct Length -> empty array check\n        # 1. Direct Array -> initialize max_dp, min_dp at index 0\n        # 2. Iterate -> 1 to n-1\n        # 3. Build From Previous -> grab previous max/min and calculate new max/min at i\n        # 4. Three Possibilities -> infer max subarray\n        # Result -> grab overall max subarray\n\n        n = len(nums)\n\n        # Direct Length -> empty array check\n        if n == 0:\n            return 0\n\n        # Direct Array -> initialize max_dp, min_dp at index 0\n        max_dp = [0] * n\n        min_dp = [0] * n\n        max_dp[0] = min_dp[0] = result = nums[0]\n\n        # Iterate -> 1 to n-1\n        for i in range(1, n):\n\n            # three possibilities\n            # 1. start new subarray at i -> num\n            # 2. extend previous max subarray -> num * prev_max\n            # 3. extend previous min subarray -> num * prev_min\n            num = nums[i]\n            max_dp[i] = max(num, max_dp[i-1] * num, min_dp[i-1] * num)\n            min_dp[i] = min(num, max_dp[i-1] * num, min_dp[i-1] * num)\n\n            # res -> overall max subarray\n            result = max(result, max_dp[i])\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return result",
        "questionNumber": 152,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-modified-kadane-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingiterative-tabulation-direct-n-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "optimal-iterative-direct-n-rolling-state-variables-bottom-up": [
      {
        "number": 4,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \n        # Note:\n        # Bottom Up Variables\n        # 0. Direct Length -> no need for len == 1 check, description says min length == 2\n        # 1. Direct Variables -> 1st + 2nd element\n        # 2. Iterate -> 2 to n-1\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 3. Roll Variables -> Iterate Variables\n        # Result: min cost to reach n via continuing from last or 2nd to last step (n-1, or n-2)\n\n        # 0. Direct Length -> no need for len == 1 check, description says min length == 2\n\n        n = len(cost)\n\n        # Direct Variables -> 1st + 2nd element\n        prev2, prev1 = cost[0], cost[1]\n\n        # Iterate -> 2 to n-1\n        for i in range(2, n):\n            \n            # Build From Previous -> grab from previous two steps and sum paths\n            curr = cost[i] + min(prev1, prev2)\n\n            # Roll Variables -> Iterate Variables\n            prev2, prev1 = prev1, curr\n\n        # res -> min cost to reach n\n        res = min(prev1, prev2)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 746,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-4-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def tribonacci(self, n: int) -> int:\n\n        # Note:\n        # this is a unique case where Direct/N, requires an array of (N+1)\n        # since we have 0 -> N fib solutions\n\n        # Note:\n        # Iterative Bottom Up Variables\n        # 1. Direct Boundary -> need len == 1 check, elements 2 and 3 may not exist\n        # 2. Direct Variables -> 1st + 2nd + 3rd elements\n        # 3. Iterate -> 3 to n\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Roll Variables -> Iterate Variables\n        # Result: T_n in Tribonacci sequence\n\n        # Direct Boundary -> need len == 1 check, elements 2 and 3 may not exist\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1 \n\n        # Direct Variables -> 1st + 2nd + 3rd elements\n        ThreePrev, TwoPrev, OnePrev = 0, 1, 1\n\n        # Iterate -> 3 to n\n        for i in range(3, n+1):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            curr = ThreePrev + TwoPrev + OnePrev\n\n            # Roll Variables -> Iterate Variables\n            ThreePrev, TwoPrev, OnePrev = TwoPrev, OnePrev, curr\n\n        # res -> nth tribonacci\n        res = OnePrev\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 1137,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def rob(self, nums: List[int]) -> int:\n\n        # Note:\n        # Bottom Up Variables\n        # 0. Direct Length -> need for len == 1 check, 2nd element may not exist\n        # 1. Direct Variables -> 1st + 2nd element\n        # 2. Iterate -> 2 to n-1\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 4. Roll Variables -> Iterate Variables\n        # Result: max loot first to last house\n\n        n = len(nums)\n\n        # Direct Length -> need for len == 1 check, 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        # Direct Variables -> 1st + 2nd element\n        prev2, prev1 = nums[0], max(nums[0], nums[1])\n\n        # Iterate -> 2 to n-1\n        for i in range(2, n):\n\n            # Build From Previous -> grab from previous two steps and sum paths\n            curr = max(prev1, nums[i] + prev2)\n\n            # Roll Variables -> Iterate Variables\n            prev2, prev1 = prev1, curr\n\n        # res -> max loot at nth house\n        res = prev1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 198,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def rob(self, nums: List[int]) -> int:\n\n        # Note:\n        # Bottom up variables\n        # 0. Direct Length -> need for len == 1 check, 2nd element may not exist\n        # 1. Direct Length (subarray) -> need for len == 1 check, 2nd element may not exist\n        # 2. Direct Variables -> 1st + 2nd element\n        # 3. Iterate -> 2 to numHouses-1\n        # 4. Build From Previous -> grab from previous two steps and sum paths\n        # 5. Roll Variables -> Iterate Variables\n        # 6. Handle circular constraint -> cannot rob both first and last\n        # Result: max loot from circular houses\n\n        n = len(nums)\n\n        # Direct Length -> need for len == 1 check, 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        def rob_range(start, end):\n\n            # Direct Length -> need for len == 1 check, 2nd element may not exist\n            m = end - start + 1\n            if m == 1:\n                return nums[start]\n\n            # Direct Variables -> 1st + 2nd element\n            TwoPrev = nums[start]\n            OnePrev = max(nums[start], nums[start+1])\n\n            # Iterate -> 2 to m-1\n            for i in range(2, m):\n                j = start + i\n                # Build From Previous -> grab from previous two steps and sum paths\n                curr = max(nums[j] + TwoPrev, OnePrev)\n\n                # Roll Variables -> Iterate Variables\n                TwoPrev, OnePrev = OnePrev, curr\n\n            # res -> max loot at last house in subarray\n            res = OnePrev\n            return res\n\n        # Handle circular constraint -> cannot rob both first and last\n        res1 = rob_range(0, n-2)\n        res2 = rob_range(1, n-1)\n\n        # res -> max loot from circular houses\n        res = max(res1, res2)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 213,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def numDecodings(self, s: str) -> int:\n\n        # Note:\n        # Iteration here is unique here because we cant initialize/skip i = 1, \n        # because it introduces the first valid two digit choice. \n        # If we jumped directly to i = 2, we’d miss the case where the answer \n        # depends entirely on that first double digit decode.\n\n        # Note:\n        # Bottom-up DP with space optimization\n        # 0. Direct Length -> need for len == 0 check, 2nd element/first char, maybe not exist\n        # 1. Direct Variables -> 1st element\n        # 2. Iterate -> 1 to n-1\n        # 3. Build From Previous -> grab from previous two steps and sum paths\n        # 4. Roll Variables -> Iterate Variables\n        # Result -> total decode ways nth\n\n        # Direct Length -> need for len == 0 check, 2nd element/first char, maybe not exist\n        if not s:\n            return 0\n\n        n = len(s)\n\n        # Direct Variables -> 1st element\n        prev2 = 0 \n        prev1 = 1 if s[0] != '0' else 0\n\n        # Iterate -> 1 to n-1\n        for i in range(1, n):\n\n            curr = 0\n\n            # Build From Previous -> grab from previous two steps and sum paths\n\n            # 'How many total ways can I decode up to here if I decide to treat \n            # the current group as a valid single or valid double digit?'\n            # Add corresponding counts from single: i-1 and double: i-2\n\n            # check previous char, if single is valid\n            if s[i] != '0':\n                curr += prev1\n\n            # decode ignoring double digit\n            two_digit = int(s[i-1:i+1])\n            if 10 <= two_digit <= 26:\n                curr += prev2 if i >= 2 else 1\n\n            # Roll Variables -> Iterate Variables\n            prev2, prev1 = prev1, curr\n\n        # res -> number of decode ways for nth\n        res = prev1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 91,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "(Modified Kadane) 0 to i Iterative Bottom Up Variables",
        "type": "1d-dynamic-programming",
        "application": "optimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def maxProduct(self, nums: List[int]) -> int:\n\n        # Note:\n        # Bottom Up DP (rolling variables)\n        # 0. Direct Length -> empty array check\n        # 1. Direct Variables -> initialize max_dp, min_dp at index 0\n        # 2. Iterate -> 1 to n-1\n        # 3. Build From Previous -> grab previous max/min and calculate new max/min at i\n        # 4. Three Possibilities -> infer max subarray\n        # Result -> grab overall max subarray\n\n        n = len(nums)\n\n        # Direct Length -> empty array check\n        if n == 0:\n            return 0\n\n        # Direct Variables -> initialize max_dp, min_dp at index 0\n        max_prod = min_prod = result = nums[0]\n\n        # Iterate -> 1 to n-1\n        for i in range(1, n):\n\n            # Store previous rolling values\n            prev_max, prev_min = max_prod, min_prod\n\n            # Build From Previous -> grab previous max/min and calculate new max/min at i\n            num = nums[i]\n            max_prod = max(num, prev_max * num, prev_min * num)\n            min_prod = min(num, prev_max * num, prev_min * num)\n\n            # Update overall result\n            result = max(result, max_prod)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return result",
        "questionNumber": 152,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-modified-kadane-0-to-i-iterative-bottom-up-variables---1d-dynamic-programmingoptimal-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "linear-property-tracking": [
      {
        "number": 3,
        "name": "Dynamic Programming",
        "type": "1d-dynamic-programming",
        "application": "linear-property-tracking",
        "code": "def longestPalindrome(self, s: str) -> str:\n        \n        n = len(s)\n        dp = [[False]*n for _ in range(n)]\n        start, max_len = 0, 1\n\n        for i in range(n):\n            dp[i][i] = True\n\n        for length in range(2, n+1):  # substring length\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j]:\n                    if length == 2 or dp[i+1][j-1]:\n                        dp[i][j] = True\n                        if length > max_len:\n                            start, max_len = i, length\n\n        return s[start:start+max_len]",
        "questionNumber": 5,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-dynamic-programming---1d-dynamic-programminglinear-property-tracking",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "Two Pointers Expand Around Center",
        "type": "1d-dynamic-programming",
        "application": "linear-property-tracking",
        "code": "def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n\n        # helper: expand from center\n        def expand(l: int, r: int) -> int:\n            local_count = 0\n            while l >= 0 and r < n and s[l] == s[r]:\n                local_count += 1   # found a palindrome\n                l -= 1\n                r += 1\n            return local_count\n\n        # expand around all possible centers\n        for i in range(n):\n            count += expand(i, i)     # odd-length palindromes\n            count += expand(i, i + 1) # even-length palindromes\n\n        return count",
        "questionNumber": 647,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-two-pointers-expand-around-center---1d-dynamic-programminglinear-property-tracking",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "Dynamic Programming",
        "type": "1d-dynamic-programming",
        "application": "linear-property-tracking",
        "code": "def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        count = 0\n\n        # single characters\n        for i in range(n):\n            dp[i][i] = True\n            count += 1\n\n        # substring lengths 2 -> n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j]:\n                    if length == 2 or dp[i + 1][j - 1]:\n                        dp[i][j] = True\n                        count += 1\n\n        return count",
        "questionNumber": 647,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-dynamic-programming---1d-dynamic-programminglinear-property-tracking",
        "blog": "1D Dynamic Programming"
      }
    ],
    "bfs-visited-memo-level-order": [
      {
        "number": 3,
        "name": "BFS Memo Coin Number Level Order Search",
        "type": "1d-dynamic-programming",
        "application": "bfs-visited-memo-level-order",
        "code": "def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        # Note:\n        # BFS Level Order (shortest path) to find min coins\n        # 0. Direct Length -> if amount is 0, no coins needed\n        # 1. Iterative stack -> (remaining_amount, coins_used_so_far)\n        # 2. Visited set -> no revisiting amount\n        # 1. Process root -> current state (amount, coins)\n        # 2. Explore choices -> subtract each coin to get next remaining amounts\n        # 3. Build -> increment steps (coins used) at each BFS level\n        # 4. Early stop -> return steps+1 when remaining reaches 0\n        # 5. Result -> -1 if queue exhausted (impossible)\n\n        # Direct Length -> if amount is 0, no coins needed\n        if amount == 0:\n            return 0\n\n        # Iterative stack -> (remaining_amount, coins_used_so_far)\n        queue = deque([(amount, 0)])\n\n        # memo_visited set -> no revisiting amount\n        memo_visited = set([amount])\n\n        while queue:\n\n            # Process Root -> current state (amount, coins)\n            rem, steps = queue.popleft()\n\n            # Build -> increment steps (coins used) at each BFS level\n            for coin in coins:\n\n                next_rem = rem - coin\n\n                # Early stop -> found a valid combination\n                if next_rem == 0:\n                    return steps + 1\n                \n                # Build -> enqueue next remaining if valid and not visited\n                elif next_rem > 0 and next_rem not in visited:\n                    visited.add(next_rem)\n                    queue.append((next_rem, steps + 1))\n\n        # No combination found\n        return -1",
        "questionNumber": 322,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-bfs-memo-coin-number-level-order-search---1d-dynamic-programmingbfs-visited-memo-level-order",
        "blog": "1D Dynamic Programming"
      }
    ],
    "opposite-ends-iterative-direct-n-rolling-state-variables-bottom-up": [
      {
        "number": 4,
        "name": "(Modified Kadane) Forward Backward Scan",
        "type": "1d-dynamic-programming",
        "application": "opposite-ends-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def maxProduct(self, nums: List[int]) -> int:\n\n        # Note:\n        # Forward-Backward Scan (cumulative products)\n        # 0. Direct Length -> empty array check\n        # 1. Direct Variables -> initialize left and right\n        # 2. Iterate -> forward and backward in the same loop\n        # 4. Build -> update result with max(left_prod, right_prod)\n        # 5. Three Possibilities -> max subarray\n        # Result -> grab overall max subarray\n\n        n = len(nums)\n\n        # Direct Length -> empty array check\n        if n == 0:\n            return 0\n\n        # Direct Variables -> initialize left and right\n        left_prod = right_prod = 1\n        result = float('-inf')\n\n        # Iterate -> forward and backward in the same loop\n        for i in range(n):\n\n            # left scan -> contiguous subarray ending here \n            # right scan -> contiguous subarray starting from here\n            # new subarray after zero -> start of new subarray after zero  \n            left_prod *= nums[i]\n            right_prod *= nums[n - 1 - i]\n\n            # Three Possibilities -> max subarray\n            result = max(result, left_prod, right_prod)\n\n            # Reset if zero encountered\n            if left_prod == 0:\n                left_prod = 1\n            if right_prod == 0:\n                right_prod = 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return result",
        "questionNumber": 152,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-4-modified-kadane-forward-backward-scan---1d-dynamic-programmingopposite-ends-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "sliding-window-iterative-direct-n-rolling-state-variables-bottom-up": [
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "1d-dynamic-programming",
        "application": "sliding-window-iterative-direct-n-rolling-state-variables-bottom-up",
        "code": "def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        \n        # Note:\n        # Bottom Up DP (tabulation)\n        # 0. Direct Length -> need len == 0 check\n        # 1. Direct Array -> empty string is segmentable\n        # 2. Iterate -> 1 to n\n        # 3. Explore Choices -> try all j < i\n        # 4. Build From Previous -> dp[i] = True if dp[j] is True and s[j:i] in dict\n        # 5. Early Prune -> break if segmentation found\n        # Result: can full string be segmented\n \n        n = len(s)\n\n        dp = [False] * (n + 1)\n\n        # quick lookup\n        word_set = set(wordDict)\n\n        # Direct Array -> empty string is segmentable\n        dp[0] = True\n\n        # Iterate -> 1 to n\n        for i in range(1, n+1):\n\n            # Explore Choices -> try all j < i\n            for j in range(i):\n                \n                # Build From Previous -> dp[i] = True if dp[j] is True and s[j:i] in dict\n                if dp[j] and s[j:i] in word_set:\n\n                    # Build -> segmentable\n                    dp[i] = True \n                    # early prune, found valid segmentation\n                    break  \n\n        # Result: can full string be segmented\n        res = dp[n]\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 139,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---1d-dynamic-programmingsliding-window-iterative-direct-n-rolling-state-variables-bottom-up",
        "blog": "1D Dynamic Programming"
      }
    ],
    "sequential-segment-choice-validation": [
      {
        "number": 4,
        "name": "0 to i Iterative Bottom Up Rolling Variables Sliding Window",
        "type": "1d-dynamic-programming",
        "application": "sequential-segment-choice-validation",
        "code": "def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        \n        # Note:\n        # Bottom Up DP with rolling variables (sliding window)\n        # 0. Direct Length -> empty string check\n        # 1. Window Size -> track last max_word_length states only\n        # 2. Initialize -> dp[0] = True for empty string\n        # 3. Iterate -> 1 to n\n        # 4. Build From Previous -> check previous positions within window\n        # 5. Early stop -> break if valid segmentation found\n        # Result -> dp[n % (max_len + 1)] gives final result\n\n        n = len(s)\n\n        if n == 0:\n            return True\n\n        word_set = set(wordDict)\n        max_len = max(map(len, wordDict)) if wordDict else 0\n\n        # Initialize DP rolling window\n        dp = [False] * (max_len + 1)\n        dp[0] = True  # empty string\n\n        # Iterate over string positions\n        for i in range(1, n + 1):\n            dp[i % (max_len + 1)] = False\n\n            # Build From Previous -> look back up to max_len\n            for l in range(1, min(i, max_len) + 1):\n                if dp[(i - l) % (max_len + 1)] and s[i - l:i] in word_set:\n                    dp[i % (max_len + 1)] = True\n                    break  # early stop, found valid segmentation\n\n        # Result -> can full string be segmented\n        res = dp[n % (max_len + 1)]\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 139,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-4-0-to-i-iterative-bottom-up-rolling-variables-sliding-window---1d-dynamic-programmingsequential-segment-choice-validation",
        "blog": "1D Dynamic Programming"
      }
    ],
    "subsequence-optimization-constrained": [
      {
        "number": 1,
        "name": "Dynamic Programming",
        "type": "1d-dynamic-programming",
        "application": "subsequence-optimization-constrained",
        "code": "def lengthOfLIS(self, nums: List[int]) -> int:\n\n        # Note:\n        # Top Down DP (recursive with memoization)\n        # 0. Direct Length -> empty array boundary covered by recursion\n        # 1. Memo Check -> computed previously\n        # 2. Direct Boundary -> single element subsequence has length 1\n        # 3. Explore Choices -> check all j > i to extend subsequence\n        # 4. Build From Previous -> max length using future extensions\n        # Result -> maximum LIS starting from index 0 to n-1\n\n        n = len(nums)\n\n        memo = {}\n\n        def dfs(i):\n\n            # Memo Check -> computed previously\n            if i in memo:\n                return memo[i]\n\n            # Direct Boundary -> single element\n            max_len = 1\n\n            # Explore Choices -> try to extend from i to future indices\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    max_len = max(max_len, 1 + dfs(j))\n\n            memo[i] = max_len\n            return max_len\n\n        # Result -> try starting from every index\n        res = max(dfs(i) for i in range(n))\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
        "questionNumber": 300,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-dynamic-programming---1d-dynamic-programmingsubsequence-optimization-constrained",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "Dynamic Programming",
        "type": "1d-dynamic-programming",
        "application": "subsequence-optimization-constrained",
        "code": "def lengthOfLIS(self, nums: List[int]) -> int:\n\n        # Note:\n        # Top Down DP (recursive memoization)\n        # 0. Direct Length -> empty array boundary covered by recursion\n        # 1. Direct array \n        # 2.\n        # 2. Direct Boundary -> single element subsequence has length 1\n        # 3. Explore Choices -> check all j > i to extend subsequence\n        # 4. Build From Previous -> max length using future extensions\n        # Result -> maximum LIS starting from index 0 to n-1\n\n        n = len(nums)\n\n        # Direct Length -> empty array boundary covered by recursion\n        if n == 0:\n            return 0\n\n        # dp[i] = length of LIS ending at i\n        dp = [1] * n\n\n        for i in range(n):\n            for j in range(i):\n\n                # Explore Choice -> extend subsequence ending at j\n                if nums[i] > nums[j]:\n\n                    # Build -> max between current and extending j\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        # res -> max from array\n        res = max(dp)\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity. O(n) (memo + recursion stack)\n        return res",
        "questionNumber": 300,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-dynamic-programming---1d-dynamic-programmingsubsequence-optimization-constrained",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "Binary Search",
        "type": "1d-dynamic-programming",
        "application": "subsequence-optimization-constrained",
        "code": "def lengthOfLIS(self, nums: List[int]) -> int:\n\n        # Note:\n        # Same as Solution 2, but manual binary search instead of bisect\n        # 1. Process root -> current number\n        # 2. Explore choices -> search for first tail >= num\n        # 3. Build -> append if end, replace otherwise\n        # 4. Result -> length of tails = LIS length\n\n        tails = []\n\n        # \n        for num in nums:\n            left, right = 0, len(tails) - 1\n            \n            # Explore Choices -> find insertion/replacement index\n            while left <= right:\n\n                # \n                mid = (left + right) // 2\n                \n                # \n                if tails[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            # Build: insert or replace\n            if left == len(tails):\n                tails.append(num)\n            else:\n                tails[left] = num\n\n        return len(tails)",
        "questionNumber": 300,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-3-binary-search---1d-dynamic-programmingsubsequence-optimization-constrained",
        "blog": "1D Dynamic Programming"
      }
    ],
    "subset-sum-linear-choice-selection": [
      {
        "number": 1,
        "name": "Dynamic Programming Subset Sum",
        "type": "1d-dynamic-programming",
        "application": "subset-sum-linear-choice-selection",
        "code": "def canPartition(self, nums: List[int]) -> bool:\n        \n        # Note:\n        # 1D DP for subset sum\n        # 1. Process root -> current number in nums\n        # 2. Explore choices -> include current number or skip it\n        # 3. Build -> update achievable sums in dp\n        # 4. Result -> check if target sum is achievable\n        \n        total = sum(nums)\n        # If total sum is odd, cannot partition equally\n        if total % 2 != 0:\n            return False\n\n        target = total // 2\n        n = len(nums)\n\n        # dp[i] = True if sum i is achievable with some subset\n        dp = [False] * (target + 1)\n        # sum 0 is always achievable (root/base case)\n        dp[0] = True\n\n        for num in nums:\n            # Explore choices in reverse to avoid using same number twice\n            for i in range(target, num - 1, -1):\n                # Build: include num if sum i-num was achievable\n                dp[i] = dp[i] or dp[i - num]\n\n        # Result: can we achieve target sum?\n        return dp[target]",
        "questionNumber": 416,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-1-dynamic-programming-subset-sum---1d-dynamic-programmingsubset-sum-linear-choice-selection",
        "blog": "1D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "Bitmask Bitset DP",
        "type": "1d-dynamic-programming",
        "application": "subset-sum-linear-choice-selection",
        "code": "def canPartition(self, nums: List[int]) -> bool:\n        \n        # Note:\n        # Bitmask DP (bitset)\n        # 1. Process root -> each number\n        # 2. Explore choices -> include or skip number, track sums as bits\n        # 3. Build -> shift bits to represent new achievable sums\n        # 4. Result -> check if target sum bit is set\n\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n\n        target = total // 2\n\n        # bitset where i-th bit = True if sum i achievable\n        bits = 1  # only 0 sum is achievable initially\n\n        for num in nums:\n            # Build: shift current bits by num to represent including it\n            bits |= bits << num\n\n        # Result: check if target sum is achievable\n        return (bits >> target) & 1 == 1",
        "questionNumber": 416,
        "solutionLink": "/Notes/1d-dynamic-programming#solution-2-bitmask-bitset-dp---1d-dynamic-programmingsubset-sum-linear-choice-selection",
        "blog": "1D Dynamic Programming"
      }
    ]
  },
  "greedy": {
    "greedy": [
      {
        "number": 1,
        "name": "Greedy Kadane Algorithm Textbook Version",
        "type": "greedy",
        "application": "greedy",
        "code": "def maxSubArray(self, nums: List[int]) -> int:\n\n        # Note:\n        # Kadane's Algorithm (Greedy / DP)\n        # iterate over array\n        # at every step either extend subarray or start new subarray\n        # Result -> max sum\n\n        n = len(nums)\n\n        local_max = nums[0]\n        global_max = nums[0]\n\n        # iterate over array\n        for i in range(1, n):\n\n            # nums[i]: start new subarray at i\n            # local_max + nums[i]: extend previous subarray\n            local_max = max(nums[i], local_max + nums[i])\n\n            # compare to global max\n            global_max = max(global_max, local_max)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return global_max",
        "questionNumber": 53,
        "solutionLink": "/Notes/greedy#solution-1-greedy-kadane-algorithm-textbook-version---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 2,
        "name": "Greedy Kadane Algorithm Practical Version",
        "type": "greedy",
        "application": "greedy",
        "code": "def maxSubArray(self, nums: List[int]) -> int:\n\n        # Note:\n        # Greedy (Kadane’s Algorithm)\n        # iterate over array\n        # at every step either extend subarray or start new subarray\n        # Result -> max sum\n\n        max_sum = nums[0]\n        current_sum = 0\n\n        # iterate over array\n        for num in nums:\n\n\n            # extend subarray: current_sum + num\n            current_sum += num\n\n            # start new subarray at i\n            if current_sum < 0:\n                current_sum = 0\n\n            # compare to global max\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_sum",
        "questionNumber": 53,
        "solutionLink": "/Notes/greedy#solution-2-greedy-kadane-algorithm-practical-version---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 3,
        "name": "Divide and Conquer",
        "type": "greedy",
        "application": "greedy",
        "code": "def maxSubArray(self, nums: List[int]) -> int:\n        # Note:\n        # Divide & Conquer approach\n        # 1. Process root -> split array into halves\n        # 2. Explore Choices -> max subarray is:\n        #    entirely in left half\n        #    entirely in right half\n        #    crosses the midpoint (ending at mid and starting at mid+1)\n        # 3. Build -> recursively compute left, right, cross sums\n        # Result -> max sum of array\n\n        def helper(left, right):\n            \n            # single element, return element\n            if left == right:\n                return nums[left]\n\n            # midpoint for split and cross_max\n            mid = (left + right) // 2\n\n            # check left and right subarray\n            left_max = helper(left, mid)\n            right_max = helper(mid + 1, right)\n\n            # maximum suffix sum of the left half: best sum ending at mid\n            left_sum = float('-inf')\n            curr = 0\n            for i in range(mid, left - 1, -1):\n                curr += nums[i]\n                left_sum = max(left_sum, curr)\n\n            # maximum prefix sum of the right half: best sum starting at mid+1\n            right_sum = float('-inf')\n            curr = 0\n            for i in range(mid + 1, right + 1):\n                curr += nums[i]\n                right_sum = max(right_sum, curr)\n\n            # maximum subarray sum that spans across the midpoint.\n            cross_max = left_sum + right_sum\n\n            # pass max from left, right, and cross section to parent\n            return max(left_max, right_max, cross_max)\n\n        res = helper(0, len(nums) - 1)\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(log n) recursion depth\n        return res",
        "questionNumber": 53,
        "solutionLink": "/Notes/greedy#solution-3-divide-and-conquer---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy Dynamic Programming Rolling Variable Early Exit",
        "type": "greedy",
        "application": "greedy",
        "code": "def canJump(self, nums: List[int]) -> bool:\n        \n        # Note:\n        # \n        # Rolling Variable -> tracks farthest possible index we can reach\n        # Iterate over array -> \n        # 2. Build From Previous -> maintain farthest reachable index so far\n        # 3. Explore Choices -> if current index > farthest, return False (stuck)\n        # 4. Result -> if iteration completes, last index is reachable\n\n        n = len(nums)\n\n        # rolling variable\n        farthest = 0\n\n        # iterate array\n        for i in range(n):\n\n            # reached an unreachable index, cannot reach end\n            if i > farthest:\n                return False\n\n            # Build From Previous -> update farthest reachable\n            farthest = max(farthest, i + nums[i])\n\n            # Early exit -> can already reach or surpass last index\n            if farthest >= n - 1:\n                return True\n\n        # last index is not reachable\n\n        # overall: time complexity\n        # overall: space complexity\n        return False",
        "questionNumber": 55,
        "solutionLink": "/Notes/greedy#solution-1-greedy-dynamic-programming-rolling-variable-early-exit---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy Layer By Layer",
        "type": "greedy",
        "application": "greedy",
        "code": "def jump(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Greedy (layer expansion like BFS)\n\n        # A layer in this context is a BFS level of the array.\n        # Each level contains all indices you can reach with the same number\n        # of jumps. \n        \n        n = len(nums)\n\n        # no jumps needed\n        if n == 1:\n            return 0\n\n        # Each level contains all indices you can reach with the same number\n        # of jumps. \n        jumps = 0\n\n        # current_end marks the rightmost index in the current layer. \n        # So when we reach current_end, it means we have finished exploring the\n        # current layer, and current_end holds the best next move for this layer.\n        current_end = 0\n\n        # keeps track of the furthest index we can reach in this layer.\n        farthest = 0\n\n        # iterate -> 0 to n-2\n        # problem guarantees we can always reach the last index,\n        # so we don't need to check for unreachable branches\n        for i in range(n-1):\n\n            # update farthest reachable index for index\n            farthest = max(farthest, i + nums[i])\n\n            # reach end of current layer, go to next layer\n            if i == current_end:\n                jumps += 1          # need to jump\n                current_end = farthest  # move to next layer\n\n        # Result -> total jumps\n\n        # overall: time complexity\n        # overall: space complexity\n        return jumps",
        "questionNumber": 45,
        "solutionLink": "/Notes/greedy#solution-1-greedy-layer-by-layer---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy",
        "type": "greedy",
        "application": "greedy",
        "code": "def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        \n        # Note:\n        # Greedy Linear Scan\n        # 0. Direct Boundary -> if total gas < total cost, impossible (-1)\n        # 1. Process root -> traverse stations\n        # 2. Build From Previous -> track current tank balance\n        # 3. Explore Choices -> if tank < 0, reset start to next station\n        # 4. Result -> return start index (guaranteed unique if feasible)\n\n        n = len(gas)\n\n        # not enough total gas to cover total cost\n        if sum(gas) < sum(cost):\n            return -1\n\n        # current gas\n        tank = 0\n        # candidate starting station\n        start = 0\n\n        # try each starting station\n        for i in range(n):\n\n            # Question guarantees solution to be unique, so:\n            # you don't need to try every starting point individually.\n            # As you iterate, you maintain a running tank balance.\n            # You never actually traverse every “branch”, but the greedy \n            # reset logic ensures the feasible branch is picked.\n\n            # update tank balance\n            tank += gas[i] - cost[i]\n\n            # reset start if tank is negative\n            # try next start candidate\n            if tank < 0:\n                tank = 0\n                start = i + 1\n\n        # Result -> guaranteed unique if feasible\n\n        # overall: time complexity \n        # overall: space complexity\n        return start",
        "questionNumber": 134,
        "solutionLink": "/Notes/greedy#solution-1-greedy---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy",
        "type": "greedy",
        "application": "greedy",
        "code": "def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        \n        # Note:\n        # Greedy with HashMap\n        # total cards must be divisible by groupSize\n        # sort cards\n        # group cards from low to high\n        # for each group start, grab all cards needed in group\n        # Result -> return True if all groups formed\n\n        n = len(hand)\n\n        # total cards must be divisible by groupSize\n        if n % groupSize != 0:\n            return False\n\n        # frequency of each card\n        count = Counter(hand)\n\n        # process cards in ascending order\n        for runStartCard in sorted(count):\n\n            # attempt to form group starting at card\n            while count[runStartCard] > 0:\n\n                # attempt to grab all cards for current run starting from card\n                for nextCard in range(runStartCard, runStartCard + groupSize):\n\n                    # no run is possible \n                    if count[nextCard] == 0:\n                        return False\n\n                    # decrease count\n                    count[nextCard] -= 1\n\n        # overall: time complexity \n        # overall: space complexity\n        return True",
        "questionNumber": 846,
        "solutionLink": "/Notes/greedy#solution-1-greedy---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 2,
        "name": "Greedy Heap",
        "type": "greedy",
        "application": "greedy",
        "code": "def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        # Note:\n        # Greedy using min heap and frequency map\n        # 0. Direct Boundary -> total cards must be divisible by groupSize\n        # 1. Process root -> build frequency map and min-heap of unique cards\n        # 2. Build From Previous -> repeatedly form groups starting from smallest card\n        # 3. Explore Choices -> check consecutive cards and update frequencies\n        # Result -> return True if all groups can be formed\n\n        n = len(hand)\n\n        # check if total cards can be divided into complete groups\n        if n % groupSize != 0:\n            return False\n\n        # frequency map of cards\n        counter = {}\n        for h in hand:\n            counter[h] = 1 + counter.get(h, 0)\n\n        # min heap of unique cards\n        heap = list(counter.keys())\n        heapq.heapify(heap)\n\n        # repeatedly form groups\n        while heap:\n\n            first = heap[0]  # smallest available card\n\n            # try to form a consecutive run starting from first\n            for h in range(first, first + groupSize):\n\n                # cannot form run if card missing\n                if h not in counter:\n                    return False\n\n                # decrement frequency\n                counter[h] -= 1\n\n                # remove from heap if no cards left\n                if counter[h] == 0:\n\n                    # ensure heap order is maintained\n                    if h != heap[0]:\n                        return False\n                    heapq.heappop(heap)\n\n        # all runs successfully formed\n\n        # overall: time complexity\n        # overall: space complexity\n        return True",
        "questionNumber": 846,
        "solutionLink": "/Notes/greedy#solution-2-greedy-heap---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy",
        "type": "greedy",
        "application": "greedy",
        "code": "def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n\n        # Note:\n        # Greedy validation\n\n        # instead of simulating all operations, you just need to \n        # ensure that for each coordinate of the target, there is at least \n        # one triplet that contributes the required value without exceeding it.\n\n        # grab target values\n        x, y, z = target\n\n        # coverage of each target index\n        good = [False, False, False]\n\n        for a, b, c in triplets:\n\n            # skip if triplet exceeds target in any dimension as \n            # merging triplet would overshoot the target since we use max()\n            if a > x or b > y or c > z:\n                continue\n\n            # mark contribution toward target dimensions\n            if a == x:\n                good[0] = True\n            if b == y:\n                good[1] = True\n            if c == z:\n                good[2] = True\n\n            # early exit -> all dimensions matched\n            if all(good):\n                return True\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return all(good)",
        "questionNumber": 1899,
        "solutionLink": "/Notes/greedy#solution-1-greedy---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy",
        "type": "greedy",
        "application": "greedy",
        "code": "def partitionLabels(self, s: str) -> List[int]:\n\n        # Note:\n        # Greedy partitioning\n        # 0. Direct Length -> empty string boundary covered implicitly\n        # 1. Precompute last occurrence of each character\n        # 2. Process root -> scan through string with two pointers\n        # 3. Expand window -> current partition must at least reach the furthest last occurrence seen so far\n        # 4. Build Partition -> when current index == window end, cut partition\n        # 5. Result -> return lengths of all partitions\n\n        # effectively gives the last occurrence of each character in the string,\n        # as last occurrence of char will overwrite index previous \n        last_index = {char: i for i, char in enumerate(s)}\n\n        partitions = []\n\n        # starting index of current partition\n        start = 0 \n\n        # Furthest index that the current partition must reach to \n        # include all characters seen so far\n        # Thus, when the iteration index i reaches end, it means the \n        # current partition contains all occurrences of the characters seen \n        # in this window, so you can \"cut\" the partition:\n        end = 0\n\n        # iterate left to right\n        for i, char in enumerate(s):\n\n            # As we go left to right, if a character appears multiple times, \n            # the dictionary keeps updating its value to the latest index\n\n            # ensures the current partition extends at least until the \n            # last occurrence of every character seen so far.\n            end = max(end, last_index[char])\n\n            # reached the last occurrence of every character seen so far,\n            # safe to cut\n            if i == end:\n                partitions.append(end - start + 1)\n                start = i + 1\n\n        # overall: time complexity\n        # overall: space complexity\n        return partitions",
        "questionNumber": 763,
        "solutionLink": "/Notes/greedy#solution-1-greedy---greedygreedy",
        "blog": "Greedy"
      },
      {
        "number": 1,
        "name": "Greedy",
        "type": "greedy",
        "application": "greedy",
        "code": "def checkValidString(self, s: str) -> bool:\n        # Note:\n        # Greedy balance with range tracking\n        # empty string is valid (covered implicitly)\n        # maintain lower and upper bound of open '(' count\n        # Bounds:\n        #    '(' increases both lower and upper\n        #    ')' decreases both (but lower cannot go below 0)\n        #    '*' can be '(', ')' or empty\n        #         -> lower decreases by 1 (min 0), upper increases by 1\n        # if upper < 0 at any point, invalid\n        # Result -> valid if lower == 0 at the end\n\n        # parenthesis count\n        lower = 0 \n        upper = 0\n\n        # iterate\n        for char in s:\n\n            # '(' increases both lower and upper\n            if char == \"(\":\n                lower += 1\n                upper += 1\n\n            # ')' decreases both (but lower cannot go below 0)\n            elif char == \")\":\n                lower = max(lower - 1, 0)\n                upper -= 1\n\n            # '*' can be '(', ')' or empty\n            # lower decreases by 1 (min 0), upper increases by 1\n            else:\n                lower = max(lower - 1, 0)  # treat as ')'\n                upper += 1                 # treat as '('\n\n            # if upper < 0 at any point, invalid\n            if upper < 0:\n                return False\n\n        # lower == 0 means all opens can be matched\n\n        # overall: time complexity\n        # overall: space complexity\n        return lower == 0",
        "questionNumber": 678,
        "solutionLink": "/Notes/greedy#solution-1-greedy---greedygreedy",
        "blog": "Greedy"
      }
    ]
  },
  "intervals": {
    "intervals": [
      {
        "number": 1,
        "name": "Greedy Merge",
        "type": "intervals",
        "application": "intervals",
        "code": "def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \n        # Note:\n        # Iterate over all intervals:\n        #   1. Interval ends before newInterval starts -> add to list\n        #   2. Interval overlaps -> merge into newInterval, then add\n        #   3. Interval starts after newInterval ends -> add to list\n        # Result -> merged list of intervals\n\n        n = len(intervals)\n\n        res = []\n\n        # to create merged interval\n        start = newInterval[0]\n        end = newInterval[1]\n\n        i = 0\n\n        # 1. Interval ends before newInterval starts -> add to list\n        while i < n and intervals[i][1] < start:\n            res.append(intervals[i])\n            i += 1\n\n        # 2. Interval overlaps -> merge into newInterval, then add\n        while i < n and intervals[i][0] <= end:\n\n            # update start and end of merged interval\n            start = min(start, intervals[i][0])\n            end = max(end, intervals[i][1])\n            i += 1\n\n        # Append merged interval\n        res.append([start, end])\n\n        # 3. Interval starts after newInterval ends -> add to list\n        while i < n:\n            res.append(intervals[i])\n            i += 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 57,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-merge---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 1,
        "name": "Greedy Sort Merge",
        "type": "intervals",
        "application": "intervals",
        "code": "def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \n        # Note:\n        # Greedy / Sorting approach\n        # 1. Process root -> sort intervals by start time\n        # 2. Build -> iterate through sorted intervals, merging overlapping ones\n        # 3. Explore Choices -> if current interval overlaps previous, merge; else, append\n        # 4. Result -> list of merged, non-overlapping intervals\n\n        # Empty check\n        if not intervals:\n            return []\n\n        # Sort intervals by start time\n        intervals.sort(key=lambda x: x[0])\n\n        # Initialize with first interval\n        merged = [intervals[0]]\n\n        # Iterate over all intervals\n        for i in range(1, len(intervals)):\n\n            # curr interval\n            current = intervals[i]\n\n            # rightmost interval\n            last_merged = merged[-1]\n\n            # if intervals overlap, merge\n            if current[0] <= last_merged[1]:\n                last_merged[1] = max(last_merged[1], current[1])\n\n            # no overlap, append interval to list\n            else:\n                merged.append(current)\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return merged",
        "questionNumber": 56,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-sort-merge---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 2,
        "name": "Greedy Heap Merge",
        "type": "intervals",
        "application": "intervals",
        "code": "def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \n        # Note:\n        # Greedy / Heap approach\n        # 1. Push all intervals into a min-heap (ordered by start)\n        # 2. Pop intervals one by one\n        # 3. Interval does not overlap with end of array, append\n        # 4. Interval overlaps with end of array, merge \n        # Result -> List of merged intervals\n\n        # Empty check\n        if not intervals:\n            return []\n\n        # 1. Push all intervals into a min-heap (ordered by start)\n        heap = [(s, e) for s, e in intervals]\n        heapq.heapify(heap)\n\n        merged = []\n\n        # 2. Pop intervals one by one\n        while heap:\n            start, end = heapq.heappop(heap)\n\n            # 3. Interval does not overlap with end of array, append\n            if not merged or merged[-1][1] < start:\n                merged.append([start, end])\n\n            # 4. Interval overlaps with end of array, merge \n            else:\n                merged[-1][1] = max(merged[-1][1], end)\n\n        # overall: time complexity O(n log n) (heapify + n pops)\n        # overall: space complexity O(n) for merged list\n        return merged",
        "questionNumber": 56,
        "solutionLink": "/Notes/leetcode-intervals#solution-2-greedy-heap-merge---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 1,
        "name": "Greedy Sort By End",
        "type": "intervals",
        "application": "intervals",
        "code": "def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        \n        # Note:\n        # Greedy / Sorting approach\n        # 0. Empty or single interval: no removals needed\n        # 1. Sort intervals by end time\n        # 2. Track end of last kept interval\n        # 3. Iterate through intervals\n        # 4. If current interval overlaps last, remove it\n        # 5. If no overlap, update end to end of new interval\n        # Result -> count of removed intervals\n\n        # Empty check\n        if not intervals:\n            return 0\n\n        # Sort intervals by end time (earliest finishing first)\n        intervals.sort(key=lambda x: x[1])\n\n        # Track end of first interval\n        end = intervals[0][1]\n        \n        removals = 0\n\n        # Iterate over intervals\n        for i in range(1, len(intervals)):\n\n            # curr interval\n            start_i, end_i = intervals[i]\n\n            # Interval overlaps -> remove\n            if start_i < end:\n                removals += 1\n\n            # No overlap -> update end to current interval end\n            else:\n                end = end_i\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return removals",
        "questionNumber": 435,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-sort-by-end---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 2,
        "name": "Greedy Sort By Start",
        "type": "intervals",
        "application": "intervals",
        "code": "def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        \n        # Note:\n        # Greedy / Sorting approach\n        # 0. Empty or single interval: no removals needed\n        # 1. Sort intervals by start time\n        # 2. Track end of last kept interval\n        # 3. Iterate through intervals\n        # 4. Overlap with last, keep the interval with smaller end\n        # 5. No overlap, update end to end of new interval\n        # Result -> count of removed intervals\n\n        # sort\n        intervals.sort()\n        \n        res = 0\n\n        # end of first interval\n        prevEnd = intervals[0][1]\n\n        # Iterate over intervals\n        for start, end in intervals[1:]:\n\n            # no overlap -> update prevEnd\n            if start >= prevEnd:\n                prevEnd = end\n\n            # overlap -> remove one interval, keep the one with smaller end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n\n        # overall: time complexity\n        # overall: space complexity \n        return res",
        "questionNumber": 435,
        "solutionLink": "/Notes/leetcode-intervals#solution-2-greedy-sort-by-start---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 1,
        "name": "Greedy Sort By Start",
        "type": "intervals",
        "application": "intervals",
        "code": "def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        \n        # Note:\n        # 1. Sort intervals by start time\n        # 2. Iterate through sorted intervals\n        # 3. Curr meeting starts before previous -> conflict\n        # Result -> Check if conflict exists\n        \n        # Empty Check\n        if not intervals:\n            return True\n\n        # Sort intervals by start time\n        intervals.sort(key=lambda x: x.start)\n\n        # Iterate through sorted intervals\n        for i in range(1, len(intervals)):\n\n            # Curr meeting starts before previous -> conflict\n            if intervals[i].start < intervals[i-1].end:\n                return False\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return True",
        "questionNumber": 252,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-sort-by-start---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 1,
        "name": "Greedy MinHeap",
        "type": "intervals",
        "application": "intervals",
        "code": "def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        \n        # Note:\n        # Greedy Min-Heap\n        # 1. Sort intervals by start time\n        # 2. MinHeap to track meeting end times\n        # 3. Iterate over intervals:\n        #    Curr starts after earliest ending -> reuse room (pop heap)\n        #    Curr starts before earliest ending -> new room needed, push curr end time to heap\n        # Result -> size of heap at end = min rooms required\n\n        # Empty Check\n        if not intervals:\n            return 0\n\n        # Sort intervals by start time\n        intervals.sort(key=lambda x: x.start)\n\n        # MinHeap to track meeting end times\n        heap = []\n\n        for interval in intervals:\n\n            # Curr starts after earliest ending -> reuse room (pop heap)\n            if heap and interval.start >= heap[0]:\n                heapq.heappop(heap)\n\n            # Curr starts before earliest ending -> new room needed, push curr end time to heap\n            heapq.heappush(heap, interval.end)\n\n        # size of heap at end = min rooms required\n        res = len(heap)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 253,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-minheap---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 1,
        "name": "Greedy MinHeap 1",
        "type": "intervals",
        "application": "intervals",
        "code": "def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        \n        # Note:\n        # Uses sorted queries with indices for mapping results.\n\n        # Note:\n        # Greedy + Min-Heap\n        # 1. Sort intervals by start\n        # 2. Sort queries with original indices\n        # 3. Iterate queries in ascending order\n        # 4. Intervals <= query -> push to heap\n        # 5. Intervals > query -> pop\n        # 6. record result\n        # Result -> top of heap is smallest interval covering query, else -1\n\n        # Sort intervals by start\n        intervals.sort(key=lambda x: x[0])\n\n        # Sort queries with original indices\n        sorted_queries = sorted([(q, i) for i, q in enumerate(queries)])\n\n        res = [-1] * len(queries)\n\n        # MinHeap: (size, end)\n        heap = []\n        \n        # pointer for intervals\n        j = 0\n\n        # Iterate queries in ascending order\n        for q_val, q_idx in sorted_queries:\n\n            # push all intervals starting <= query into heap\n            while j < len(intervals) and intervals[j][0] <= q_val:\n                start, end = intervals[j]\n                size = end - start + 1\n                heapq.heappush(heap, (size, end))\n                j += 1\n\n            # pop intervals ending before query\n            while heap and heap[0][1] < q_val:\n                heapq.heappop(heap)\n\n            # record result\n            if heap:\n                res[q_idx] = heap[0][0]\n\n        # overall: time complexity O(n log n + q log n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 1851,
        "solutionLink": "/Notes/leetcode-intervals#solution-1-greedy-minheap-1---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 2,
        "name": "Greedy MinHeap 2",
        "type": "intervals",
        "application": "intervals",
        "code": "def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        \n        # Note:\n        # Uses a defaultdict map for clarity.\n\n        # Note:\n        # Greedy + Min-Heap\n        # 0. Direct Boundary -> empty inputs handled implicitly\n        # 1. Sort intervals by start\n        # 2. Iterate queries in ascending order\n        # 3. Push intervals whose start <= query into min-heap (ordered by size)\n        # 4. Remove intervals whose end < query\n        # 5. Result -> top of heap is smallest interval covering query, else -1\n        # 6. Map results back to original query order\n\n        # Sort intervals by start\n        intervals.sort(key=lambda x: x[0])\n\n        res_map = defaultdict(int)\n        # MinHeap of (size, end)\n        min_heap = []\n        # Pointer for intervals\n        i = 0\n\n        # Iterate queries in ascending order\n        for q in sorted(queries):\n\n            # Push all intervals starting <= query into heap\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(min_heap, (r - l + 1, r))  # (size, end)\n                i += 1\n\n            # Pop intervals ending before query\n            while min_heap and min_heap[0][1] < q:\n                heapq.heappop(min_heap)\n\n            # Record result\n            res_map[q] = min_heap[0][0] if min_heap else -1\n\n        # Map results back to original query order\n        res = [res_map[q] for q in queries]\n\n        # overall: time complexity O(n log n + q log n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 1851,
        "solutionLink": "/Notes/leetcode-intervals#solution-2-greedy-minheap-2---intervalsintervals",
        "blog": "LeetCode: Intervals"
      },
      {
        "number": 3,
        "name": "Greedy MinHeap 3",
        "type": "intervals",
        "application": "intervals",
        "code": "def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        \n        # Note:\n        # Uses a hash to avoid recomputation and pushes intervals \n        # into heap lazily.\n        \n        soq = sorted(queries)\n        out = []\n        intervals.sort(key=lambda x: x[0])\n        hsh = {}\n        i=0\n        pq = []\n        for q in soq:\n            if hsh.get(q,-1) != -1:\n                continue\n            \n            while i<len(intervals) and q>=intervals[i][0]:\n                l,r = intervals[i]\n                heapq.heappush(pq,(r-l+1,r))\n                i+=1\n            \n            while pq:\n                pr,end = pq[0]\n                if q>end:\n                    heapq.heappop(pq)\n                else:\n                    hsh[q]=pr\n                    break\n\n            \n        \n        return [hsh.get(p,-1) for p in queries]",
        "questionNumber": 1851,
        "solutionLink": "/Notes/leetcode-intervals#solution-3-greedy-minheap-3---intervalsintervals",
        "blog": "LeetCode: Intervals"
      }
    ]
  },
  "bit-manipulation": {
    "bit-manipulation": [
      {
        "number": 1,
        "name": "Bit Manipulation XOR Trick",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def singleNumber(self, nums: List[int]) -> int:\n        \n        # Note:\n        # 1. num XOR num -> 0\n        # 2. num XOR 0 -> num\n        # 3. XOR is commutative and associative\n        # 4. Iterate XOR over all pairs of numbers to leave the unique number\n\n        result = 0\n\n        # Accumulative XOR to generate the unique number\n        for num in nums:\n            result ^= num\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return result",
        "questionNumber": 136,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-bit-manipulation-xor-trick---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "Basic Shift and Mask",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def hammingWeight(self, n: int) -> int:\n        \n        # Note:\n        # 1. Given a 32-bit signed integer, check all bits for set\n        # 2. Set bit check -> check lowest bit\n        # 3. Iterate -> shift binary representation by 1\n        # Result -> count of set bits of binary representation\n\n        count = 0\n\n        for _ in range(32):\n            \n            # set bit check -> validate if lowest bit is 1\n            count += n & 1 \n\n            # iterate -> shift right by 1 regardless\n            n >>= 1\n\n        # overall: time complexity O(32) = O(1)\n        # overall: space complexity O(1)\n        return count",
        "questionNumber": 191,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-basic-shift-and-mask---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 2,
        "name": "Brian Kernighan Algorithm",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def hammingWeight(self, n: int) -> int:\n        \n        # Note:\n        # 1. Iterate while some bit is set\n        # 2. Removes the lowest/rightmost set bit\n        # 3. Add to count\n        # Result -> count number of set bits\n\n        count = 0\n\n        # continues while some bit is set\n        while n:\n            \n            # clears the right most 1 and everything to the right of it\n            # n      = 101000\n            # n - 1  = 100111\n            # ----------------\n            # n&(n-1)= 100000\n\n            n &= (n - 1)\n\n            # add to set bit count\n            count += 1\n\n        # overall: time complexity O(k), k = number of set bits\n        # overall: space complexity O(1)\n        return count",
        "questionNumber": 191,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-2-brian-kernighan-algorithm---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "DP with Integer Division + Bit Shift",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def countBits(self, n: int) -> List[int]:\n        \n        # Note:\n        # 1. DP relation via bit manipulation\n        #    i >> 1 removes the least significant bit\n        #    i & 1 checks if least significant bit is set\n        # 2. Recurrence:\n        #    dp[i] = dp[i >> 1] + (i & 1)\n        # 3. Build array bottom-up from 0 to n\n\n        ans = [0] * (n + 1)\n\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return ans",
        "questionNumber": 338,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-dp-with-integer-division-bit-shift---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "Iterative Bit Manipulation",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def reverseBits(self, n: int) -> int:\n\n        # Note:\n        # 1. Given a 32-bit signed integer\n        # 2. Iterate res left by 1 and n right by 1 to continuing copying right most bit\n        # Result -> reversed n\n\n        result = 0\n\n        # Iterate over 32 bits\n        for _ in range(32):\n\n            # shift result left by 1, making space for new rightmost bit\n            result <<= 1\n\n            # copy n's rightmost bit (least significant) to res\n            result |= n & 1\n            \n            # shift n right by 1, preparing next bit for copy\n            n >>= 1\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return result",
        "questionNumber": 190,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-iterative-bit-manipulation---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "Verify Against Math Formula",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def missingNumber(self, nums: List[int]) -> int:\n        \n        # Note:\n        # Math approach\n        # 0. The sum of numbers 0 -> n is (n * (n+1)/2)\n        # 1. Sum all elements in nums\n        # 2. Missing = expected sum - actual sum\n\n        n = len(nums)\n        \n        expected_sum = n * (n + 1) // 2\n        \n        sum = 0\n        for n in nums:\n            sum += n\n\n        missing = expected_sum - sum\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return missing",
        "questionNumber": 268,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-verify-against-math-formula---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 2,
        "name": "XOR Trick",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def missingNumber(self, nums: List[int]) -> int:\n        \n        # Note:\n        # XOR approach\n        # 1. num XOR num -> 0, all paired numbers cancel out\n        # 2. Iterate over range -> num XOR index -> 0\n        # 3. Missing number -> will not XOR correctly, will remain at end\n        # Result -> missing number\n\n        n = len(nums)\n\n        missing = 0\n\n        # loop from 0 to n inclusive\n        for i in range(n + 1):\n\n            # XOR index and array value\n            if i < n:\n                missing ^= i ^ nums[i]\n\n            # i == n, just XOR the number n, avoid out of bounds index\n            else:\n                missing ^= i\n\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        return missing",
        "questionNumber": 268,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-2-xor-trick---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "Bit Manipulation",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def getSum(self, a: int, b: int) -> int:\n        \n        # -----------------------------------------\n        # a  b  '^' sum (without carry)  carry\n        # 0  0        0                    0\n        # 0  1        1                    0\n        # 1  0        1                    0\n        # 1  1        0                    1\n\n        # -----------------------------------------\n        # Note:\n        # all bits are processed in parallel, one bit at a time\n\n        # Iteration 1: sum bits 0 and 1 (rightmost two bits) \n        # a = 0110\n        # b = 0011\n        # sum_ = a ^ b = 0101\n        # carry = (a & b) << 1 = 0100  (carry from bit 1 moves to bit 2)\n\n        # Iteration 2: sum bits 2 and 2 (carry affecting bit 2)\n        # a = sum_ = 0101\n        # b = carry = 0100\n        # sum_ = a ^ b = 0001\n        # carry = (a & b) << 1 = 0100 << 1 = 1000  (carry from bit 2 moves to bit 3)\n\n        # Iteration 3: sum bits 3 and 3 (carry affecting highest bit)\n        # a = 0001\n        # b = 1000\n        # sum_ = 1001\n        # carry = (a & b) << 1 = 0000  (no more carry)\n\n        # Done, carry is 0 → final sum = 1001 (9)\n\n        # -----------------------------------------\n\n        # Note:\n        # 1. (a ^ b) -> acts as sum without carry, mask ensures all operations are restricted to 32 bits\n        # 2. (a & b) << 1 -> Carry is 1 only when both bits are 1, otherwise 0\n        # 2. carry -> Use AND (&) + left shift (<<)\n        # 3. Repeat until carry is 0 -> no value left\n        # 4. Handle negative numbers with 32-bit mask\n        # Result ->\n\n        # limit to 32 bits\n        MASK = 0xFFFFFFFF\n        maxInt = 2**31 - 1\n\n        # while carry is not 0\n        while b != 0:\n\n            # sum without carry\n            sum_ = (a ^ b) & MASK\n\n            # carry\n            carry = ((a & b) << 1) & MASK\n            \n            # update a and b\n            a, b = sum_, carry\n\n        # if a > 2^31-1, it's negative in 32-bit signed\n        res = a if a <= maxInt else ~(a ^ MASK)\n\n        # overall: time complexity O(1)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 371,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-bit-manipulation---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      },
      {
        "number": 1,
        "name": "Iterative Math Approach",
        "type": "bit-manipulation",
        "application": "bit-manipulation",
        "code": "def reverse(self, x: int) -> int:\n        \n        # -----------------------------------------\n        # Iterative process: process each digit from right to left\n\n        # Example: x = 123\n        # Iteration 1:\n        #   digit = 123 % 10 = 3\n        #   x = 123 // 10 = 12\n        #   res = 0 * 10 + 3 = 3\n        #\n        # Iteration 2:\n        #   digit = 12 % 10 = 2\n        #   x = 12 // 10 = 1\n        #   res = 3 * 10 + 2 = 32\n        #\n        # Iteration 3:\n        #   digit = 1 % 10 = 1\n        #   x = 1 // 10 = 0\n        #   res = 32 * 10 + 1 = 321\n        #\n        # Done, x == 0 → final reversed number = 321\n\n        # -----------------------------------------\n        # Note:\n        # 1. Extract digits one by one using modulo 10\n        # 2. Append to result using multiply by 10 + digit\n        # 3. Handle negative numbers\n        # 4. Check for 32-bit overflow\n        # Result -> \n\n\n        INT_MAX = 2**31 - 1 # 2147483647\n        INT_MIN = -2**31    # -2147483648\n\n        res = 0\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n\n        while x != 0:\n            digit = x % 10\n            x //= 10\n\n            # Check overflow before multiplying by 10\n            if res > (INT_MAX - digit) // 10:\n            \n                # would overflow 32-bit signed integer\n                return 0\n\n            res = res * 10 + digit\n\n        # Apply original sign\n        res1 = sign * res\n\n        # overall: time complexity O(log10(x))\n        # overall: space complexity O(1)\n        return res1",
        "questionNumber": 7,
        "solutionLink": "/Notes/leetcode-bit-manipulation#solution-1-iterative-math-approach---bit-manipulationbit-manipulation",
        "blog": "LeetCode: Bit Manipulation"
      }
    ]
  },
  "math-and-geometry": {
    "math-and-geometry": [
      {
        "number": 1,
        "name": "Layer by Layer Rotation",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def rotate(self, matrix: List[List[int]]) -> None:\n        \n        # Note:\n        # Rotate n x n matrix 90 degrees clockwise in place\n        # 1. Process the matrix layer by layer (outermost to innermost)\n        # 2. For each layer, rotate elements in four way swaps:\n        #       Top -> Right -> Bottom -> Left -> Top\n        # 3. Repeat for all layers\n        # Result -> No extra matrix allocation, in place modification\n\n        # Example (n=3, outer layer rotation):\n        # [1, 2, 3]         [7, 4, 1]\n        # [4, 5, 6]   --->  [8, 5, 2]\n        # [7, 8, 9]         [9, 6, 3]\n\n        n = len(matrix)\n\n        # There are n//2 layers\n        # Odd sized matrix -> one single center cell, inner does not rotate\n        # Even sized matrix -> no single center cell, all layers rotate\n        layers = n//2\n\n        for layer in range(layers):\n\n            # first -> start index of current ring (top-left corner)\n            first = layer\n\n            # last -> end index of current ring (bottom-right corner)\n\n            # layer 1:\n            # [ 1, 1, 1, 1, 1, 1]\n            # [ 1, 1, 1, 1, 1, 1]\n            #     f^.       l^\n            # ... \n            # ...\n            last = n - 1 - layer\n\n            # length of current ring - 1\n            # notice we only need 3 swaps as 4th swap is 1 swap of next switch\n            # [1,  2,  3,  4 ]\n            # [5,  6,  7,  8 ]\n            # [9,  10, 11, 12]\n            # [13, 14, 15, 16]\n            \n            # we only swap, 1, 2, 3, as 4 will be taken care of \n            # by the next iteration, therefore ringLen is -1 its actual length\n            # thus ring len of 4 goes to 3\n            ringLen = last - first            \n\n            # iterate -> 0 to ringLen-1 \n            for i in range(ringLen):\n\n                # left -> top\n                # bottom -> left\n                # right -> bottom\n                # saved top -> right\n\n                # save top\n                top_val = matrix[first][first + i]\n\n                # top: left right via row    || left: bottom up via column\n                matrix[first][first + i] = matrix[last - i][first]\n\n                # left: bottom up via column ||  bottom: right left via row\n                matrix[last - i][first] = matrix[last][last - i]\n\n                # bottom: right left via row ||  right: top down via column\n                matrix[last][last - i] = matrix[first + i][last]\n\n                # right: top down via column ||  top: left right via row\n                matrix[first + i][last] = top_val\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(1)",
        "questionNumber": 48,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-layer-by-layer-rotation---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Layer by Layer Spiral Traversal",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n        # Note:\n        # Traverse the matrix in clockwise spiral order using layers\n        # 1. Treat each layer as a shrinking “frame” around the matrix\n        # 2. For each layer, traverse top row, right column, bottom row, left column\n        # 3. Increment layer and repeat until all elements are processed\n\n        # Empty check\n        if not matrix or not matrix[0]:\n            return []\n\n        res = []\n\n        # boundaries\n        m, n = len(matrix), len(matrix[0])\n\n        # number of layer -> min between rows and columns\n        # There are (min(row, col) // 2) layers\n        # Odd sized matrix -> one single center cell\n        # Even sized matrix -> no single center cell\n        layers = (min(m, n) + 1) // 2\n\n        for layer in range(layers):\n\n            # boundaries of current layer\n            first_row = layer\n            first_col = layer\n\n            # inclusive via last element\n\n            # layer 1:\n            # [ 1, 1, 1, 1, 1, 1]\n            # [ 1, 1, 1, 1, 1, 1]\n            #     f^.       l^\n            # ... \n            # ...\n            last_row = m - 1 - layer\n            last_col = n - 1 - layer\n\n            # Top and Right sides always exist in every layer\n            # Bottom and left may not always exist\n\n            # Top row: left -> right\n            for col in range(first_col, last_col + 1):\n                res.append(matrix[first_row][col])\n\n            # Right column: top+1 -> bottom\n            for row in range(first_row + 1, last_row + 1):\n                res.append(matrix[row][last_col])\n\n            # Bottom row: right-1 -> left (if more than one row)\n            if last_row > first_row:\n                for col in range(last_col - 1, first_col - 1, -1):\n                    res.append(matrix[last_row][col])\n\n            # Left column: bottom-1 -> top+1 (if more than one column)\n            if last_col > first_col:\n                for row in range(last_row - 1, first_row, -1):\n                    res.append(matrix[row][first_col])\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(m*n) for output list\n        return res",
        "questionNumber": 54,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-layer-by-layer-spiral-traversal---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Brute Force O(m*n) Space",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def setZeroes(self, matrix: List[List[int]]) -> None:\n        \n        # Note:\n        # Separate iterating from writing via creating copy of matrix using O(m*n)\n        # We read over the copy while updating the original in place\n        # 1. Iterate through original matrix\n        # 2. If cell is 0, set corresponding row and column in copy to 0\n        # 3. Copy back to original matrix\n        # Result -> original matrix set correctly in place\n\n        m, n = len(matrix), len(matrix[0])\n        \n        # Create a copy\n        copy = [row[:] for row in matrix]  # O(m*n) space\n\n        for i in range(m):\n            for j in range(n):\n                if copy[i][j] == 0:\n                    # Zero entire row\n                    for col in range(n):\n                        matrix[i][col] = 0\n                    # Zero entire column\n                    for row in range(m):\n                        matrix[row][j] = 0\n\n        # overall: time complexity O(m*n*(m+n)) due to nested zeroing loops\n        # overall: space complexity O(m*n) for copy",
        "questionNumber": 73,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-brute-force-o-m-n-space---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 2,
        "name": "Using O(m+n) Space",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def setZeroes(self, matrix: List[List[int]]) -> None:\n        \n        # Note:\n        # Separate iterating from writing via creating copy of matrix using O(m+n)\n        # Use two arrays to store flags to track zero rows and zero columns\n        # 1. row_flag[m] -> True if row i should be zero\n        # 2. col_flag[n] -> True if column j should be zero\n        # 3. Iterate matrix, set flags\n        # 4. Iterate matrix again, zero out flagged rows and columns\n        # Result -> original matrix set correctly in place\n\n\n        m, n = len(matrix), len(matrix[0])\n        row_flag = [False] * m\n        col_flag = [False] * n\n\n        # Flag zero rows and columns\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row_flag[i] = True\n                    col_flag[j] = True\n\n        # Zero out flagged rows and columns in original matrix\n        for i in range(m):\n            for j in range(n):\n                if row_flag[i] or col_flag[j]:\n                    matrix[i][j] = 0\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(m+n)",
        "questionNumber": 73,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-2-using-o-m-n-space---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 3,
        "name": "Constant Space O(1)",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def setZeroes(self, matrix: List[List[int]]) -> None:\n        \n        # Note:\n        # Separate iterating from writing via creating copy of matrix using O(m+n)\n        # We use the first row and first column of the matrix itself\n        # 1. row_flag[m] -> True if row i should be zero\n        # 2. col_flag[n] -> True if column j should be zero\n        # 4. Iterate matrix again, zero out flagged rows and columns\n        # Result -> original matrix set correctly in place\n\n        # Boundaries\n        m, n = len(matrix), len(matrix[0])\n\n        # Pre check if first row has any zeros\n        first_row_zero = False\n        for j in range(n):\n            if matrix[0][j] == 0:\n                first_row_zero = True\n                break\n\n        # Pre check if first column has any zeros\n        first_col_zero = False\n        for i in range(m):\n            if matrix[i][0] == 0:\n                first_col_zero = True\n                break\n\n        # Set zero flags using first row and column\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0  # mark row\n                    matrix[0][j] = 0  # mark column\n\n        # Using zero flags, zero out rows and cols\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        # Afterwards:\n        # Zero out the first row if needed\n        if first_row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n\n        # Afterwards:\n        # Zero out the first column if needed\n        if first_col_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(1)",
        "questionNumber": 73,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-3-constant-space-o-1---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Hash Set Detection",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def isHappy(self, n: int) -> bool:\n        \n        # Note:\n        # 1. Compute sum of squares of digits repeatedly\n        # 2. Keep track of numbers seen in a hash set\n        # 3. If we see a number again, a cycle exists → not happy\n        # 4. If we reach 1, number is happy\n        # Result -> Determine if number is happy\n\n        # store numbers to detect cycles\n        seen = set()\n\n        # cycle formula\n        def next_number(num):\n            return sum(int(d) ** 2 for d in str(num))\n\n        while n != 1:\n\n            # cycle detected\n            if n in seen:\n                return False\n            seen.add(n)\n\n            # compute sum of squares of digits\n            n = next_number(n)\n\n        # reached 1 = happy number\n        res = True\n\n        # overall: time complexity O(log n) (per iteration * number of unique sums)\n        # overall: space complexity O(log n) (for hash set)\n        return res",
        "questionNumber": 202,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-hash-set-detection---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 2,
        "name": "Slow Fast Pointer",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def isHappy(self, n: int) -> bool:\n        \n        # Note:\n        # Treat sum-of-squares transformation as a linked list\n        # 2. Slow and fast pointers to detect cycle\n        # 3. If fast or fast.next reaches 1 -> happy\n        # 4. If slow == fast → cycle exists -> not happy\n        # Result -> Determine if number is happy\n\n        # cycle formula\n        def next_number(num):\n            return sum(int(d) ** 2 for d in str(num))\n\n        # set pointers\n        slow = n\n        fast = next_number(n)\n\n        # slow and fast pointer to check happy number requirements\n        while fast != 1 and slow != fast:\n            slow = next_number(slow)\n            fast = next_number(next_number(fast))\n\n        # happy number == 1\n        res = fast == 1\n\n        # overall: time complexity O(log n) (per iteration * number of iterations before cycle)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 202,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-2-slow-fast-pointer---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Hash Set Detection",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def plusOne(self, digits: List[int]) -> List[int]:\n        \n        # Note:\n        # Process digits from least significant to most significant\n        # 1. Iterate right to left in array\n        # 2. Add 1 to the last digit\n        # 3. Propagate carry if sum >= 10\n        # 4. If carry remains after the most significant digit, insert at front\n        # 5. Time complexity O(n), space O(1) extra (besides output)\n\n        n = len(digits)\n\n        # iterate from last digit to first\n        for i in range(n - 1, -1, -1):\n            \n            # add to current digit\n            digits[i] += 1\n            \n            # if no carry, finished array, else continue\n            if digits[i] < 10:\n                return digits\n\n            # if carry, set current to zero, continue\n            digits[i] = 0\n\n        # if carry remains after processing all digits\n        # prepend [1] to array\n        res = [1] + digits\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 66,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-hash-set-detection---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Recursive Fast Exponentiation",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def myPow(self, x: float, n: int) -> float:\n        \n        # Note:\n        # Math behind Fast Exponentiation:\n\n        # x^n -> even -> [x^(n/2)]^2\n        #     -> odd  -> x * (x^[(n-1)/2])^2\n\n        # Example:\n        # x^6 = (x^3)^2\n        # x^7 = x * (x^3)^2\n\n        # Now simply apply some recursion\n\n        # Note:\n        # 1. Recursively compute half power to reduce computation\n        # 2. If exponent is negative, use reciprocal: x^-n = 1 / x^n\n        # 3. Base case: n == 0 → return 1\n        # Result -> pow() calculation\n\n        if n == 0:\n            return 1.0\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n\n        half = self.myPow(x, n // 2)\n        \n        if n % 2 == 0:\n            return half * half\n        else:\n            return half * half * x\n\n        # overall: time complexity O(log n)\n        # overall: space complexity O(log n) due to recursion stack",
        "questionNumber": 50,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-recursive-fast-exponentiation---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 2,
        "name": "Iterative Fast Binary Exponentiation",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def myPow(self, x: float, n: int) -> float:\n        \n        # Note:\n        # Binary Exponentiation uses the binary representation of n\n        # n = 13 -> 1101\n\n        # Start with result = 1 and current_product = x. \n        # Then for each bit from LSB to MSB:\n\n        # If bit is 1 → multiply result by current_product\n        # Square current_product each step\n        # Shift to next bit\n\n        # Note:\n        # 1. Use binary exponentiation iteratively\n        # 2. Convert negative exponent to positive and invert at end\n        # 3. Multiply result by x whenever the current bit of n is 1\n        # 4. Shift exponent right each iteration\n\n        N = n\n        if N < 0:\n            x = 1 / x\n            N = -N\n\n        result = 1.0\n        current_product = x\n\n        while N > 0:\n            if N % 2 == 1:  # current bit is 1\n                result *= current_product\n            current_product *= current_product  # square for next bit\n            N //= 2\n\n        # overall: time complexity O(log n)\n        # overall: space complexity O(1)\n        return result",
        "questionNumber": 50,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-2-iterative-fast-binary-exponentiation---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Simulate Grade School Multiplication",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "def multiply(self, num1: str, num2: str) -> str:\n        \n        # Note:\n        # 1. Multiply each digit of num1 by each digit of num2\n        # 2. Store intermediate sums in an array of length len(num1) + len(num2)\n        # 3. Handle carry for each position\n        # 4. Convert array to string, skipping leading zeros\n\n        # Zero Check\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n\n        # max number of digits the product can have when multiplying two integers\n        pos = [0] * (m + n)\n\n        # multiply digits from right to left\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n\n                # i -> index of digit in num1 \n                # j -> index of digit in num2\n\n                # single digit multiplication\n                mul = int(num1[i]) * int(num2[j])\n\n                # stores the carry that will affect the next higher digit\n                p1 = i + j\n\n                # stores the ones place for this multiplication\n                p2 = i + j + 1\n\n                # pos[p2] holds previous carry that contributes to new multiplication\n                total = mul + pos[p2]\n\n                # new current digit\n                pos[p2] = total % 10\n\n                # new carry\n                pos[p1] += total // 10\n\n        # convert to string, skipping leading zeros\n        result = []\n        \n        # to skip leading zeros in final result\n        for p in pos:\n\n            # if result == empty, ensures we haven't added any non-zero digits yet\n            # which ensures we only skip leading zeros, not inner zeros\n            if not result and p == 0:\n                continue\n\n            # append inner zeros or values\n            result.append(str(p))\n\n        # more efficient of concatenating strings\n        res = \"\".join(result)\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(m+n)\n        return res",
        "questionNumber": 43,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-simulate-grade-school-multiplication---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      },
      {
        "number": 1,
        "name": "Hash Map Counting",
        "type": "math-and-geometry",
        "application": "math-and-geometry",
        "code": "class DetectSquares:\n\n        def __init__(self):\n\n            # Note:\n            # counts[x][y] -> tracks how many times point (x,y) has been added\n            # This allows O(1) insertion and O(k) count queries\n            self.counts = defaultdict(lambda: defaultdict(int))\n\n        def add(self, point: List[int]) -> None:\n\n            # Increment point count\n            x_col, y_row = point\n            self.counts[x_col][y_row] += 1\n\n        def count(self, point: List[int]) -> int:\n            x_col, y_row = point\n            total = 0\n\n            # Look for all points in same column x, but with different y\n            for curr_y_row, count_at_point in self.counts[x_col].items():\n                if curr_y_row == y_row:  # skip the query point itself\n                    continue\n\n                # distance = side length\n                d = curr_y_row - y_row\n\n                # Left square\n                left_x = x_col - d\n                count_left_top = self.counts.get(left_x, {}).get(y_row, 0)\n                count_left_bottom = self.counts.get(left_x, {}).get(curr_y_row, 0)\n                total += count_at_point * count_left_top * count_left_bottom\n\n                # Right square\n                right_x = x_col + d\n                count_right_top = self.counts.get(right_x, {}).get(y_row, 0)\n                count_right_bottom = self.counts.get(right_x, {}).get(curr_y_row, 0)\n                total += count_at_point * count_right_top * count_right_bottom\n\n            return total\n\n        # overall: add O(1), count O(k) where k = # points sharing same x\n        # overall: space complexity O(n) for n points stored",
        "questionNumber": 2013,
        "solutionLink": "/Notes/leetcode-math-and-geometry#solution-1-hash-map-counting---math-and-geometrymath-and-geometry",
        "blog": "LeetCode: Math and Geometry"
      }
    ]
  },
  "advanced-graphs": {
    "advanced-graphs": [
      {
        "number": 1,
        "name": "Dijkstras Algorithm via BFS + MinHeap",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        \n        # Note:\n        # Why Dijkstras algorithm\n        # Dijkstras algorithm is designed to find the shortest path \n        # from a single source to all nodes in a weighted graph \n        # with non-negative edge weights, which fits this case\n\n        # Directed Edge -> signal path with weight w (time)\n        # Want minimum time for signal at k to reach all nodes\n        # If some node is unreachable, we return -1\n\n        # Note:\n        # 1. Build adjacency list: graph[src] = list of (dest, time)\n        # 2. MinHeap to always expand node with smallest current time\n        # 3. Track shortest times to each node in a dictionary\n        # 4. If all nodes are reached, return max shortest time\n        # 5. If some node is unreachable, return -1\n        # Result -> min time if all nodes are reachable\n        \n        # Build adjacency list\n        graph = defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n        \n        # MinHeap: (time_to_reach_node, node)\n        heap = [(0, k)]\n        \n        # Track seen nodes with shortest known times\n        shortest_time = {}\n        \n        while heap:\n\n            # next smallest time node\n            time, node = heapq.heappop(heap)\n            \n            # already visited neighbor with shorter time, skip\n            if node in shortest_time:\n                continue\n            \n            # Record shortest time to reach node\n            shortest_time[node] = time\n            \n            # Explore Choices -> push adjacent neighbors onto minHeap\n            for neighbor, wt in graph[node]:\n                if neighbor not in shortest_time:\n                    heapq.heappush(heap, (time + wt, neighbor))\n        \n        # Check if all nodes were reached\n        if len(shortest_time) != n:\n            return -1\n        \n        # max time among all shortest times -> min time required\n        res = max(shortest_time.values())\n\n        # overall: time complexity O(E log N) for min-heap operations\n        # overall: space complexity O(N + E) for graph and shortest_time     \n        return res",
        "questionNumber": 743,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-dijkstras-algorithm-via-bfs-minheap---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Hierholzers Algorithm Eulerian Path via DFS + MinHeap for Lexical Order",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        \n        # Note:\n        # Why Hierholzers Algorithm?\n        # Hierholzers algorithm is designed to find an Eulerian path or \n        # circuit in a graph a path that uses every edge exactly once.\n        \n        # In our case:\n        # Flight ticket -> edge\n        # Must use all tickets once -> Eulerian path\n        # Start -> \"JFK\"\n\n        # Note:\n        # 1. Build graph: graph[src] = MinHeap of destinations\n        #    (MinHeap ensures lexical order when multiple choices exist)\n        # 2. Use DFS to traverse graph:\n        #      Always choose the smallest lexical destination first\n        #      Remove tickets (edges) as we use them\n        # 3. Append airports to itinerary in post-order (after visiting neighbors/edges)\n        # 4. Reverse itinerary at the end to get correct order starting at JFK\n        # Result -> shortest path through all airports starting at jfk\n\n        # Build adjacency list with MinHeaps\n        graph = defaultdict(list)\n        \n        # Build MinHeap for each source airport\n        for src, dest in tickets:\n            heapq.heappush(graph[src], dest)\n        \n        # itinerary build in reverse (post order)\n        itinerary = []\n\n        def dfs(airport):\n\n            # Explore all neighbors -> left1, left2.. \n            while graph[airport]:\n                next_dest = heapq.heappop(graph[airport])\n                dfs(next_dest)\n            \n            # post order append\n            itinerary.append(airport)\n\n        # Start Eulerian Oath via DFS + MinHeap from \"JFK\"\n        dfs(\"JFK\")\n        \n        # Reverse to get correct order\n        res = itinerary[::-1]\n\n        # overall: time complexity O(E log E) due to heap operations\n        # overall: space complexity O(E + V) for graph + recursion stack\n        return res",
        "questionNumber": 332,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-hierholzers-algorithm-eulerian-path-via-dfs-minheap-for-lexical-order---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Kruskals Algorithm + Union-Find",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        # path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n\n        # already connected\n        if xr == yr:\n            return False\n        # union by rank\n        if self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: list[list[int]]) -> int:\n        \n        # Why Kruskals Algorithm?\n        # Edge Based\n        # Good when we can easily compute all pairwise edges\n        # Add edges in increasing order + avoiding cycles with Union Find\n        # Stop when MST has n-1 edges, ensures min total cost \n\n        # Note:\n        # 1. Compute all pairwise edges with Manhattan distance\n        # 2. Sort edges by cost\n        # 3. Use Union-Find to connect points without forming cycles\n        # 4. Sum the costs of edges added to MST\n\n        n = len(points)\n        edges = []\n\n        # Build all edges (Manhattan distance)\n        for i in range(n):\n            for j in range(i + 1, n):\n                xi, yi = points[i]\n                xj, yj = points[j]\n                cost = abs(xi - xj) + abs(yi - yj)\n                edges.append((cost, i, j))\n\n        # Sort edges by cost\n        edges.sort()\n\n        uf = UnionFind(n)\n        total_cost = 0\n        edges_used = 0\n\n        # Kruskal’s main loop\n        for cost, i, j in edges:\n            if uf.union(i, j):\n                total_cost += cost\n                edges_used += 1\n\n                # MST complete\n                if edges_used == n - 1:\n                    break\n\n\n        # overall: time complexity O(n^2 log n) for edge sorting\n        # overall: space complexity O(n^2) for edges\n        return total_cost",
        "questionNumber": 1584,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-kruskals-algorithm-union-find---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 2,
        "name": "Prim’s Algorithm + MinHeap",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        # Why Prims Algorithm?\n        # Node Based\n        # Grow MST from starting point using smallest connecting edge\n        # Efficient when checking edges dynamically with a MinHeap\n        # Stops when all points are connected, ensures min total cost\n\n        n = len(points)\n\n        # shortest edge to MST\n        min_dist = [float('inf')] * n\n        visited = [False] * n\n        min_dist[0] = 0\n\n        # (cost, point)\n        heap = [(0,0)]\n        total_cost = 0\n        \n\n        while heap:\n            cost, u = heapq.heappop(heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += cost\n\n            # Explore all possible new edges\n            for v in range(n):\n                if not visited[v]:\n                    dist = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])\n                    if dist < min_dist[v]:\n                        min_dist[v] = dist\n                        heapq.heappush(heap,(dist, v))\n\n        # overall: time complexity O(n^2 log n)\n        # overall: space complexity O(n)\n        return total_cost",
        "questionNumber": 1584,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-2-prim-s-algorithm-minheap---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Dijkstra + MinHeap",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        \n        # Why Dijkstras + MinHeap?\n        # Dijkstras finds shortest path from a source node to all other nodes\n        # in a weighted graph with non-negative edge weights, our case\n        \n        # Cell -> Node\n        # Effort (absolute height difference) -> Weight\n        # MinHeap ensures we always explore next cell with minimal effort first\n        # Guarantees the minimum maximum effort path to the bottom-right cell.\n        \n        # Note:\n        # 1. Use MinHeap to track cells by minimal effort seen so far\n        # 2. Effort to reach a cell -> max(absolute difference along path)\n        # 3. Track visited/effort for each cell\n        # 4. Pop cell with lowest effort from heap, update neighbors\n        # 5. Stop when reaching bottom-right cell\n        # Result -> path of lowest effort\n\n        rows, cols = len(heights), len(heights[0])\n        efforts = [[float('inf')] * cols for _ in range(rows)]\n        efforts[0][0] = 0\n\n        # (effort, row, col)\n        min_heap = [(0, 0, 0)]\n        directions = [(0,1),(1,0),(-1,0),(0,-1)]\n\n        while min_heap:\n            curr_effort, r, c = heappop(min_heap)\n\n            # Reached target -> bottom right\n            if r == rows - 1 and c == cols - 1:\n                return curr_effort\n\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    next_effort = max(curr_effort, abs(heights[r][c] - heights[nr][nc]))\n                    if next_effort < efforts[nr][nc]:\n                        efforts[nr][nc] = next_effort\n                        heappush(min_heap, (next_effort, nr, nc))\n\n        # default, though problem guarantees a path exists\n    \n        # overall: time complexity O(R*C*log(R*C)) due to heap operations\n        # overall: space complexity O(R*C) for effort tracking and heap\n        return 0",
        "questionNumber": 1631,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-dijkstra-minheap---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Dijkstra + MinHeap",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def swimInWater(self, grid: List[List[int]]) -> int:\n        \n        # Why Dijkstras + MinHeap? \n        # Cell -> Node\n        # Weight -> determined by max elevation along path so far\n        # Dijkstras algo finds path from source (0,0) to target (n-1,n-1)\n        # that minimizes the max elevation\n        # MinHeap ensures we always expand the path with lowest current\n        # maximum elevation\n        # Guarantees minimum time t\n        # Result -> path of minimum height\n        \n        # Note:\n        # 1. We want min time t to reach (n-1, n-1)\n        # 2. At any step, t = max elevation along the path\n        # 3. Use min-heap to always expand the path with lowest t so far\n        # 4. Track visited cells to avoid revisiting\n\n        n = len(grid)\n        visited = [[False] * n for _ in range(n)]\n        \n        # (time_so_far, row, col)\n        min_heap = [(grid[0][0], 0, 0)]\n        directions = [(0,1),(1,0),(-1,0),(0,-1)]\n\n        while min_heap:\n            t, r, c = heappop(min_heap)\n            if visited[r][c]:\n                continue\n            visited[r][c] = True\n\n            # Reached target cell\n            if r == n - 1 and c == n - 1:\n                return t\n\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]:\n\n                    # time to reach neighbor = max(current path t, neighbor elevation)                    \n                    heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n\n        # default, problem guarantees a path exists\n        \n        # overall: time complexity O(n^2 * log(n^2)) due to heap operations\n        # overall: space complexity O(n^2) for heap and visited\n        return 0",
        "questionNumber": 778,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-dijkstra-minheap---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Topological Sort using BFS",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def foreignDictionary(self, words: List[str]) -> str:\n        \n        # Why Topological Sort?\n        # Each character -> node in directed graph\n        # Edge (c1 -> c2) means -> c1 comes before c2 in alien dictionary\n        # Topological sort -> Finding a valid order of characters\n        # Finding a valid order of characters is equivalent to performing\n        # a topological sort on this graph.\n        # If cycle exists, no valid order exists\n\n        # Note:\n        # 1. Build a graph of character dependencies from adjacent words\n        # 2. Count in-degrees for each character\n        # 3. Use BFS to perform topological sort\n        # 4. Detect cycles: if result length != total unique chars, return \"\"\n\n        # Initialize graph and in-degree counts\n        graph = defaultdict(set)  # char -> set of chars that come after it\n        in_degree = {c: 0 for word in words for c in word}\n\n        # Build graph edges based on adjacent words\n        for i in range(len(words) - 1):\n            word1, word2 = words[i], words[i+1]\n            min_len = min(len(word1), len(word2))\n            found_diff = False\n\n            for j in range(min_len):\n                c1, c2 = word1[j], word2[j]\n                if c1 != c2:\n                    if c2 not in graph[c1]:\n                        graph[c1].add(c2)\n                        in_degree[c2] += 1\n                    found_diff = True\n                    break\n\n            # Edge case: prefix situation invalid, e.g., \"abc\" before \"ab\"\n            if not found_diff and len(word1) > len(word2):\n                return \"\"\n\n        # BFS topological sort\n        queue = deque([c for c in in_degree if in_degree[c] == 0])\n        result = []\n\n        while queue:\n            c = queue.popleft()\n            result.append(c)\n            for nei in graph[c]:\n                in_degree[nei] -= 1\n                if in_degree[nei] == 0:\n                    queue.append(nei)\n\n        # Check for cycle\n        if len(result) != len(in_degree):\n            return \"\"\n\n        res = \"\".join(result)\n\n\n        # overall: time complexity O(C + W*L)\n        # C = number of unique characters, W = number of words, L = average word length\n        # overall: space complexity O(C + W*L) for graph and in-degree\n        return res",
        "questionNumber": 269,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-topological-sort-using-bfs---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      },
      {
        "number": 1,
        "name": "Modified Dijkstra via BFS + MinHeap",
        "type": "advanced-graphs",
        "application": "advanced-graphs",
        "code": "def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        \n        # Modified Disjkstras?\n        # Modified for graphs with 'stops' constraint\n        # Each node in heap is (stops_so_far, current_node, cost_so_far)\n        # MinHeap guarantees we expand path with lowest cost so far\n        # Only continue paths that respect the stops limit (<= k)\n        \n        # Build adjacency list\n        adj={i:[] for i in range(n)}\n        for u,v,w in flights:\n            adj[u].append((v,w))\n\n        # Initialize distance array and min-heap\n        dist=[float('inf')]*n\n        dist[src]=0\n        q=[]\n        \n        # (stops_so_far, current_node, cost_so_far)\n        heapq.heappush(q,(0, src, 0))\n\n        # Process heap\n        while q:\n            stops,node,wei=heapq.heappop(q)\n\n            # Skip if stops exceed limit\n            if stops>k:\n                continue\n\n            # Explore neighbors \n            for nei,w in adj[node]:\n                next_cost = cost + w\n\n                # Only push if we improve distance\n                if dist[nei]>next_cost and stops<=k:\n                    dist[nei]=next_cost\n                    heapq.heappush(q,((stops+1,nei,next_cost)))\n        print(dist)\n\n        # Check if destination reachable\n        if dist[dst]==float('inf'):\n            return -1\n\n        res = dist[dst]\n\n        # overall: time complexity O(E log N) in practice, E = # of edges\n        # overall: space complexity O(N + E) for adjacency list and heap    \n        return res",
        "questionNumber": 787,
        "solutionLink": "/Notes/leetcode-advanced-graphs#solution-1-modified-dijkstra-via-bfs-minheap---advanced-graphsadvanced-graphs",
        "blog": "LeetCode: Advanced Graphs"
      }
    ]
  },
  "2d-dynamic-programming": {
    "2d-dynamic-programming": [
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def uniquePaths(self, m: int, n: int) -> int:\n        \n        # Note:\n        # Bottom Up Tabulation\n        # 1. Initialize Array -> dp[i][j] = number of ways to reach cell (i,j)\n        # 2. Base Set Up -> first row and first column = 1 (only one way)\n        # 3. Explore -> fill dp for all cells from (1,1) to (m-1,n-1)\n        # 4. Build -> dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # Result: dp[m-1][n-1] = unique paths to bottom-right corner\n\n        # Initialize Array -> m x n grid\n        dp = [[0] * n for _ in range(m)]\n\n        # Base Set Up -> first row and first col = 1\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n\n        # Process -> from (1,1) to (m-1,n-1)\n        for i in range(1, m):\n            for j in range(1, n):\n                # Explore Choices -> from top or left\n                top = dp[i-1][j]\n                left = dp[i][j-1]\n\n                # Build -> total ways\n                dp[i][j] = top + left\n\n        # Result -> bottom-right cell\n        res = dp[m-1][n-1]\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(m*n)\n        return res",
        "questionNumber": 62,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def uniquePaths(self, m: int, n: int) -> int:\n        \n        # Note:\n        # Bottom Up Variables (row compression)\n        # 1. Initialize Row -> dp[j] = number of ways to reach column j in current row\n        # 2. Base Set Up -> first row = all 1's\n        # 3. Explore -> update row from left to right\n        # 4. Build -> dp[j] = dp[j] + dp[j-1]\n        # Result: dp[n-1] = unique paths to bottom-right corner\n\n        # Initialize Row -> all 1's for first row\n        dp = [1] * n\n\n        # Process -> rows 1 to m-1\n        for i in range(1, m):\n            for j in range(1, n):\n                # Explore + Build -> update in-place\n                dp[j] = dp[j] + dp[j-1]\n\n        # Result -> bottom-right cell\n        res = dp[n-1]\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 62,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-variables---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        # Note:\n        # Bottom Up Tabulation\n        # 1. Initialize 2D Array -> dp[i][j] = LCS length for first i chars of text1, first j chars of text2\n        # 2. Base Set Up -> dp[0][*] = 0, dp[*][0] = 0 (empty string has LCS = 0)\n        # 3. Explore -> iterate i=1..m, j=1..n\n        # 4. Explore Choices:\n        #       if text1[i-1] == text2[j-1]: dp[i][j] = 1 + dp[i-1][j-1]\n        #       else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # 5. Build -> fill dp row by row\n        # Result: dp[m][n] = LCS length for full strings\n\n        m, n = len(text1), len(text2)\n\n        # Initialize Array -> size (m+1) x (n+1) for base row/col\n        dp = [[0] * (n+1) for _ in range(m+1)]\n\n        # Process -> iterate through chars of both strings\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n\n                # Explore Choices\n                if text1[i-1] == text2[j-1]:\n                    # Characters match -> extend subsequence\n                    dp[i][j] = 1 + dp[i-1][j-1]\n                else:\n                    # Skip one from either string\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n        # Result -> LCS length for full strings\n        res = dp[m][n]\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(m*n)\n        return res",
        "questionNumber": 1143,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        # Note:\n        # Bottom Up Variables (row compression)\n        # 1. Only previous row is needed at any time\n        # 2. Initialize two rows -> prev, curr\n        # 3. Explore -> for each i, build row j=1..n\n        # 4. Explore Choices:\n        #       if text1[i-1] == text2[j-1]: curr[j] = 1 + prev[j-1]\n        #       else: curr[j] = max(prev[j], curr[j-1])\n        # 5. Slide -> prev = curr\n        # Result: prev[n] = LCS length for full strings\n\n        m, n = len(text1), len(text2)\n\n        # Initialize two rows\n        prev = [0] * (n+1)\n\n        # Process -> iterate rows\n        for i in range(1, m+1):\n            curr = [0] * (n+1)\n            for j in range(1, n+1):\n\n                # Explore Choices\n                if text1[i-1] == text2[j-1]:\n                    curr[j] = 1 + prev[j-1]\n                else:\n                    curr[j] = max(prev[j], curr[j-1])\n\n            # Slide -> update row\n            prev = curr\n\n        # Result -> LCS length\n        res = prev[n]\n\n        # overall: time complexity O(m*n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 1143,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-variables---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "black magic",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        intersection = set(text1) & set(text2)\n        if len(intersection) == 0: return 0\n        t1 = [char for char in text1 if char in intersection]\n        t2 = [char for char in text2 if char in intersection]\n        dp = [0] * len(t2)\n        for char in t1:\n            count = 0\n            for j in range(len(t2)):\n                if dp[j]>count:\n                    count=dp[j]\n                elif t2[j] == char:\n                    dp[j] = count + 1\n        return max(dp)",
        "questionNumber": 1143,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-black-magic---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # Bottom Up Tabulation\n        # Three states per day:\n        #   1. hold[i]    -> max profit at day i if holding stock\n        #   2. sold[i]    -> max profit at day i if just sold stock (cooldown next day)\n        #   3. rest[i]    -> max profit at day i if in cooldown or not holding\n        #\n        # Transitions:\n        #   hold[i] = max(hold[i-1], rest[i-1] - prices[i])   # buy or continue holding\n        #   sold[i] = hold[i-1] + prices[i]                   # sell today\n        #   rest[i] = max(rest[i-1], sold[i-1])               # cooldown or stay at rest\n        #\n        # Base Set Up:\n        #   hold[0] = -prices[0]   # buy first day\n        #   sold[0] = 0            # cannot sell on day 0\n        #   rest[0] = 0            # do nothing\n        #\n        # Result: max(sold[n-1], rest[n-1])  # must end not holding stock\n\n        n = len(prices)\n\n        # Initialize Arrays -> track 3 states per day\n        hold = [0] * n\n        sold = [0] * n\n        rest = [0] * n\n\n        # Base Set Up -> day 0\n        hold[0] = -prices[0]\n        sold[0] = 0\n        rest[0] = 0\n\n        # Process -> day 1 to n-1\n        for i in range(1, n):\n\n            # Transition: continue holding or buy today\n            hold[i] = max(hold[i-1], rest[i-1] - prices[i])\n\n            # Transition: sell today\n            sold[i] = hold[i-1] + prices[i]\n\n            # Transition: cooldown or rest\n            rest[i] = max(rest[i-1], sold[i-1])\n\n        # Result -> max profit if not holding stock\n        res = max(sold[n-1], rest[n-1])\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
        "questionNumber": 309,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        n = len(prices)\n        if n == 1: return 0\n        b = [-10 ** 9] * n\n        s = [0] * n\n        for i in range(n):\n            s[i] = max(s[i - 1], prices[i] + b[i - 1])\n            b[i] = max(b[i - 1], s[i - 2] - prices[i])\n        return s[-1]",
        "questionNumber": 309,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Variables",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # Bottom Up Variables (rolling states)\n        # Three states tracked in variables:\n        #   hold -> max profit holding stock\n        #   sold -> max profit just sold (cooldown next day)\n        #   rest -> max profit cooldown / not holding\n        #\n        # Transitions:\n        #   new_hold = max(hold, rest - prices[i])\n        #   new_sold = hold + prices[i]\n        #   new_rest = max(rest, sold)\n        #\n        # Base Set Up:\n        #   hold = -prices[0]\n        #   sold = 0\n        #   rest = 0\n        #\n        # Result: max(sold, rest)\n\n        n = len(prices)\n\n        # Base Set Up -> day 0\n        hold = -prices[0]\n        sold = 0\n        rest = 0\n\n        # Process -> day 1 to n-1\n        for i in range(1, n):\n\n            # Save previous states\n            prev_hold, prev_sold, prev_rest = hold, sold, rest\n\n            # Transitions\n            hold = max(prev_hold, prev_rest - prices[i])\n            sold = prev_hold + prices[i]\n            rest = max(prev_rest, prev_sold)\n\n        # Result -> max profit not holding stock\n        res = max(sold, rest)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
        "questionNumber": 309,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-variables---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def change(self, amount: int, coins: List[int]) -> int:\n        # Note:\n        # Bottom Up Tabulation (2D DP)\n        # dp[i][j] = number of ways to make sum j using first i coins\n        #\n        # Transitions:\n        #   if coin value > j:\n        #       dp[i][j] = dp[i-1][j]            # cannot take coin i\n        #   else:\n        #       dp[i][j] = dp[i-1][j] + dp[i][j-coin] \n        #           -> ways without this coin + ways including this coin\n        #\n        # Base Set Up:\n        #   dp[0][0] = 1    # one way to make amount 0 (use no coins)\n        #   dp[0][j>0] = 0  # cannot make positive amount with 0 coins\n        #\n        # Result: dp[n][amount]\n\n        n = len(coins)\n        dp = [[0] * (amount + 1) for _ in range(n + 1)]\n        \n        # base setup: one way to make 0\n        for i in range(n + 1):\n            dp[i][0] = 1\n        \n        # process\n        for i in range(1, n + 1):\n            for j in range(1, amount + 1):\n                if j < coins[i-1]:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j - coins[i-1]]\n        \n        return dp[n][amount]",
        "questionNumber": 518,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def change(self, amount: int, coins: List[int]) -> int:\n        # Note:\n        # Optimized Bottom Up (1D DP)\n        # dp[j] = number of ways to make sum j\n        #\n        # Transitions:\n        #   dp[j] += dp[j - coin]   # add ways using this coin\n        #\n        # Base Set Up:\n        #   dp[0] = 1  # one way to make amount 0\n        #\n        # Result: dp[amount]\n\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        \n        for coin in coins:\n            for j in range(coin, amount + 1):\n                dp[j] += dp[j - coin]\n        \n        return dp[amount]",
        "questionNumber": 518,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def change(self, amount: int, coins: List[int]) -> int:\n        # Note:\n        # DP State is \"first i elements\" style -> dp[i][sum]\n        # dp[i][s] = number of ways to reach sum s using nums[0..i-1]\n        #\n        # Transition:\n        #   dp[i][s] = dp[i-1][s - nums[i-1]] + dp[i-1][s + nums[i-1]]\n        #\n        # Base:\n        #   dp[0][0] = 1  (no numbers, only one way to make sum 0)\n        #\n        # Result:\n        #   dp[n][target]\n        #\n        # DP size:\n        #   total sum range = [-total, total] → shift by offset = total\n        #   index = s + offset\n\n        total = sum(nums)\n        if abs(target) > total: return 0\n        offset = total\n        n = len(nums)\n\n        dp = [[0] * (2 * total + 1) for _ in range(n + 1)]\n        dp[0][0 + offset] = 1\n\n        for i in range(1, n + 1):\n            num = nums[i - 1]\n            for s in range(-total, total + 1):\n                if dp[i - 1][s + offset] != 0:\n                    dp[i][s + num + offset] += dp[i - 1][s + offset]\n                    dp[i][s - num + offset] += dp[i - 1][s + offset]\n\n        return dp[n][target + offset]",
        "questionNumber": 494,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def findTargetSumWays(self, nums: List[int], target: int) -> int:\n\n        # Note:\n        # Same as Solution 1, but optimize to 1D array (rolling state)\n        # dp[s] = number of ways to reach sum s at current step\n        # Must use temp array to avoid overwriting\n\n        total = sum(nums)\n        if abs(target) > total: return 0\n        offset = total\n\n        dp = [0] * (2 * total + 1)\n        dp[0 + offset] = 1\n\n        for num in nums:\n            next_dp = [0] * (2 * total + 1)\n            for s in range(-total, total + 1):\n                if dp[s + offset] != 0:\n                    next_dp[s + num + offset] += dp[s + offset]\n                    next_dp[s - num + offset] += dp[s + offset]\n            dp = next_dp\n\n        return dp[target + offset]",
        "questionNumber": 494,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def findTargetSumWays(self, nums: List[int], target: int) -> int:\n\n        # Note:\n        # Transform into subset sum:\n        # Let P = sum(positive nums), N = sum(negative nums)\n        # Then P - N = target and P + N = total\n        # → P = (target + total) / 2\n        #\n        # Count number of subsets that sum to P\n        #\n        # dp[s] = number of ways to reach sum s using subset of nums\n\n        total = sum(nums)\n        if total < abs(target) or (target + total) % 2 != 0: return 0\n        P = (target + total) // 2\n\n        dp = [0] * (P + 1)\n        dp[0] = 1\n\n        for num in nums:\n            for s in range(P, num - 1, -1):\n                dp[s] += dp[s - num]\n\n        return dp[P]",
        "questionNumber": 494,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # Note:\n        # DP State:\n        #   dp[i][j] = True if s3[0..i+j-1] can be formed \n        #              by interleaving s1[0..i-1] and s2[0..j-1]\n        #\n        # Transition:\n        #   dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) \n        #            or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n        #\n        # Base:\n        #   dp[0][0] = True\n        #\n        # Result:\n        #   dp[len(s1)][len(s2)]\n\n        n1, n2, n3 = len(s1), len(s2), len(s3)\n        if n1 + n2 != n3: return False\n\n        dp = [[False] * (n2 + 1) for _ in range(n1 + 1)]\n        dp[0][0] = True\n\n        for i in range(n1 + 1):\n            for j in range(n2 + 1):\n                if i > 0 and s1[i-1] == s3[i+j-1]:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0 and s2[j-1] == s3[i+j-1]:\n                    dp[i][j] |= dp[i][j-1]\n\n        return dp[n1][n2]",
        "questionNumber": 97,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # Note:\n        # Space optimized version of Solution 1\n        # dp[j] = True if prefix of s1[0..i-1] and s2[0..j-1]\n        #         can form s3[0..i+j-1]\n        #\n        # Roll through s1, update dp in place\n\n        n1, n2, n3 = len(s1), len(s2), len(s3)\n        if n1 + n2 != n3: return False\n\n        dp = [False] * (n2 + 1)\n        dp[0] = True\n\n        for j in range(1, n2 + 1):\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n\n        for i in range(1, n1 + 1):\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\n            for j in range(1, n2 + 1):\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or \\\n                        (dp[j-1] and s2[j-1] == s3[i+j-1])\n\n        return dp[n2]",
        "questionNumber": 97,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "DFS + Memoization",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        # Notes:\n        # - Use DFS with memoization to avoid recomputation.\n        # - Each cell (i, j) stores the length of the longest increasing path starting there.\n        # - Explore 4 directions: up, down, left, right if the next cell is larger.\n        #\n        # Result: max value across all cells in memo\n\n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        memo = [[0] * n for _ in range(m)]  # memo[i][j] = longest path starting from (i, j)\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        def dfs(i, j):\n            # Return cached result\n            if memo[i][j] != 0:\n                return memo[i][j]\n            \n            # At least the cell itself\n            best = 1\n            for dx, dy in directions:\n                x, y = i + dx, j + dy\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    best = max(best, 1 + dfs(x, y))\n            \n            memo[i][j] = best\n            return best\n\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res",
        "questionNumber": 329,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-dfs-memoization---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        # Notes:\n        # - Treat each cell as a node in a DAG.\n        # - Edges go from smaller value -> larger value neighbor.\n        # - Topological sorting via Kahn's algorithm counts layers = path length.\n        #\n        # Result: number of BFS layers processed.\n\n        if not matrix or not matrix[0]:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        indegree = [[0] * n for _ in range(m)]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        # Compute indegree for each cell\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                        indegree[x][y] += 1\n\n        # Collect nodes with indegree 0\n        q = deque()\n        for i in range(m):\n            for j in range(n):\n                if indegree[i][j] == 0:\n                    q.append((i, j))\n\n        res = 0\n        # BFS layer by layer\n        while q:\n            res += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                        indegree[x][y] -= 1\n                        if indegree[x][y] == 0:\n                            q.append((x, y))\n        return res",
        "questionNumber": 329,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def numDistinct(self, s: str, t: str) -> int:\n        # Notes:\n        # - dp[i][j] = number of subsequences of s[:i] that equals t[:j]\n        # - Transitions:\n        #     if s[i-1] == t[j-1]:\n        #         dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        #     else:\n        #         dp[i][j] = dp[i-1][j]\n        # - Base cases:\n        #     dp[i][0] = 1   (empty t can always be formed)\n        #     dp[0][j] = 0   (non-empty t cannot be formed from empty s)\n        #\n        # Result: dp[m][n]\n\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # Base: empty t\n        for i in range(m + 1):\n            dp[i][0] = 1\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[m][n]",
        "questionNumber": 115,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def numDistinct(self, s: str, t: str) -> int:\n        # Notes:\n        # - Optimize to 1D by rolling over dp for target string.\n        # - Iterate j backwards to avoid overwriting needed states.\n        #\n        # Result: dp[n] (subsequences of s forming full t)\n\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n        dp[0] = 1  # empty t\n\n        for i in range(1, m + 1):\n            # iterate backwards for correctness\n            for j in range(n, 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[n]",
        "questionNumber": 115,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def numDistinct(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        cache = {}\n        def rec(x=0, y=0) -> int:\n            if y == m:\n                return 1\n            \n            if (n - x) < (m - y):\n                return 0\n\n            if (x, y) not in cache:\n                cache[(x, y)] = rec(x+1, y) + (rec(x+1, y+1) if s[x] == t[y] else 0)\n            return cache[(x, y)]\n        return rec()",
        "questionNumber": 115,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def minDistance(self, word1: str, word2: str) -> int:\n        # Notes:\n        # - dp[i][j] = minimum edit distance to convert word1[:i] to word2[:j]\n        # - Operations:\n        #     1. Insert:  dp[i][j-1] + 1\n        #     2. Delete:  dp[i-1][j] + 1\n        #     3. Replace: dp[i-1][j-1] + (0 if same else 1)\n        #\n        # Base cases:\n        # - dp[0][j] = j (convert empty word1 to word2[:j] by inserting)\n        # - dp[i][0] = i (convert word1[:i] to empty by deleting)\n        #\n        # Result: dp[m][n]\n\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # Base initialization\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n\n        # Fill dp table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + 1,     # delete\n                        dp[i][j - 1] + 1,     # insert\n                        dp[i - 1][j - 1] + 1  # replace\n                    )\n\n        return dp[m][n]",
        "questionNumber": 72,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def minDistance(self, word1: str, word2: str) -> int:\n        # Notes:\n        # - Optimize to 1D DP by rolling rows.\n        # - Keep prev row and update current row iteratively.\n        #\n        # Result: dp[n]\n\n        m, n = len(word1), len(word2)\n\n        prev = list(range(n + 1))  # dp[0][j]\n        curr = [0] * (n + 1)\n\n        for i in range(1, m + 1):\n            curr[0] = i  # base: delete all chars of word1[:i]\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    curr[j] = prev[j - 1]\n                else:\n                    curr[j] = min(\n                        prev[j] + 1,     # delete\n                        curr[j - 1] + 1, # insert\n                        prev[j - 1] + 1  # replace\n                    )\n            prev, curr = curr, prev  # swap\n\n        return prev[n]",
        "questionNumber": 72,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def minDistance(self, word1: str, word2: str) -> int:\n        # Notes:\n        # - Recursive definition:\n        #   dfs(i, j) = min edit distance between word1[:i] and word2[:j]\n        # - Base cases:\n        #   if i == 0: return j  (insert all j chars)\n        #   if j == 0: return i  (delete all i chars)\n        # - If last chars equal: dfs(i, j) = dfs(i-1, j-1)\n        # - Else: min(insert, delete, replace)\n        #\n        # - Manual memoization using dictionary\n\n        memo = {}\n        m, n = len(word1), len(word2)\n\n        def dfs(i, j):\n            if (i, j) in memo:\n                return memo[(i, j)]\n\n            if i == 0:\n                return j\n            if j == 0:\n                return i\n\n            if word1[i - 1] == word2[j - 1]:\n                memo[(i, j)] = dfs(i - 1, j - 1)\n            else:\n                memo[(i, j)] = min(\n                    dfs(i - 1, j) + 1,     # delete\n                    dfs(i, j - 1) + 1,     # insert\n                    dfs(i - 1, j - 1) + 1  # replace\n                )\n            return memo[(i, j)]\n\n        return dfs(m, n)",
        "questionNumber": 72,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxCoins(self, nums: List[int]) -> int:\n        # Note:\n        # Bottom Up DP / Interval DP\n        # 1. Pad Array -> add 1 to both ends to simplify edge calculations\n        # 2. dp[i][j] -> max coins from bursting balloons in nums[i:j+1] exclusive\n        # 3. Iterate -> all intervals length 1 to n\n        # 4. Explore Choices -> last balloon to burst in interval k\n        # 5. Build -> dp[i][j] = max(dp[i][k-1] + nums[i]*nums[k]*nums[j] + dp[k+1][j])\n        # Result: dp[0][n-1] holds max coins for full interval\n\n        n = len(nums)\n        # Pad nums with 1 at both ends\n        nums = [1] + nums + [1]\n        n += 2\n\n        # Initialize dp array -> max coins for interval i->j\n        dp = [[0] * n for _ in range(n)]\n\n        # Process -> interval lengths 1 to n-2 (excluding padded 1s)\n        for length in range(1, n-1):\n            for left in range(1, n - length):\n                right = left + length - 1\n\n                # Explore Choices -> last balloon to burst in interval\n                for k in range(left, right + 1):\n                    # Build -> max coins considering bursting k last\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]\n                    )\n\n        # Result -> max coins for interval 1 -> n-2\n        res = dp[1][n-2]\n        return res",
        "questionNumber": 312,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxCoins(self, nums: List[int]) -> int:\n        # Note:\n        # Bottom Up Interval DP\n        # 1. Pad Array -> simplify edge cases\n        # 2. dp[i][j] -> max coins interval i->j exclusive\n        # 3. Iterate -> interval lengths 1 to n-2\n        # 4. Explore Choices -> last balloon k to burst in interval\n        # 5. Build -> dp[i][j] = max(dp[i][k-1] + nums[i]*nums[k]*nums[j] + dp[k+1][j])\n        # Result: dp[1][n-2] holds max coins\n\n        n = len(nums)\n        nums = [1] + nums + [1]\n        n += 2\n\n        dp = [[0]*n for _ in range(n)]\n\n        for length in range(1, n-1):\n            for left in range(1, n - length):\n                right = left + length - 1\n                for k in range(left, right+1):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]\n                    )\n\n        res = dp[1][n-2]\n        return res",
        "questionNumber": 312,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def maxCoins(self, nums: List[int]) -> int:\n        # Note:\n        # Bottom Up Interval DP Space Optimized\n        # 1. Pad Array -> simplify edge cases\n        # 2. Process intervals iteratively using 2D dp\n        # 3. Explore Choices -> last balloon k to burst\n        # 4. Build -> dp[left][right] = max(dp[left][k-1] + nums[left-1]*nums[k]*nums[right+1] + dp[k+1][right])\n        # 5. Use only necessary interval slices to reduce memory footprint\n        # Result: max coins for full interval\n\n        n = len(nums)\n        nums = [1] + nums + [1]\n        n += 2\n\n        dp = [[0]*n for _ in range(n)]\n\n        for length in range(1, n-1):\n            for left in range(1, n - length):\n                right = left + length - 1\n                max_coins = 0\n                for k in range(left, right+1):\n                    coins = nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]\n                    if coins > max_coins:\n                        max_coins = coins\n                dp[left][right] = max_coins\n\n        res = dp[1][n-2]\n        return res",
        "questionNumber": 312,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 1,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isMatch(self, s: str, p: str) -> bool:\n        # Note:\n        # Top Down DP / Memoized Recursion\n        # 1. dfs(i,j) -> does s[i:] match p[j:]\n        # 2. Explore Choices -> '*' zero or more preceding char, '.' single char\n        # 3. Build -> check match current char and recurse\n        # 4. Memo Return -> store result for (i,j) to avoid recomputation\n        # Result: match for full strings\n\n        memo = {}\n\n        def dfs(i, j):\n            if (i,j) in memo:\n                return memo[(i,j)]\n            if j == len(p):\n                memo[(i,j)] = i == len(s)\n                return memo[(i,j)]\n            match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j+1 < len(p) and p[j+1] == '*':\n                memo[(i,j)] = dfs(i, j+2) or (match and dfs(i+1, j))\n            else:\n                memo[(i,j)] = match and dfs(i+1, j+1)\n            return memo[(i,j)]\n\n        res = dfs(0,0)\n        return res",
        "questionNumber": 10,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-1-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 2,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isMatch(self, s: str, p: str) -> bool:\n        # Note:\n        # Bottom Up DP / Tabulation\n        # 1. dp[i][j] -> does s[0..i-1] match p[0..j-1]\n        # 2. Base Set Up -> dp[0][0] = True (empty matches empty)\n        # 3. Explore -> fill dp table considering '*' and '.' rules\n        # 4. Build -> handle '*' zero or more, '.' matches any char\n        # Result: dp[len(s)][len(p)]\n\n        m, n = len(s), len(p)\n        dp = [[False]*(n+1) for _ in range(m+1)]\n        dp[0][0] = True\n\n        for j in range(2, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-2]\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]=='.'))\n                else:\n                    dp[i][j] = dp[i-1][j-1] and (s[i-1]==p[j-1] or p[j-1]=='.')\n\n        res = dp[m][n]\n        return res",
        "questionNumber": 10,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-2-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 3,
        "name": "0 to i Iterative Bottom Up Array",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isMatch(self, s: str, p: str) -> bool:\n        # Note:\n        # Bottom Up DP Space Optimized\n        # 1. Use two rows to store dp[i-1] and dp[i] to save space\n        # 2. dp[j] -> does current row s[0..i] match p[0..j-1]\n        # 3. Explore -> '*' and '.' rules applied for each column\n        # 4. Slide window -> update previous row after each s[i]\n        # Result: dp[len(s)][len(p)]\n\n        m, n = len(s), len(p)\n        prev = [False]*(n+1)\n        curr = [False]*(n+1)\n        prev[0] = True\n\n        for j in range(2, n+1):\n            if p[j-1] == '*':\n                prev[j] = prev[j-2]\n\n        for i in range(1, m+1):\n            curr[0] = False\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    curr[j] = curr[j-2] or (prev[j] and (s[i-1]==p[j-2] or p[j-2]=='.'))\n                else:\n                    curr[j] = prev[j-1] and (s[i-1]==p[j-1] or p[j-1]=='.')\n            prev, curr = curr, [False]*(n+1)\n\n        res = prev[n]\n        return res",
        "questionNumber": 10,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-3-0-to-i-iterative-bottom-up-array---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      },
      {
        "number": 4,
        "name": "space optimized",
        "type": "2d-dynamic-programming",
        "application": "2d-dynamic-programming",
        "code": "def isMatch(self, s: str, p: str) -> bool:\n        if not p:\n            return not s\n        first = bool(s) and (s[0] == p[0] or p[0] == '.')\n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (first and self.isMatch(s[1:], p))\n        return first and self.isMatch(s[1:], p[1:])",
        "questionNumber": 10,
        "solutionLink": "/Notes/2d-dynamic-programming#solution-4-space-optimized---2d-dynamic-programming2d-dynamic-programming",
        "blog": "2D Dynamic Programming"
      }
    ]
  }
}