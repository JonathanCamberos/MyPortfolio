{
  "1": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "logic-mapping",
      "code": "def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        # map of {complement: index, complement: index...}\n        # space complexity: hashmap of list of n length  O(n)\n        tracking = {}\n \n        # time complexity: iterating over list of size n O(n)\n        for i in range (len(nums)):\n\n            # grab curr complement -> (target = nums[i] + complement) \n            # time complexity: subtraction O(1) \n            complement = target - nums[i]\n\n            # time complexity: lookup operation O(1)\n            if complement in tracking:\n                \n                # [curr_index, complement_index]\n                return [i, tracking[complement]]\n    \n            # if miss, track currElement as potential complement\n            # time complexity: insert operation O(1)\n            tracking[nums[i]] = i\n\n        # overall: time complexity  O(n) \n        # overall: space complexity O(n)\n        return []",
      "questionNumber": 1,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaplogic-mapping",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "5": [
    {
      "number": 1,
      "name": "Manacher's Algorithm",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def longestPalindrome(self, s: str) -> str:\n        # Preprocess the string to handle even-length palindromes\n        t = \"#\".join(f\"^{s}$\")\n        n = len(t)\n        p = [0] * n\n        center = right = 0\n\n        \n        for i in range(1, n - 1):\n            mirror = 2 * center - i  # Mirror of `i` with respect to `center`\n\n            # If within bounds of the current right boundary\n            if i < right:\n                p[i] = min(right - i, p[mirror])\n\n            # Expand around `i`\n            while t[i + p[i] + 1] == t[i - p[i] - 1]:\n                p[i] += 1\n\n            # Update the center and right boundary if the palindrome is expanded\n            if i + p[i] > right:\n                center = i\n                right = i + p[i]\n\n        # Find the maximum length palindrome\n        max_len, center_index = max((n, i) for i, n in enumerate(p))\n        start = (center_index - max_len) // 2  # Convert index back to original string\n        return s[start: start + max_len]",
      "questionNumber": 5,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-manacher-s-algorithm---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "11": [
    {
      "number": 2,
      "name": "Greedy",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def trap(self, height: List[int]) -> int:\n        n = len(height)\n        water = 0\n\n        # time complexity: iterate over list of n length o(n)\n        for i in range(n):\n\n            # Use two pointers to calculate leftMax and rightMax\n            leftMax, left = 0, i\n            rightMax, right = 0, i\n\n            # time complexity: iterate over left hand side of list n length per outer iteration O(n^2)\n            while left >= 0:\n                leftMax = max(leftMax, height[left])\n                left -= 1\n\n            # time complexity: iterate over right hand side of list n length per outer iteration O(n^2)\n            while right < n:\n                rightMax = max(rightMax, height[right])\n                right += 1\n\n            # curr water trapped for curr bar i\n            water += min(leftMax, rightMax) - height[i]\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(1)\n        return water",
      "questionNumber": 11,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-greedy---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 1,
      "name": "Two Pointer Early Break",
      "type": "two-pointers",
      "application": "partitioning",
      "code": "def maxArea(self, height: List[int]) -> int:\n        \n        L, R = 0, len(height)-1\n        maxWater = 0 \n\n        # time complexity: iterate over list of n length with two pointers O(n)\n        while L < R:\n\n            # grabbing weak link\n            smallerHeight = min(height[L], height[R])\n\n            # calculate curr water = (smallerHeight * width)\n            currWater = smallerHeight * (R-L)\n            \n            # compare to max\n            maxWater = max(maxWater, currWater)\n\n            # grabbing weak link, continue past it\n            # time complexity: continue iterating over list n length with two pointers O(n)\n            if height[L] < height[R]:\n                L += 1\n\n                # early break: eliminate redundant comparisons\n                # by skipping heights guaranteed to be suboptimal\n                while height[L] < smallerHeight:\n                    L += 1 \n            \n            else:\n                R -= 1\n\n                # early break: eliminate redundant comparisons\n                # by skipping heights guaranteed to be suboptimal \n                while height[R] < smallerHeight:\n                    R -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return maxWater",
      "questionNumber": 11,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-two-pointer-early-break---two-pointerspartitioning",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "15": [
    {
      "number": 1,
      "name": "Frozen Pointer with Two Pointers Early Break (Sorting)",
      "type": "two-pointers",
      "application": "k-pointer-variants",
      "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n\n        # space complexity:\n        results = set()\n        n = len(nums)\n\n        # time complexity:\n        nums.sort()\n\n        # time complexity\n        for i in range(n - 2):\n\n            #\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            # early break: eliminate redundant comparisons\n            # can't get to 0 without negative number\n            if nums[i] > 0:\n                break\n\n            left, right = i + 1, n - 1\n            while left < right:\n                curr_sum = nums[i] + nums[left] + nums[right]\n\n                if curr_sum == 0:\n                    results.add((nums[i], nums[left], nums[right]))\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif curr_sum < 0:\n                    left += 1\n                else:\n                    right -= 1\n\n        # Time Complexity: O(n^2) for two-pointer traversal + O(n^2) for manual sorting.\n        # Space Complexity: O(k), where k is the number of unique triplets.\n        return [list(triplet) for triplet in results]",
      "questionNumber": 15,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-frozen-pointer-with-two-pointers-early-break-sorting---two-pointersk-pointer-variants",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Grouping By Parity (No Sorting)",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n        p, n, z = [], [], []\n        res = set()\n\n        for i in nums:\n            if i < 0:\n                n.append(i)\n            elif i > 0:\n                p.append(i)\n            else:\n                z.append(i)\n\n        # sets for access\n        P, N = set(p), set(n)\n\n        # 1. (0, num, -num) if at least one 0\n        if len(z) > 0:\n            for i in P:\n                n_target = -i\n                if n_target in N:\n                    res.add((n_target, 0, i ))\n\n        # 2. (0, 0, 0) if at least three 0's\n        if len(z) > 2:\n            res.add((0, 0, 0))\n\n        # 3. (-, -, +) negative pairs\n        for i in range(len(n)):\n            for j in range(i+1, len(n)):\n                p_target = -(n[i] + n[j])\n                if p_target in P:\n                    res.add(tuple(sorted([n[i], n[j], p_target])))\n        \n        # 4. (-, +, +) positive pairs\n        for i in range(len(p)):\n            for j in range(i+1, len(p)):\n                n_target = -(p[i] + p[j])\n                if n_target in N:\n                    res.add(tuple(sorted([p[i], p[j], n_target])))\n\n        return list(res)",
      "questionNumber": 15,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-grouping-by-parity-no-sorting---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "36": [
    {
      "number": 1,
      "name": "Defaultdict Matrix",
      "type": "hashmap",
      "application": "representation",
      "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # space complexity: hashsets for rows, columns, and flattened boxes of n length O(n) = O(3n)\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        grids = defaultdict(set)\n\n        # time complexity: iterating over all cells (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                tmp = board[r][c]\n                if tmp != \".\":\n\n                    # indexing box sets by tuple key (r/3, c/3)\n                    gridTuple = (r // 3, c // 3)\n\n                    # time complexity: lookup operation for element to corresponding sets in constant O(1)\n                    if (tmp in rows[r] or \n                        tmp in cols[c] or \n                        tmp in grids[gridTuple] ):\n                        return False\n                    \n                    # time complexity: insert operation for new element to corresponding sets in constant O(1)\n                    cols[c].add(tmp)\n                    rows[r].add(tmp)\n                    grids[gridTuple].add(tmp)\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n)\n        return True",
      "questionNumber": 36,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-defaultdict-matrix---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "[[]] Matrix",
      "type": "hashmap",
      "application": "representation",
      "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # space complexity: hashsets for rows, columns, and flattened boxes of n length O(n) = O(3n)\n        rows = [[], [], [], [], [], [], [], [], []]\n        col = [[], [], [], [], [], [], [], [], []]\n        grids = [[], [], [], [], [], [], [], [], []]\n\n        # time complexity: iterating over all cells (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                tmp = board[r][c]\n                if tmp != \".\":  \n\n                    # indexing box sets by unique int calculation  \n                    gridKey = (3 * (i//3)) + (j//3)\n\n                    # time complexity: lookup operation for element to corresponding sets in constant O(1)\n                    if (tmp in rows[r] or \n                        tmp in col[c]  or \n                        tmp in grids[gridKey]):\n                        return False\n\n                    # space complexity: lookup operation for new element to corresponding sets in constant O(1)\n                    col[c].append(tmp)\n                    rows[r].append(tmp)\n                    grids[gridKey].append(tmp)\n        \n        # overall: time complexity O(n^2)\n        # overall: space complexity  O(n)\n        return True",
      "questionNumber": 36,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-matrix---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "42": [
    {
      "number": 1,
      "name": "Two Pointers Early Break",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def trap(self, height: List[int]) -> int:\n\n        # Set initial variables\n        L, R = 0, len(height) - 1\n        water = 0\n        leftMax, rightMax = 0, 0\n\n        # time complexity: iterate over list of n length with two pointers O(n)\n        while L <= R:\n\n            # grabbing weak link\n            if height[L] < height[R]:\n\n                # Update leftMax\n                if height[L] >= leftMax:\n                    leftMax = height[L]\n\n                # outer if/else implies right is taller, so simply add to water count\n                else:\n                    water += leftMax - height[L]\n\n                # shifting pointer after calculation\n                L += 1\n\n            # grabbing weak link\n            else:\n                # Update rightMax\n                if height[R] >= rightMax:\n                    rightMax = height[R]\n\n                # outer if/else implies left is taller, so simply add to water count\n                else:\n                    water += rightMax - height[R]\n\n                # shifting pointer after calculation\n                R -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-two-pointers-early-break---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Monotonic Stack",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def trap(self, height: List[int]) -> int:\n        stack = []  # Monotonic stack to store indices\n        water = 0\n        n = len(height)\n\n        # Traverse the height array\n        for i in range(n):\n            # While current height > height at stack top (possible water trap)\n            while stack and height[i] > height[stack[-1]]:\n                top = stack.pop()  # Index of the bottom of the trapped water\n\n                # No water can be trapped without both left and right walls\n                if not stack:\n                    break\n\n                # Calculate the distance and bounded height\n                distance = i - stack[-1] - 1\n                bounded_height = min(height[i], height[stack[-1]]) - height[top]\n                water += distance * bounded_height\n\n            stack.append(i)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (due to the stack)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-monotonic-stack---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 3,
      "name": "Dynamic Programming",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n\n        # Arrays to store max heights from the left and right\n        left_max = [0] * n\n        right_max = [0] * n\n        water = 0\n\n        # Calculate left max for each bar\n        left_max[0] = height[0]\n        for i in range(1, n):\n            left_max[i] = max(left_max[i - 1], height[i])\n\n        # Calculate right max for each bar\n        right_max[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], height[i])\n\n        # Calculate trapped water for each bar\n        for i in range(n):\n            water += min(left_max[i], right_max[i]) - height[i]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (for left_max and right_max arrays)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-3-dynamic-programming---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "49": [
    {
      "number": 1,
      "name": "Hashmap of 26 to Tuple Key",
      "type": "hashmap",
      "application": "grouping-by-criteria",
      "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \n        # Note: Tuples in python are immutable which makes them suitable as keys for a hashmaps\n        # Lists are mutable and as such not hashable for hashmaps\n        # You should use tuples where the position carries semantic meaning. \n\n        # [26 char count tuple key -> [anagram group list], ...]\n        \n        # space complexity: stores unique m tuple keys O(m) and lists of k strings O(k), O(m * k)\n        anaGroup = {}\n\n        # time complexity: iterating over all strings O(n) \n        for word in strs:\n            \n            # space complexity: fixed-sized array for 26 lowercase letters O(1)\n            charCount = [0] * 26  \n            \n            # time complexity: counting chars in string of k length O(k)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # space complexity: fixed-size tuple of length 26 O(1)\n            key = tuple(charCount)  \n            \n            # time complexity: lookup operation of O(1) \n            if key not in anaGroup:\n                anaGroup[key] = []  \n\n            # time complexity: append operation to list O(1)\n            anaGroup[key].append(word)  \n\n\n        # overall: time complexity  O(n * k)  \n        # overall: space complexity O(m * k)\n        return list(anaGroup.values())",
      "questionNumber": 49,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-of-26-to-tuple-key---hashmapgrouping-by-criteria",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Array of 26 to String Key",
      "type": "hashmap",
      "application": "grouping-by-criteria",
      "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n\n        # Note: using a list to build the string key is more efficient than repeatedly appending to a string, \n        # as it avoids the overhead of creating new string objects on each append\n        # list takes O(m) time vs string append which takes O(m^2)\n\n        # space complexity: stores n tuple keys O(n) and lists of original k strings O(k), O(n * k)\n        anaGroup = {}\n\n        # time complexity: iterating over n strings O(n)\n        for word in strs:\n\n            # space complexity: fixed-sized array of 26 lowercase characters O(1)\n            charCount = [0] * 26\n            \n            # time complexity: counting characters for string k length O(k)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # time complexity: creating unique char count key from fixed-sized array of 26 O(1)\n            # Using a list to build the key\n            key_parts = []\n            for count in charCount:\n                key_parts.append(str(count))\n                key_parts.append(\"#\")  # Separator\n\n            # Concatenate once at the end\n            key = ''.join(key_parts)\n\n            # time complexity: lookup operation for key O(1)\n            if key not in anaGroup:\n                anaGroup[key] = []  # Initialize list for key if doesn't exist\n            anaGroup[key].append(word)  # Add word to corresponding key group\n\n        # overall: time complexity\n        # overall: space complexity \n        return list(anaGroup.values())",
      "questionNumber": 49,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-26-to-string-key---hashmapgrouping-by-criteria",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "125": [
    {
      "number": 1,
      "name": "Compare Ends Pre Clean",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def isPalindrome(self, s: str) -> bool:\n        \n        # space complexity: list to store cleaned string of n length O(n)\n        cleaned = []\n\n        # simple way for alphaNum check\n        def alphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        # time complexity: iterate over string of n length O(n)\n        for c in s:\n            # Check if character is alphanumeric\n            if isAlphaNum(c):\n                # Convert uppercase to lowercase\n                if 'A' <= c <= 'Z':\n                    cleaned.append(chr(ord(c) + 32))\n                else:\n                    cleaned.append(c)\n\n        # time complexity: two-pointer traversal of cleaned string O(n)\n        left, right = 0, len(cleaned) - 1\n        while left < right:\n            if cleaned[left] != cleaned[right]:\n                return False\n            left += 1\n            right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return True",
      "questionNumber": 125,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-compare-ends-pre-clean---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Compare Ends In Place",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def isPalindrome(self, s: str) -> bool:\n        # space complexity: no additional space used for storage O(1)\n        left, right = 0, len(s) - 1\n\n        # simple way for alphaNum check\n        def alphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        # time complexity: iteration over string of n length O(n)\n        while left < right:\n            # time complexity: moving left pointer to next alphanumeric character O(n)\n            while left < right and not isAlphaNum(s[left]):\n                left += 1\n\n            # time complexity: moving right pointer to previous alphanumeric character O(n)\n            while left < right and not isAlphaNum(s[right]):\n                right -= 1\n\n            # Convert characters to lowercase\n            leftChar = s[left]\n            if 'A' <= left_char <= 'Z':\n                left_char = chr(ord(leftChar) + 32)\n\n            rightChar = s[right]\n            if 'A' <= right_char <= 'Z':\n                rightChar = chr(ord(rightChar) + 32)\n\n            # Compare characters\n            if leftChar != rightChar:\n                return False\n\n            left += 1\n            right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 125,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-compare-ends-in-place---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "128": [
    {
      "number": 1,
      "name": "HashMap Boundaries",
      "type": "hashmap",
      "application": "representation",
      "code": "def longestConsecutive(nums: List[int]) -> int:\n        \n        # space complexity: hashmap of list of n length O(n)\n        seqLen = deafultdict(int)\n        longest = 0\n\n        # time complexity: iterate over list of n length O(n)\n        for num in nums:\n\n            # if new num found\n            # time complexity: lookup operations in constant O(1)\n            if num not in seqLen:\n\n                # grab left (right-most) -> sequence count\n                # grab right (left-most) -> sequence count\n                # may be 0 if no value\n                leftContinentBoundary = seqLen[num - 1]  \n                rightContinentBoundary = seqLen[num + 1] \n\n                # bridge the two continents together\n                bridgedLen = 1 + left + right\n\n                # Update prev, curr, next, sequence counts if applicable\n                seqLen[num - leftContinentBoundary] = bridgedLen\n                seqLen[num] = bridgedLen\n                seqLen[num + rightContinentBoundary] = bridgedLen\n\n                # Validate with global max sequence\n                longest = max(longest, currLen)\n\n        # overall: time complexity: O(n)\n        # overall: space complexity: O(n)\n        return longest",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-boundaries---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Set",
      "type": "hashmap",
      "application": "representation",
      "code": "def longestConsecutive(self, nums: List[int]) -> int: \n    \n    # space complexity: hashset for list of n length O(n)\n    numSet = set(nums)\n    longest = 0\n\n    # time complexity: iterate over list of n length O(n)\n    for i in numSet:\n\n        # found a new left most element, (start of new sequence)\n        # time complexity: lookup operation takes constant O(1)\n        if (i - 1) not in numSet: \n\n            # add sequential numbers while present in numSet, compare length\n            # time complexity: iterate over potential n sequence O(n) + lookup operation constant O(1), O(n)\n            currLen = 1\n            while (i + currLen) in numSet:\n                currLen += 1 \n\n            # validate with global max sequence\n            longest = max(longest, currLen)\n\n    # overall: time complexity O(n)\n    # overall: space complexity O(n)\n    return longest",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-set---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 3,
      "name": "Union Find Tree",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def longestConsecutive(self, nums: List[int]) -> int:\n        \n        if not nums:\n            return 0\n\n        # Union-Find Initialization\n        parent = {}  # Stores parent of each number\n        size = {}    # Stores the size of the connected components\n\n        # Find operation with path compression\n        # Amortized O(α(n)) time complexity\n        def find(x):\n\n            # if the parent of x is not itself, we have not reached the representative  \n            if parent[x] != x:\n\n                parent[x] = find(parent[x])  # Path compression\n            return parent[x]\n\n        # Union operation with size optimization\n        # Amortized O(α(n)) time complexity\n        def union(x, y):\n\n            # grab representatives of both x and y\n            root_x = find(x)\n            root_y = find(y)\n\n            # If both nodes do not have the same representative\n            # Attach smaller tree under the larger tree\n            if root_x != root_y:\n\n                # update representative for smaller\n                # update size for larger\n                if size[root_x] > size[root_y]:\n                    parent[root_y] = root_x\n                    size[root_x] += size[root_y]\n                else:\n                    parent[root_x] = root_y\n                    size[root_y] += size[root_x]\n\n        # Initialize Union-Find structure for unique numbers\n        # and set parents to themselves\n        for num in nums:\n            if num not in parent:\n                parent[num] = num\n                size[num] = 1\n\n        # Join consecutive numbers via Union operation\n        for num in nums:\n            if num + 1 in parent:\n                union(num, num + 1)\n\n        # Find the largest component size\n        # Amortized O(n) due to path compression\n        return max(size.values())",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-union-find-tree---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "167": [
    {
      "number": 2,
      "name": "Shift Pointer Ends Based on Sum",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n\n        # space complexity: l and r pointers constant O(1)\n        left, right = 0, len(numbers) - 1  \n\n        # time complexity: iterate over list of n length until l and r pointers meet O(n)\n        while left < right:\n\n            # check current pointer values\n            currSum = numbers[left] + numbers[right]  \n\n            if currSum == target:\n                # convert to 1-indexed array\n                return [left + 1, right + 1]\n\n            # increase left pointer to increase currSum\n            elif currSum < target:\n                left += 1\n\n            # decrease right pointer to decrease currSum\n            else:\n                right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return []",
      "questionNumber": 167,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-shift-pointer-ends-based-on-sum---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 1,
      "name": "Binary Search for Complement",
      "type": "two-pointers",
      "application": "one-pointer-with-auxiliary-state",
      "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n        \n        # time complexity: iteration over list of n length O(n)\n        for i in range(len(numbers)): \n\n            complement = target - numbers[i]\n            \n            # Binary search: O(log n)\n            left, right = i + 1, len(numbers) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if numbers[mid] == complement:\n\n                    # Convert to 1-indexed array\n                    return [i + 1, mid + 1]  \n                elif numbers[mid] < complement:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return []",
      "questionNumber": 167,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-binary-search-for-complement---two-pointersone-pointer-with-auxiliary-state",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "217": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "representation",
      "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n\n        # space complexity: dictionary of O(n)\n        count = defaultdict(int)\n\n        # time complexity: iteration over list of n length O(n)\n        for num in nums:\n\n            # time complexity: lookup operation in constant O(1)\n            if count[num] >= 1:\n                return True\n            count[num] += 1\n\n        # overall: time complexity  O(n) \n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 217,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Hashset",
      "type": "hashmap",
      "application": "representation",
      "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n        \n        # space complexity: hashset of O(n)\n        seen = set()\n\n        # time complexity: iteration of O(n)\n        for n in nums:\n\n            # time complexity: lookup operation of O(1)\n            if n in seen:\n                return True\n            seen.add(n)\n            \n        # overall: time complexity  O(n)\n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 217,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-hashset---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "238": [
    {
      "number": 1,
      "name": "Prefix and Postfix O(n)",
      "type": "array",
      "application": "in-place-transformations",
      "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # space complexity: prefix, postfix, and result arrays to calculate and store final value for n integers O(n) = O(3n)\n        prefix = [1] * len(nums)\n        postfix = [1] * len(nums)\n        res = [1] * len(nums)\n\n        # Compute prefix products\n        # time complexity: iteration over list of n length O(n)\n        for i in range(1, len(nums)):\n            \n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (prefix of i) = (prefix of i - 1) * (nums[i - 1])\n            prefix[i] = prefix[i - 1] * nums[i - 1]\n\n        # Compute postfix products\n        # time complexity: iteration over list of n length O(n)\n        for i in range(n - 2, -1, -1):\n\n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (postfix of i) = (postfix of i + 1) * (nums[i + 1])\n            postfix[i] = postfix[i + 1] * nums[i + 1]\n\n        # Combine prefix and postfix products\n        # time complexity: iteration over list of length n O(n)\n        for i in range(n):\n\n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (product except self of i) = (prefix of i) * (postfix of i)\n            res[i] = prefix[i] * postfix[i]\n\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 238,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-prefix-and-postfix-o-n---arrayin-place-transformations",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Prefix and Postfix Optimal O(1)",
      "type": "array",
      "application": "in-place-transformations",
      "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # instantiate to 1, start prefix calculation at res[1], prefix of res[0] is always 1\n        # space complexity: array to store results for n integers O(n) \n        res = [1] * len(nums)\n\n        # Compute prefix products in res\n        # time complexity: iterate over list of size n O(n)\n        for i in range(1, len(nums)):\n\n            # time complexity:\n            # (prefix of i) = (prefix of i - 1) * (num at i - 1)\n            res[i] = res[i - 1] * nums[i - 1]\n\n        # accumulate running postfix through reverse iteration\n        # postfix starts at 1, the postfix of len(n) - 1\n        postfix = 1\n\n        # start iteration at (len(n)-1), postfix of last integer will always be 1\n        # time complexity: iterate over list of size n in reverse O(n)\n        for i in range(len(nums) - 1, -1, -1):\n            \n            # (product except i) = (prefix of i) * (postfix of i)\n            res[i] *= postfix\n            \n            # (postfix of i - 1) = (postfix of i) * (num at i) \n            postfix *= nums[i]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
      "questionNumber": 238,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-prefix-and-postfix-optimal-o-1---arrayin-place-transformations",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "242": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "representation",
      "code": "def isAnagram(self, s: str, t: str) -> bool:\n        \n        # space complexity: hashmap of 26 elements constant  O(1) \n        count = defaultdict(int)\n\n        # time complexity: iteration over string of n length O(n)\n        for x in s:\n           count[x] += 1\n\n        # time complexity: iteration over string of n length O(n)\n        for x in t:\n           count[x] -= 1\n\n        # time complexity: iteration over string of n length O(n)\n        for value in count.values():\n\n            # time complexity: comparison operation in constant O(1)\n            if value != 0:\n                return False\n\n        # overall: time complexity  O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 242,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Array of 26",
      "type": "hashmap",
      "application": "representation",
      "code": "def isAnagram(self, s: str, t: str) -> bool:\n\n        # note: ord() converts a single uni-code character to its integer representation\n        # int: 97-122 -> lowercase English alphabet (a-z)\n        # we can calculate any char (a-z)'s uni-code integer by subtracting uni-code of 'a'\n        # '(a-z)' - 'a': returns a value of 0-25 which we can index into our array\n        # this simulates a hashing into our array\n\n        # space complexity: array of 26 elements constant O(1)\n        count = [0] * 26\n\n        # time complexity: iteration of O(n)\n        for x in s:\n           count[ord(x) - ord('a')] += 1\n\n        # time complexity: iteration of O(n)\n        for x in t:\n           count[ord(x) - ord('a')] -= 1\n\n        # time complexity: iteration of O(n)\n        for value in count:\n\n            # time complexity: comparison of O(1)\n            if value != 0:\n                return False\n\n        # overall: time complexity: O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 242,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-26---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "271": [
    {
      "number": 1,
      "name": "One Pointer Length Delimiter",
      "type": "two-pointers",
      "application": "one-pointer-with-auxiliary-state",
      "code": "def encode(self, strs: List[str]) -> str:\n\n        # python strings are immutable so concatenation creates new string time complexity o(n^2)\n        # python list allows us to add encoded strings in O(n)\n        # space complexity: storage for encoding all strings in a list O(n)\n        encoded = []\n\n        # time complexity: iterate over list of strings n length O(n)\n        for s in strings:\n            \n            # time complexity: iterate over all chars in string O(n)\n\n            # lenDelim = len + delim\n            left = 0\n            lenDelim = str(len(s)) + \"#\"\n\n            # append each char of (length + delimiter) O(n)\n            while left < len(lenDelim):\n                encoded.append(lenDelim[left])\n                left += 1\n            \n            # append each char of string itself O(n)\n            left = 0\n            while left < len(s):\n                encoded.append(s[left])\n                left += 1\n        \n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return ''.join(res)\n\n\n    def decode(self, s: str) -> List[str]:\n\n        # space complexity:\n        decoded = []\n        left = 0\n\n        # time complexity: iterate over list of n chars O(n)\n        while left < len(encoded):\n\n            # time complexity: \n            currLen = 0\n            while encoded[left] != \"#\":\n\n                # grabbing value ensuring base 10\n                currLen = currLen * 10 + int(encoded[i]) \n                left += 1\n\n            # skip delimiter, point to string\n            left += 1  \n\n            # grabbing currLen many chars to form string\n            # time complexity: \n            substring = \"\"\n            while left < range(currLen)\n\n                # forming string\n                substring += encoded[left]\n                left += 1\n            \n            # added string to decoded list of strings\n            decoded.append(substring)\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return decoded",
      "questionNumber": 271,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-one-pointer-length-delimiter---two-pointersone-pointer-with-auxiliary-state",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "347": [
    {
      "number": 1,
      "name": "MaxHeap Track N Elements",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n\n        # Note: A heap only guarantees that the root is the max (max heap) or min (min heap).\n        # The heap data structure only allows removing the root efficiently (O(log n))\n        # The heap property says nothing about the relative order of leaves or internal nodes.\n        # The smallest element could be anywhere in the leaves or internal nodes, not necessarily a leaf.\n        # Thus for maxHeap, we need to add all of the elements to the tree\n        # since we can't removed the smallest leaf as we go\n\n        # space complexity: count for m unique elements worst case n elements O(n)\n        count = defaultdict(int)\n\n        # time complexity: iterate over list of n length O(n)\n        for num in nums:\n            count[num] += 1\n\n        # space complexity: maxHeap must store all n elements O(n)\n        maxHeap = []\n\n        # time complexity: iteate over m unique elements worst case over n elements O(n)\n        for num, freq in count.items():\n\n            # time complexity: push onto heap O(log m) worst case O(log n) leading to best case O(m log m) worst case O(n log n) \n            heapq.heappush(maxHeap, (-freq, num))\n\n        # space complexity: list of k elements worst case n elements best O(k) worst O(n)\n        result = []\n\n        # cannot iterate over array, as order is not guaranteed left to right\n        # time complexity: iterate for k elements worst case n elements best O(k) worst O(n)\n        for _ in range(k):\n\n            # time complexity: pop top element O(log n) for k elements, worst case O(log n) for n elements, best case O(k log n) worst O(n log n)\n            freq, num = heapq.heappop(maxHeap)\n            result.append(num)\n\n        # same as above\n        # res = [num for _, num in (heapq.heappop(maxHeap) for _ in range(k))]\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return result",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-maxheap-track-n-elements---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "MinHeap Track K Elements",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n\n        # Note: A heap only guarantees that the root is the min (min heap) or max (max heap).\n        # The heap data structure only allows removing the root efficiently (O(log n))\n        # The heap property says nothing about the relative order of leaves or internal nodes.\n        # The largest element could be anywhere in the leaves or internal nodes, not necessarily a leaf.\n        # Thus for a minHeap, the root always holds the smallest element.\n        # If we only remove the smallest element when heap as exceeded size k, \n        # the heap will always contains the k largest frequencies seen so far.\n\n        # space complexity: count for m unique elements worst case n elements O(n)\n        count = defaultdict(int)\n\n        # time complexity: iterate over list of n length O(n)\n        for num in nums: \n            count[num] += 1\n\n        # space complexity: minHeap tracks k elements O(k)\n        minHeap = []\n\n        # time complexity: worst case iterate over n unique elements O(n)\n        for num, freq in count.items(): \n\n            # time complexity: push onto heap O(log n) for n elements, leading to O(n log n) \n            heapq.heappush(minHeap, (freq, num)) \n            \n            # if heap grows to size k + 1\n            if len(minHeap) > k:\n\n                # pop smallest element, heap will be back to size k\n                # time complexity: # pop smallest O(log k) for worst case n elements, leading to O(n log k)\n                heapq.heappop(minHeap) \n        \n        # can iterate over heap array as only holding top k elements\n        # time complexity: grab all k elements from minHeap worst case grab n elements O(n)\n        result = [num for freq, num in minHeap]\n\n        # for _, num in minHeap:\n        #    result.append(num) \n        # same as above\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return result",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-minheap-track-k-elements---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 3,
      "name": "Descending QuickSelect BinarySearch",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n    \n        # Note: QuickSelect is a modified quicksort\n        # Once the finalPartitionMarker is placed in its correct position, \n        # elements to the left and right are guaranteed to be smaller/larger\n        # This avoids sorting the entire array and isolates the elements we need\n\n        # In-place partition of array based on pivot value\n        def partitionSection(left, right, randPivotElemIndex):\n            \n            # time complexity: partition processes m elements, n in worst case O(n)\n            # Frequency of pivot element\n            pivotElemFreq = frequency[unique[randPivotElemIndex]]\n\n            # Move pivot to end\n            # tuple unpacking in python, allows to swap two variables in a single line\n            unique[randPivotElemIndex], unique[right] = unique[right], unique[randPivotElemIndex]\n            \n            # Index to partition larger elements to the left side of the section\n            partitionIndex = left\n\n            # Partition elements with freq more than pivotElemFreq to left\n            # time complexity: iterates over unique elements between left and right segment O(m)\n            for i in range(left, right):\n\n                # Higher frequency -> \"greater\"\n                if pivotElemFreq < frequency[unique[i]]:  \n\n                    # swap larger element to left, sorting high to low\n                    unique[i], unique[partitionIndex] = unique[partitionIndex], unique[i]\n                    partitionIndex += 1\n\n            # swap pivot to its final correct partitioned index\n            # now elements to the right and left follow the conditions according to pivot element\n            unique[partitionIndex], unique[right] = unique[right], unique[partitionIndex]\n            return partitionIndex\n\n        # time complexity: average recursion depth O(log m)\n        # space complexity: recursion stack for in place partitioning on average O(log m)\n        def quickSelectBinarySearchHelper(left, right, finalPartitionMarker):\n            \n            # Base Case: see 'For descending' below\n            if left == right:\n                return\n\n            # Randomly choose a pivot index\n            # differs from QuickSort \"median-of-three\" approach\n            # random pivot is focused on finding the k-th smallest or largest\n            # rather than fully sorting the array, random pivot avoids degrading to worst case O(n^2)\n            randPivotElemIndex = random.randint(left, right)\n\n            # Partition the array\n            resultPivotElemIndex = partitionSection(left, right, randPivotElemIndex)\n            \n            # Base Case: see 'For descending' below\n            if finalPartitionMarker == resultPivotElemIndex:\n                return \n            \n            # Binary Search Modification:\n            # Selects next partition pivot\n            # Recursively QuickSelect on partitioned section (left or right)\n            # where finalPartitionMarker belongs to\n\n            # finalPartitionMarker is in the left partition of resultPivotElemIndex\n            elif finalPartitionMarker < resultPivotElemIndex:\n                quickSelectBinarySearchHelper(left, resultPivotElemIndex - 1, finalPartitionMarker)\n            \n            # finalPartitionMarker is in the right partition of resultPivotElemIndex\n            else:\n                quickSelectBinarySearchHelper(resultPivotElemIndex + 1, right, finalPartitionMarker)\n\n        # time complexity: iterate over list of n length O(n)\n        frequency = defaultdict(int)\n        for num in nums:\n            frequency[num] += 1\n\n        # QuickSelect BinarySearch to find the k most frequent elements\n        unique = list(frequency.keys())\n        n = len(unique)\n        finalPartition = k - 1\n        l, r = 0, n - 1\n\n        # For descending:\n        # say we have a list of 6 elements, we are trying to grab the largest 2 elements\n        # if we do 2 - 1 we get 1.\n        # so if we find we have partitioned and set index 1\n        # we know that the elements 0 and 1 are the 2 largest elements\n        # so we splice [:2] = [0, 1]\n        quickSelectBinarySearchHelper(l, r, finalPartition)\n\n        # overall: time complexity\n        # overall: space complexity \n        return unique[:k]",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-descending-quickselect-binarysearch---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 4,
      "name": "Ascending QuickSelect BinarySearch",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\n        # Note: QuickSelect is a modified quicksort\n        # Once the finalPartitionMarker is placed in its correct position, \n        # elements to the left and right are guaranteed to be smaller/larger\n        # This avoids sorting the entire array and isolates the elements we need\n\n        # In-place partition of array based on pivot frequency (low to high sorting)\n        def partitionSection(left, right, randPivotElemIndex):\n            \n            # Frequency of pivot element\n            pivotElemFreq = frequency[unique[randPivotElemIndex]]\n\n            # Move pivot to end\n            # tuple unpacking in python, allows to swap two variables in a single line\n            unique[randPivotElemIndex], unique[right] = unique[right], unique[randPivotElemIndex]\n            \n            # Index to place smaller elements\n            partitionIndex = left\n\n            # Partition elements with freq less than pivotElemFreq to left\n            # time complexity: iterates over unique elements between left and right segment O(m)\n            for i in range(left, right):\n\n                # Lower frequency -> \"lower\"\n                if frequency[unique[i]] < pivotElemFreq:\n\n                    # swap larger element\n                    unique[i], unique[partitionIndex] = unique[partitionIndex], unique[i]\n                    partitionIndex += 1\n\n            # swap pivot to its final correct partitioned index\n            # now elements to the right and left follow the conditions according to pivot element\n            unique[partitionIndex], unique[right] = unique[right], unique[partitionIndex]\n            return partitionIndex\n\n        # QuickSelect helper for low to high sorting\n        # Avg recursion depth: O(log m), space: O(log m)\n        def quickSelectBinarySearchHelper(left, right, finalPartitionMarker):\n            \n            # Base Case: see 'For ascending' below\n            if left == right:\n                return\n\n            # Randomly choose a pivot index\n            # differs from QuickSort \"median-of-three\" approach\n            # random pivot is focused on finding the k-th smallest or largest\n            # rather than fully sorting the array, random pivot avoids degrading to worst case O(n^2)\n            partitionElemIndex = random.randint(left, right)\n            \n            # Partition the array\n            finalPartitionElemIndex = partitionPivot(left, right, partitionElemIndex)\n\n            # Base Case: see 'For ascending' below\n            if finalPartitionMarker == finalPartitionElemIndex:\n                return\n\n            # Binary Search Modification:\n            # Selects next partition pivot\n            # Recursively QuickSelect on partitioned section (left or right)\n            # where finalPartitionMarker belongs to\n\n            # finalPartitionMarker is in the left partition of resultPivotElemIndex\n            elif finalPartitionMarker < finalPartitionElemIndex:\n                quickSelectBinarySearchHelper(left, finalPartitionElemIndex - 1, finalPartitionMarker)\n            \n            # finalPartitionMarker is in the right partition of resultPivotElemIndex\n            else:\n                quickSelectBinarySearchHelper(finalPartitionElemIndex + 1, right, finalPartitionMarker)\n\n        # time complexity: iterate over list of n length O(n)        \n        frequency = defaultdict(int)\n        for num in nums:\n            frequency[num] += 1\n\n        # Quickselect to find the k most frequent elements\n        unique = list(frequency.keys())\n        n = len(unique)\n        finalPartition = n - k\n        l, r = 0, n - 1\n\n        # For ascending:\n        # say we have a list of 6 elements, we are trying to grab the largest 2 elements\n        # if we do 6 - 2 we get 4.\n        # so if we find we have partitioned and set index 4\n        # we know that the elements 4 and 5 are the 2 largest elements\n        # so we splice [6-2:] = [4:] = [4, 5]\n        # quickSelectBinarySearchHelper(left, right, finalPartitionMarker)\n        quickSelectBinarySearchHelper(l, r, finalPartition)\n\n        # overall: time complexity\n        # overall: space complexity\n        return unique[n - k:]",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-4-ascending-quickselect-binarysearch---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 5,
      "name": "BucketSort by Count",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n            \n        # space complexity: frequency count for unique integers O(m) \n        # time complexity: iterate over list of n integers O(n)\n        count = defaultdict(int)\n        for key in nums:\n\n            # time complexity: insertion operation takes constant O(1)\n            count[key] += 1\n\n        # numBuckets equal to length to account for max possible frequency count\n        # the case where list is full of only 1 element O(n)\n        # + 1 for case of element with 1 list, need bucket of frequency 0 and bucket of frequency 1\n        numBuckets = len(nums) + 1\n\n        # below is saying: create a list of empty lists numBuckets amount of times \n        # time complexity: iterating to set empty list for each bucket\n        # space complexity: creating O(n) bucket lists\n        freqBuckets = [[] for i in range(numBuckets)]\n\n        # time complexity: iterate over frequency list for m unique integer tuples (int, occurrences) O(m) \n        for int, occurrences in count.items():\n\n            # time complexity: insert operation takes constant O(1)\n            freqBuckets[occurrences].append(int)\n\n        # space complexity: grabbing top k integers O(k)\n        res = []\n\n        # time complexity: iterate over n buckets O(n)\n        for i in range(len(freqBuckets) - 1, 0, -1):\n            \n            # time complexity: iterate over all entries in current bucket O(n)\n            for num in freqBuckets[i]:\n                \n                # time complexity: insert operation takes constant O(1)\n                res.append(num)\n                \n                # time complexity: continue while less than k integers have been grabbed O(k)\n                if len(res) == k:\n                    return res\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-5-bucketsort-by-count---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ]
}