{
  "1": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "logic-mapping",
      "code": "def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        # map of {complement: index, complement: index...}\n        # space complexity: hashmap of list of n length  O(n)\n        tracking = {}\n \n        # time complexity: iterating over list of size n O(n)\n        for i in range (len(nums)):\n\n            # grab curr complement -> (target = nums[i] + complement) \n            # time complexity: subtraction O(1) \n            complement = target - nums[i]\n\n            # time complexity: lookup operation O(1)\n            if complement in tracking:\n                \n                # [curr_index, complement_index]\n                return [i, tracking[complement]]\n    \n            # if miss, track currElement as potential complement\n            # time complexity: insert operation O(1)\n            tracking[nums[i]] = i\n\n        # overall: time complexity  O(n) \n        # overall: space complexity O(n)\n        return []",
      "questionNumber": 1,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaplogic-mapping",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "2": [
    {
      "number": 1,
      "name": "Recursive",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        \n        # Note:\n        # 1. Recursion to simulate digit addition with carry\n        # 2. Add Corresponding digits with carry passed to recursive call\n        # 3. Current node created with .next -> recursively created node\n        # 4. Base case: both lists empty and carry is 0\n        # Result: new sum list created recursively\n        \n        # time complexity: iterate over two lists of m and n length O(max(m, n))\n        # space complexity: recursive call over two lists of m and n length O(max(m, n))\n        def recursiveSum(l1, l2, carry):\n            \n            # Base Case:\n            # Both lists and carry are empty\n            if not l1 and not l2 and carry == 0:\n                return None\n\n            # grab values if exist\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            # sum\n            sum = val1 + val2 + carry\n            carry = sum//10\n\n            # iterate lists if exist\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n            # new node and attach\n            newNode = ListNode(sum % 10)\n            newNode.next = recursiveSum(l1, l2, carry)\n\n            # return: curr node -> rest of list\n            return newNode\n\n        # calculate new sum list over two lists\n\n        # overall: time complexity O(max(m, n))\n        # overall: space complexity O(max(m, n))\n        return recursiveSum(l1, l2, 0)",
      "questionNumber": 2,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Iterative",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        \n        # Note:\n        # 1. Dummy node to create a sum list\n        # 2. Iterate over both lists until complete\n        # 3. Added values node by node, and pass the carry\n        # Result: sum of two lists\n\n        # dummy trick to return curr head\n        dummy = ListNode(-1)\n        prev = dummy\n        carry = 0\n\n        # Traverse while either list or carry is non empty\n        while l1 or l2 or carry:\n            \n            # grab if value exists\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # add values and carry\n            sum = v1 + v2 + carry\n            carry = sum // 10\n\n            # create new Node for new value  \n            newNode = ListNode(sum % 10)\n            prev.next = newNode\n            prev = prev.next\n\n            # iterate list\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n\n        # return new head of sum list\n\n        # overall: time complexity O(max(m, n))\n        # overall: space complexity O(1)\n        return dummy.next",
      "questionNumber": 2,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-iterative---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "3": [
    {
      "number": 1,
      "name": "Enumerate Char Most Recent Index Within Window Validation Two Pointer Sliding Window",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def lengthOfLongestSubstring(self, s: str) -> int:\n\n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> most recent index\n        # 1. move right pointer forward while no duplicates, \n        # 2. If duplicate found, move left to index after oldest duplicate\n        # 3. Update max length after processing each character.\n        # Result: max length without repeating characters\n\n        # char -> most recent index\n        char_MRI = {} \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # time complexity: iterate over string n length O(n)\n        for right, new_char in enumerate(s):\n\n            # check if char already found and within curr window\n            if new_char in char_MRI and left <= char_MRI[new_char]:\n                \n                # duplicate exists, move left -> oldest index + 1\n                left = char_MRI[new_char] + 1\n            \n            # update most recent index for curr char\n            char_MRI[new_char] = right\n\n            # get new length\n            new_length = right - left + 1\n\n            # update string length\n            max_len = max(max_len, new_length)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
      "questionNumber": 3,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-enumerate-char-most-recent-index-within-window-validation-two-pointer-sliding-window---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 2,
      "name": "Explicit Loop Char Most Recent Index Within Window Validation Two Pointer Sliding Window",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def lengthOfLongestSubstring(self, s: str) -> int:\n\n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> most recent index\n        # 1. move right pointer forward while no duplicates, \n        # 2. If duplicate found, move left to index after oldest duplicate\n        # 3. Update max length after processing each character.\n        # Result: max length without repeating characters\n\n        # char -> most recent index\n        char_MRI = {} \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # total prices\n        n = len(s)\n\n        # time complexity: iterate over string n length O(n)\n        for right in range(n):\n\n            new_char = s[right]\n\n            # check if new_char already found\n            if new_char in char_MRI:\n\n                # check if new_char within current window\n                if left <= char_MRI[new_char]:\n                \n                    # duplicate found,\n                    # move left: oldest index + 1\n                    left = char_MRI[new_char] + 1\n            \n            # update most recent index for curr new_char\n            char_MRI[new_char] = right\n            new_length = right - left + 1\n\n            # update string length\n            max_len = max(max_len, new_length)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
      "questionNumber": 3,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-2-explicit-loop-char-most-recent-index-within-window-validation-two-pointer-sliding-window---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "4": [
    {
      "number": 1,
      "name": "Two Pointer Merge Until Median",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "def findMedianSortedArrays(self, nums1, nums2):\n        \n        # Precondition:\n        # nums1 and nums2 are sorted in non-decreasing order\n        # 0 <= len(nums1), len(nums2) <= 10^6\n\n        # Postcondition:\n        # Returns the median value of the merged sorted array\n        # If merged length is odd: median is the middle value\n        # If merged length is even: median is the average of the two middle values\n        \n        # Lengths of the two arrays\n        m, n = len(nums1), len(nums2)\n\n        # Pointers to the current index in nums1 and nums2\n        p1, p2 = 0, 0\n\n        # Helper function:\n        # simulating one step of merge by returning the smallest\n        # of the current elements pointed to by p1 and p2\n        def get_min():\n            nonlocal p1, p2\n\n            # Case 1: Both pointers in bounds\n            # Return the smaller element and advance the pointer\n            if p1 < m and p2 < n:\n\n                # p1 smaller\n                if nums1[p1] < nums2[p2]:\n                    ans = nums1[p1]\n                    p1 += 1\n                # p2 smaller\n                else:\n                    ans = nums2[p2]\n                    p2 += 1\n\n            # Case 2: One of the pointers is out of range\n            # Return the smaller element in the other pointer and advance\n            \n            # p2 out of bounds\n            elif p2 == n:\n                ans = nums1[p1]\n                p1 += 1\n            # p1 out of bounds\n            else:\n                ans = nums2[p2]\n                p2 += 1\n\n            # current smallest value between p1 and p2\n            return ans\n\n        # Invariant:\n        # At call i to get_min() (0 based indexing):\n        #   Returns (i+1)th smallest element\n        # After i calls to get_min():\n        #   i smallest elements have been discarded\n\n        # Note:\n        # Instead of merging the arrays fully, \n        # simulate merge only up to the median index.\n\n        # Note:\n        # For length k = m + n:\n        # If Odd: median is the k//2 element\n        #   k = 5 -> k // 2 = 2 (3rd smallest)\n\n        # If Even: median is average of (k//2)-1 and k//2\n        #   k = 6 -> (k // 2)-1 = 2   k//2 = 3  (3rd and 4th smallest)\n\n        # For odd length merged array\n        if (m+n)%2 == 1:\n\n            # Discard the first k//2 smallest elements\n            for i in range((m + n) // 2):\n                get_min()\n\n            # Return the k//2 smallest element\n            return get_min()\n\n        # For even length merged array\n        else:\n\n            # Discard the first (k//2 - 1) elements \n            for i in range((m + n) // 2 - 1):\n                get_min()\n\n            # Grab (k//2)-1\n            # Grab (k//2) \n            # Return average\n            return (get_min() + get_min()) / 2\n\n    # overall: time complexity O(m + n)\n    # overall: space complexity O(1)",
      "questionNumber": 4,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-two-pointer-merge-until-median---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 2,
      "name": "Binary Search Partition",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "def findMedianSortedArrays(self, nums1, nums2):\n\n        # Precondition:\n        # nums1 and nums2 are sorted in ascending order\n        # 0 <= len(nums1), len(nums2) <= 10^6\n\n        # Postcondition:\n        # returns the median of the merged sorted array:\n        # If Odd: middle value of total length\n        # If Even: average of two middle values\n\n        # Invariant:\n        # At each iteration, we maintain a partition (cut point) in nums1 (partitionX)\n        # and implicit partition (cut point) in nums2 (partitionY) such that:\n        # 1. Total count of elements between both left partitions = \n        # Total count of elements between both right partitions\n        # 2. maxLeftX <= minRightY and maxLeftY <= minRightX:\n        # means the partition correctly divides arrays so  \n        # 3. all elements in left partitions are less than or equal to all elements in right partitions.\n        \n        # sanity check smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        # lens of the two arrays        \n        m, n = len(nums1), len(nums2)\n\n        # search space for the cut point in nums1\n        # range between [0, m]\n        # can put anywhere from no elements to all elements on left\n        low, high = 0, m\n\n        # Target Binary Search: \"<=\" in smaller array\n        # Each iteration is \"guess\" a cut across the smaller array \n        # (and implicitly the larger array) such that the Partition Rule is true\n        while low <= high:\n\n            # Guess cut point for nums1\n            # current nums1 search interval: [low, high]\n            \n            # we guess partitionX in nums1, and computer partitionY in nums2 accordingly\n            partitionX = (low + high) // 2\n\n            # Total count left half is fixed (half of all elements),\n            # so once you choose how many elements from nums1 go left (partitionX),\n            # you know how many elements from nums2 must go left (partitionY),\n            # in order to keep the two half of all elements balanced\n\n            # (5+1)//2 -> 3, (6+1)//2 -> 3\n            partitionY = (m + n + 1) // 2 - partitionX\n\n            # Grab values for partitions\n            # Allow for our invariant condition to be possible\n            # after reaching out of bounds of array\n            # if maxLeftX <= minRightY and maxLeftY <= minRightX:\n\n            # If the left part of nums1 is empty (partitionX == 0), then the maximum of an empty set should not restrict the comparison.\n            # Setting maxLeftX = -inf ensures the condition maxLeftX <= minRightY is always satisfied in this case.\n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            \n            # If the right part of nums1 is empty (partitionX == m), then there are no values to compare in the right half.\n            # Setting minRightX = +inf ensures the condition maxLeftY <= minRightX is always satisfied in this case.\n            minRightX = float('inf') if partitionX == m else nums1[partitionX]\n\n            # If the left part of nums2 is empty (partitionY == 0), then the maximum of an empty set should not restrict the comparison.\n            # Setting maxLeftY = -inf ensures the condition maxLeftY <= minRightX is always satisfied in this case.\n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            \n            # If the right part of nums2 is empty (partitionY == n), then the minimum of an empty set should not restrict the comparison.\n            # Setting minRightY = inf ensures the condition maxLeftX <= minRightY is always satisfied in this case.\n            minRightY = float('inf') if partitionY == n else nums2[partitionY]\n\n            # Discard Mid via Partitions Rule:\n            # max of left partition nums1 < min of right partition of nums2\n            # max of left partition nums2 < min of right partition of nums1\n            # we have successfully split 'merged' array into halves\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n\n                # Even Merged Array\n                if (m + n) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                \n                # Odd Merged Array:\n                else:\n                    return max(maxLeftX, maxLeftY)\n            \n            # Continue Split Monotonic Increasing Shift\n\n            # If maxLeftX > minRightY:\n            # Means largest element on the left side of nums1 partition is greater\n            # than the smallest element on the right side of nums2 partition\n            # Implies: our partitionX is too far right -> too many elements from nums1\n            # are in the left half\n\n            # Condition Breaks Invariant: maxLeftX <= minRightY\n\n            # Discard right half of [low, partitionX, high]\n            # new search interval: [low, partitionX - 1]\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n\n            # If maxLeftY > minRightX\n            # Means largest element on the left side of nums2 partition is greater\n            # than the smallest element on the right side of nums1 partition\n            # Implies: our partitionX is too far left -> not enough elements from nums1\n            # are in the left half\n\n            # Condition Breaks Invariant: maxLeftY <= minRIghtX\n\n            # Discard left half of [low, partitionX, high]\n            # new search interval: [partition + 1, high] \n            elif maxLeftY > minRightX:\n                low = partitionX + 1 \n\n\n        # overall: time complexity O(log (min(m, n)))\n        # overall: space complexity O(1)",
      "questionNumber": 4,
      "solutionLink": "/Notes/leetcode-binary-search#solution-2-binary-search-partition---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "5": [
    {
      "number": 1,
      "name": "Manacher's Algorithm (iterate, mirror radius optimization, and expand)",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def longestPalindrome(self, s: str) -> str:\n\n        # Note: \n        # Preprocessing with #, ^, and $:\n        # '#': ensures uniform expansion, for both odd and even length palindromes\n        # '^' and '$': sentinel characters don't match valid input characters, serve as true start and end markers\n        # '#': ensures all palindromes start and end with '#'\n        # '#': occur on odd indexes\n\n        # Mapping:\n        # we can map odd '#' indexes to their even character:\n        # mapping '#' at index 1 to char pair 'a' at index 2, to original 'a' at index 0\n        # [ ^ # a # b # a # $ ] -> [ a b a ]    via : originalStart = (expandedCenter - radius) / 2\n        #   0 1 2 3 4 5 6 7 8        0 1 2      thus: originalStart = (4 - 3) / 2 = 0\n        \n        # Boundary expansion: \n        # For any index i, center of palindrome at i can either be: \n        # - character from the original string\n        # - placeholder '#'\n        # Center definition allows even length palindromes such as \"abba\", see below,\n        # to have a single middle point, allowing the same expanding logic \n        # for even and odd strings for palindrome validation\n\n        # Ex:\n        # ^ # a # b # b # a # $    || new string len 11,\n        # 0 1 2 3 4 5 6 7 8 9 10   ||\n        #           ^              || index 5 center for even length \"abba\"\n\n        # index 1 palindrome: \"#\"\n        # index 2 palindrome: \"#a#\"\n        # index 5 palindrome: \"#a#b#b#a#\"\n        # etc...\n\n        expandedStr = \"#\".join(f\"^{s}$\")\n        n = len(expandedStr)\n\n        # Right Most Palindrome and Mirror Trick: \n        # Iteration tracks the right boundary for the current farthest right palindromic substring, \n        # which allows us to take advantage of the mirror radius trick.\n        # It speeds up palindrome expansion by starting the current palindrome radius\n        # at the radius value of its mirror\n\n        # p[i]: radius of palindrome centered at some index i\n        p = [0] * n\n\n        # mirror radius validation: tracking right boundary\n        # right: right boundary of the current right most palindrome\n        right = 0\n\n        # mirror radius validation: tracking center of right most in order to calculate mirror index\n        # center: center index of the current right most palindrome\n        center = 0 \n\n        # iteration range ignores sentinel indexes 0 and (n-1): ^ and $\n        # i: center of current palindrome\n        # time complexity: iterate over list of n length O(n)\n        for i in range(1, n - 1):\n\n            # mirror:\n            # i is current index being processed\n            # i is to the right of center and has a mirror to the left of center\n            # ex: center = 6, i = 7 => mirror = (2 * 6) - 7 = 5\n            mirror = (2 * center) - i \n\n            # mirror radius validation:\n            # if i lies within bounds of the right most palindrome,\n            # the right most palindrome symmetry guarantees that the palindrome radius\n            # for the mirror of i, is applicable to i as well,\n            # while within the bounds of the right most palindrome\n            if i < right:\n\n                # mirror radius is either:\n                # - less than the distance between i and right bound,\n                #   in which case all of the radius is valid\n                # - exceeds bounds and is farther than right bound,\n                #   in which case only the radius up until the right bound is valid\n                \n                # i radius is thus, bounded by minimum between: \n                # - mirror radius\n                # - distance from i to the right bound\n                p[i] = min(right - i, p[mirror])\n\n            # assumption: if valid mirror, we pre-set p[i] to p[mirror]\n            # now expand: expand radius p[i] until palindromic status is broken\n            while expandedStr[i + p[i] + 1] == expandedStr[i - p[i] - 1]:\n                p[i] += 1\n\n            # p[i]: radius for palindrome at i\n            # i: center for palindrome at i\n            # check: if we have a new right most boundary, update center and right \n            if i + p[i] > right:\n                right = i + p[i]\n                center = i\n\n        # expandedStr iteration complete:\n        # p[] stores radius of palindrome centered at each index\n\n        # scan p[] grabbing max palindrome radius alongside its center\n        maxRadius, centerIndex = max((palindromeRadius, i) for (i, palindromeRadius) in enumerate(p))\n\n        # Note:\n        # index and radius are relative to expandedStr, not the original string\n        # thus, we need to translate to original string indexes\n\n        # Notice, how in the expanded string, \n        #  - all original characters are on even index\n        #  - all original characters have matching # on the left odd index\n\n        # abba =>  ^ # a # b # b # a # $   | a=2, b=4, b=6, a=8\n        # 0123 =>  0 1 2 3 4 5 6 7 8 9 10  | #=1, #=3, #=5, #=7\n\n        # aba =>   ^ # a # b # a # $       | a=2, b=4, a=6\n        # 012 =>   0 1 2 3 4 5 6 7 8       | #=1, #=3, #=5\n\n        # any palindrome will always end with a '#'.\n        # so if we divide the starting odd position by 2, it will always map\n        # to an original character.\n        # so an easy translation formula is:\n\n        start = (centerIndex - maxRadius) // 2\n        \n        # splice longest substring\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return s[start: start + maxRadius]",
      "questionNumber": 5,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-manacher-s-algorithm-iterate-mirror-radius-optimization-and-expand---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Expand Around Center checking for Odd and Even palindromes (constant space)",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def longestPalindrome(self, s: str) -> str:\n\n        # expand from a given left and right while \n        # maintaining palindrome property\n        def expandAroundCenter(left, right):\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n\n            # curr iteration is not valid:\n            # ignore left: incrementing index\n            # ignore right: noninclusive right slicing\n            return s[left+1:right] \n         \n        n = len(s)\n        maxPalindrome = \"\"\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(n):\n            # odd expansion, centered at i\n            oddPalindrome = expandAroundCenter(i, i)      \n            # even expansion, centered at i and i + 1\n            evenPalindrome = expandAroundCenter(i, i+1)\n\n            # update longest\n            if len(oddPalindrome) > len(maxPalindrome):\n                maxPalindrome = oddPalindrome\n            if len(evenPalindrome) > len(maxPalindrome):\n                maxPalindrome = evenPalindrome\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(1)\n        return maxPalindrome",
      "questionNumber": 5,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-expand-around-center-checking-for-odd-and-even-palindromes-constant-space---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "11": [
    {
      "number": 1,
      "name": "Greedy Opposite Ends Pointer Shift by BinarySearch Modification",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def maxArea(self, height: List[int]) -> int:\n        \n        # set up \"BinarySearch\" modification\n        left, right = 0, len(height)-1\n        maxWater = 0 \n\n        # time complexity: two pointer iteration over list of n length O(n)\n        while left < right:\n\n            # grab smaller height between outside pointers\n            smallerHeight = min(height[left], height[right])\n\n            # width includes walls: \n            # [1, 1] is 1 water, so (rightIndex - leftIndex) = width\n            # calculate curr water between outside pointers, (smallerHeight * width)\n            currWater = smallerHeight * (right-left)\n            \n            # compare to global max\n            maxWater = max(maxWater, currWater)\n\n            # Greedy:\n            # As we move pointers inwards, width is guaranteed to get shrink\n            # Thus, we can continue to move our pointers,\n            # until we hit a bigger height than our current smaller height\n            # time complexity: two pointer iteration over list of n length O(n)\n            if height[left] < height[right]:\n                # step past current left/right wall combination\n                left += 1\n                # Greedy:\n                while left < right and height[left] < smallerHeight:\n                    left += 1 \n            else:\n                # step past current left/right wall combination\n                right -= 1\n                # Greedy:\n                while left < right and height[right] < smallerHeight:\n                    right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return maxWater",
      "questionNumber": 11,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-greedy-opposite-ends-pointer-shift-by-binarysearch-modification---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "15": [
    {
      "number": 2,
      "name": "Grouping By Parity 4 Triplet Combinations (time limit exceeded)",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \n        # Note: Two Sum vs 3Sum\n        # Two sum, finding two numbers whose sum equals a target is simple\n        # with hashmaps or two pointer approaches being efficient\n        # 3Sum adds complexity with a third variable.\n        # Grouping techniques aim to narrow and organize the solution space\n        # reducing redundant checks while finding valid triplets\n\n        # positive, negative, and zero sets\n        # space complexity: \n        p, n, z = [], [], []\n        \n        # set ensures no duplicate triplets\n        # space complexity: \n        res = set()\n\n        # time complexity: iterate over list of n length O(n)\n        for i in nums:\n            if i < 0:\n                n.append(i)\n            elif i > 0:\n                p.append(i)\n            else:\n                z.append(i)\n\n        # sets for unique groups\n        # time complexity: convert list into set O(n)\n        P, N = set(p), set(n)\n\n        # (0, num, -num)\n        # time complexity: iterate over positive numbers list n length O(n)\n        if len(z) > 0:\n            for i in P:                \n                # time complexity: negative target lookup in constant O(1)\n                nTarget = -i\n                if nTarget in N:\n                    res.add((nTarget, 0, i ))\n\n        # (0, 0, 0)\n        # time complexity: len operation constant O(1)\n        if len(z) >= 3:\n            res.add((0, 0, 0))\n\n        # (-, -, +) negative pairs\n        # time complexity: iterate over list of negative numbers n length O(n)\n        for i in range(len(n)):\n            # time complexity: iterate over list of negative numbers n length O(n) per outer iteration O(n), leading to O(n^2)\n            for j in range(i+1, len(n)):\n                # time complexity: lookup operation constant O(1)\n                pTarget = -(n[i] + n[j])\n                if pTarget in P:\n                    res.add(tuple(sorted([n[i], n[j], pTarget])))\n        \n        # (-, +, +) positive pairs\n        # time complexity: iterate over list of positive numbers n length O(n)\n        for i in range(len(p)):\n            # time complexity: iterate over list of positive numbers n length O(n) per outer iteration O(n), leading to O(n^2)\n            for j in range(i+1, len(p)):\n                # time complexity: lookup operation constant O(1)\n                nTarget = -(p[i] + p[j])\n                if nTarget in n:\n                    res.add(tuple(sorted([p[i], p[j], nTarget])))\n\n        # convert valid set of tuple triplets into valid list of tuple triplets\n\n        # overall: time complexity O(n^2) \n        # overall: space complexity O(n)\n        return list(res)",
      "questionNumber": 15,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-grouping-by-parity-4-triplet-combinations-time-limit-exceeded---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 1,
      "name": "Mimicking Two Sum by doing Per Element Opposite Ends Pointer Shift by BinarySearch Modification for 0 (Sorting)",
      "type": "two-pointers",
      "application": "k-pointer-variants",
      "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n\n        # Note: Two Sum vs 3Sum\n        # Two sum, finding two numbers whose sum equals a target is simple\n        # with hashmaps or two pointer solutions being efficient\n        # 3Sum adds complexity with a third variable,\n        # but converting 3Sum into a two sum problem allows\n        # the use of hashmap or two pointer solutions again\n\n        # set ensures no duplicate triplets\n        # space complexity: \n        results = set()\n        n = len(nums)\n\n        # time complexity: default python sorting TimSort, O(n log n)\n        nums.sort()\n\n        # mimic \n        # time complexity\n        for i in range(n - 2):\n\n            # skip iteration:\n            # i should only \"BinarySearch\" through any number once \n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            # early break: \n            # only allow negative numbers for i in (i, j, k)\n            if nums[i] > 0:\n                break\n\n            # Set up \"BinarySearch\" modification:          \n            # set new left boundary for iteration BinarySearch\n            # reset right boundary for iteration BinarySearch  \n            left, right = i + 1, n - 1\n\n            # \"BinarySearch\" modification: \n            # \"<\": working within subarray separate from i\n            # cannot evaluate num at left == right given constraint i != j, i != k, j != k\n            # Base case: no more array remaining to search\n            # complement for numbers[i] was not found, \n            # continue iteration for i\n            # time complexity: BinarySearch on subarray of n elements O(log n) for n iterations, leading to O(n log n)\n            while left < right:\n                \n                # grab current sum (i, j, k)\n                currSum = nums[i] + nums[left] + nums[right]\n\n                # found target sum\n                if currSum == 0:\n                    \n                    # add triplet to result set\n                    results.add((nums[i], nums[left], nums[right]))\n\n                    # skip iteration:\n                    # j and k should only \"BinarySearch\" through any number once \n                    left += 1\n                    right -= 1\n\n                    # skip iteration:\n                    # j and k should only \"BinarySearch\" through any number once \n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n\n                # \"BinarySearch\" on relevant subsection\n                # update left or right pointer\n                elif currSum < 0:\n                    left += 1\n                else:\n                    right -= 1\n\n        # convert valid set of tuple triplets into valid list of tuple triplets\n\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        return list(results)",
      "questionNumber": 15,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-mimicking-two-sum-by-doing-per-element-opposite-ends-pointer-shift-by-binarysearch-modification-for-0-sorting---two-pointersk-pointer-variants",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "19": [
    {
      "number": 1,
      "name": "Two Pass Get Length and Stop Prev to Removal Index",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Traverse list once to calculate total length\n        # 2. Use a dummy node to handle edge cases (like removing head)\n        # 3. Traverse again, stop at node prior to removal index\n        # 4. point prior.next = prior.next.next, disconnecting removal node\n        # Result: removed node at distance n from end of list\n\n        # First pass: get length of list\n        listLen = 0\n        curr = head\n        while curr:\n            listLen += 1\n            curr = curr.next\n\n        # Second pass: find the node behind target index\n\n        remove = listLen - n\n\n        # we adding an element to the list\n        dummy = ListNode(0, head)\n        curr = dummy\n\n        # this stops at the Node before the target remove index\n        # thus we can disconnect it\n        index = 0\n        while index != remove:\n            index += 1\n            curr = curr.next\n        \n        # remove nth node from end by skipping it\n        curr.next = curr.next.next\n\n        # Return head dummy is pointing to (may be different from original)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return dummy.next",
      "questionNumber": 19,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-two-pass-get-length-and-stop-prev-to-removal-index---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "One Pass Fast Slow with HeadStart of N+1",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Use two pointers spaced n+1 apart (fast and slow)\n        # 2. Move both pointers until fast hits end\n        # 3. Slow pointer will be right before the node to remove\n        # 4. Remove node by skipping it\n       \n        dummy = ListNode(-1, head)\n        slow = fast = dummy\n        \n        # Set fast pointer: \n        # head start of n + 1 step,\n        # in order to create a gap of n between fast and slow\n        # (taking dummy node into account)\n        index = 0\n        while index != n+1:\n            index += 1\n            fast = fast.next\n        \n        # When fast reaches end:\n        # n + 1 gap between slow (within list) and fast (end of list)\n        while fast:\n            fast = fast.next\n            slow = slow.next\n        \n        # skip nth node\n        slow.next = slow.next.next\n\n        # Return head dummy is pointing to (may be different from original)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return dummy.next",
      "questionNumber": 19,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-one-pass-fast-slow-with-headstart-of-n-1---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "20": [
    {
      "number": 1,
      "name": "Manual Condition Stack Check",
      "type": "stack",
      "application": "tracking-nested-or-hierarchical-structures",
      "code": "def isValid(self, s: str) -> bool:\n\n        # note: in python, an empty list [] is falsy evaluating to false\n        # not [] -> true\n\n        # space complexity: stack stores up to n opening brackets O(n)\n        stack = []\n\n        # time complexity: iterate over list of n length O(n)\n        for c in s:\n\n            # found closing bracket, match with opening bracket\n            if c in ')]}':\n\n                # check stack is empty, no matching opening available\n                if not stack:\n                    return False\n\n                # time complexity: pop in constant O(1)\n                topElem = stack.pop()\n\n                # check if opening matches closing\n                if  ((c == ')' and topElem != '(') or\n                     (c == '}' and topElem != '{') or\n                     (c == ']' and topElem != '[')):\n                    return False\n\n            # found opening bracket, push to stack\n            if c in '([{':\n                stack.append(c)\n                               \n        # if stack is empty, success\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return not stack",
      "questionNumber": 20,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-manual-condition-stack-check---stacktracking-nested-or-hierarchical-structures",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "Stack with Hashmap lookup",
      "type": "stack",
      "application": "tracking-nested-or-hierarchical-structures",
      "code": "def isValid(self, s: str) -> bool:\n\n        # space complexity: stack stores opening brackets for string n length O(n)\n        stack = []\n\n        # space complexity: closed -> open mapping in constant O(1)\n        mapping = {\n            ')' : '(',\n            ']' : '[',\n            '}' : '{'\n        }\n\n        # time complexity: iterate over string of n length O(n)\n        for c in s:\n            \n            # found closing bracket, match with opening bracket\n            if c in mapping:\n\n                # check stack is empty, no matching opening available\n                if not stack:\n                    return False\n\n                # time complexity: pop in constant O(1)\n                topElem = stack.pop()\n\n                # check if opening matches closing\n                if mapping[c] != topElem:\n                    return False\n            \n            # found opening bracket, push to stack\n            else:   \n                stack.append(c)\n                \n        # if stack is empty, success\n\n        # overall: time complexity O(n)\n        # overall: space complexity\n        return not stack",
      "questionNumber": 20,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-stack-with-hashmap-lookup---stacktracking-nested-or-hierarchical-structures",
      "blog": "LeetCode: Stacks"
    }
  ],
  "21": [
    {
      "number": 1,
      "name": "Recursive",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Note:\n        # Building merged list from right to left,\n        # connecting current node and passing back as we go\n        \n        # Base case: \n        # One of the lists is empty,\n        # return second list for the .next\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n\n        # Recursive Call:\n        # Point smaller val -> rest of list\n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)",
      "questionNumber": 21,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Iterative Sentinel Anchor",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Note:\n        # DummyHead is used to enter the iterative loop cleanly\n        # without handling first node assigning case\n        \n        # sentinel anchor for real head\n        dummyHead = ListNode(-1)  \n\n        # curr node of list\n        tail = dummy          \n\n        # Traverse both lists while both have nodes\n        # time complexity: iterate over both lists O(m + n)\n        while list1 and list2:\n\n            # grab smaller value between list1 and list2\n            if list1.val < list2.val:\n                \n                # append and iterate list1\n                tail.next = list1     \n                list1 = list1.next   \n            else:\n                # append and iterate list2\n                tail.next = list2\n                list2 = list2.next    \n\n            # 1st iteration: dummyHead/tail no longer point to same obj\n            # nth iteration: iterate tail to whatever the next_node is\n            tail = tail.next          \n\n        # At least one list is non empty at this point:\n        # point tail to rest of list\n        if list1:\n            tail.next = list1\n        else \n            tail.next = list2\n\n        # Jump to merged head using dummyHead\n\n        # overall: time complexity O(m + n)\n        # overall: space complexity O(1)\n        return dummyHead.next",
      "questionNumber": 21,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-iterative-sentinel-anchor---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "22": [
    {
      "number": 4,
      "name": "Dynamic Programming Building Parentheses Combinations",
      "type": "stack",
      "application": "dynamic-programming-state-compression",
      "code": "def generateParenthesis(self, n: int) -> List[str]:\n        \n        # Note:\n        # We exploit the recursive structure of Catalan numbers\n        # by building a list of all valid parentheses combinations for each level n\n\n        # dp:    list of list of parentheses combinations \n        # dp[n]: list containing all valid parenthesis combinations for n pairs\n        dp = [[] for i in range(n + 1)]\n        \n        # Base case: valid combination for n = 0\n        dp[0] = [\"\"]  \n        \n        # Iterate: create valid lists from dp[1] to dp[n]\n        # Current: building list for i pairs\n        # time complexity: iterate over list of n length O(n) \n        for i in range(1, n + 1): \n\n            # iterate over stored lists up to now\n            for j in range(i):  \n\n                # Setup: Two Pointer Variation: Opposite Ends\n\n                # forward iteration: over each valid string of parentheses for level j\n                # start: first parentheses pairs level (0) pairs\n                for left in dp[j]:\n\n                    # reverse iteration: over each valid string of parentheses for level (i - 1 - j)\n                    # start: last parentheses pairs level (i-1) pairs\n                    for right in dp[i - 1 - j]:\n\n                        # Two Pointer Variation: Opposite Ends\n                        # as pointers meet in middle, number of parentheses will remain balanced\n                        # which allows us to just add them randomly within valid rules:\n\n                        # Why:\n                        # ({left}){right} or {left}({right}) are both valid formulas\n                        # Since we are doing Opposite Ends and left and right will cross over each other,\n                        # left and right will both individually use all values\n                        # which means with these 2 iterations\n                        # we are eventually doing both ({left}){right} and {left}({right})\n\n                        dp[i].append(f\"({left}){right}\")\n\n        # overall: time complexity O(Catalan(n) * n)\n        # overall: space complexity O(Catalan(n) * n)\n        return dp[n]",
      "questionNumber": 22,
      "solutionLink": "/Notes/leetcode-stacks#solution-4-dynamic-programming-building-parentheses-combinations---stackdynamic-programming-state-compression",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 1,
      "name": "BackTracking Recursive with String Concatenation",
      "type": "stack",
      "application": "backtracking-by-tracking-history-or-state",
      "code": "def generateParenthesis(self, n: int) -> List[str]:\n\n        # Note:\n        # Backtracking explores all valid sequences of parentheses.\n        # A new string is created on each recursive call using string \n        # concatenation for string length up to 2n leading to O(n^2).\n\n        res = []\n\n        # Backtracking        \n        # space complexity: call stack depth is O(n), string copying adds O(n) per leaf path, leading to O(n^2)\n        def helper(current: List[str], num_open: int, num_closed: int):\n\n            # Base case: if the length of the current combination is 2 * n, it's complete\n            if len(current) == n * 2:\n                # time complexity: concat add to res for 2n length O(n)\n                res.append(current)\n                return\n\n            # Check: open count is less than total expected\n            # Ensures: string is always valid, with total number of parens being valid\n            # Recursive case 1: add '('\n            if num_open < n: \n                # time complexity: concat per iteration O(n)\n                helper(current + \"(\", num_open + 1, num_closed)\n            \n            # Check: closed count is less than open count\n            # Ensures: string is always valid, with each open having a matching close\n            # Recursive case 2: add ')'\n            if num_closed < num_open:\n                # time complexity: concat per iteration O(n)\n                helper(current + \")\", num_open, num_closed + 1)\n\n        # Start backtracking process with an empty list and counts at 0\n        helper(\"\", 0, 0)\n\n        # overall: time complexity O(Catalan(n) * n^2)\n        # overall: space complexity O(Catalan(n) * n)\n        return res",
      "questionNumber": 22,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-backtracking-recursive-with-string-concatenation---stackbacktracking-by-tracking-history-or-state",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "BackTracking Recursive with Mutable List",
      "type": "stack",
      "application": "backtracking-by-tracking-history-or-state",
      "code": "def generateParenthesis(self, n: int) -> List[str]:\n        \n        # Note:\n        # Backtracking explores all valid sequences of parentheses.\n        # Only when a complete sequence is found (length == 2 * n), \n        # we convert the list to a string via concat in O(n)\n\n        res = []\n        \n        # Backtracking\n        # time complexity: each recursion explores a state; only leaf call does ''.join(), leading to O(n)\n        # space complexity: call stack depth O(n), current list holds up to 2n\n        def backtrack(current, openCount, closeCount):\n\n            # Base case: if we have used all open and close parentheses\n            if openCount == n and closeCount == n:\n                # time complexity: convert once at leaf for 2n length O(n)\n                res.append(\"\".join(current))\n                return\n            \n            # Check: open count is less than total expected\n            # Ensures: string is always valid, with total number of parens being valid\n            # Recursive case 1: add '('\n            if openCount < n: \n                current.append('(')\n\n                # Recursive call explores all combinations from new state\n                helper(current, openCount + 1, closeCount)\n\n                # Backtrack by removing the last added '('\n                current.pop()\n            \n            # Check: closed count is less than open count\n            # Ensures: string is always valid, with each open having a matching close\n            # recursive case: add ')'\n            if closeCount < openCount:\n\n                current.append(')')\n\n                # Recursive call explores all combinations starting from new state\n                helper(current, openCount, closeCount + 1)\n\n                # Backtrack by removing the last added ')'\n                current.pop()\n\n        # starts recursion with an empty string and zero counts\n        backtrack([], 0, 0)\n\n        # overall: time complexity O(Catalan(n) * n)\n        # overall: space complexity O(Catalan(n) * n)\n        return res",
      "questionNumber": 22,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-backtracking-recursive-with-mutable-list---stackbacktracking-by-tracking-history-or-state",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 3,
      "name": "Iterative State Tracking Stack",
      "type": "stack",
      "application": "backtracking-by-tracking-history-or-state",
      "code": "def generateParenthesis(self, n: int) -> List[str]:\n\n        # Note:\n        # Explicit stack simulates backtracking process iteratively.\n        # Each stack element stores the current string and counts of open and closed parentheses.\n        # Allows state tracking without recursion.\n\n        # Store valid parentheses\n        result = []\n\n        # Tracks state (current_string, open_count, closed_count)\n        stack = [([], 0, 0)] \n\n        # Simulate backtracking\n        # time complexity: each state processed once, building up to O(Catalan(n)) strings\n        # space complexity: stack can grow to O(Catalan(n)), result stores O(Catalan(n)) strings\n        while stack:\n\n            # Pop current state, current state is explored only once\n            curr, openCount, closeCount = stack.pop()\n\n            # Base case: reached valid string\n            if openCount == n and closeCount == n:\n                result.append(\"\".join(curr))\n                continue\n\n            # Check: open count is less than total expected\n            # Ensures: string is always valid, with total number of parens being valid\n            # Iterative step 1: add '('\n            if openCount < n:\n                \n                # copy list to avoid mutating other branches\n                new_curr = curr + ['(']\n                stack.append((new_curr, openCount + 1, closeCount))\n\n            # Check: closed count is less than open count\n            # Ensures: string is always valid, with each open having a matching close\n            # Iterative step 2: add '('\n            if closeCount < openCount:\n                new_curr = curr + [')']\n                stack.append((new_curr, openCount, closeCount + 1))\n\n        # overall: time complexity O(Catalan(n) * n)\n        # overall: space complexity O(Catalan(n) * n)\n        return result",
      "questionNumber": 22,
      "solutionLink": "/Notes/leetcode-stacks#solution-3-iterative-state-tracking-stack---stackbacktracking-by-tracking-history-or-state",
      "blog": "LeetCode: Stacks"
    }
  ],
  "23": [
    {
      "number": 1,
      "name": "Min Heap Priority Queue",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. minHeap stores current head for each sorted list\n        # 2. minHeap sorted by value, list_index breaking ties: \n        #    (value, list_index, node)\n        # 3. smallest value across heads added to list\n        # 4. push to minHeap to replaced added node\n        # Result: merge list in O(n log k)\n\n        # minHeap of: (val, list index, node)\n        min_heap = []\n\n        # Push the head of each non-empty list into the heap\n        for i_list, head_list in enumerate(lists):\n            if head_list:\n                # minHeap sorted by node.val,\n                # i_list index used to break ties\n                heappush(min_heap, (head_list.val, i_list, head_list))  \n\n        dummy = ListNode(-1)\n        prev = dummy\n\n        # Pop smallest node, attach to merged list, push from same list if min.next\n        while min_heap:\n\n            # grab min value\n            minVal, i_list, node = heappop(min_heap)\n            prev.next = node\n            prev = prev.next\n\n            # valid node.next for current i_list\n            if node.next:\n                # grab next node from i_list\n                heappush(min_heap, (node.next.val, i_list, node.next))\n\n        # minHeap empty -> all lists empty\n        # return head of merged list\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(k)\n        return dummy.next",
      "questionNumber": 23,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-min-heap-priority-queue---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Merge Pair of List at a Time with Standard Merge Two Sorted Linked List",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Merge lists in pairs with standard merge two sorted lists\n        # 2. Each round halves the total number of lists -> O(log k) rounds\n        # 3. Each round processes all nodes (across all merges) -> O(n) work per round\n        # Result: Merging k lists in place\n        \n        # Empty check\n        if not lists: \n            return None\n\n        # Merge two sorted linked lists\n        # time complexity: iterate over lists of n length O(n)\n        def mergeTwo(l1, l2):\n\n            # dummy node trick\n            dummy = ListNode(-1)\n            prev = dummy\n\n            # merge while both lists non empty\n            while l1 and l2:\n                # grab smaller head\n                if l1.val < l2.val:\n                    prev.next = l1\n                    l1 = l1.next\n                else:\n                    prev.next = l2\n                    l2 = l2.next\n                # iterate\n                prev = prev.next\n\n            # attach remaining list \n            if not l1:\n                prev.next = l2 \n            else:\n                prev.next = l1\n\n            # return merged new merged list\n            return dummy.next\n\n        # iteratively merge lists in pairs until one list remains\n        # time complexity: log(len(list)) total merges\n        while len(lists) > 1:\n            merged = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                merged.append(mergeTwo(l1, l2))\n            lists = merged\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(1)\n        return lists[0]",
      "questionNumber": 23,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-merge-pair-of-list-at-a-time-with-standard-merge-two-sorted-linked-list---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "25": [
    {
      "number": 1,
      "name": "Recursive",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Check if there are at least k nodes ahead (otherwise return head)\n        # 2. Reverse the first k nodes\n        # 3. Recurse and process sub list\n        # 4. Connect reversed head with resulting sub list\n        # Result: original lists with reversed groups of k length\n\n        # Base case: check if at least k nodes remain\n        kLen = 0\n        node = head\n        while node and kLen < k:\n            kLen += 1\n            node = node.next\n\n        # Base case: less than k nodes, return head\n        if kLen < k:\n            return head  \n\n        # ----\n        # standard reverse linked list\n\n        # Reverse current sub list up to k\n        prev = None\n        curr = head\n        for _ in range(k):\n            # grab next\n            next = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate\n            prev = curr\n            curr = next\n        \n        # curr -> start of next sub list\n        # prev -> new head of curr sub list\n        # head -> new tail of curr sub list\n        # connect head (new tail) via head.next to next reversed sub list\n        head.next = self.reverseKGroup(curr, k)\n        \n        # return prev (new head) of curr sub list\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n/k) ~ O(n) recursive stack\n        return prev",
      "questionNumber": 25,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Iterative",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # Note:\n        # 1. Dummy node handles head swaps cleanly\n        # 2. For each sub list:\n        #    Find the kth node\n        #    Reverse the group in place\n        #    Connect previous reverse group's tail to head of new reversed group\n        # 3. Continue until remaining nodes < k, then return\n\n        # dummy node trick for head of overall list\n        dummy = ListNode(0, head)\n\n        # group_prev_tail points to tail of the previous reverse group,\n        # where group.next points to head of next list\n        group_prev_tail = dummy\n\n        # while remaining sub list is greater than k\n        while True:\n\n            # last item in previous reversed sub list\n            kth_elem = group_prev_tail\n            # check if k more elements exist\n            for _ in range(k):\n                kth_elem = kth_elem.next\n\n                # less than k nodes remain, return head of entire list\n                if not kth_elem:\n                    return dummy.next \n\n            # next sub list start\n            group_next = kth_elem.next\n\n            # ----\n            # standard reverse linked list\n\n            # Reverse group [group_prev_tail.next, kth]\n            prev = group_next\n            curr = group_prev_tail.next\n\n            # Reverse group in place for nodes [0, k):\n            for _ in range(k):\n                # grab next\n                next = curr.next\n                # reverse flow\n                curr.next = prev\n                # iterate\n                prev = curr\n                curr = next\n\n            # group_prev_tail -> (new tail) of prev sub list\n            # curr -> head of next sub list\n            # prev -> (new head) of curr sub list\n            # group_prev_tail.next -> (new tail) of curr sub list\n\n            # ----\n            # connect new tail of previous sub list \n            # to new head of curr sub list\n\n            # last node of previous group, still pointing to original head,\n            # which is now the tail \n            curr_tail = group_prev_tail.next\n            \n            # point last node of previous group, to new head of curr sub list\n            group_prev_tail.next = prev\n            # update last node of previous group, to last node of curr sub list\n            group_prev_tail = curr_tail\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
      "questionNumber": 25,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-iterative---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "33": [
    {
      "number": 1,
      "name": "Inequality Boundaries Discard Mid Binary Search",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "def search(self, nums: List[int], target: int) -> int:\n        \n        # Precondition:\n        # num is non empty list of integers\n        # num is sorted in ascending order\n        # num has been rotated\n        # num has no duplicates\n\n        # Postcondition:\n        # Returns index of target if exists\n        # Returns -1 if target does not exist\n\n        # Invariant:\n        # target, if exists, is in interval [left, right]\n        # interval [left, right] is always either \n        #   a) entirely sorted\n        #   b) contains a rotation\n        # search space halves each iteration\n\n        # outer boundaries\n        left, right = 0, len(nums) - 1\n\n        # binary target search: '<='\n        # time complexity: binary search over list n length O(log n)\n        while left <= right:\n\n            mid = (left + right) // 2 \n\n            # Check Mid\n            if nums[mid] == target:\n                return mid\n\n            # guarantees right half is sorted\n            # contains ascending range: [mid, right]\n            if nums[mid] <= nums[right]:\n                \n                # target is within range (mid, right]\n                # discard elements on left side\n                # new search interval: [mid+1, right]\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1 \n                \n                # target is not with range (mid, right]\n                # discard higher elements on right side\n                # new search interval: [left, mid-1]\n                else:\n                    right = mid - 1      \n\n            # guarantees left half is sorted\n            # contains ascending range: [left, mid]\n            else:\n\n                # target is within range [left, mid)\n                # discard on right side\n                # new search interval: [left, mid-1]\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1 \n                \n                # target is not within range [left, mid)\n                # discard elements on left side\n                # new search interval: [mid+1, right]\n                else:\n                    left = mid + 1\n\n        # Loop exited: left > right\n        # Invariant broken: no valid [left, right] remaining\n        # Target not found -> return -1\n\n        # overall: time complexity O(log n)\n        # overall: space complexity O(1)\n        return -1",
      "questionNumber": 33,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-inequality-boundaries-discard-mid-binary-search---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "36": [
    {
      "number": 1,
      "name": "Defaultdict Matrix",
      "type": "hashmap",
      "application": "representation",
      "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # space complexity: hashsets for rows, columns, and flattened boxes of n length O(n) = O(3n)\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        grids = defaultdict(set)\n\n        # time complexity: iterating over all cells (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                tmp = board[r][c]\n                if tmp != \".\":\n\n                    # indexing box sets by tuple key (r/3, c/3)\n                    gridTuple = (r // 3, c // 3)\n\n                    # time complexity: lookup operation for element to corresponding sets in constant O(1)\n                    if (tmp in rows[r] or \n                        tmp in cols[c] or \n                        tmp in grids[gridTuple] ):\n                        return False\n                    \n                    # time complexity: insert operation for new element to corresponding sets in constant O(1)\n                    cols[c].add(tmp)\n                    rows[r].add(tmp)\n                    grids[gridTuple].add(tmp)\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n)\n        return True",
      "questionNumber": 36,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-defaultdict-matrix---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "[[]] Matrix",
      "type": "hashmap",
      "application": "representation",
      "code": "def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # space complexity: hashsets for rows, columns, and flattened boxes of n length O(n) = O(3n)\n        rows = [[], [], [], [], [], [], [], [], []]\n        col = [[], [], [], [], [], [], [], [], []]\n        grids = [[], [], [], [], [], [], [], [], []]\n\n        # time complexity: iterating over all cells (r * c) O(n^2)\n        for r in range(9):\n            for c in range(9):\n                \n                tmp = board[r][c]\n                if tmp != \".\":  \n\n                    # indexing box sets by unique int calculation \n                    #  (j//3) = 0, 1, 2\n                    #  (3 * (i//3)) = 0, 3, 6\n                    #    0 1 2\n                    # 0  0 1 2\n                    # 3  3 4 5\n                    # 6  6 7 8\n                    # leads to 0-8 index indexing\n                    gridKey = (3 * (i//3)) + (j//3)\n\n                    # time complexity: lookup operation for element to corresponding sets in constant O(1)\n                    if (tmp in rows[r] or \n                        tmp in col[c]  or \n                        tmp in grids[gridKey]):\n                        return False\n\n                    # space complexity: lookup operation for new element to corresponding sets in constant O(1)\n                    col[c].append(tmp)\n                    rows[r].append(tmp)\n                    grids[gridKey].append(tmp)\n        \n        # overall: time complexity O(n^2)\n        # overall: space complexity  O(n)\n        return True",
      "questionNumber": 36,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-matrix---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "42": [
    {
      "number": 2,
      "name": "Monotonic Stack",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def trap(self, height: List[int]) -> int:\n\n        # Note: \n        # Monotonic Stack: A stack that maintains monotonic decreasing heights \n        # When monotonic decreasing rule breaks, curr height will serve as right wall,\n        # and if stack is non empty, top of stack will serve as depth, \n        # and top of stack - 1 will serve as left wall\n\n        # Monotonic stack to store indices\n        stack = []  \n        water = 0\n\n        # push and pop each bar at most once\n        # time complexity: iterate over list of n length O(n)\n        for i in range(len(height)):\n\n            # Check: stack is non empty, depth candidate exists\n            # Check: if current height[i] breaks monotonic decreasing order,\n            # will be viable to act as a right wall\n            # implies: we keep appending while monotonic decreasing stays valid\n            # implies: stack is kept in monotonic decreasing order\n            # implies: when monotonic decreasing breaks, we have found right wall\n            while stack and height[i] > height[stack[-1]]:\n                \n                # curr while loop iteration:\n                # height[i]: right wall\n                # pop stack[-1]: depth candidate\n                # peak stack[-2]: left wall\n\n                # while stack is non-empty:\n                # stack.pop() will iterate depth candidate and left wall\n                # essentially dragging the right wall over the monotonic stack, \n                # adding all possible water, with all combinations of left wall and depth candidate\n                # until a depth candidate is taller than the current right wall\n                # then we just add the right wall to the stack maintaining monotonic order\n                depthCandidateIndex = stack.pop() \n\n                # Check: if stack empty after pop, no left wall exists\n                # implies: cannot trap water, end while loop, add item to stack\n                if not stack:\n                    break\n\n                # trapped water involves the space between two walls, excluding walls\n                # width = (right - left - 1)\n\n                # After stack.pop():\n                # height[i]: right wall\n                # popped depthCandidate: depth\n                # peak stack[-1]: left wall\n                # while loop check implies: depthCandidate < height[i]\n                # monotonic stack check implies: depthCandidate < stack[-1]\n                rightWallIndex = i\n                leftWallIndex = stack[-1]\n                distance = rightWallIndex - leftWallIndex - 1\n\n                rightHeight = height[rightWallIndex]\n                depthHeight = height[depthCandidateIndex]\n                leftHeight = height[leftWallIndex]\n\n                # subtract the depth minus smaller height to get water depth\n                boundedHeight = min(rightHeight, leftHeight) - depthHeight\n\n                # add the trapped water for the current segment \n                # [5, 0, 0, 2]\n                # in this case, (0, 0, 2)\n                # would return with the left wall being 0\n                # so no water captured\n                # but then, (5, 0, 2)\n                # would return with the right wall being 5\n                # in which case we would need the distance.\n                \n                # so distance will always be 1\n                # unless we have a run of identical heights\n                water += distance * boundedHeight\n\n            # implies: monotonic decreasing is still valid\n            # implies: append height to stack\n            stack.append(i)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n) (due to the stack)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-monotonic-stack---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 3,
      "name": "Dynamic Programming",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def trap(self, height: List[int]) -> int:\n        \n        # Note:\n        # Dynamic Programming Concept:\n        # Left Maximum Array: Stores the maximum height encountered from the start up to each index i.\n        # Right Maximum Array: Stores the maximum height encountered from the end up to each index i.\n        # Avoid recomputing maximum heights repeatedly.\n\n        n = len(height)\n        if n == 0:\n            return 0\n\n        # Arrays to store max heights from the left and right\n        # leftMax[i]: Maximum height from 0 to index i\n        # rightMax[i]: Maximum height from index i to (n-1)\n        leftMax = [0] * n\n        rightMax = [0] * n\n        water = 0\n\n        # calculate left max for each bar\n        # compare previous max, with current bar height,\n        # as curr may be new max, for the curr index\n        # time complexity: iterate over list of n length O(n)\n        leftMax[0] = height[0]\n        for i in range(1, n):\n            leftMax[i] = max(leftMax[i - 1], height[i])\n\n        # calculate right max for each bar\n        # compare previous max, with current bar height,\n        # as curr may be new max, for the curr index\n        # time complexity: iterate over list of n length O(n)\n        rightMax[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            rightMax[i] = max(rightMax[i + 1], height[i])\n\n        # calculate trapped water for each bar\n        # time complexity: iterate over list of n length O(n)\n        for i in range(n):\n\n            # The water trapped above bar i is determined by the minimum between\n            # leftMax[i] and rightMax[i] minus the curr bar height\n            water += min(leftMax[i], rightMax[i]) - height[i]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-3-dynamic-programming---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 1,
      "name": "Monotonic Traversal 2 Outer/2 Inner Pointers Creating Bounds Opposite Ends Pointer Shift by BinarySearch Modification (Sorting)",
      "type": "two-pointers",
      "application": "k-pointer-variants",
      "code": "def trap(self, height: List[int]) -> int:\n\n        # Note: \n        # Outer Pointers: act as wall/side to bound inner pointers\n        # Inner Pointers: traverse inward from both ends to track height for current position\n        # Water Trapping: compare inner pointer to outer pointers wall/side to determine \n        # if theres enough depth to trap water\n\n        # Set up \"BinarySearch\" modification\n        # outer pointers\n        outerLeftMax, outerRightMax = 0, 0\n        # inner pointers\n        left, right = 0, len(height) - 1\n        water = 0\n\n        # Monotonic \"BinarySearch\" modification\n        # time complexity: two pointer iteration over list of n length O(n)\n        while left < right:\n\n            # Monotonic \"BinarySearch\" on relevant subsection\n            # implies: height[left] < height[right]\n            # case 1: [5, 0, 3, 2, 4, 6], left < right for entire array \n            # case 2: [5, 0, 3, 9, 4, 6], left < right broken at some point\n            # case 1 implies: while height[left] < height[right] \n            # and while height[left] < outerLeftMax\n            # then: water is limited by outerLeft/outerRight \n            # as water will eventually be caught by right\n            if height[left] < height[right]:\n\n                # case 1: implication broken\n                # implies: outerLeftMax < height[left] < height[right] \n                # then: update outerLeftMax             \n                if height[left] >= outerLeftMax:\n                    outerLeftMax = height[left]\n\n                # case 1: implication applies\n                # implies: height[left] < outerLeftMax < height[right]\n                else:\n                    water += outerLeftMax - height[left]\n\n                # shift pointer\n                left += 1\n\n            # implies: height[right] < height[left]\n            else:\n                \n                # case 1: implication broken\n                # implies: outerRightMax < height[right] < height[left]     \n                # then: update outerRightMax\n                if height[right] >= outerRightMax:\n                    outerRightMax = height[right]\n\n                # case 1: implication applies\n                # implies: height[right] < outerRightMax < height[left]\n                else:\n                    water += outerRightMax - height[right]\n\n                # shift pointer\n                right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return water",
      "questionNumber": 42,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-monotonic-traversal-2-outer-2-inner-pointers-creating-bounds-opposite-ends-pointer-shift-by-binarysearch-modification-sorting---two-pointersk-pointer-variants",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "49": [
    {
      "number": 1,
      "name": "Array of 26 to Tuple Key",
      "type": "hashmap",
      "application": "grouping-by-criteria",
      "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \n        # Note: Tuples in python are immutable which makes them suitable as keys for a hashmaps\n        # Lists are mutable and as such not hashable for hashmaps\n        # You should use tuples where the position carries semantic meaning. \n\n        # [26 char count tuple key -> [anagram group list], ...]\n        \n        # space complexity: stores unique m tuple keys O(m) and lists of k strings O(k), O(m * k)\n        anaGroup = {}\n\n        # time complexity: iterating over all strings O(n) \n        for word in strs:\n            \n            # space complexity: fixed-sized array for 26 lowercase letters O(1)\n            charCount = [0] * 26  \n            \n            # time complexity: counting chars in string of k length O(k)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # space complexity: fixed-size tuple of length 26 O(1)\n            key = tuple(charCount)  \n            \n            # time complexity: lookup operation of O(1) \n            if key not in anaGroup:\n                anaGroup[key] = []  \n\n            # time complexity: append operation to list O(1)\n            anaGroup[key].append(word)  \n\n\n        # overall: time complexity  O(n * k)  \n        # overall: space complexity O(m * k)\n        return list(anaGroup.values())",
      "questionNumber": 49,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-array-of-26-to-tuple-key---hashmapgrouping-by-criteria",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Array of 26 to String Key",
      "type": "hashmap",
      "application": "grouping-by-criteria",
      "code": "def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n\n        # Note: using a list to build the string key is more efficient than repeatedly appending to a string, \n        # as it avoids the overhead of creating new string objects on each append\n        # list takes O(m) time vs string append which takes O(m^2)\n\n        # space complexity: stores n tuple keys O(n) and lists of original k strings O(k), O(n * k)\n        anaGroup = {}\n\n        # time complexity: iterating over n strings O(n)\n        for word in strs:\n\n            # space complexity: fixed-sized array of 26 lowercase characters O(1)\n            charCount = [0] * 26\n            \n            # time complexity: counting characters for string k length O(k)\n            for char in word:\n                charCount[ord(char) - ord('a')] += 1\n            \n            # time complexity: creating unique char count key from fixed-sized array of 26 O(1)\n            # Using a list to build the key\n            key_parts = []\n            for count in charCount:\n                key_parts.append(str(count))\n                key_parts.append(\"#\")  # Separator\n\n            # Concatenate once at the end\n            key = ''.join(key_parts)\n\n            # time complexity: lookup operation for key O(1)\n            if key not in anaGroup:\n                anaGroup[key] = []  # Initialize list for key if doesn't exist\n            anaGroup[key].append(word)  # Add word to corresponding key group\n\n        # overall: time complexity\n        # overall: space complexity \n        return list(anaGroup.values())",
      "questionNumber": 49,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-26-to-string-key---hashmapgrouping-by-criteria",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "74": [
    {
      "number": 1,
      "name": "Flattened Matrix by Index To Coordinates Binary Search",
      "type": "binary-search",
      "application": "searching",
      "code": "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \n        # Note:\n        # Treats the 2D matrix as a sorted 1D array by flattening indices.\n        # Uses binary search on the 1D index space,\n        # and converts indices to 2D coordinates with the helper function.\n        # This approach runs in O(log(m * n)) time and O(1) space.\n        \n        # Precondition:\n        # Each row is sorted in ascending order,\n        # and first element of each row is greater than the last of the previous row\n\n        # diagram:\n        # matrix = [\n        # col 0   1   2\n        #   [ 1,  3,  5],   # row 0\n        #   [ 7,  9, 11],   # row 1\n        #   [13, 15, 17],   # row 2\n        # ] \n\n        # Invariant:\n        # Target, if it exists, lies within subarray [left, right]\n        # Search space is reduced by half on each iteration.\n\n        # Helper: Convert 1D index to 2D matrix coordinates (row, col)\n        # index 4 -> (4//3, 4%3) -> (1, 1) = 9, index 5 -> (5//3, 5%3) -> (1, 2) = 11\n        def index_to_coords(index, cols) -> tuple[int, int]:\n            row = index // cols\n            col = index % cols\n            return (row, col)\n\n        # Empty Check\n        if not matrix or not matrix[0]:\n            return False\n\n        # calculate 2D matrix representation\n        rows, cols = len(matrix), len(matrix[0])\n        left, right = 0, (rows * cols) - 1\n\n        # binary target search: '<='\n        # time complexity: binary search on flattened 2D matrix [0,(m*n)-1] O(log(m*n))\n        while left <= right:\n            \n            # calculating mid\n            mid = (left + right) // 2\n            (row, col) = index_to_coords(mid, cols)\n            mid_value = matrix[row][col]\n\n            # Check Mid\n            if mid_value == target:\n                return True\n            \n            # mid is less than target:\n            # discard left side of [left, mid, right]\n            # new search interval: [mid+1, right]\n            elif mid_value < target:\n                left = mid + 1\n            \n            # mid is greater than target:\n            # discard the right side of [left, mid, right]\n            # new search interval: [left, mid-1]\n            else:\n                right = mid - 1\n\n        # left > right: searched entire array\n        # target not found and does not exist\n\n        # overall time complexity: O(log (m * n))\n        # overall space complexity: O(1)\n        return False",
      "questionNumber": 74,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-flattened-matrix-by-index-to-coordinates-binary-search---binary-searchsearching",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 2,
      "name": "Two Phase Binary Search over Row Ranges and Binary Search in Row Candidate",
      "type": "binary-search",
      "application": "searching",
      "code": "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \n        # Note:\n        # Performs two separate binary searches:\n        # 1. Binary Search over rows to locate potential row\n        # 2. Binary Search within that row to find the target\n        \n        # Precondition:\n        # Each row is sorted in ascending order,\n        # and the first element of each row is greater than the last of the previous row\n\n        # diagram:\n        # matrix = [\n        # col 0   1   2\n        #   [ 1,  3,  5],   # row 0\n        #   [ 7,  9, 11],   # row 1\n        #   [13, 15, 17],   # row 2\n        # ]\n\n        # Invariant (First Binary Search):\n        # Target must lie within range of candidate row window [top, bottom] (if it exists)\n\n        # Empty Check\n        if not matrix or not matrix[0]:\n            return False\n\n        # top and bottom rows (refer to diagram)\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom = 0, rows - 1\n\n        # binary target search: '<='\n        # time complexity: binary search over n rows O(log n)\n        while top <= bottom:\n\n            # get mid\n            mid_row = (top + bottom) // 2\n\n            # Check Mid\n            if matrix[mid_row][0] <= target <= matrix[mid_row][-1]:\n                break\n\n            # mid_row smallest value is greater than target:\n            # discard upper rows\n            # new search interval: [top, mid_row - 1]\n            elif matrix[mid_row][0] > target:\n                bottom = mid_row - 1\n\n            # mid_row smallest value is less than target:\n            # discard lower rows\n            # new search interval: [mid_row + 1, bottom]\n            else:\n                top = mid_row + 1\n\n        # No break triggered:\n        # top > bottom: all row ranges checked\n        # no target exists\n        else:\n            return False\n            \n        # row boundaries\n        row = mid_row\n        left, right = 0, cols - 1\n\n        # binary target search: '<='\n        # time complexity: binary search across m columns in row O(log m)\n        while left <= right:\n\n            # mid of row\n            mid_col = (left + right) // 2\n            \n            # Check mid\n            if matrix[row][mid_col] == target:\n                return True\n            \n            # mid is less than target:\n            # discard left side of [left, mid, right]\n            # new search interval: [mid + 1, right]\n            elif matrix[row][mid_col] < target:\n                left = mid_col + 1\n            \n            # mid is greater than target:\n            # discard right side of [left, mid, right]\n            # new search interval: [left, mid - 1]\n            else:\n                right = mid_col - 1\n\n\n        # left > right: all columns in candidate row checked\n        # no target exists\n\n        # overall: time complexity O(log (m * n)) \n        # overall: space complexity O(1)\n        return False",
      "questionNumber": 74,
      "solutionLink": "/Notes/leetcode-binary-search#solution-2-two-phase-binary-search-over-row-ranges-and-binary-search-in-row-candidate---binary-searchsearching",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "76": [
    {
      "number": 1,
      "name": "Classic Sliding Window with Two Hashmaps",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def checkInclusion(self, s1: str, s2: str) -> bool:\n\n        # Note:\n        # 1. Uses two hashmaps:\n        # 2. Expands right pointer until all required chars are included\n        # 3. Shifts left pointer to shrink window while maintaining validity\n        # 4. Tracks smallest valid window found so far\n        # Result: returns smallest substring containing all chars of t or \"\"\n\n        # t len > s len: substring not possible\n        if len(t) > len(s):\n            return \"\"\n\n        # t char count\n        target_freq = defaultdict(int)\n        for char in t:\n            target_freq[char] += 1\n\n        # sliding window char count\n        window_freq = defaultdict(int)\n\n        # Number of unique chars from t needed  \n        need = len(target_freq)     \n\n        # Number of chars from t that meet the required count\n        have = 0                          \n\n        # min substring\n        min_len = float(\"inf\")\n\n        # Variable Sliding Window => [left, right]\n        left = 0\n\n        # \n        res_start = 0\n\n        # time complexity: iterate right over list s of n length O(n)\n        for right in range(len(s)):\n\n            # extending window, update char count\n            char = s[right]\n            window_freq[char] += 1\n\n            # Check if this character satisfies the required t frequency\n            if char in target_freq and window_freq[char] == target_freq[char]:\n                have += 1\n\n            # shrink window while frequencies are valid\n            while have == need:\n                \n                # curr window\n                window_len = right - left + 1\n                \n                # update min length, mark start of min window\n                if window_len < min_len:\n                    min_len = window_len\n                    res_start = left\n\n                # reduce char count and shrink window\n                left_char = s[left]\n                window_freq[left_char] -= 1\n                \n                # check if frequencies are valid\n                if left_char in target_freq and window_freq[left_char] < target_freq[left_char]:\n                    have -= 1\n\n                # iterate\n                left += 1\n\n        # if at least one valid sub string exists, return\n        if min_len != float(\"inf\"):\n            res = s[res_start:res_start + min_len]\n\n        # no sub string found, return \"\"\n        else: \n            res = \"\"\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
      "questionNumber": 76,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-classic-sliding-window-with-two-hashmaps---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 2,
      "name": "Single Hashmap + Remaining Required Tracker",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def minWindow(self, s1: str, s2: str) -> bool:\n\n        # Note:\n        # 1. Single hashmap to track remaining required chars\n        # 2. Expands right pointer while decreasing count of matched chars\n        # 3. When all chars matches, contracts left pointer\n        # 4. Tracks smallest window\n        # 5. Returns smallest substring containing all chars of t (or \"\" if none)\n\n        # t len > s len: substring not possible\n        if len(s) < len(t):\n            return \"\"\n\n        # t char count\n        char_count = defaultdict(int)\n        for ch in t:\n            char_count[ch] += 1\n\n        # Total num of characters (with duplicates) still needed\n        target_chars_remaining = len(t)         \n\n        # (start_index, end_index)\n        min_window = (0, float(\"inf\"))          \n\n        # Left pointer\n        start_index = 0                         \n\n        # time complexity: iterate right over s2 of n length O(n)\n        for end_index, ch in enumerate(s):\n\n            # Expand right\n            if char_count[ch] > 0:\n                # One needed character matched\n                target_chars_remaining -= 1     \n\n            # Always decrement (can go negative)\n            char_count[ch] -= 1                 \n\n            # Once we have matched all characters\n            if target_chars_remaining == 0:\n                # Shrink from left as much as possible\n                while True:\n                    char_at_start = s[start_index]\n                    if char_count[char_at_start] == 0:\n                        break                   # Cannot remove this char without breaking\n                    char_count[char_at_start] += 1\n                    start_index += 1\n\n                # Check if current window is smaller\n                if end_index - start_index < min_window[1] - min_window[0]:\n                    min_window = (start_index, end_index)\n\n                # Shrink window by 1 to move forward\n                char_count[s[start_index]] += 1\n                target_chars_remaining += 1\n                start_index += 1\n\n        # Extract window if found\n        if min_window[1] > len(s):\n            res = \"\"\n        else: \n            res = s[min_window[0]:min_window[1]+1]\n\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
      "questionNumber": 76,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-2-single-hashmap-remaining-required-tracker---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "84": [
    {
      "number": 1,
      "name": "Double Dragging Forward Iteration Monotonic Increasing of Higher Bar Height Index",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def largestRectangleArea(self, heights: List[int]) -> int:\n\n        # \"we keep popping as long as the current small height candidate\n        #  is still covered by the taller bars before it,\n        #  which means that either:\n        #  1. the stack gets completely popped, which means the small height candidate\n        #     is the smallest height encountered, so it spans from 0 -> i, which is\n        #     a width of i\n        #  2. there is a left height on the stack, a tall wall which we can drag up until\n        #     the small height candidate, since we know all popped walls were taller than\n        #     this current left height, so we can do i - left index - 1\n        \n        # Note:\n        # Monotonic stack: A stack that maintains monotonic increasing heights\n        # When monotonic increasing rule breaks, curr height will serve as right boundary\n        # If stack is non empty, that means we have a stack full of tall bars.\n        # Each popped bar acts as as the height of a rectangle. \n        # The width of the rectangle is determined by the distance \n        # to the previous smaller bar, the left boundary \n\n        # Note: \n        # Sentinel: \n        # Given that are trigger for the area check is that we have found the tallest wall\n        # when the monotonic increasing rule has broken\n        # we need to add a height wall of 0 at the end of the heights array as a sentinel\n        # so that it triggers and checks the last valid height\n\n        # Space complexity: stores heights for up to n heights O(n)\n        stack = []\n        max_area = 0\n\n        # Sentinel: 0-height bar to trigger monotonic increasing rule break\n        heights.append(0)\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(len(heights)):\n\n            # Check: if current bar breaks monotonic increasing order\n            # First Implies: First time this triggers, tallest bar found so far is on stack[-1]\n            # Invariant Implies: There is a tall wall at stack[-1], which is covered by \n            #  previously popped tall walls\n            while stack and heights[stack[-1]] > height[i]:\n                \n                # grab tall bar index and height\n                tallWallIndex = stack.pop()\n                tallWall = heights[tallWallIndex]\n\n                # if stack is empty\n                # smallest height popped off all other heights\n                # so we are guaranteed width of 0 through i, width length of i\n                if not stack:\n                    width = i\n\n                # stack is not empty\n                # current tallWall is bounded by the left wall in distance\n                # -1 is to account for the left wall\n                else:\n                    leftWallIndex = stack[-1]\n                    width = i - leftWallIndex - 1\n\n                # check new max area\n                max_area = max(max_area, tallWall * width)\n\n            # monotonic increasing is maintained: \n            # curr height is no longer covered by the tall bars, add to stack \n            stack.append(i)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return max_area",
      "questionNumber": 84,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-double-dragging-forward-iteration-monotonic-increasing-of-higher-bar-height-index---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "Double Dragging Reverse Iteration Monotonic Increasing of Higher Bar Height Index",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def largestRectangleArea(self, heights: List[int]) -> int:\n        \n        n = len(heights)\n        max_area = 0\n\n        # We process from right to left, so we reverse the indices\n        stack = []\n\n        # Sentinel: iteration through -1\n        # time complexity: iterate over list of n length O(n)\n        for i in range(n-1, -2, -1):\n\n            # Sentinel: append a sentinel index of -1, height of 0\n            curr_height = 0 if i == -1 else heights[i]\n\n            # maintain monotonic increasing height\n            while stack and heights[stack[-1]] > curr_height:\n\n                # monotonic increasing broken, pop until true again\n                index = stack.pop()\n                height = heights[index]\n\n                # if stack is empty\n                # small height popped all taller walls\n                # so current height extends from i to (n-1)\n                if not stack:\n                    width = (n - 1) - i\n                \n                # if stack is not empty\n                # the width is bounded from i to the right wall\n                # right wall is currently on the stack on stack[-1]\n                # -1 is to account for the right wall\n                else:\n                    rightWall = stack[-1]\n                    width = (rightWall - 1) - i\n\n                # check new area\n                max_area = max(max_area, height * width)\n\n            # if non-sentinel index, append\n            if i >= 0:\n                stack.append(i)\n\n        # overall: time complexity \n        # overall: space complexity\n        return max_area",
      "questionNumber": 84,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-double-dragging-reverse-iteration-monotonic-increasing-of-higher-bar-height-index---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    }
  ],
  "98": [
    {
      "number": 1,
      "name": "DFS with Range Limits",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        # Helper DFS function with valid value range constraints\n        def dfs(node, low, high):\n            if not node:\n                return True  # Reached leaf, no violations\n\n            # If current node violates BST property -> invalid\n            if not (low < node.val < high):\n                return False\n\n            # Left subtree must have values < node.val\n            # Right subtree must have values > node.val\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\n\n        # Start with infinite bounds\n        return dfs(root, float('-inf'), float('inf'))",
      "questionNumber": 98,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-with-range-limits---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Pre Order Right-to-Left First Depth Capture",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        self.prev = None  # Stores last visited node value\n\n        def inorder(node):\n            if not node:\n                return True\n\n            # Inorder: Left -> Node -> Right\n            if not inorder(node.left):\n                return False\n\n            # Current node must be greater than previous inorder value\n            if self.prev is not None and node.val <= self.prev:\n                return False\n            self.prev = node.val\n\n            return inorder(node.right)\n\n        return inorder(root)",
      "questionNumber": 98,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-right-to-left-first-depth-capture---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "100": [
    {
      "number": 2,
      "name": "BFS Iterative",
      "type": "tree",
      "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "code": "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # Note:\n        # BFS Iterate: level by level\n        # 1. Process root ->\n        #    pop() left and right nodes\n        #    if both nodes are 'None' -> trees match\n        #    if only one node is 'None' -> trees differ\n        #    if values mismatch -> trees differ\n        # 2. Process -> left -> right\n        # Result: validate tree match \n        \n        # iterative stack\n        # process root1 -> and root2 ->\n        queue = deque([(p, q)])\n        \n        while queue:\n\n            # pop() left and right nodes\n            node1, node2 = queue.popleft()\n            \n            # Process root -> : both nodes are 'None'\n            if not node1 and not node2:\n                continue\n            \n            # Process root -> : only one node is 'None' \n            if not node1 or not node2\n                return False\n            \n            # Process root -> : values differ\n            if node1.val != node2.val:\n                return False\n            \n            # process -> left -> right\n            queue.append((node1.left, node2.left))\n            queue.append((node1.right, node2.right))\n        \n        # overall: time complexity\n        # overall: space complexity\n        return True",
      "questionNumber": 100,
      "solutionLink": "/Notes/leetcode-trees#solution-2-bfs-iterative---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 1,
      "name": "DFS Pre Order Recursive Pass Node Match Down",
      "type": "tree",
      "application": "dfs-pre-order-recursive-one-sided-top-down",
      "code": "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order recursive: root -> left -> right\n        # 2. Process root -> :\n        #    if both nodes are 'None' -> trees match\n        #    if only one node is 'None' -> trees differ\n        #    if values mismatch -> trees differ\n        # 3. Process -> left -> right :\n        # Result: validate tree match \n        \n        # Process root -> : both nodes are 'None'\n        if not p and not q:\n            return True\n\n        # Process root -> : only one node is 'None' \n        if not p or not q:\n            return False\n\n        # Process root -> : values differ\n        if p.val != q.val:\n            return False\n        \n        # Process left -> right\n        left_match = self.isSameTree(p.left, q.left)\n        right_match = self.isSameTree(p.right, q.right)\n\n        # Process left -> right : pass left and right match upwards\n        match = left_match and right_match\n        \n        # overall: time complexity\n        # overall: space complexity\n        return match",
      "questionNumber": 100,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive-pass-node-match-down---treedfs-pre-order-recursive-one-sided-top-down",
      "blog": "LeetCode: Trees"
    }
  ],
  "102": [
    {
      "number": 1,
      "name": "BFS Iterative",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Empty check\n        if not root:\n            return []\n        \n        groups = []\n        queue = deque([root])  # start with root\n        \n        while queue:\n            # grab size of current level\n            size = len(queue)\n            level = []\n            \n            # process each node in this level\n            for _ in range(size):\n                node = queue.popleft()\n                level.append(node.val)\n                \n                # enqueue children for next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            groups.append(level)\n        \n        return groups",
      "questionNumber": 102,
      "solutionLink": "/Notes/leetcode-trees#solution-1-bfs-iterative---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Pre Order Recursive",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        groups = []\n        \n        def dfs(node, depth):\n            if not node:\n                return\n            \n            # expand groups list if new depth reached\n            if len(groups) == depth:\n                groups.append([])\n            \n            groups[depth].append(node.val)\n            \n            # recurse left and right children\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n        \n        dfs(root, 0)\n        return groups",
      "questionNumber": 102,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-recursive---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "104": [
    {
      "number": 1,
      "name": "DFS Post Order Recursive Pass Up Subtree Depth",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # DFS post order traversal: left -> right -> root\n        # 1. Process left -> right: subtrees\n        # 2. Process -> root: by max(left_subtree, right_subtree)\n        # Result: max depth of tree\n        \n        # Base case:\n        # leaf -> depth of 0\n        if not root:\n            return 0\n        \n        # process left -> right ->\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        \n        # could have been: right -> left ->\n        # right_depth = self.maxDepth(root.right)\n        # left_depth = self.maxDepth(root.left)\n\n        # process -> root\n        return 1 + max(left_depth, right_depth)",
      "questionNumber": 104,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-pass-up-subtree-depth---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Post Order Iterative Pass Up Subtree Depth",
      "type": "tree",
      "application": "dfs-post-order-iterative-two-sided-bottom-up",
      "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # DFS post order traversal: left -> right -> root\n        # 1. Process left -> right: subtrees\n        # 2. Process -> root: by max(left_subtree, right_subtree)\n        # Result: max depth of tree\n        \n        if not root:\n            return 0\n\n        stack = []\n        depth_map = defaultdict(int)\n        max_depth = 0\n        node = root\n        last_visited = None\n\n        while stack or node:\n            # Go as far left as possible\n            while node:\n                stack.append(node)\n                node = node.left\n            \n            peek = stack[-1]\n\n            # If right child exists and hasn't been processed yet, go right\n            if peek.right and last_visited != peek.right:\n                node = peek.right\n            else:\n                # Process the node (post-order)\n                stack.pop()\n                \n                left_depth = depth_map[peek.left]\n                right_depth = depth_map[peek.right]\n                current_depth = 1 + max(left_depth, right_depth)\n\n                depth_map[peek] = current_depth\n                max_depth = max(max_depth, current_depth)\n\n                last_visited = peek\n                node = None  # prevent going left again\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_depth",
      "questionNumber": 104,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-post-order-iterative-pass-up-subtree-depth---treedfs-post-order-iterative-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 3,
      "name": "DFS Pre Order Iterative Throw Down Tuple (Root, Depth)",
      "type": "tree",
      "application": "dfs-pre-order-iterative-one-sided-top-down",
      "code": "# Note:\n    # DFS pre order iterative: root -> left -> right\n    # 1. Process root -> : check current depth against max_depth\n    # 2. Process -> left -> right : continue incrementing depth down both subtrees\n    # Result: deepest branch updates global max_depth\n    \n    # Empty check\n    if not root:\n        return 0\n    \n    # iterative stack\n    stack = [(root, 1)]\n\n    # global depth\n    max_depth = 0\n    \n    while stack:\n\n        # process root -> : (node, node_depth)\n        node, depth = stack.popleft()\n        \n        # check node depth against max_depth\n        max_depth = max(max_depth, depth)\n        \n        # append process left and right subtrees: increment depth by + 1\n        if node.left:\n            stack.append((node.left, depth+1))\n        if node.right:\n            stack.append((node.right, depth+1))\n    \n    # overall: time complexity\n    # overall: space complexity\n    return max_depth",
      "questionNumber": 104,
      "solutionLink": "/Notes/leetcode-trees#solution-3-dfs-pre-order-iterative-throw-down-tuple-root-depth---treedfs-pre-order-iterative-one-sided-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 4,
      "name": "BFS Pre Order Iterative Full Level Each Node Count Level Number",
      "type": "tree",
      "application": "bfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
      "code": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # BFS iterative: full across level, (node -> node -> ...)\n        # 1. Process level: pop() all nodes in current level\n        # 2. Increment depth count\n        # Result: depth is total of levels -> max depth \n        \n        # Empty check\n        if not root:\n            return 0\n        \n        # iterative stack\n        queue = deque([root])\n\n        # global depth\n        depth = 0\n        \n        while queue:\n\n            # level size\n            size = len(queue)\n\n            # process all nodes in current level\n            for _ in range(size):\n\n                # pop() all nodes\n                node = queue.popleft()\n\n                # append() subtrees belonging to next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            # level processed, add to depth counter\n            depth += 1\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return depth",
      "questionNumber": 104,
      "solutionLink": "/Notes/leetcode-trees#solution-4-bfs-pre-order-iterative-full-level-each-node-count-level-number---treebfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    }
  ],
  "105": [
    {
      "number": 1,
      "name": "Recursive Build with Hash Map",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        # Step 1: Map each value to its index in inorder for O(1) lookups\n        inorder_index_map = {val: idx for idx, val in enumerate(inorder)}\n\n        # Step 2: Preorder index pointer (to track root positions)\n        self.pre_idx = 0\n\n        def array_to_tree(left, right):\n            # Base case: no elements to construct the subtree\n            if left > right:\n                return None\n\n            # Step 3: Get root value from preorder\n            root_val = preorder[self.pre_idx]\n            self.pre_idx += 1\n\n            # Create the root node\n            root = TreeNode(root_val)\n\n            # Step 4: Recursively build left & right subtrees\n            root.left = array_to_tree(left, inorder_index_map[root_val] - 1)\n            root.right = array_to_tree(inorder_index_map[root_val] + 1, right)\n\n            return root\n\n        # Step 5: Build the tree from full range\n        return array_to_tree(0, len(inorder) - 1)",
      "questionNumber": 105,
      "solutionLink": "/Notes/leetcode-trees#solution-1-recursive-build-with-hash-map---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "Iterative Using Stack",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        stack = [root]\n        inorder_index = 0\n        \n        for i in range(1, len(preorder)):\n            node = stack[-1]\n            preorder_val = preorder[i]\n            \n            # If the last node in stack is not equal to current inorder,\n            # then the next preorder value is in the left subtree.\n            if node.val != inorder[inorder_index]:\n                node.left = TreeNode(preorder_val)\n                stack.append(node.left)\n            else:\n                # Otherwise, pop nodes from the stack while the node's value\n                # matches inorder and move inorder_index forward.\n                while stack and stack[-1].val == inorder[inorder_index]:\n                    node = stack.pop()\n                    inorder_index += 1\n                \n                # The next preorder value is the right child of the last popped node\n                node.right = TreeNode(preorder_val)\n                stack.append(node.right)\n        \n        return root",
      "questionNumber": 105,
      "solutionLink": "/Notes/leetcode-trees#solution-2-iterative-using-stack---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "110": [
    {
      "number": 1,
      "name": "DFS Post Order Recursive Pass Height Upwards",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right -> :\n        # 2. Process -> root : validate if balanced, throw -1 imbalance error\n        # Results: detect imbalance\n\n        def dfs(node):\n\n            # Base case: pass height upwards\n            if not node:\n                return 0\n            \n            # process left -> right ->\n            left_height = dfs(node.left)\n            right_height = dfs(node.right)\n\n            # pass thrown error upwards\n            if left_height == -1:\n                return -1         \n            if right_height == -1:\n                return -1\n            \n            # process -> root : validate balanced left and right subtrees\n            if abs(left_height - right_height) > 1:\n                return -1\n            \n            # process -> root : add to height and pass to root's parent\n            return 1 + max(left_height, right_height)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return dfs(root) != -1",
      "questionNumber": 110,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-pass-height-upwards---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Post Order Recursive Pass Height Error Tuple Upwards",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right ->\n        # 2. Process -> root : validate if balanced, throw -1 imbalance error\n        # Results: detect imbalance\n        \n        def dfs(node):\n\n            # Base case: leaf -> (balanced:True, height:0)\n            if not node:\n                return (0, True)\n            \n            # Process left -> right -> (is_balanced, height)\n            (left_height, left_bal) = dfs(node.left)\n            (right_height, right_bal) = dfs(node.right)\n\n            # pass thrown error upwards\n            if not left_bal:\n                return (-1, False)\n            if not right_bal:\n                return (-1, False)\n            \n            # process -> root : validate balanced left and right subtrees\n            is_root_balanced = abs(left_height - right_height) <= 1\n\n            # process -> root : add to height and pass to root's parent\n            root_height = 1 + max(left_height, right_height)\n\n            return (root_height, is_root_balanced)\n        \n        # overall: time complexity\n        # overall space complexity\n        return dfs(root)[1]",
      "questionNumber": 110,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-post-order-recursive-pass-height-error-tuple-upwards---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    }
  ],
  "121": [
    {
      "number": 1,
      "name": "Explicit Sliding Window Tracking Min Price and Max Profit",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # Variable Size Sliding Window => [left, right]\n        # 1. left points to day we buy (lowest price so far)\n        # 2. right scans forward best profit day (highest sell price -> highest profit)\n        # 3. Get profit:\n        #    if prices[left] < prices[right]: profit possible, update max_profit\n        #    if prices[left] > prices[right]: lower buy found, update left\n        # Result: finds lowest buy and highest profit\n\n        # Lowest buy price day index, curr sell price day index\n        left, right = 0, 1\n\n        # max profit so far\n        max_profit = 0\n\n        # time complexity: iterate over list of n days\n        while right < len(prices):\n\n            # curr day higher than min\n            if prices[left] < prices[right]:\n                \n                # calculate possible profit, update max_profit\n                profit = prices[right] - prices[left]\n                max_profit = max(max_profit, profit)\n\n            # curr day lower than min\n            else:\n                left = right\n\n            # iterate curr day\n            right += 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
      "questionNumber": 121,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-sliding-window-tracking-min-price-and-max-profit---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 2,
      "name": "Implicit Sliding Window Tracking Min Price and Max Profit",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxProfit(self, prices: List[int]) -> int:\n        \n        # Note:\n        # Variable Size Sliding Window => [left, right]\n        # 1. left points to day we buy (lowest price so far)\n        # 2. right scans forward for best profit day (highest sell price -> highest profit)\n        # 3. Get profit:\n        #    if prices[left] < prices[right]: profit possible, update max_profit\n        #    if prices[left] > prices[right]: lower buy found, update left\n        # Result: finds lowest buy and highest profit\n        \n        # Lowest Buy Day so far (+inf)\n        left = float('inf')\n        \n        # max profit so far\n        max_profit = 0\n\n        # time complexity: iterate over list of n prices O(n)\n        for right in prices:\n\n            # profit possible\n            if left < right:\n                profit = right - left\n                max_profit = max(max_profit, profit)\n\n            # new min buy day found\n            else:\n                left = right\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
      "questionNumber": 121,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-2-implicit-sliding-window-tracking-min-price-and-max-profit---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 3,
      "name": "Table Dynamic Programming",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # 1. DP[i][0] = highest profit so far\n        #    DP[i][1] = lowest buy price so far\n        # 2. At each day update [0] and [1]:\n        #    [0] = max(highest profit so far, profit from using lowest buy price so far against today sell price)\n        #    [1] = min(lowest buy price so far, todays buy price)\n    \n        # Empty check\n        if not prices:\n            return 0\n\n        n = len(prices)\n\n        # 2D array of n rows with 2 columns\n        # [i][0] -> max profit at day i\n        # [i][1] -> min buying price at day i\n        dp = [[0]*2 for _ in range(n)]\n\n        # set up dynamic programming table first iteration:\n\n        # min price up to day 0\n        dp[0][0] = -prices[0]\n        # max profit up to day 0\n        dp[0][1] = 0\n\n\n        # time complexity: iterate across n days for prices O(n)\n        for i in range(1, n):\n\n            # update min price\n            dp[i][0] = max(dp[i-1][0], -prices[i])            \n            # update max profit\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return dp[-1][1]",
      "questionNumber": 121,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-3-table-dynamic-programming---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 4,
      "name": "State Compression Dynamic Programming",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxProfit(self, prices: List[int]) -> int:\n\n        # Note:\n        # 1.  Compress DP O(n) table to O(1)\n        #     min_price = min price up to day i\n        #     max_profit = max profit up to day i\n        # # 2. At each day update min and max:\n        #     min_price = min(lowest price so far vs todays buy price)\n        #     max_profit = max(highest profit so far vs profit from todays sell price - lowest buy price)\n        # Result: Max profit at day n\n\n        n = len(prices)\n\n        # set up compressed dynamic programming table first iteration:        \n        # [i][0] -> min buying price up to day i\n        # [i][1] -> max profit up to day i\n\n        # min price up to day 0\n        min_price = -prices[0]\n        # max profit up to day 0\n        max_profit = 0\n\n\n        # time complexity: iterate over n day prices O(n)\n        for i in range(1, n):\n            \n            # update compressed dp table, (for up to day i)\n          \n            # update min price\n            min_price = max(min_price, -prices[i])\n            # update max profit\n            max_profit = max(max_profit, min_price + prices[i])  \n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_profit",
      "questionNumber": 121,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-4-state-compression-dynamic-programming---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "124": [
    {
      "number": 1,
      "name": "DFS Post-Order + Global Max Tracker",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        max_sum = float('-inf')\n\n        def dfs(node):\n            nonlocal max_sum\n\n            if not node:\n                return 0\n\n            # Get max gain from left and right subtree; ignore negative gains by max with 0\n            left_gain = max(dfs(node.left), 0)\n            right_gain = max(dfs(node.right), 0)\n\n            # Current max path including both children and current node\n            current_path_sum = node.val + left_gain + right_gain\n\n            # Update global max sum if current path is better\n            max_sum = max(max_sum, current_path_sum)\n\n            # Return max gain to parent (single path)\n            return node.val + max(left_gain, right_gain)\n\n        dfs(root)\n        return max_sum",
      "questionNumber": 124,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-global-max-tracker---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "125": [
    {
      "number": 1,
      "name": "Slicing Traversing in Reverse Order",
      "type": "two-pointers",
      "application": "algorithm",
      "code": "def isPalindrome(self, s: str) -> bool:\n        \n        # space complexity: cleaned version of string of n length O(n)\n        phrase = \"\"\n\n        # time complexity: iterate over string of n length O(n)\n        for c in s:\n            if c.isalnum():\n                phrase += c.lower()\n        \n        # slicing\n        # [start:stop:step]\n        # [::-1]\n        # here start and stop are omitted, so the slice includes the entire sequence\n        # step is -1, which indicates that sequences should be traversed in reverse order\n\n        # phrase is traversed left to right\n        # phrase[::-1] is traversed right to left\n        return phrase == phrase[::-1]",
      "questionNumber": 125,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-slicing-traversing-in-reverse-order---two-pointersalgorithm",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Pre Clean Opposite Ends Comparison",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def isPalindrome(self, s: str) -> bool:\n        \n        # space complexity: cleaned version string of n length O(n)\n        cleaned = []\n\n        # isAlphaNum check using ord()\n        def isAlphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        def isUpper(c):\n            return ord('A') <= ord(c) <= ord('Z')\n\n        def toLower(c):\n            return chr(ord(c) + 32)\n\n        # time complexity: iterate over string of n length O(n)\n        for c in s:\n\n            # skip until isAlphaNum char\n            if isAlphaNum(c):\n                \n                # Convert to lowercase char\n                if isUpper(c):\n                    cleaned.append(toLower(c))\n                else:\n                    cleaned.append(c)\n\n        # clean is now lowercase alphaNum\n        # compare using left and right pointers\n        # time complexity: iterate over list of n length O(n)\n        left, right = 0, len(cleaned) - 1\n        while left < right:\n            if cleaned[left] != cleaned[right]:\n                return False\n            left += 1\n            right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return True",
      "questionNumber": 125,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-pre-clean-opposite-ends-comparison---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 3,
      "name": "In Place Opposite Ends Comparison",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def isPalindrome(self, s: str) -> bool:\n\n        # isAlphaNum check using ord()\n        def isAlphaNum(c):\n            return (ord('A') <= ord(c) <= ord('Z') or \n                    ord('a') <= ord(c) <= ord('z') or \n                    ord('0') <= ord(c) <= ord('9'))\n\n        def isUpper(c):\n            return ord('A') <= ord(c) <= ord('Z')\n\n        def toLower(c):\n            return chr(ord(c) + 32)\n\n        # space complexity: no additional space used for storage O(1)\n        left, right = 0, len(s) - 1\n\n        # time complexity: iteration over string of n length O(n)\n        while left < right:\n            \n            # time complexity: move left and right to isAlphaNum char O(n)\n            while left < right and not isAlphaNum(s[left]):\n                left += 1\n            while left < right and not isAlphaNum(s[right]):\n                right -= 1\n\n            # Convert left and right to lowercase char\n            leftChar = s[left]\n            rightChar = s[right]\n\n            if isUpper(leftChar):\n                leftChar = toLower(leftChar)\n            if isUpper(rightChar):\n                rightChar = toLower(rightChar)\n\n            # Compare left and right char\n            if leftChar != rightChar:\n                return False\n\n            # move pointers\n            left += 1\n            right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 125,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-3-in-place-opposite-ends-comparison---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "128": [
    {
      "number": 1,
      "name": "HashMap Continent Boundaries",
      "type": "hashmap",
      "application": "representation",
      "code": "def longestConsecutive(nums: List[int]) -> int:\n        \n        # space complexity: hashmap of list of n length O(n)\n        seqLen = defaultdict(int)\n        longest = 0\n\n        # Handle duplicates\n        nums = set(nums)  \n\n        # Iterate over unique numbers\n        for num in nums:\n            # Skip if num is already part of an existing sequence\n            # Fetch lengths of neighboring sequences\n            leftContinentLenFromBoundary = seqLen[num - 1]\n            rightContinentLenFromBoundary = seqLen[num + 1]\n\n            # Calculate new sequence length\n            bridgedLen = 1 + leftContinentLenFromBoundary + rightContinentLenFromBoundary\n\n            # Update new continent boundaries\n            seqLen[num - leftContinentLenFromBoundary] = bridgedLen\n            seqLen[num + rightContinentLenFromBoundary] = bridgedLen\n\n            # Update the global max\n            longest = max(longest, bridgedLen)\n\n        return longest",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap-continent-boundaries---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Set Rummy Run",
      "type": "hashmap",
      "application": "representation",
      "code": "def longestConsecutive(self, nums: List[int]) -> int: \n    \n    # space complexity: set for list of n length O(n)\n    numSet = set(nums)\n    longest = 0\n\n    # time complexity: iterate over list of n length O(n)\n    for num in numSet:\n\n        # found start of a run\n        # time complexity: lookup operation takes constant O(1)\n        if (num - 1) not in numSet: \n\n            # rummy run until missing an element\n            currLen = 1\n            # time complexity: iterate over m sequence worst case n sequence O(n), lookup O(1), leading to O(n)\n            while (num + currLen) in numSet:\n                currLen += 1 \n\n            # validate with global max sequence\n            longest = max(longest, currLen)\n\n    # overall: time complexity O(n)\n    # overall: space complexity O(n)\n    return longest",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-set-rummy-run---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 3,
      "name": "Union Find Tree",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def longestConsecutive(self, nums: List[int]) -> int:\n        \n        if len(nums) == 0:\n            return 0\n\n        # Union-Find Initialization:\n        \n        # Stores parent of each number\n        # space complexity: hashmap of size n O(n)\n        parent = {}  \n\n        # Stores the size of connected components\n        # space complexity: hashmap of size n O(n)\n        size = {}    \n\n        # Find operation with path compression\n        # time complexity: Amortized O(α(n)) per operation\n        def find(x):\n\n            # if the parent of x is not itself, we have not reached the representative  \n            if parent[x] != x:\n\n                # Path compression\n                # set parent of curr, to parent of parent\n                parent[x] = find(parent[x])\n\n            # return representative of group\n            # either return self\n            # or return parent of parent\n            return parent[x]\n\n        # Union operation with size optimization\n        # time complexity: Amortized O(α(n)) per operation\n        def union(x, y):\n\n            # grab representatives of both x and y\n            rootX = find(x)\n            rootY = find(y)\n\n            # trees are not already connected\n            if rootX != rootY:\n\n                # grab tree sizes\n                xSize = size[rootX]\n                ySize = size[rootY]\n\n                # x tree is larger\n                if ySize < xSize:\n                    # attach smaller tree to larger tree\n                    parent[rootY] = rootX\n                    # add smaller tree size to larger tree\n                    size[rootX] += size[rootY]\n\n                # y tree is larger\n                else:\n                    # attach smaller tree to larger tree\n                    parent[rootX] = rootY\n                    # add smaller tree size to larger tree\n                    size[rootY] += size[rootX]\n\n        # Initialize Union-Find structure: \n        # Set all parents to self\n        # time complexity: iterate over list of n length O(n)\n        for num in nums:\n            if num not in parent:\n                parent[num] = num\n                size[num] = 1\n\n        # Join consecutive numbers: \n        # Union operation on sequences\n        # time complexity: iterate over list of n length O(n)\n        for num in nums:\n            if num + 1 in parent:\n                union(num, num + 1)\n        \n        # return largest group\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return max(size.values())",
      "questionNumber": 128,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-union-find-tree---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "138": [
    {
      "number": 1,
      "name": "Two Pass Hashmap Create Nodes and Set Next and Random Deep References",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # .get() returns 'None' if nothing exists,\n        # so perfect for our use case\n\n        # Note:\n        # 1. Traverse once: create all nodes (no wiring of next/random yet)\n        # 2. Use a dictionary to map old nodes -> new nodes\n        # 3. Traverse Twice: wire up both next and random using the map\n        # 4. Return deep copy of head\n\n        # Empty Check\n        if not head:\n            return None\n\n        # Orig node -> deep node copy\n        orig_to_deepCopy = {}\n\n        # Iteration 1: \n        # Copy all nodes values (no next/random pointers yet)\n        curr = head\n        while curr:\n            # create\n            copy = Node(curr.val)\n            # insert\n            orig_to_deepCopy[curr] = copy\n            # iterate\n            curr = curr.next\n\n        # Iteration 2:\n        # All nodes created, now assign next and random pointers\n        curr = head\n        while curr:\n            # grab curr deepCopy\n            copy = orig_to_deepCopy[curr]\n            # grab and set next and random deepCopy (value could be None, .get() returns None by default if no answer exists)\n            copy.next = orig_to_deepCopy.get(curr.next)\n            copy.random = orig_to_deepCopy.get(curr.random)\n            # iterate\n            curr = curr.next\n\n        # Return deep copy of the head node\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return orig_to_deepCopy[head]",
      "questionNumber": 138,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-two-pass-hashmap-create-nodes-and-set-next-and-random-deep-references---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Memoization Lazy Construction One Pass Hashmap",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # 1. Maintain a memo dictionary to store mapping on the fly\n        # 2. Iterate once through original list while building the copy\n        # 3. Create each copy node only whe first encountered (lazy construction)\n        # 4. Maintain a pointer to build out the next chain\n\n        # Empty check\n        if not head:\n            return None\n        \n        # dummy node head trick\n        dummy = Node(-1)\n\n        # prev allows deepCopy to connect once we create them lazily\n        # for the entire deepCopy list as we go\n        prev = dummy\n        curr = head\n\n        # orig -> deepCopy\n        memo = {}\n        \n        # time complexity: iterate over list of n length\n        while curr:\n            \n            # grab or create and grab curr deepCopy\n            if curr not in memo:\n                memo[curr] = Node(curr.val)\n            currDeepCopy = memo[curr]\n            \n            # validate curr.random\n            if curr.random:\n                # grab or create and grab curr.random deepCopy\n                if curr.random not in memo:\n                    memo[curr.random] = Node(curr.random.val)\n                currDeepCopy.random = memo[curr.random]\n            \n            # First iteration: dummy points to deepCopy head\n            # next iteration: previous deepCopy node points to current deepCopy node \n            # after termination: entire deepCopy list is now connected\n            prev.next = currDeepCopy\n\n            # iterate to current deepCopy node connect next node\n            # iterate over original list\n            prev = prev.next\n            curr = curr.next\n        \n        # Return deepCopy head\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n\n        return memo[head]\n        # or\n        # return dummy.next",
      "questionNumber": 138,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-memoization-lazy-construction-one-pass-hashmap---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 3,
      "name": "Three Pass In Place Interleaving Technique",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        # Note:\n        # 1. First interleave copy and paste nodes between original nodes O(1) space\n        #    A -> B -> C ===> A -> A' -> B -> B' -> C -> C'\n        \n        # 2. Assign random pointers to the copy nodes using original's .random\n\n        # 3. Detach copy list from original (restoring original list) \n        #    and setting valid .next for deepCopy list\n        #    A -> A' -> B -> B' -> C -> C' ===> A' -> B' -> C'\n        \n        # 4. Return deepCopy head\n        # Result: constant space within original list, but requires 3 passes \n        \n        # Empty Check\n        if not head:\n            return None\n\n        # Interleave deepCopy nodes\n        # A -> A' -> B -> B' -> C -> C'\n        curr = head\n        while curr:\n            # create and interweave\n            deepCopy = Node(curr.val)\n            deepCopy.next = curr.next\n\n            # link A -> A' and iterate to next orig\n            curr.next = deepCopy\n            curr = deepCopy.next\n\n        # Assign random pointers\n        curr = head\n        while curr:\n            # grab intertwined deepCopy\n            deepCopy = curr.next\n\n            # assign random from orig if non None\n            if curr.random:\n                deepCopy.random = curr.random.next\n\n            # iterate to next orig\n            curr = deepCopy.next\n\n        # Split orig and deepCopy list\n        # (A) orig head: A -> A' -> B -> ...\n        curr = head\n        # (A') deepCopy head: A -> A' -> B -> ...\n        deepCopyHead = head.next\n\n        # time complexity: iterate over list of 2n length O(n)\n        while curr:\n            # grab deepCopy\n            deepCopy = curr.next\n            \n            # link orig to next orig node, iterate to next orig\n            # A -> A' -> B -> ...\n            # A -> B\n            curr.next = deepCopy.next\n            curr = curr.next\n\n            # if new orig is non None \n            # (B' -> C -> ...) vs (B' -> None)\n            # there will exists a new deepCopy\n            # iterate to deepCopy\n            if curr:\n                deepCopy.next = curr.next\n\n        # return deepCopy head\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return deepCopyHead",
      "questionNumber": 138,
      "solutionLink": "/Notes/leetcode-linked-list#solution-3-three-pass-in-place-interleaving-technique---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "141": [
    {
      "number": 1,
      "name": "Track Visited Notes",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def hasCycle(self, head: Optional[ListNode]) -> bool:\n        \n        # Note:\n        # Track visited nodes to check for repeats (cycles)\n        \n        # Nodes are stored by obj reference,\n        # perfect for cycle detection\n        visited = set()\n\n        # start of iteration\n        curr = head\n        \n        # time complexity: iterate over list of n length O(n)\n        while curr:\n\n            # repeated node: (cycle detected)\n            if curr in visited:\n                return True\n\n            # add and continue iteration\n            visited.add(curr)\n            curr = curr.next\n        \n        # no repeat nodes (no cycles)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 141,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-track-visited-notes---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Floyd Cycle Detection Tortoise and Hare",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def hasCycle(self, head: Optional[ListNode]) -> bool:\n        \n        # Note:\n        # If no cycle: fast pointer will hit None (end of list)\n        # If cycle: once both fast and slow pointer enter cycle of size k,\n        # fast pointer will lap and hit slow pointer within k steps\n\n        # set pointers\n        slow, fast = head, head\n        \n        # time complexity: iterate over list \n        while fast and fast.next:\n\n            # move both slow and fast pointers\n            slow = slow.next\n            fast = fast.next.next\n            \n            # check if match (cycle detected)\n            if slow == fast:\n                return True\n\n        # reached end of list (no cycle detected)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return False",
      "questionNumber": 141,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-floyd-cycle-detection-tortoise-and-hare---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "143": [
    {
      "number": 1,
      "name": "Slow.next Explicit Set Tail of Final List Two Way Disconnect Iteration Reversal",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note:\n        # 1. Use Tortoise Hare to find the middle\n        # 2. Reverse second half of list in place\n        # 3. Merges first half and reverse second half alternating\n        # Result: Fully in place reordering\n\n        slow = fast = head\n        while fast and fast.next:\n            # slow travels half distance vs fast pointer\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # prev for reverse tail\n        prev = None\n        \n        # Set Curr:\n\n        # Odd List:\n        # curr = slow.next, (mid.next)\n        # left will be 1 element longer (keeps mid element), right does not\n\n        # Even List:\n        # curr = slow.next, (mid2.next)\n        # left will be 2 elements longer (keeps mid1 and mid2), right does not\n\n        curr = slow.next\n\n        # Explicit Disconnect:\n        # Set slow (belonging solely to left list)\n        # to slow -> None\n        slow.next = None \n\n        # Reverse second half of list\n        while curr:\n            # grab next\n            next_node = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate \n            prev = curr\n            curr = next_node\n\n        # iterate over left half and right half\n        left, right = head, prev\n\n        # Explicit Termination:\n        # right half is always than the left half (by 1 or 2 nodes)\n        # when we terminate right,\n        # right.next = next_left guarantees that \n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Explicit Disconnect'\n        # our merged list will terminate\n        while right:\n            # grab next before disconnect\n            next_left, next_right = left.next, right.next\n            # alternate flow\n            left.next = right\n            right.next = next_left\n            # iterate left and right half -> connect next_nodes\n            left, right = next_left, next_right\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
      "questionNumber": 143,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-slow-next-explicit-set-tail-of-final-list-two-way-disconnect-iteration-reversal---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Shared Slow Between Left and Right List Implicit Disconnect",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note\n        # 1. Use Tortoise and Hare to find midpoint.\n        # 2. Reverse the second half in place (without disconnecting manually)\n        # 3. Merge first and reversed second half alternating nodes\n        # Result: Fully in place reordering\n\n        slow = fast = head\n        while fast and fast.next:\n            # slow travels half distance vs fast pointer: iterate references in memory\n            fast = fast.next.next\n            slow = slow.next\n        \n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # prev for reverse tail\n        prev = None\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow, (mid)\n        # left and right will be even (both keep mid element)\n\n        # Even List:\n        # curr = slow, (mid2)\n        # left will be 1 element longer (keeps mid1 and mid2), (right keeps mid2)\n\n        curr = slow\n\n        # Implicit Disconnect:\n        # Both left and right contain slow (either odd mid or mid2) in their list\n        # during the first modification of slow, we point it to prev (None)\n        # now, both lists have a slow.next -> None\n\n        # Reverse second half of list:\n        while curr:\n            # grab next before disconnect\n            next_node = curr.next\n            # reverse flow\n            curr.next = prev\n            # iterate reference in memory\n            prev = curr\n            curr = next_node\n\n        # iterate over left and right lists\n        left, right = head, prev\n\n        # Implicit Termination:\n        # Now since:\n        # left equal or longer by 1,\n        # slow -> None is contained by both lists,\n        # we will reach right's copy of slow\n        # at the same time or earlier by 1 iteration.\n        # However, when we reach right's copy,\n        # right.next = next_left guarantees that\n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Implicit Disconnect'\n        # our merged list will terminate\n        while right != slow:\n            next_left, next_right = left.next, right.next\n            left.next = right\n            right.next = next_left\n            left, right = next_left, next_right\n\n        # brain teaser:\n        # why does this work:\n        right.next = None\n        # but right.next.next = None \n        # does not work\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)",
      "questionNumber": 143,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-shared-slow-between-left-and-right-list-implicit-disconnect---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 3,
      "name": "Stack",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note:\n        # 1. Use Tortoise Hare to find the middle\n        # 2. Iterate over right half in order and store elements in stack\n        # 3. Pop all elements (in reverse order) and place in between left elements:\n        # left -> right -> left.next\n        # Result: Fully reordered\n\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n        \n        # store right half list in order\n        # space complexity: store half list of n length O(n)\n        stack = []\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow.next, (mid.next)\n        # left will be 1 element longer (keeps mid element), right does not\n\n        # Even List:\n        # curr = slow.next, (mid2.next)\n        # left will be 2 elements longer (keeps mid1 and mid2), right does not\n\n        curr = slow.next \n\n        # Explicit Disconnect:\n        # Set slow (belonging solely to left list)\n        # to slow -> None      \n        slow.next = None  \n\n        # time complexity: iterate over list of n length O(n)\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        # forward iteration over list \n        left = head\n\n        # Odd List Len: left will be 1 element longer (keeps mid element)\n        # Even List Len: left is 2 elements longer (keeps 1st and 2nd mid elements)\n\n        # Explicit Termination:\n        # right half stack is always than the left half (by 1 or 2 nodes)\n        # when we terminate right,\n        # right.next = next_left guarantees that \n        # the rest of the left list was connected,\n        # and since we already terminated the left list 'Explicit Disconnect'\n        # our merged list will terminate\n        # time complexity: iterate over stack O(n)\n        while stack:\n\n            # iterate over right half\n            right = stack.pop()\n\n            # set: left -> right -> left.next \n            right.next = left.next\n            left.next = right\n\n            # iterate left list\n            left = right.next\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)",
      "questionNumber": 143,
      "solutionLink": "/Notes/leetcode-linked-list#solution-3-stack---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 4,
      "name": "Brain Teaser slow longer or equal Right list Stack",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reorderList(self, head: Optional[ListNode]) -> None:\n\n        # Note:\n        # 1. Use Tortoise Hare to find the middle\n        # 2. Iterate over right half in order and store elements in stack\n        # 3. Pop all elements (in reverse order) and place in between left elements:\n        # left -> right -> left.next\n        # Result: Fully reordered\n\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Slow result:\n        # Odd List: slow -> odd mid\n        # Even List: slow -> mid2\n\n        # store right half list in order\n        # space complexity: store list of n length O(n)\n        stack = []\n\n        # Set Curr:\n\n        # Odd List:\n        # curr = slow, (mid)\n        # left and right will be even (both keep mid element)\n\n        # Even List:\n        # curr = slow, (mid2)\n        # left will be 1 element longer (keeps mid1 and mid2), (right keeps mid2)\n    \n        curr = slow \n\n        # No Implicit Disconnect:\n        # (deal with that later)\n        \n        # time complexity: iterate over list of n length O(n)\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        # iterate over left list \n        left = head\n\n        # time complexity: iterate over stack O(n)\n        while stack:\n\n            # grab right half node element\n            right = stack.pop()\n\n            # place right half node in between left half curr and curr.next: \n            # curr -> tail -> curr.next \n            right.next = left.next\n            left.next = right\n\n            # iterate left half of list\n            left = right.next\n\n        # brain teaser:\n        # why does this work:\n        # Odd/Even Case:\n        # left is equal or longer by 1 node\n        # Odd: \n        # left and right are equal in length, both share 'slow'\n        # so at the last iteration, left -> right -> left.next\n        # but we never disconnected, so left slow -> right slow\n        # and since they share the same object in memory\n        # this does not matter since it is pointing to itself\n        # Even:\n        # left is longer by 1, both share 'slow'\n        # last iteration, right slow -> left slow\n        # but we never disconnected, so left slow -> right slow\n        # and since they share the same object in memory\n        # this does not matter since it is pointing to itself\n        right.next.next.next.next.next = None\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)",
      "questionNumber": 143,
      "solutionLink": "/Notes/leetcode-linked-list#solution-4-brain-teaser-slow-longer-or-equal-right-list-stack---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "146": [
    {
      "number": 1,
      "name": "Doubly Linked List with Hashmap",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "class Node:\n    def __init__(self, key: int, val: int):\n\n        # key -> value node\n        self.key = key\n        self.val = val\n        # doubly linked prev and next\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n\n        # list capacity\n        self.capacity = capacity\n\n        # key -> Node\n        self.cache = {} \n\n        # MRU head\n        self.head = Node(0, 0)\n        # LRU tail\n        self.tail = Node(0, 0)\n\n        # set dummy head and tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def _remove_node(self, node: Node):\n\n        # Remove node from doubly linked list by linked neighbors\n        prev, next = node.prev, node.next\n        prev.next = next\n        next.prev = prev\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def _push_MRU(self, node: Node):\n\n        # Insert node between dummy head and MRU \n        node.next = self.head.next\n        node.prev = self.head\n\n        # Update head and 2nd MRU\n        self.head.next = node\n        node.next.prev = node\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def get(self, key: int) -> int:       \n\n        # if node does not exist, return -1\n        if key not in self.cache:\n            return -1\n\n        # grab node\n        node = self.cache[key]\n\n        # Move node and update MRU\n        self._remove_node(node)\n        self._push_MRU(node)\n\n        # return val\n        return node.val\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def put(self, key: int, value: int) -> None:\n\n        # If key exists, remove to avoid duplicates,\n        # need to grab node to update prev and next nodes\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove_node(node)\n\n            # update existing node\n            node.val = value\n\n        # If key does not exist, create new node set to new value\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n\n        # push updates node to top of MRU\n        self._push_MRU(node)\n\n        # Remove LRU if capacity broken\n        if len(self.cache) > self.capacity:\n            lruNode = self.tail.prev\n            self._remove_node(lruNode)\n            self.cache.pop(lruNode.key)\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(1)",
      "questionNumber": 146,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-doubly-linked-list-with-hashmap---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Python Implementation OrderedDict a Doubly Linked List with Hashmap",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "class LRUCache:\n    def __init__(self, capacity: int):\n        \n        # OrderedDict in Python is implemented internally\n        # as a doubly linked list + hashmap (same as our solution):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    # time complexity: O(1) \n    # space complexity: O(1)\n    def get(self, key: int) -> int:\n\n        # Check if key exists, else return -1\n        if key not in self.cache:\n            return -1\n\n        # Update MRU\n        self.cache.move_to_end(key)\n\n        # return value\n        return self.cache[key]\n\n    # time complexity: O(1)\n    # space complexity: O(1)\n    def put(self, key: int, value: int) -> None:\n\n        # If key exists, remove to avoid duplicates\n        if key in self.cache:\n            self.cache.pop(key)\n        \n        # Insert new value, automatically updates MRU,\n        # automatically updates doubly linked list\n        self.cache[key] = value\n        \n        # capacity exceeded, remove LRU\n        if len(self.cache) > self.capacity:\n            \n            # last=True -> pops MRU\n            # last=False -> pops LRU\n            self.cache.popitem(last=False)\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(1)",
      "questionNumber": 146,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-python-implementation-ordereddict-a-doubly-linked-list-with-hashmap---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "150": [
    {
      "number": 1,
      "name": "Postfix Expression Evaluation Algorithm",
      "type": "stack",
      "application": "expression-evaluation-and-parsing",
      "code": "def evalRPN(self, tokens: List[str]) -> int:\n        # space complexity: stack holds up to n/2 intermediate results O(n)\n        stack = []\n\n        # time complexity: iterate over tokens array of n length O(n)\n        for token in tokens:\n\n            # found operand, cast to int and push to stack\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            \n            # found operator, grab operands and compute\n            else:\n                # time complexity: pop two operands from stack O(1)\n                # input:    [\"4\",\"13\",\"5\",\"/\",\"+\"]\n                # expected: 4 + (13 / 5) = 6\n                # \"4\"    -> [4]\n                # \"13\"   -> [4, 13]\n                # \"5\"    -> [4, 13, 5]\n                # \"/\"    -> [4, 2]         # a = 13, b = 5 → int(13 / 5) = 2\n                # \"+\"    -> [6]            # a = 4, b = 2 → 4 + 2 = 6\n\n                # 5\n                b = stack.pop()\n                # 13\n                a = stack.pop()\n\n                # apply operator manually and push result\n                match token:\n                    case \"+\":\n                        stack.append(a + b)\n                    case \"-\":\n                        stack.append(a - b)\n                    case \"*\":\n                        stack.append(a * b)\n                    case \"/\":\n                        # a / b\n                        # 13 / 5\n\n                        # Explicit truncation towards zero\n                        # -7 / 3         # -2.333  division:        leaves remainder\n                        # -7 // 3        # -3      floor division:  rounds down \"towards infinity\"\n                        # int(-7 / 3)    # -2      int(division):   truncates \"toward 0\", as required by RPN\n                        stack.append(int(a / b))\n\n        # return top of stack\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return stack[-1]",
      "questionNumber": 150,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-postfix-expression-evaluation-algorithm---stackexpression-evaluation-and-parsing",
      "blog": "LeetCode: Stacks"
    }
  ],
  "153": [
    {
      "number": 1,
      "name": "Find Min by Determining if Smaller Numbers on Left or Right of Middle Binary Search",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "def findMin(self, nums: List[int]) -> int:\n\n        # Preconditions:\n        # nums is a non empty list of integers\n        # nums was originally sorted in ascending order\n        # nums has been rotated\n        # no duplicates\n\n        # Postcondition:\n        # Loop terminates when left == right\n        # both left and right point to min element\n\n        # Invariant:\n        # The min value is always in the interval [left, right]\n        # At each iteration we discard half of search space\n\n        # outer boundaries\n        left, right = 0, len(nums) - 1\n        \n        # Check: Rotated into Ascending Order\n        if nums[left] < nums[right]:\n            return nums[left]\n        \n        # Binary Optimization Search: '<' for min\n        while left < right:\n\n            mid = (left + right) // 2\n            \n            # property of rotated sorted array:\n\n            # 1: [4, 5, 6, 7, 0, 1, 2]\n            # 7 > 2:\n            # smaller numbers on right half of mid\n\n            # 2: [10, 1, 2, 3, 6, 7, 8] \n            # 3 < 8:\n            # smaller elements on left half of mid (including mid) \n\n            # mid is less than right\n            # discard higher elements on right side\n            # include lower elements on left side with mid\n            # new search interval: [left, mid]\n            if nums[mid] < nums[right]:\n                right = mid\n\n            # mid is greater than right\n            # discard higher elements on left side with mid\n            # include lower elements on right side\n            # new search interval: [mid+1, right]\n            else:\n                left = mid+1\n        \n        # Loop Terminated:\n        # left == right is the minimum element index\n\n        # Via Invariant:\n        # left and right point to min element\n        \n        # overall: time complexity O(log n)\n        # overall: space complexity O(1)\n        return nums[left]",
      "questionNumber": 153,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-find-min-by-determining-if-smaller-numbers-on-left-or-right-of-middle-binary-search---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "155": [
    {
      "number": 1,
      "name": "2 Stacks for main and min",
      "type": "stack",
      "application": "dynamic-programming-state-compression",
      "code": "class MinStack:\n\n    # overall: space complexity O(n)\n    def __init__(self):\n\n        # Note:\n        # minTracker stack tracks the min value at each level of the main stack. \n\n        # space complexity: two stacks for n elements O(n)\n\n        # stores all pushed values\n        self.mainStack = []\n        # for each level, stores minimum value\n        self.minTracker = []\n        # logical size\n        self.mainSize = 0\n\n    def _validateNotEmpty(self, errMsg: str):\n        if self.mainSize == 0:\n            raise IndexError(errMsg)\n\n    def _compressStack(self, stack):\n        return self.mainSize < len(stack)\n            \n    # overall: time complexity O(1)\n    def push(self, val: int):\n\n        # add new val at index or append\n        if self._compressStack(self.mainStack):\n            self.mainStack[self.mainSize] = val\n        else:\n            self.mainStack.append(val)\n\n        # add new min at index or append\n        if self._compressStack(self.minTracker):\n            # min between (new value, previous level of min stack)\n            self.minTracker[self.mainSize] = min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val)\n        else:\n            self.minTracker.append(min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val))\n        \n        # increases logical size\n        self.mainSize += 1\n\n    # overall: time complexity O(1)\n    def pop(self):\n        # validate non empty, decrease logical length\n        self._validateNotEmpty(\"Invalid pop, stack is empty\")\n        self.mainSize -= 1\n\n    # overall: time complexity O(1)\n    def top(self):\n        # validate non empty, return elem\n        self._validateNotEmpty(\"Invalid top, stack is empty\")\n        return self.mainStack[self.mainSize - 1]\n\n    # overall: time complexity O(1)\n    def getMin(self):\n        # validate non empty, return min\n        self._validateNotEmpty(\"Invalid getMin, stack is empty\")\n        return self.minTracker[self.mainSize - 1]\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(n)",
      "questionNumber": 155,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-2-stacks-for-main-and-min---stackdynamic-programming-state-compression",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "Tuple Stack",
      "type": "stack",
      "application": "dynamic-programming-state-compression",
      "code": "class MinStack:\n    \n    # overall: space complexity O(n)\n    def __init__(self):\n\n        # Note: \n        # We combine the main and minTracker stack via a tuple (val, min), \n        # to track the min at each level of the stack.\n\n        # space complexity: stores all pushed tuples (val, min) O(n)\n        self.stack = []\n        self.size = 0\n\n    def _validateNotEmpty(self, errMsg: str):\n        if self.size == 0:\n            raise IndexError(errMsg)\n\n    def _compressStack(self):\n        return self.size < len(self.stack)\n\n    # overall: time complexity O(1)\n    def push(self, val: int):\n\n        # min between (new value, previous level of stack)\n        currMin = min(val, self.stack[self.size - 1][1] if self.size > 0 else val)\n        \n        # update min at index, or append\n        if self._compressStack():\n            self.stack[self.size] = (val, currMin)\n        else:\n            self.stack.append((val, currMin))\n\n        # increases logical size\n        self.size += 1\n\n    # overall: time complexity O(1)\n    def pop(self):\n        self._validateNotEmpty(\"Invalid pop, stack is empty\")\n        self.size -= 1\n\n    # overall: time complexity O(1)\n    def top(self):\n        self._validateNotEmpty(\"Invalid top, stack is empty\")\n        return self.stack[self.size - 1][0]\n\n    # overall: time complexity O(1)\n    def getMin(self):\n        self._validateNotEmpty(\"Invalid getMin, stack is empty\")\n        return self.stack[self.size - 1][1]\n\n    # overall: time complexity O(1)\n    # overall: space complexity O(n)",
      "questionNumber": 155,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-tuple-stack---stackdynamic-programming-state-compression",
      "blog": "LeetCode: Stacks"
    }
  ],
  "162": [
    {
      "number": 1,
      "name": "Modified Binary Search over Towards Higher Slope",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "def findPeakElement(self, nums: List[int]) -> int:\n        \n        # Precondition:\n        # len(nums) >= 1\n        # nums[i] != nums[i+1] for all valid i\n\n        # Postcondition:\n        # returns index i such that nums[i] is a peak:\n        # nums[i] > nums[i-1] (if i > 0)\n        # nums[i] > nums[i+1] (if i < n-1)\n\n        left, right = 0, len(nums) - 1\n\n        # Invariant:\n        # At least one peak exists within interval [left, right]\n        # Half of search space removed per iteration\n        # Binary Search Optimization: '<'\n        while left < right:\n            \n            # mid\n            mid = (left + right) // 2\n\n            # Zoom In Excluding Mid:\n            # Peak towards right\n            # Discard left half of [left, mid, right]\n            # new search interval: [mid+1, right]\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n\n            # Zoom Including Mid:\n            # Peak towards left\n            # Discard right half of [left, mid, right] including Mid\n            # new search interval: [left, mid]\n            else:\n                right = mid\n\n        # Loop Exits: left == right\n        # Invariant: peak exists within interval [left, right]\n        # both left and right are pointing to peak \n         \n        # overall: time complexity O(log n)\n        # overall: space complexity O(1)\n        return left",
      "questionNumber": 162,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-modified-binary-search-over-towards-higher-slope---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "167": [
    {
      "number": 2,
      "name": "Opposite Ends Pointer Shift by BinarySearch Modification for Target",
      "type": "two-pointers",
      "application": "opposite-ends",
      "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n\n        # Set up BinarySearch Modification\n        # initialize outer pointers\n        # space complexity: left and right pointers constant O(1)\n        left, right = 0, len(numbers) - 1  \n\n        # BinarySearch Modification\n        # \"<\": working within subarray containing left and right\n        # cannot evaluate num at left == right, breaks constraints of index1 < index2\n        # Base Case: no more array remaining to search, \n        # return []\n        # time complexity: iterate over list of n length O(n)\n        while left < right:\n\n            # grab current sum\n            currSum = numbers[left] + numbers[right]  \n\n            # found target sum\n            if currSum == target:\n                # convert to 1-indexed array, per input/output example\n                return [left + 1, right + 1]\n\n            # \"BinarySearch\" on relevant subsection\n            # update left or right pointer\n            elif currSum < target:\n                left += 1\n            else:\n                right -= 1\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return []",
      "questionNumber": 167,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-opposite-ends-pointer-shift-by-binarysearch-modification-for-target---two-pointersopposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 1,
      "name": "BinarySearch Per Element for Complement",
      "type": "two-pointers",
      "application": "one-pointer-with-auxiliary-state",
      "code": "def twoSumII(self, numbers: List[int], target: int) -> List[int]:\n        \n        # time complexity: iteration over list of n length O(n)\n        for i in range(len(numbers)): \n\n            # search for complement\n            currComplementSearch = target - numbers[i]\n            \n            # Set up BinarySearch\n            # set new left boundary for iteration BinarySearch\n            # reset right boundary for iteration BinarySearch\n            # given constraint index1 < index2\n            # BinarySearch on right section of array after left element\n            # time complexity: binarySearch O(log n) for each iteration O(n), leading to O(n log n)\n            left, right = i + 1, len(numbers) - 1\n            \n            # BinarySearch\n            # \"<=\": working within subarray [i+1, j] separate from i, \n            # so must evaluate num at left == right, as might be currComplementSearch\n            # Base Case: no more array remaining to search\n            # complement for numbers[i] was not found, continue iteration\n            while left <= right:\n                \n                # middle element\n                midIndex = (left + right) // 2\n                midNum = numbers[midIndex]\n\n                # found target complement\n                if midNum == currComplementSearch:\n                    # convert to 1-indexed array, per input/output example\n                    return [i + 1, midIndex + 1]  \n\n                # \"BinarySearch\" on relevant subsection\n                # update left or right pointer\n                elif midNum < currComplementSearch:\n                    left = midIndex + 1\n                else:\n                    right = midIndex - 1\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return []",
      "questionNumber": 167,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-binarysearch-per-element-for-complement---two-pointersone-pointer-with-auxiliary-state",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "199": [
    {
      "number": 1,
      "name": "BFS Iterative",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.popleft()\n                # If this is the last node in the current level, capture it\n                if i == level_size - 1:\n                    result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        return result",
      "questionNumber": 199,
      "solutionLink": "/Notes/leetcode-trees#solution-1-bfs-iterative---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Pre Order Right-to-Left First Depth Capture",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \n        result = []\n        \n        def dfs(node, depth):\n            if not node:\n                return\n            # If visiting this depth for the first time, this is the rightmost node\n            if depth == len(result):\n                result.append(node.val)\n            dfs(node.right, depth + 1)  # Prioritize right child\n            dfs(node.left, depth + 1)   # Then left child\n        \n        dfs(root, 0)\n        return result",
      "questionNumber": 199,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-right-to-left-first-depth-capture---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "206": [
    {
      "number": 1,
      "name": "Recursive",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Note:\n        # With recursive Linked Lists:\n        # A good way to think about the problem, is that you have access\n        # to the list in reverse order, so what actions do you need to\n        # take in order to reverse the list, while traversing the list\n        # from back to front\n\n        # Base case: \n        # If current list is empty or has only one node -> this node becomes the new head\n        if head == None or head.next == None:\n            return head\n\n        # Recursion: reverse the rest of the list (head.next to end)\n        # After Recursion: new_head is new head of reverse list (tail of original list)\n        new_head = self.reverseList(head.next)\n\n        # Recursion Part 1: Reverse Flow of next element (by adding head <- head.next)\n        # After recursion: Point second Element to Original Head\n        head.next.next = head\n\n        # Recursion Part 2: Reverse Flow of curr element (by adding None <- head), as current head may be first element in original list\n        # After recursion: point first element in original list to None\n        head.next = None\n\n        # Continue passing back new head (last element from original list), from the deepest recursive call\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return new_head",
      "questionNumber": 206,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-recursive---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Recursive Clean (Learning Not)",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return head\n\n        new_head = self.reverseList(head.next)\n        \n        head.next.next = head\n        head.next = None\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return new_head",
      "questionNumber": 206,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-recursive-clean-learning-not---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 3,
      "name": "Iterative",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        # Setting prev pointing to None (end of reversed list)\n        prev = None\n\n        # Starting at head\n        curr = head\n\n        # while _ is not None\n        # time complexity: iterate over list of n length O(n)\n        while curr != None:\n\n            # Grab next node, before disconnecting\n            next_node = curr.next  \n\n            # Disconnect and Reverse Flow: \n            # <- prev    curr -> next \n            # <- prev <- curr    next \n            curr.next = prev      \n\n            # Advance both prev and curr\n            prev = curr            \n            curr = next_node       \n\n\n        # Loop exits: \n        # val: (val)  (None)\n        # node: prev -> curr\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return prev",
      "questionNumber": 206,
      "solutionLink": "/Notes/leetcode-linked-list#solution-3-iterative---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 4,
      "name": "Iterative Clean (Learning Not)",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        prev = None\n        curr = head\n\n        while curr:\n\n            next_node = curr.next  \n\n            curr.next = prev      \n\n            prev = curr            \n            curr = next_node       \n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return prev",
      "questionNumber": 206,
      "solutionLink": "/Notes/leetcode-linked-list#solution-4-iterative-clean-learning-not---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "217": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "representation",
      "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n\n        # space complexity: dictionary of O(n)\n        count = defaultdict(int)\n\n        # time complexity: iteration over list of n length O(n)\n        for num in nums:\n\n            # time complexity: lookup operation in constant O(1)\n            if count[num] >= 1:\n                return True\n            count[num] += 1\n\n        # overall: time complexity  O(n) \n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 217,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Hashset",
      "type": "hashmap",
      "application": "representation",
      "code": "def containsDuplicate(self, nums: List[int]) -> bool:\n        \n        # space complexity: hashset of O(n)\n        seen = set()\n\n        # time complexity: iteration of O(n)\n        for n in nums:\n\n            # time complexity: lookup operation of O(1)\n            if n in seen:\n                return True\n            seen.add(n)\n            \n        # overall: time complexity  O(n)\n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 217,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-hashset---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "226": [
    {
      "number": 1,
      "name": "DFS Post Order Recursive Pass Up Inverted Subtrees",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right: inverting\n        # 2. Process  -> root: swap left and right subtree\n        # Result: swapping bottom to up \n\n        # Base case: no swap\n        if not root:\n            return None\n\n        # Recursive call to process left -> right subtrees\n        left_inverted = self.invertTree(root.left)\n        right_inverted = self.invertTree(root.right)\n\n        # Could have been: right -> left subtrees\n        # right_inverted = self.invertTree(root.right)\n        # left_inverted = self.invertTree(root.left)\n\n        # Process -> root: swap left and right subtrees\n        root.left = right_inverted\n        root.right = left_inverted\n\n        # pass inverted root to parent\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(h), O(log n) for balanced tree\n        return root",
      "questionNumber": 226,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-pass-up-inverted-subtrees---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Post Order Iterative Carry Up Inverted Subtrees",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right: inverting\n        # 2. Process  -> root: swap left and right subtree\n        # Result: swapping bottom to up \n\n        if not root:\n            return None\n\n        stack = []\n\n        # current pointer\n        curr = root\n\n        # last visited\n        lastVisitde = None \n\n        while stack or curr:\n\n            # process -> left : \n            # traverse left subtree of root \n            while curr: \n                stack.append(curr)\n                curr = curr.left\n\n            # check if right subtree exists\n            peek = stack[-1]\n\n            # process  -> right : \n            # if right subtree exists and has not been visited: \n            # (remember: left subtree of right subtree will be traversed first)\n            if peek.right and lastVisited != peek.right:\n                curr = peek.right\n            \n            # process -> root : (after both subtrees)\n            else:\n                stack.pop()\n\n                # process node\n                peek.left, peek.right = peek.right, peek.left\n\n                # last visited set to curr\n                lastVisited = peek\n\n        return root",
      "questionNumber": 226,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-post-order-iterative-carry-up-inverted-subtrees---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 3,
      "name": "BFS Pre Order Iterative Full Level Each Node Inversion",
      "type": "tree",
      "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "code": "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Note:\n        # BFS iterative: level by level: root -> left -> right\n        # 1. Process root -> : iterate over level\n        #      swap left and right subtrees\n        # 2. Process -> left -> right: append left and right iterative process\n        # Result: Top down invert\n        \n        # Empty check\n        if not root:\n            return None\n        \n        # iterative stack:\n        queue = deque([root])\n        \n        while queue:\n\n            # process root:\n            currRoot = queue.popleft()\n            \n            # swap left and right subtrees\n            currRoot.left, currRoot.right = currRoot.right, currRoot.left\n            \n            # Append left and right subtrees for iterative process\n            if currRoot.left:\n                queue.append(currRoot.left)\n            if currRoot.right:\n                queue.append(currRoot.right)\n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return root",
      "questionNumber": 226,
      "solutionLink": "/Notes/leetcode-trees#solution-3-bfs-pre-order-iterative-full-level-each-node-inversion---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    }
  ],
  "230": [
    {
      "number": 1,
      "name": "In Order Traversal Early Stop",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        self.k = k\n        self.result = None\n        \n        def inorder(node):\n            if not node or self.result is not None:\n                return\n            \n            inorder(node.left)\n            \n            self.k -= 1\n            if self.k == 0:\n                self.result = node.val\n                return\n            \n            inorder(node.right)\n        \n        inorder(root)\n        return self.result",
      "questionNumber": 230,
      "solutionLink": "/Notes/leetcode-trees#solution-1-in-order-traversal-early-stop---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Pre Order Right-to-Left First Depth Capture",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            \n            root = stack.pop()\n            k -= 1\n            if k == 0:\n                return root.val\n            \n            root = root.right",
      "questionNumber": 230,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-right-to-left-first-depth-capture---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 3,
      "name": "DFS Pre Order Right-to-Left First Depth Capture",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        # Postorder: compute size of subtree, and store left subtree size\n        def compute_sizes(node):\n            if not node:\n                return 0\n            left_size = compute_sizes(node.left)\n            right_size = compute_sizes(node.right)\n            # attach attribute to the node instance\n            node.left_count = left_size\n            return left_size + right_size + 1\n\n        compute_sizes(root)\n\n        # Now query using left_count (no recursion needed)\n        node = root\n        while node:\n            left_count = getattr(node, \"left_count\", 0)\n            if k == left_count + 1:\n                return node.val\n            elif k <= left_count:\n                node = node.left\n            else:\n                k -= (left_count + 1)\n                node = node.right\n\n        return None  # not reached if 1 <= k <= n",
      "questionNumber": 230,
      "solutionLink": "/Notes/leetcode-trees#solution-3-dfs-pre-order-right-to-left-first-depth-capture---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "235": [
    {
      "number": 1,
      "name": "Recursive BST Traversal",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        \n        # Note:\n        # continue traversing down left and irght subtrees to find \n        \n        # p and q are smaller -> LCA is in left subtree\n        if p.val < root.val and q.val < root.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n\n        # p and q are smaller -> LCA is in right subtree\n        elif p.val > root.val and q.val > root.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        \n        # p and q are in different subtrees -> current node is LCA\n        else:\n            return root\n\n        # overall: time complex\n        # overall: space complex",
      "questionNumber": 235,
      "solutionLink": "/Notes/leetcode-trees#solution-1-recursive-bst-traversal---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "Iterative BST Traversal",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        \n        curr = root\n        while curr:\n\n            # p and q are smaller -> LCA is in left subtree\n            if p.val < curr.val and q.val < curr.val:\n                curr = curr.left  # Both on left\n\n            # p and q are larger -> LCA is in right subtree\n            elif p.val > curr.val and q.val > curr.val:\n                curr = curr.right\n\n            # p and q are in different subtrees -> current node is LCA\n            else:\n                return curr\n        \n        # overall: time complex\n        # overall: space complex",
      "questionNumber": 235,
      "solutionLink": "/Notes/leetcode-trees#solution-2-iterative-bst-traversal---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "238": [
    {
      "number": 1,
      "name": "Prefix and Postfix O(n)",
      "type": "array",
      "application": "in-place-transformations",
      "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # space complexity: prefix, postfix, and result arrays to calculate and store final value for n integers O(n) = O(3n)\n        prefix = [1] * len(nums)\n        postfix = [1] * len(nums)\n        res = [1] * len(nums)\n\n        # Compute prefix products\n        # time complexity: iteration over list of n length O(n)\n        for i in range(1, len(nums)):\n            \n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (prefix of i) = (prefix of i - 1) * (nums[i - 1])\n            prefix[i] = prefix[i - 1] * nums[i - 1]\n\n        # Compute postfix products\n        # time complexity: iteration over list of n length O(n)\n        for i in range(n - 2, -1, -1):\n\n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (postfix of i) = (postfix of i + 1) * (nums[i + 1])\n            postfix[i] = postfix[i + 1] * nums[i + 1]\n\n        # Combine prefix and postfix products\n        # time complexity: iteration over list of length n O(n)\n        for i in range(n):\n\n            # time complexity: lookup + multiplication operations take constant O(1)\n            # (product except self of i) = (prefix of i) * (postfix of i)\n            res[i] = prefix[i] * postfix[i]\n\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 238,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-prefix-and-postfix-o-n---arrayin-place-transformations",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Prefix and Postfix Optimal O(1)",
      "type": "array",
      "application": "in-place-transformations",
      "code": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # instantiate to 1, start prefix calculation at res[1], prefix of res[0] is always 1\n        # space complexity: array to store results for n integers O(n) \n        res = [1] * len(nums)\n\n        # Compute prefix products in res\n        # time complexity: iterate over list of size n O(n)\n        for i in range(1, len(nums)):\n\n            # time complexity:\n            # (prefix of i) = (prefix of i - 1) * (num at i - 1)\n            res[i] = res[i - 1] * nums[i - 1]\n\n        # accumulate running postfix through reverse iteration\n        # postfix starts at 1, the postfix of len(n) - 1\n        postfix = 1\n\n        # start iteration at (len(n)-1), postfix of last integer will always be 1\n        # time complexity: iterate over list of size n in reverse O(n)\n        for i in range(len(nums) - 1, -1, -1):\n            \n            # (product except i) = (prefix of i) * (postfix of i)\n            res[i] *= postfix\n            \n            # (postfix of i - 1) = (postfix of i) * (num at i) \n            postfix *= nums[i]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return res",
      "questionNumber": 238,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-prefix-and-postfix-optimal-o-1---arrayin-place-transformations",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "239": [
    {
      "number": 1,
      "name": "Heap (Priority Queue) Approach",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Use a max heap (negative value min heap), to keep track of\n        #    potential max values in the current window\n        # 2. Each heap entry is (-value, index) so max is at top\n        # 3. Before taking max from heap, pop all elements that are outside of \n        #    of the current window (index <= i - k)\n        # 4. Append the top of the heap (largest value) to the result for each window\n\n        # Empty check\n        if not nums or k == 0:\n            return []\n\n        # list of max values for each window\n        result = []\n\n        # max heap (min heap with negative values)\n        # (-value, index)\n        heap = []  \n\n        # Initialize the first window:\n        # push all elements to the max heap\n        for i in range(k):\n            heapq.heappush(heap, (-nums[i], i))\n\n        # append curr window max to result list, after k values added to queue\n        peek_max = -heap[0][0]\n        result.append(peek_max)\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(k, len(nums)):\n\n            # Push new element: (-value, index)\n            heapq.heappush(heap, (-nums[i], i))\n\n            # we only care about elements affecting the current max\n            # so we pop the top of the heap,\n            # while elements are out of the current window range\n            while heap[0][1] <= i - k:\n                # removes top stale element\n                heapq.heappop(heap)\n\n            # max is guaranteed to be within current window range\n            # append curr window max to result list\n            peek_max = -heap[0][0]\n            result.append(peek_max)\n\n        # overall: time complexity O(n log k)\n        # overall: space complexity O(k)\n        return result",
      "questionNumber": 239,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-heap-priority-queue-approach---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 2,
      "name": "Sliding Window + Monotonic Queue",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Use a dequeue to store elements in decreasing order to track max\n        # 2. Maintain the dequeue such that front has max element for current window\n        # 3. When sliding the window:\n        #    Remove elements smaller than incoming element from back of dequeue\n        #    Remove outgoing element from the front if it equals element leaving the window\n        # 4. Append the front element of the dequeue (curr max) to results after each slide\n\n        # Empty check\n        if not nums or k == 0:\n            return []\n\n        res = []\n\n        # stores elements in decreasing order\n        dq = deque([])\n\n        # put k element in the dequeue and make sure the max is at the front\n        for i in range(k):\n            while (dq and nums[i] > dq[-1]):\n                dq.pop()\n            dq.append(nums[i])\n\n        # append current max for first window\n        res.append(dq[0])\n\n        # slide window from k to end\n        for i in range(k, len(nums)):\n\n            # remove element leaving the window from front if it matches\n            if (nums[i - k] == dq[0]):\n                dq.popleft()\n\n            # \n            while (dq and nums[i] > dq[-1]):\n                dq.pop()\n\n            # append new elem max\n            dq.append(nums[i])\n            \n            # append current max\n            res.append(dq[0])\n\n        # overall: time complexity\n        # overall: space complexity\n        return res",
      "questionNumber": 239,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-2-sliding-window-monotonic-queue---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 3,
      "name": "Block Partition Precomputed Maxes",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        # Note:\n        # 1. Precompute max in fixed-size blocks:\n        #    - left_max[i]: max from block start to i\n        #    - right_max[i]: max from block end to i (scanned backwards)\n        # 2. For window starting at i, max = max(right_max[i], left_max[i+k-1])\n        #    - right_max[i] covers block starting at i\n        #    - left_max[i+k-1] covers block ending at i+k-1\n        # 3. Eliminates need for deque by reusing block maxima\n\n        n = len(nums)\n        if not nums or k == 0:\n            return []\n\n        left_max = [0] * n\n        right_max = [0] * n\n\n        # Fill left_max: scanning forward\n        for i in range(n):\n            if i % k == 0:\n                left_max[i] = nums[i]  # Block start\n            else:\n                left_max[i] = max(left_max[i-1], nums[i])\n\n        # Fill right_max: scanning backward\n        for i in range(n-1, -1, -1):\n            if (i+1) % k == 0 or i == n-1:\n                right_max[i] = nums[i]  # Block end\n            else:\n                right_max[i] = max(right_max[i+1], nums[i])\n\n        # Compute sliding window max\n        res = []\n        for i in range(n-k+1):\n            res.append(max(right_max[i], left_max[i+k-1]))\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 239,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-3-block-partition-precomputed-maxes---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "242": [
    {
      "number": 1,
      "name": "Hashmap",
      "type": "hashmap",
      "application": "representation",
      "code": "def isAnagram(self, s: str, t: str) -> bool:\n        \n        # space complexity: hashmap of 26 elements constant  O(1) \n        count = defaultdict(int)\n\n        # time complexity: iteration over string of n length O(n)\n        for x in s:\n           count[x] += 1\n\n        # time complexity: iteration over string of n length O(n)\n        for x in t:\n           count[x] -= 1\n\n        # time complexity: iteration over string of n length O(n)\n        for value in count.values():\n\n            # time complexity: comparison operation in constant O(1)\n            if value != 0:\n                return False\n\n        # overall: time complexity  O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 242,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-hashmap---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "Array of 26",
      "type": "hashmap",
      "application": "representation",
      "code": "def isAnagram(self, s: str, t: str) -> bool:\n\n        # note: ord() converts a single uni-code character to its integer representation\n        # int: 97-122 -> lowercase English alphabet (a-z)\n        # we can calculate any char (a-z)'s uni-code integer by subtracting uni-code of 'a'\n        # '(a-z)' - 'a': returns a value of 0-25 which we can index into our array\n        # this simulates a hashing into our array\n\n        # space complexity: array of 26 elements constant O(1)\n        count = [0] * 26\n\n        # time complexity: iteration of O(n)\n        for x in s:\n           count[ord(x) - ord('a')] += 1\n\n        # time complexity: iteration of O(n)\n        for x in t:\n           count[ord(x) - ord('a')] -= 1\n\n        # time complexity: iteration of O(n)\n        for value in count:\n\n            # time complexity: comparison of O(1)\n            if value != 0:\n                return False\n\n        # overall: time complexity: O(n)\n        # overall: space complexity O(1)\n        return True",
      "questionNumber": 242,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-array-of-26---hashmaprepresentation",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "271": [
    {
      "number": 1,
      "name": "Splicing Delimiter with Catchup 2 pointers",
      "type": "two-pointers",
      "application": "catchup",
      "code": "def encode(self, strs: List[str]) -> str:\n\n        # Note: python strings are immutable so concatenation with += \"\" \n        # python creates new string time complexity o(n^2)\n        # python list .append() modifies list in place by adding a single\n        # element at end in O(1) operation\n        # so doing .append() with a \"\".join() at the end is more efficient  \n\n        # space complexity: for n strings O(n) store n characters O(n), leading to O(n^2)\n        encoded = []\n\n        # time complexity: iterate over list of n strings O(n)\n        for s in strs:\n            \n            # lenDelim = len + delim\n            lenDelim = str(len(s)) + \"#\"\n\n            # append length and delimiter \"5#\"\n            left = 0\n            while left < len(lenDelim):\n                encoded.append(lenDelim[left])\n                left += 1\n            \n            # append string itself\n            # time complexity: iterate over string of n length O(n), for n iterations, leading to O(n^2)\n            left = 0\n            while left < len(s):\n                encoded.append(s[left])\n                left += 1\n        \n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return ''.join(encoded)\n\n\n    def decode(self, encoded: str) -> List[str]:\n\n        # space complexity: list of n strings O(n) each of n length O(n), leading to O(n^2)\n        decoded = []\n        left = 0\n\n        # time complexity: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)\n        while left < len(encoded):\n\n            # update right pointer to start of next (delim + string) group\n            right = left\n\n            # grab length before delimiter\n            while encoded[right] != \"#\":\n                right += 1\n            # right is now pointing at delim\n            # [ 2 # h i ... ]\n            #   ^ ^\n            #   l r \n\n            # splicing the length of the string\n            length = int(encoded[left:right])\n\n            right += 1\n            # skip delimiter, point to start of string\n            # [ 2 # h i ... ]\n            #   ^   ^\n            #   l   r \n\n            # time complexity: splice over string n length O(n) for n iterations O(n), leading to O(n^2)\n            decoded.append(encoded[right:right + length])\n            # splicing the string of 'length' characters\n            # [ 2 # h i 4 # ...]\n            # [ 0 1 2 3 4 5 6 ...]\n            #   ^   ^   ^\n            #   l   r   r'\n            # 2 + 2 = 4, start of length in next delimiter group\n\n            left = right + length\n            # left pointing to start of next len\n            # [ 2 # h i 4 # ...]\n            # [ 0 1 2 3 4 5 6 ...]\n            #       ^   ^\n            #       r   l\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return decoded",
      "questionNumber": 271,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-1-splicing-delimiter-with-catchup-2-pointers---two-pointerscatchup",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "number": 2,
      "name": "Base 10 Auxiliary Length Delimiter with 1 pointer",
      "type": "two-pointers",
      "application": "one-pointer-with-auxiliary-state",
      "code": "def encode(self, strs: List[str]) -> str:\n\n        # Note: python strings are immutable so concatenation with += \"\" \n        # python creates new string time complexity o(n^2)\n        # python list .append() modifies list in place by adding a single\n        # element at end in O(1) operation\n        # so doing .append() with a \"\".join() at the end is more efficient  \n\n        # space complexity: for n strings O(n) store n characters O(n), leading to O(n^2)\n        encoded = []\n\n        # time complexity: iterate over list of strings n length O(n)\n        for s in strs:\n            \n            # lenDelim = len + delim\n            lenDelim = str(len(s)) + \"#\"\n\n            # append length and delimiter \"5#\"\n            left = 0\n            while left < len(lenDelim):\n                encoded.append(lenDelim[left])\n                left += 1\n            \n            # append string itself\n            # time complexity: iterate over string of n length O(n), for n iterations, leading to O(n^2)\n            left = 0\n            while left < len(s):\n                encoded.append(s[left])\n                left += 1\n        \n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return ''.join(encoded)\n\n\n    def decode(self, encoded: str) -> List[str]:\n\n        # space complexity: list of n strings O(n) each of n length O(n), leading to O(n^2)\n        decoded = []\n        left = 0\n\n        # time complexity: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)\n        while left < len(encoded):\n\n            # grab length prefix behind \"#\" delimiter\n            currLen = 0\n            while encoded[left] != \"#\":\n\n                # grabbing value while calculating base 10 of prev\n                currLen = currLen * 10 + int(encoded[left]) \n                left += 1\n\n            # skip delimiter, point to start of string\n            left += 1  \n\n            # extract substring of 'currLen' characters\n            # time complexity: iterate over string n length O(n) for n iterations O(n), leading to O(n^2)\n            substring = []\n            for _ in range(currLen):\n\n                # forming string\n                substring.append(encoded[left])\n                left += 1\n            \n            # left is pointing to start of next len\n\n            # add string to decoded list of strings\n            decoded.append(''.join(substring))\n\n\n        # overall: time complexity O(n^2)\n        # overall: space complexity O(n^2)\n        return decoded",
      "questionNumber": 271,
      "solutionLink": "/Notes/leetcode-two-pointers#solution-2-base-10-auxiliary-length-delimiter-with-1-pointer---two-pointersone-pointer-with-auxiliary-state",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "287": [
    {
      "number": 1,
      "name": "Max Bit Length Duplicate Flips",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def findDuplicate(self, nums: List[int]) -> int:\n        \n        # Note:\n        # 1. Idea: Compare bit counts between full nums list and range [1..n]\n        # 2. Duplicate number will cause extra set bits in some positions\n        # 3. Identify bits where counts mismatch, reconstruct duplicate from bits\n\n        n = len(nums) - 1\n        bit_reconstruction = 0\n\n        # max_bits = how many binary bits needed to represent the largest number\n        # determines how many bit positions we need to check\n        # [1, 3, 4, 2, 2] -> 4 bit_length is 3 bits (100 binary) \n        # we will check bit positions 0, 1, 2\n        max_bit = max(num.bit_length() for num in nums)\n\n        # building duplicate number by iterating over each available bit position\n        # bit = 0 -> mask = 1 (binary 001)\n        # bit = 1 -> mask = 2 (binary 010)\n        # bit = 2 -> mask = 3 (binary 100)\n        for bit in range(max_bit):\n\n            # current mask\n            # 0 -> 1 << 0 = 0001\n            # 1 -> 1 << 1 = 0010\n            # 2 -> 1 << 2 = 0100\n            # 3 -> 1 << 3 = 1000\n            mask = 1 << bit\n\n            # for each num in array, count if bit is set\n            # &: bitwise AND\n            # sets current bit to 1 if both mask and bit are set to 1\n            # else sets current bit to 0,\n            # determines if current num has the bit set\n            curr_bit_set_count = sum((num & mask) > 0 for num in nums)\n\n            # across expected range [1..n], sum if bit is expected to be set\n            # &: bitwise AND\n            # checks how many numbers within range [1..n]\n            # are expected to have current bit set.\n            expected_bit_set_count = sum((i & mask) > 0 for i in range(1, n + 1))\n\n            # compare bit set to expected bit set,\n            # if bit is set more times than expected\n            # duplicate number must have that bit set:\n            # add it to bit reconstruction\n            if curr_bit_set_count > expected_bit_set_count:\n                bit_reconstruction |= mask\n        \n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return bit_reconstruction",
      "questionNumber": 287,
      "solutionLink": "/Notes/leetcode-linked-list#solution-1-max-bit-length-duplicate-flips---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 2,
      "name": "Pigeonhole Over Range 1 to N Then Count Array Binary Search",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def findDuplicate(self, nums: List[int]) -> int:\n\n        # Note:\n        # Idea: Duplicate number must satisfy pigeonhole principle:\n        #   With n+1 numbers range [1..n], at least one value is duplicated\n        #  (n containers, n+1 pigeons -> at least one container has two pigeons)\n        \n        # 1. Binary search on value range [1..n]\n        # 2. For mid value:\n        #    mid = number of containers in lower half (including mid)\n        #    count = numbers of pigeons (nums <= mid) in lower half\n        # 3. Decision:\n        #   If count <= mid -> equal or lesser pigeons to containers -> duplicate is in upper half\n        #   Else count > mid -> more pigeons than containers -> duplicate is in lower half\n\n        # smallest value 1\n        # largest value n (but we have n+1) n+1 - 1 -> n (the largest value)\n        left, right = 1, len(nums) - 1\n\n        # [ 1 4 3 5 2 ], for some n,\n        # there must be n-1 numbers below:\n        # for 2, there is 1 number below\n        # for 5, there are 4 numbers below\n        # Binary optimization search: '<'\n        while left < right:\n            \n            mid = (left + right) // 2\n\n            # count how many numbers <= mid\n            curr_count = sum(num <= mid for num in nums)\n\n            # if count <= mid, there are no extra numbers in lower half:\n            # duplicate must be in upper half\n            if curr_count <= mid:\n                left = mid + 1\n\n            # if count > mid, there are too many numbers in lower half:\n            # duplicate must be in lower half\n            else:\n                right = mid\n\n        # Loop exit: left == right\n        # left and right are pointing at duplicate number\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(1)\n        return left",
      "questionNumber": 287,
      "solutionLink": "/Notes/leetcode-linked-list#solution-2-pigeonhole-over-range-1-to-n-then-count-array-binary-search---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "number": 3,
      "name": "Head to Start of Cycle Proof Floyd Tortoise and Hare",
      "type": "linked-list",
      "application": "simple-traversal",
      "code": "def findDuplicate(self, nums: List[int]) -> int:\n\n        # Note:\n        # 1. definitions\n        # L = distance from head to start of cycle\n        # C = length of the cycle (number of nodes in the cycle)\n        # x = distance from the start of the cycle to the meeting point inside the cycle\n        # k = number of full cycles the fast pointer has completed by the time of the first meeting\n\n        # 2. setup\n        # When slow and fast pointers first meet inside the cycle:\n        \n        # Slow pointer has traveled: L + x steps:\n        #    L steps to reach the start of the cycle\n        #    x steps inside the cycle to the meeting pointer\n\n        # Fast pointer has traveled L + x + (k * C) steps:\n        #    L steps to reach the start of the cycle\n        #    x steps inside the cycle to the meeting point\n        #    k full extra loops around the cycle (each length C)\n\n        # Fast Substitute:\n        # By definition, fast pointer speed is double slow pointer, so substitute\n        #     L + x + (k * C) = 2(L + x)\n        \n        # Solve for L:\n        #     L + x + kC = 2L + 2x\n        #     kX = L + x\n        #     L = kC - x \n\n        # Rewrite Rule Context:\n        # Traveling x steps inside cycle of length C =\n        # to traveling C - x steps backwards, due to wrap around\n        # x steps forward = C - x backwards\n\n        # 3. Rearrange\n        #    L = kC - x\n        #    L = kC + (C - x)\n\n        #    L = kC + (C - x)   <-- this proves moving slow to right will cover\n\n        # once we move slow to the head:\n        # L -> distance from head to start of cycle\n\n        # fast will stay at the meeting point:\n        # kC + (C - x)\n\n        # kC -> number of cycles (we can ignore this)\n        # (C - x) -> steps remaining to get to the start (since we have traveled x steps already)\n\n        # L = (C - x)\n        # so both slow and fast will travel the same amount of steps \n        # to get to the start of the cycle\n\n\n        # The above math proves the below algorithm:\n\n        # Note:\n        # Idea: Treat array as linked list: index -> nums[index]\n        #    Problem set up with duplicate guarantees cycle in linked list representation\n        \n        # 1. Detect cycle (slow = nums[slow], fast = nums[nums[fast]])\n        # 2. Move slow to head, advance both one step at a time to find cycle start (duplicate)\n\n        # Find meeting point in cycle\n        slow = nums[0]\n        fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # Move slow to head, move fast and slow one step at time,\n        # fast and slow will meet at start of cycle\n        slow = nums[0]\n        while True:\n            if slow == fast:\n                break\n            slow = nums[slow]\n            fast = nums[fast]\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return slow",
      "questionNumber": 287,
      "solutionLink": "/Notes/leetcode-linked-list#solution-3-head-to-start-of-cycle-proof-floyd-tortoise-and-hare---linked-listsimple-traversal",
      "blog": "LeetCode: Linked List"
    }
  ],
  "297": [
    {
      "number": 1,
      "name": "DFS Post-Order + Global Max Tracker",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "class Codec:\n\n    def serialize(self, root):\n        vals = []\n\n        def dfs(node):\n            if not node:\n                vals.append(\"N\")\n                return\n            vals.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(vals)\n        \n\n    def deserialize(self, data):\n        vals = deque(data.split(\",\"))\n\n        def dfs():\n            if not vals:\n                return None\n            val = vals.popleft()\n            if val == \"N\":\n                return None\n\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()",
      "questionNumber": 297,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-global-max-tracker---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "347": [
    {
      "number": 1,
      "name": "MaxHeap Track N Elements",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n\n        # Note: A heap only guarantees that the root is the max (max heap) or min (min heap).\n        # The heap data structure only allows removing the root efficiently (O(log n))\n        # The heap property says nothing about the relative order of leaves or internal nodes.\n        # The smallest element could be anywhere in the leaves or internal nodes, not necessarily a leaf.\n        # Thus for maxHeap, we need to add all of the elements to the tree\n        # since we can't removed the smallest leaf as we go\n\n        # space complexity: count for m unique elements worst case n elements O(n)\n        count = defaultdict(int)\n\n        # time complexity: iterate over list of n length O(n)\n        for num in nums:\n            count[num] += 1\n\n        # space complexity: maxHeap must store all n elements O(n)\n        maxHeap = []\n\n        # time complexity: iteate over m unique elements worst case over n elements O(n)\n        for num, freq in count.items():\n\n            # time complexity: push onto heap O(log m) worst case O(log n) leading to best case O(m log m) worst case O(n log n) \n            heapq.heappush(maxHeap, (-freq, num))\n\n        # space complexity: list of k elements worst case n elements best O(k) worst O(n)\n        result = []\n\n        # cannot iterate over array, as order is not guaranteed left to right\n        # time complexity: iterate for k elements worst case n elements best O(k) worst O(n)\n        for _ in range(k):\n\n            # time complexity: pop top element O(log n) for k elements, worst case O(log n) for n elements, best case O(k log n) worst O(n log n)\n            freq, num = heapq.heappop(maxHeap)\n            result.append(num)\n\n        # same as above\n        # res = [num for _, num in (heapq.heappop(maxHeap) for _ in range(k))]\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return result",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-1-maxheap-track-n-elements---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 2,
      "name": "MinHeap Track K Elements",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n\n        # Note: A heap only guarantees that the root is the min (min heap) or max (max heap).\n        # The heap data structure only allows removing the root efficiently (O(log n))\n        # The heap property says nothing about the relative order of leaves or internal nodes.\n        # The largest element could be anywhere in the leaves or internal nodes, not necessarily a leaf.\n        # Thus for a minHeap, the root always holds the smallest element.\n        # If we only remove the smallest element when heap as exceeded size k, \n        # the heap will always contains the k largest frequencies seen so far.\n\n        # space complexity: count for m unique elements worst case n elements O(n)\n        count = defaultdict(int)\n\n        # time complexity: iterate over list of n length O(n)\n        for num in nums: \n            count[num] += 1\n\n        # space complexity: minHeap tracks k elements O(k)\n        minHeap = []\n\n        # time complexity: worst case iterate over n unique elements O(n)\n        for num, freq in count.items(): \n\n            # time complexity: push onto heap O(log n) for n elements, leading to O(n log n) \n            heapq.heappush(minHeap, (freq, num)) \n            \n            # if heap grows to size k + 1\n            if len(minHeap) > k:\n\n                # pop smallest element, heap will be back to size k\n                # time complexity: # pop smallest O(log k) for worst case n elements, leading to O(n log k)\n                heapq.heappop(minHeap) \n        \n        # can iterate over heap array as only holding top k elements\n        # time complexity: grab all k elements from minHeap worst case grab n elements O(n)\n        result = [num for freq, num in minHeap]\n\n        # for _, num in minHeap:\n        #    result.append(num) \n        # same as above\n\n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return result",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-2-minheap-track-k-elements---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 3,
      "name": "Descending QuickSelect BinarySearch",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n    \n        # Note: QuickSelect is a modified quicksort\n        # Once the finalPartitionMarker is placed in its correct position, \n        # elements to the left and right are guaranteed to be smaller/larger\n        # This avoids sorting the entire array and isolates the elements we need\n\n        # In-place partition of array based on pivot value\n        def partitionSection(left, right, randPivotElemIndex):\n            \n            # time complexity: partition processes m elements, n in worst case O(n)\n            # Frequency of pivot element\n            pivotElemFreq = frequency[unique[randPivotElemIndex]]\n\n            # Move pivot to end\n            # tuple unpacking in python, allows to swap two variables in a single line\n            unique[randPivotElemIndex], unique[right] = unique[right], unique[randPivotElemIndex]\n            \n            # Index to partition larger elements to the left side of the section\n            partitionIndex = left\n\n            # Partition elements with freq more than pivotElemFreq to left\n            # time complexity: iterates over unique elements between left and right segment O(m)\n            for i in range(left, right):\n\n                # Higher frequency -> \"greater\"\n                if pivotElemFreq < frequency[unique[i]]:  \n\n                    # swap larger element to left, sorting high to low\n                    unique[i], unique[partitionIndex] = unique[partitionIndex], unique[i]\n                    partitionIndex += 1\n\n            # swap pivot to its final correct partitioned index\n            # now elements to the right and left follow the conditions according to pivot element\n            unique[partitionIndex], unique[right] = unique[right], unique[partitionIndex]\n            return partitionIndex\n\n        # time complexity: average recursion depth O(log m)\n        # space complexity: recursion stack for in place partitioning on average O(log m)\n        def quickSelectBinarySearchHelper(left, right, finalPartitionMarker):\n            \n            # Base Case: see 'For descending' below\n            if left == right:\n                return\n\n            # Randomly choose a pivot index\n            # differs from QuickSort \"median-of-three\" approach\n            # random pivot is focused on finding the k-th smallest or largest\n            # rather than fully sorting the array, random pivot avoids degrading to worst case O(n^2)\n            randPivotElemIndex = random.randint(left, right)\n\n            # Partition the array\n            resultPivotElemIndex = partitionSection(left, right, randPivotElemIndex)\n            \n            # Base Case: see 'For descending' below\n            if finalPartitionMarker == resultPivotElemIndex:\n                return \n            \n            # Binary Search Modification:\n            # Selects next partition pivot\n            # Recursively QuickSelect on partitioned section (left or right)\n            # where finalPartitionMarker belongs to\n\n            # finalPartitionMarker is in the left partition of resultPivotElemIndex\n            elif finalPartitionMarker < resultPivotElemIndex:\n                quickSelectBinarySearchHelper(left, resultPivotElemIndex - 1, finalPartitionMarker)\n            \n            # finalPartitionMarker is in the right partition of resultPivotElemIndex\n            else:\n                quickSelectBinarySearchHelper(resultPivotElemIndex + 1, right, finalPartitionMarker)\n\n        # time complexity: iterate over list of n length O(n)\n        frequency = defaultdict(int)\n        for num in nums:\n            frequency[num] += 1\n\n        # QuickSelect BinarySearch to find the k most frequent elements\n        unique = list(frequency.keys())\n        n = len(unique)\n        finalPartition = k - 1\n        l, r = 0, n - 1\n\n        # For descending:\n        # say we have a list of 6 elements, we are trying to grab the largest 2 elements\n        # if we do 2 - 1 we get 1.\n        # so if we find we have partitioned and set index 1\n        # we know that the elements 0 and 1 are the 2 largest elements\n        # so we splice [:2] = [0, 1]\n        quickSelectBinarySearchHelper(l, r, finalPartition)\n\n        # overall: time complexity\n        # overall: space complexity \n        return unique[:k]",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-3-descending-quickselect-binarysearch---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 4,
      "name": "Ascending QuickSelect BinarySearch",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\n        # Note: QuickSelect is a modified quicksort\n        # Once the finalPartitionMarker is placed in its correct position, \n        # elements to the left and right are guaranteed to be smaller/larger\n        # This avoids sorting the entire array and isolates the elements we need\n\n        # In-place partition of array based on pivot frequency (low to high sorting)\n        def partitionSection(left, right, randPivotElemIndex):\n            \n            # Frequency of pivot element\n            pivotElemFreq = frequency[unique[randPivotElemIndex]]\n\n            # Move pivot to end\n            # tuple unpacking in python, allows to swap two variables in a single line\n            unique[randPivotElemIndex], unique[right] = unique[right], unique[randPivotElemIndex]\n            \n            # Index to place smaller elements\n            partitionIndex = left\n\n            # Partition elements with freq less than pivotElemFreq to left\n            # time complexity: iterates over unique elements between left and right segment O(m)\n            for i in range(left, right):\n\n                # Lower frequency -> \"lower\"\n                if frequency[unique[i]] < pivotElemFreq:\n\n                    # swap larger element\n                    unique[i], unique[partitionIndex] = unique[partitionIndex], unique[i]\n                    partitionIndex += 1\n\n            # swap pivot to its final correct partitioned index\n            # now elements to the right and left follow the conditions according to pivot element\n            unique[partitionIndex], unique[right] = unique[right], unique[partitionIndex]\n            return partitionIndex\n\n        # QuickSelect helper for low to high sorting\n        # Avg recursion depth: O(log m), space: O(log m)\n        def quickSelectBinarySearchHelper(left, right, finalPartitionMarker):\n            \n            # Base Case: see 'For ascending' below\n            if left == right:\n                return\n\n            # Randomly choose a pivot index\n            # differs from QuickSort \"median-of-three\" approach\n            # random pivot is focused on finding the k-th smallest or largest\n            # rather than fully sorting the array, random pivot avoids degrading to worst case O(n^2)\n            partitionElemIndex = random.randint(left, right)\n            \n            # Partition the array\n            finalPartitionElemIndex = partitionPivot(left, right, partitionElemIndex)\n\n            # Base Case: see 'For ascending' below\n            if finalPartitionMarker == finalPartitionElemIndex:\n                return\n\n            # Binary Search Modification:\n            # Selects next partition pivot\n            # Recursively QuickSelect on partitioned section (left or right)\n            # where finalPartitionMarker belongs to\n\n            # finalPartitionMarker is in the left partition of resultPivotElemIndex\n            elif finalPartitionMarker < finalPartitionElemIndex:\n                quickSelectBinarySearchHelper(left, finalPartitionElemIndex - 1, finalPartitionMarker)\n            \n            # finalPartitionMarker is in the right partition of resultPivotElemIndex\n            else:\n                quickSelectBinarySearchHelper(finalPartitionElemIndex + 1, right, finalPartitionMarker)\n\n        # time complexity: iterate over list of n length O(n)        \n        frequency = defaultdict(int)\n        for num in nums:\n            frequency[num] += 1\n\n        # Quickselect to find the k most frequent elements\n        unique = list(frequency.keys())\n        n = len(unique)\n        finalPartition = n - k\n        l, r = 0, n - 1\n\n        # For ascending:\n        # say we have a list of 6 elements, we are trying to grab the largest 2 elements\n        # if we do 6 - 2 we get 4.\n        # so if we find we have partitioned and set index 4\n        # we know that the elements 4 and 5 are the 2 largest elements\n        # so we splice [6-2:] = [4:] = [4, 5]\n        # quickSelectBinarySearchHelper(left, right, finalPartitionMarker)\n        quickSelectBinarySearchHelper(l, r, finalPartition)\n\n        # overall: time complexity\n        # overall: space complexity\n        return unique[n - k:]",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-4-ascending-quickselect-binarysearch---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "number": 5,
      "name": "BucketSort by Count",
      "type": "hashmap",
      "application": "algorithm",
      "code": "def topKFrequent(self, nums: List[int], k:int) -> List[int]:\n            \n        # space complexity: frequency count for unique integers O(m) \n        # time complexity: iterate over list of n integers O(n)\n        count = defaultdict(int)\n        for key in nums:\n\n            # time complexity: insertion operation takes constant O(1)\n            count[key] += 1\n\n        # numBuckets equal to length to account for max possible frequency count\n        # the case where list is full of only 1 element O(n)\n        # + 1 for case of element with 1 list, need bucket of frequency 0 and bucket of frequency 1\n        numBuckets = len(nums) + 1\n\n        # below is saying: create a list of empty lists numBuckets amount of times \n        # time complexity: iterating to set empty list for each bucket\n        # space complexity: creating O(n) bucket lists\n        freqBuckets = [[] for i in range(numBuckets)]\n\n        # time complexity: iterate over frequency list for m unique integer tuples (int, occurrences) O(m) \n        for int, occurrences in count.items():\n\n            # time complexity: insert operation takes constant O(1)\n            freqBuckets[occurrences].append(int)\n\n        # space complexity: grabbing top k integers O(k)\n        res = []\n\n        # time complexity: iterate over n buckets O(n)\n        for i in range(len(freqBuckets) - 1, 0, -1):\n            \n            # time complexity: iterate over all entries in current bucket O(n)\n            for num in freqBuckets[i]:\n                \n                # time complexity: insert operation takes constant O(1)\n                res.append(num)\n                \n                # time complexity: continue while less than k integers have been grabbed O(k)\n                if len(res) == k:\n                    return res\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 347,
      "solutionLink": "/Notes/leetcode-arrays-and-hashing#solution-5-bucketsort-by-count---hashmapalgorithm",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "402": [
    {
      "number": 1,
      "name": "Forward Iteration Monotonic Increasing Digits Stack",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def removeKdigits(self, num: str, k: int) -> str:\n\n        # Same as histogram or graph problem\n        # We are removing a taller height if a smaller height follows it\n\n        # Note:\n        # Monotonic stack: a stack that maintains increasing digits\n        # Greedy: remove from top of stack if higher digit at top of stack \n        # is followed by a smaller one, as this lowers value\n        # Inverse Greedy: don't remove smaller digit if higher digit follows, as this increases value \n\n        # space complexity: stack holds increasing digits up to n digits O(n)\n        stack = []\n\n        # time complexity: iterate over list of n length O(n)\n        for digit in num:\n\n            # Check: non empty stack\n            # Check: we still need to remove more digits (k > 0)\n            # Check: if monotonic increasing broken\n            # Implies: found smaller digits in front of larger, replace larger value at top of stack\n            while stack and k > 0 and stack[-1] > digit:\n                \n                # remove higher digit at top of stack\n                stack.pop()\n                k -= 1\n\n            # monotonic increasing valid\n            stack.append(digit)\n\n        # monotonic stack is valid\n\n        # Check: if we still need to remove digits k\n        # ignore larger digits on right side, \n        # splice and grab digits from the left side\n\n        # \"12345\" [:3] -> \"123\"\n        # \"12345\" [:-3] -> \"12\"\n        # -3 removes 3 digits\n        if k > 0:\n            stack = stack[:-k]\n\n        # Join the stack into a number and remove leading zeros \"0200\" -> \"200\" \n        result = ''.join(stack).lstrip('0')\n\n        # Return \"0\" if the result is empty\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return result or \"0\"",
      "questionNumber": 402,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-forward-iteration-monotonic-increasing-digits-stack---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    }
  ],
  "424": [
    {
      "number": 1,
      "name": "Explicit Two Pointer Sliding Window",
      "type": "sliding-window",
      "application": "variable-size-window",
      "code": "def characterReplacement(self, s: str, k: int) -> int:\n        \n        # Note:\n        # Variable Sliding Window => [left, right]\n        # Hashmap => char -> count\n\n        # Note:\n        # Idea: extend window via right,\n        # keep count of chars within the window,\n        # keep count of highest count char within window,\n        # shrink the window via left shift.\n\n        # needed replacements:\n        # (window size - count of most frequent char within window),\n        # is higher than available replacements: k\n        # then we shrink the window from the left.\n\n        # char -> count\n        count = defaultdict(int)\n\n        # max_freq: max count across all chars in count hashmap\n        max_freq = 0  \n\n        # Variable Sliding window: [left, right]\n        left = 0\n\n        # max length\n        max_len = 0\n\n        # time complexity: iterate right pointer over string n length O(n)\n        for right in range(len(s)):\n\n            # intake new char, increase count\n            count[s[right]] = count.get(s[right], 0) + 1\n\n            # update max_freq\n            max_freq = max(max_freq, count[s[right]])\n\n            # check if window shrink required:\n            # needed replacements > available replacements\n            if (right - left + 1) - max_freq > k:\n\n                # decrease char count and shrink window\n                count[s[left]] -= 1\n                left += 1  \n\n            # update max_len\n            max_len = max(max_len, right - left + 1)\n\n        # overall: time complexity O(n)\n        # overall: space complexity O(1)\n        return max_len",
      "questionNumber": 424,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-two-pointer-sliding-window---sliding-windowvariable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "543": [
    {
      "number": 1,
      "name": "DFS Post Order Recursive Global Diameter + Local Edge Count Pass",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right : subtrees width\n        # 2. Process -> node : 1 + max(left width, right width)\n        # Result: longest path of edges between any two nodes\n\n        max_diameter = 0\n        \n        def dfs(node):\n            nonlocal max_diameter\n\n            # Base case:\n            # no width added\n            if not node:\n                return 0\n            \n            # Process left -> right ->\n            left_len = dfs(node.left)\n            right_len = dfs(node.right)\n            \n            # Process -> root : connecting left and right diameters\n            max_diameter = max(max_diameter, left_len + right_len)\n\n            # Process -> root: root edge diameter adds 1 edge to longer diameter\n            add_edge = 1 + max(left_len, right_len)\n\n            return add_edge\n        \n        # recursive process root\n        dfs(root)\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_diameter",
      "questionNumber": 543,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-post-order-recursive-global-diameter-local-edge-count-pass---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Post Order Recursive Local Diameter + Local Edge Count Pass",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # Note:\n        # DFS post order: left -> right -> root\n        # 1. Process left -> right\n        # 2. Process -> root : Pass up by max(left width, right width)\n        # Result: longest path of edges between any two nodes\n        # Avoids: global variable\n\n        def dfs(node):\n\n            # Leaf case: (diameter:0, max_diameter:0)\n            if not node:\n                return 0, 0\n            \n            # process left -> right -> : length and longest diameter for subtree\n            left_edges, left_bridge = dfs(node.left)\n            right_edges, right_bridge = dfs(node.right)\n            \n            # process -> root : root connects left and right length\n            connected_bridge = left_edges + right_edges\n            \n            # process -> root : max between -> \n            # 1. bridged left edges and right edges\n            # 2. max bridge in left subtree\n            # 3. max bridge in right subtree\n            root_max_bridge = max(connected_bridge, left_bridge, right_bridge)\n            \n            # Process -> root: account for edge from root to root's parent by + 1,\n            # return to roots parent\n            root_edges = 1 + max(left_edges, right_edges)\n            \n            # pass up (root edges, root max bridge)\n            return (root_edges, root_max_bridge)\n        \n        # overall: time complexity\n        # overall: space complexity\n        return dfs(root)[1]",
      "questionNumber": 543,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-post-order-recursive-local-diameter-local-edge-count-pass---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 3,
      "name": "DFS Post Order Iterative Global Diameter + Dictionary Local Edge Count",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \n        # Empty check\n        if not root:\n            return 0\n        \n        max_diameter = 0\n        \n        # iterative stack\n        stack = []\n\n        # store results \n        depth_map = defaultdict(int)\n        last_visited = None\n        node = root\n\n        while stack or node:\n            \n            # process left -> \n            # \n            while node:\n                stack.append(node)\n                node = node.left\n            \n            # check if right subtree exists\n            peek = stack[-1]\n\n            # process -> right -> \n            # if right subtree exists and not visited yet:\n            if peek.right and last_visited != peek.right:\n                node = peek.right\n            \n            # process -> root : (after subtrees)\n            else:\n                # remove from stack\n                stack.pop()\n\n                # results from subtrees\n                left_depth = depth_map[peek.left]\n                right_depth = depth_map[peek.right]\n\n                # process -> root : Update diameter with path through current node\n                max_diameter = max(max_diameter, left_depth + right_depth)\n\n                # process -> root : get diameter of root\n                depth_map[peek] = 1 + max(left_depth, right_depth)\n\n                # update last visited to current\n                last_visited = peek\n\n        # overall: time complexity\n        # overall: space complexity\n        return max_diameter",
      "questionNumber": 543,
      "solutionLink": "/Notes/leetcode-trees#solution-3-dfs-post-order-iterative-global-diameter-dictionary-local-edge-count---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 4,
      "name": "DFS Post Order Iterative Dictionary Local Diameter + Local Edge Count",
      "type": "tree",
      "application": "dfs-post-order-recursive-two-sided-bottom-up",
      "code": "def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n\n        # Empty check\n        if not root:\n            return 0\n\n        max_diameter = 0\n        stack = []\n        last_visited = None\n\n        # lambda sets default to (0, 0)\n        node_data = defaultdict(lambda: (0, 0))\n\n        curr = root\n        while stack or curr:\n            \n            # Process left -> : \n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            # Check if right subtree exists\n            peek = stack[-1]\n\n            # Process -> right -> \n            # if right subtree exists and had not been visited:\n            if peek.right and last_visited != peek.right:\n                curr = peek.right\n\n            # Process -> root\n            else:\n                # remove root from stack\n                stack.pop()\n\n                # grab results from subtrees\n                left_edges, left_bridge = node_data[peek.left]\n                right_edges, right_bridge = node_data[peek.right]\n\n                # bridge by connecting left and right edges\n                connected_bridge = left_edges + right_edges\n\n                # max bridge between new bridge, max left bridge, and max right bridge\n                root_max_bridge = max(connected_bridge, left_bridge, right_bridge)\n\n                # length/edges at current root\n                root_edges = 1 + max(left_edges, right_edges)\n\n                # update data for current root\n                node_data[peek] = (root_edges, root_max_bridge)\n\n                # check max diameter\n                max_diameter = max(max_diameter, root_max_bridge)\n\n                # update last visited\n                last_visited = peek\n                \n        return max_diameter",
      "questionNumber": 543,
      "solutionLink": "/Notes/leetcode-trees#solution-4-dfs-post-order-iterative-dictionary-local-diameter-local-edge-count---treedfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    }
  ],
  "567": [
    {
      "number": 1,
      "name": "Explicit Two Pointer Sliding Window",
      "type": "sliding-window",
      "application": "fixed-size-window",
      "code": "def checkInclusion(s1: str, s2: str) -> bool:\n\n        # Note:\n        # Fixed Sliding Window => [left, right] of len (s1)\n\n        # Note:\n        # 1. Track char count in s1 and sliding window\n        # 2. right extends to fit len(s1)\n        # 3. shift left and right to fit len(s1)\n        # 4. If char count match, permutation exist\n\n        # s1 len > s2 len: permutation not possible\n        len_s1, len_s2 = len(s1), len(s2)\n        if len_s1 > len_s2:\n            return False\n\n        # s1 char count\n        freq_s1 = {}\n        for ch in s1:\n            freq_s1[ch] = freq_s1.get(ch, 0) + 1\n\n        # sliding window char count\n        window_freq = {}\n        \n        # Fixed sliding window [left, right]\n        left = 0\n\n        # time complexity: iterate right over string s2 n length O(n)\n        for right in range(len_s2):\n\n            # extend sliding window, update char count\n            window_freq[s2[right]] = window_freq.get(s2[right], 0) + 1\n\n            # reduce sliding window if size > s1\n            if right - left + 1 > len_s1:\n\n                # decrease char count and shift left\n                left_char = s2[left]\n                window_freq[left_char] -= 1\n\n                # remove if frequency reaches 0\n                if window_freq[left_char] == 0:\n                    del window_freq[left_char]\n\n                # iterate left pointer\n                left += 1\n\n            # counts match, permutation exists\n            if window_freq == freq_s1:\n                return True\n\n        # no permutation found\n\n        # overall: time complexity O(n) \n        # overall: space complexity O(n)\n        return False",
      "questionNumber": 567,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-1-explicit-two-pointer-sliding-window---sliding-windowfixed-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "number": 2,
      "name": "Explicit Two Pointer Sliding Window",
      "type": "sliding-window",
      "application": "fixed-size-window",
      "code": "def checkInclusion(s1: str, s2: str) -> bool:\n        \n        # Note:\n        # 1. Fixed sliding window of len(s1)\n        # 2. Two Count arrays size 26 for s1 and window\n        # 3. Track chars arrays between arrays that match with count\n        # 4. Window slides:\n        #    Add new char and update matches\n        #    Remove old char and updates matches\n        # 5. If matches == 26, permutation s1 exists in window and s2\n        # Results: validate if permutation of s1 exists in s2\n\n        # s1 len > s2 len: permutation not possible\n        len_s1, len_s2 = len(s1), len(s2)\n        if len_s1 > len_s2:\n            return False\n\n        # s1 and window counts\n        freq_s1 = [0] * 26\n        freq_window = [0] * 26\n\n        # char count for s1\n        for ch in s1:\n            freq_s1[ord(ch) - ord('a')] += 1\n        \n        # char count for first window in s2\n        for ch in s2[:len_s1]:\n            freq_window[ord(ch) - ord('a')] += 1\n\n        # Matches: \n        # number of positions between s1 and window counts where count matches\n        matches = sum(1 for i in range(26) if freq_s1[i] == freq_window[i])\n\n        # Fixed Size Window => [left, right] for len(s1)\n        left = 0\n\n        # time complexity: iterate right over list of n length O(n)\n        for right in range(len_s1, len_s2):\n            \n            # if count arrays match between s1 and window: permutation exists\n            if matches == 26:\n                return True\n\n            # Add new char to window\n            index_add = ord(s2[right]) - ord('a')\n            freq_window[index_add] += 1\n\n            # update matches for added char\n            if freq_window[index_add] == freq_s1[index_add]:\n                matches += 1\n            elif freq_window[index_add] == freq_s1[index_add] + 1:\n                matches -= 1\n\n            # Remove char going out of window\n            index_remove = ord(s2[left]) - ord('a')\n            freq_window[index_remove] -= 1\n\n            # update matches for removed char\n            if freq_window[index_remove] == freq_s1[index_remove]:\n                matches += 1\n            elif freq_window[index_remove] == freq_s1[index_remove] - 1:\n                matches -= 1\n            left += 1\n\n        # overall: time complexity \n        # overall: space complexity \n        return matches == 26",
      "questionNumber": 567,
      "solutionLink": "/Notes/leetcode-sliding-window#solution-2-explicit-two-pointer-sliding-window---sliding-windowfixed-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "572": [
    {
      "number": 2,
      "name": "BFS Iterative",
      "type": "tree",
      "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # BFS order: level by level\n        # 1. For each node:\n        #    - If value matches subRoot root, run isSameTree\n        # 3. Uses queue to iterate nodes iteratively\n\n        def isSameTree(s, t):\n\n            # Base case: leaf -> match\n            if not s and not t:\n                return True\n\n            # no longer match: propagate error upwards\n            if not s or not t:\n                return False  \n            if s.val != t.val:\n                return False\n            \n            # validate subtrees\n            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)\n\n        # Empty check:\n        # empty subRoot is always a subtree\n        if not subRoot:\n            return True\n\n        # Empty check:\n        # empty root cannot have subtrees\n        if not root:\n            return False\n        \n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node.val == subRoot.val and isSameTree(node, subRoot):\n                return True\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return False",
      "questionNumber": 572,
      "solutionLink": "/Notes/leetcode-trees#solution-2-bfs-iterative---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 3,
      "name": "DFS + Serialization String Matching",
      "type": "tree",
      "application": "bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Node values with leading comma\n        #    (\"2\" in \"12\" would match incorrectly without boundaries)\n        # 2. Check if serialized subRoot is substring of serialized root\n        # Result: checks if tree is subtree\n\n        def serialize(node):\n            if not node:\n                return \",N\"  # \"N\" represents None\n            return f\",{node.val}\" + serialize(node.left) + serialize(node.right)\n\n        serializedSubRoot = serialize(subRoot)\n        serializedRoot = serialize(root)\n\n        return serializedSubRoot in serializedRoot",
      "questionNumber": 572,
      "solutionLink": "/Notes/leetcode-trees#solution-3-dfs-serialization-string-matching---treebfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 1,
      "name": "DFS Pre Order Recursive",
      "type": "tree",
      "application": "dfs-pre-order-recursive-one-sided-top-down",
      "code": "def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Note:\n        # DFS pre order: root -> left -> right\n        # 1. Process node\n        #    Check if subtree matches isSameTree()\n        # 2. Process left and right subtrees\n        # Result: validate if match found\n\n        # same as above\n        def isSameTree(s, t):\n            # Base case: \n            # leaf -> node match\n            if not s and not t:\n                return True\n\n            # no match: propagate upwards\n            if not s or not t:\n                return False\n            if s.val != t.val:\n                return False\n            \n            # process subtrees\n            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)\n        \n        # Empty check:\n        # empty subRoot is always a subtree\n        if not subRoot:\n            return True\n\n        # Empty check:\n        # empty root cannot have subtrees\n        if not root:\n            return False\n        \n        # recursive call over root and subRoot\n        if isSameTree(root, subRoot):\n            return True\n        \n        # process root left and right subtrees\n        match = self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot) \n\n        return match",
      "questionNumber": 572,
      "solutionLink": "/Notes/leetcode-trees#solution-1-dfs-pre-order-recursive---treedfs-pre-order-recursive-one-sided-top-down",
      "blog": "LeetCode: Trees"
    }
  ],
  "704": [
    {
      "number": 1,
      "name": "Recursive Binary Search",
      "type": "binary-search",
      "application": "searching",
      "code": "def search(self, nums: List[int], target: int) -> int:\n        \n        # Note:\n        # Recursive binary search calls itself with smaller range,\n        # and leads to call stack of O(log n)\n\n        def helper(left, right):\n            # base case: target not found\n            if left > right:\n                return -1\n\n            mid = (left + right) // 2\n\n            # base case: target found\n            if nums[mid] == target:\n                return mid\n\n            # search right side\n            elif nums[mid] < target:\n                return helper(mid + 1, right)\n            # search left side\n            else:\n                return helper(left, mid - 1)\n\n        # time complexity: each call halves the search space O(log n)\n        # space complexity: call stack grows with depth O(log n)\n        result = helper(0, len(nums) - 1)\n\n        # overall: time complexity O(log n)\n        # overall: space complexity O(log n)\n        return result",
      "questionNumber": 704,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-recursive-binary-search---binary-searchsearching",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 2,
      "name": "Iterative Binary Search",
      "type": "binary-search",
      "application": "searching",
      "code": "def search(self, nums: List[int], target: int) -> int:\n        \n        # Note:\n        # simple binary search\n\n        # Precondition: \n        # nums is sorted in ascending order\n\n        # Invariant:\n        # Subarray nums[left:right] contains the target if it exists\n        # Search space halves on each iteration\n\n        # space complexity: simple variables in constant O(1)\n        left, right = 0, len(nums)-1\n\n        # target binary search: '<='\n        # time complexity: search space halves each iteration O(log n)\n        while left <= right:\n            \n            mid = (left+right)//2\n            \n            # Discard Mid\n            if nums[mid] == target:\n                return mid\n\n            # Mid is less than target:\n            # discard left side of [left, mid, right]\n            # new search interval: [mid+1, right]\n            elif nums[mid] < target:\n                left = mid + 1\n            \n            # mid is greater than target:\n            # discard right side of [left, mid, right]\n            # new search interval: [left, mid-1]\n            else: \n                right = mid - 1\n\n        # overall: time complexity O(log n)\n        # overall: space complexity O(1)\n        return -1",
      "questionNumber": 704,
      "solutionLink": "/Notes/leetcode-binary-search#solution-2-iterative-binary-search---binary-searchsearching",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "739": [
    {
      "number": 1,
      "name": "Forward Iteration Monotonic Decreasing Stack of Cold Temps",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Note:\n        # Monotonic Stack: A stack that maintains monotonic decreasing temperatures \n        # When monotonic decreasing rule breaks, the current temperature will serve as new higher temperature,\n        # and if stack is non empty, wait days distance for top of stack \n        # while monotonic decreasing rule breaks \n\n        # space complexity: list wait days for n temperatures O(n)\n        n = len(temperatures)\n        res = [0] * n\n\n        # space complexity: stores indices for up to n unresolved temperatures O(n)\n        stack = []\n\n        # time complexity: iterate over list of n length O(n)\n        for i in range(n):\n\n            # Check: stack is non empty, unresolved temperature exists\n            # Check: if current temperature[i] breaks monotonic decreasing order,\n            # will be viable to act as right temperature\n            # implies: we keep appending while monotonic decreasing stays valid\n            # implies: stack is kept in monotonic decreasing order\n            # implies: when monotonic decreasing breaks, we have found right temperature\n            while stack and temperatures[stack[-1]] < temperatures[i]:\n                \n                # curr while loop iteration:\n                # temperatures[i]: right temperature\n                # pop stack[-1]: tempWaitDaysCandidateIndex\n\n                # while stack is non-empty:\n                # stack.pop() will iterate tempWaitDays candidate\n                # essentially dragging the right temperature over the monotonic stack,\n                # calculating all the tempWaitDays, until a temperature is higher than\n                # the current right temperature,\n                # then we just add the right wall to the stack maintaining monotonic order\n                tempWaitDaysCandidateIndex = stack.pop()\n                \n                # After stack.pop():\n                # height[i]: right temperature\n                # tempWaitDays: tempWaitDaysCandidateIndex\n\n                # Distance from right temperature to current tempWaitDaysCandidate\n                # is the days until a warmer temperature for the current candidate\n                res[tempWaitDaysCandidateIndex] = i - tempWaitDaysCandidateIndex  \n\n            # monotonic decreasing has been re-enabled\n            # add right temperature to monotonic stack\n            # push right temperature index\n            stack.append(i)  \n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 739,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-forward-iteration-monotonic-decreasing-stack-of-cold-temps---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "Reverse Iteration Monotonic Decreasing Stack of Warm Temps",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Note:\n        # Solution 2 tends to use less actual in memory due to more \n        # aggressive pruning of colder temperatures during reverse traversal\n\n        # iterating reverse: why monotonic decreasing?\n        # index: 0  1  2  3  4  5  6\n        # temp:[ 1, 4, 6, 8, 5, 3, 2]\n\n        # a monotonic increasing (iterating backwards) would be [2, 3, 5, 8]\n        # but we don't care about decreasing cold values, but increasing hot values\n        # so we still want a monotonic decreasing (backwards) [8, 6, 4, 1]\n        \n        # difference from forward iteration is that we are tracking the hot values\n        # rather than tracking the cold values \n        \n        # space complexity: storing up to n indexes O(n)\n        n = len(temperatures)\n        stack = []\n\n        # space complexity: storing wait days for n temperatures\n        res = [0] * n\n\n        # time complexity: iterate over list of n temperatures O(n)\n        for i in range(n-1, -1, -1):\n\n            # maintain decreasing temp of hot temps by:\n            # prevent equal or hotter temp from being added\n            # which will remove older hot temps\n            # and replacing with newer hot temps\n            while stack and temperatures[stack[-1]] <= temperatures[i]:\n                stack.pop()\n\n            # check: monotonic decreasing kept with stack (backwards)\n            # which means top of stack has a hotter temperature, calculate distance\n            if stack:\n                # stack[-1]: previous hot temperature\n                res[i] = stack[-1] - i\n\n            # Invariant: monotonic decreasing, append to list \n            stack.append(i)        \n        \n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return res",
      "questionNumber": 739,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-reverse-iteration-monotonic-decreasing-stack-of-warm-temps---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 3,
      "name": "Dynamic Programming Jump Traversal using Future Warm Temperatures",
      "type": "stack",
      "application": "algorithm",
      "code": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \n        # Note:\n        # This solution uses a jump-based approach via leveraging \n        # results from previously computed indices.\n        # It avoids an explicit stack by simulating the search for \n        # the next warmer temperature using a two-pointer like mechanism,\n        # jumping ahead using previously filled results.\n        # This effectively builds a \"path\" toward the next warmer day\n\n        # Key Insight:\n        # Once we know the next warmer day for some index j, we can skip\n        # forward using res[j] to find the next warmer day for earlier indices i.\n        \n        # space complexity: result list for storing wait times o(n)\n        n = len(temperatures)\n        dp = [0] * n\n\n        # tracking index of hottest day seen so far right to left\n        # set hottest day to last element\n        hottest_day = n - 1\n\n        # time complexity: reverse iterate through temperatures from second last to first O(n)\n        for i in range(n - 2, -1, -1):\n\n            # found new hottest day, \n            # then ignore wait days calculation\n            # Check: if current temperature is >= hottest_day temp,\n            # Implies: found new hottest day, \n            # and since we are iterating right to left, \n            # then no hotter day can be to the right of new hottest\n            if temperatures[i] >= temperatures[hottest_day]:\n                # new hottest day index\n                hottest_day = i\n\n            # find hottest day\n            else:\n                # check hotter day for next index\n                j = i + 1\n\n                # while hotter day not found\n                while temperatures[j] <= temperatures[i]:\n                    # jump to hottest day candidate's hottest day\n                    j += dp[j]\n\n                # found hotter day\n                dp[i] = j - i \n\n        # overall: time complexity O(n)\n        # overall: space complexity O(n)\n        return dp",
      "questionNumber": 739,
      "solutionLink": "/Notes/leetcode-stacks#solution-3-dynamic-programming-jump-traversal-using-future-warm-temperatures---stackalgorithm",
      "blog": "LeetCode: Stacks"
    }
  ],
  "853": [
    {
      "number": 1,
      "name": "Monotonic Increasing Stack of Slower/Higher Fleet Times",
      "type": "stack",
      "application": "monotonic-property-maintenance",
      "code": "def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        # Note: \n        # Each car is represented by its position and speed\n        # We calculate the the time for each car to reach the target mile.\n        # We sort the cars by highest distance first (higher value closer to target, smaller farther),\n        # so that we can process the cars in order from target to start (closer to farther),\n        # to check the generation of fleets\n\n        # Note:\n        # Monotonic stack: maintains a monotonic increasing stack of times to target\n        \n        # space complexity: stores times for up to n fleets O(n)\n        stack = []\n\n        # Sort cars by position in descending order\n        # time complexity: timSort cars by starting position distance descending O(n log n)\n        # generate fleets by going iterating over closest to target -> farthest to target        \n        # time complexity: iterate over n cars O(n) \n        for pos, spd in sorted(zip(position, speed), reverse=True): \n            \n            # current car time to target\n            currTimeToTarget = (target - pos) / spd \n            \n            # A new fleet means if a farther car has a higher time to target than closer car\n            # then this car will never catch up to the fleet and instead will form a new fleet\n\n            # A fleet means if a farther car has a lower time to target than a closer car\n            # it will catch up to the current fleet\n\n            # stack[-1]: will have the current lowest time to target value for some fleet\n            # For each new car we check its time to target relative to the current fleet \n\n            # Thus:\n            # If current car is faster (time to target <= stack top), it will catch up with fleet and merge\n            # If current car is slower (time to target > stack top), it will never catch up and thus form a new fleet\n            \n            # Check: stack is empty, create first fleet\n            # Check: is farther car slower than current fleet, create new fleet\n            if not stack or currTimeToTarget > stack[-1]:\n\n                # Create new fleet at top of stack\n                stack.append(currTimeToTarget)\n\n            # Otherwise, catches up to the fleet in front (we do nothing)\n        \n        # overall: time complexity O(n log n)\n        # overall: space complexity O(n)\n        return len(stack)",
      "questionNumber": 853,
      "solutionLink": "/Notes/leetcode-stacks#solution-1-monotonic-increasing-stack-of-slower-higher-fleet-times---stackmonotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    },
    {
      "number": 2,
      "name": "Greedy Tracking One Slowest/Higher Fleet",
      "type": "stack",
      "application": "algorithm",
      "code": "def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        \n        # Note:\n        # Greedy strategy based on arrival times\n        # We only need to track 1 fleet at a time,\n        # since if current car cannot catch up with current fleet,\n        # it cannot catch up with previously created fleets\n\n        num_fleets, slowest_fleet_time = 0\n        for pos, spe in sorted(zip(position, speed), reverse=True): \n            \n            # current car time to target\n            currCarTimeToTarget = (target - pos)/spe \n\n            # Check: current car has higher time to target than current fleet\n            if currCarTimeToTarget > slowest_fleet_time: \n\n                # update tracking fleet and total num of fleets\n                num_fleets += 1\n                slowest_fleet_time = currCarTimeToTarget\n\n        # overall: time complexity O(n log n)\n        # overall space complexity O(n)\n        return num_fleets",
      "questionNumber": 853,
      "solutionLink": "/Notes/leetcode-stacks#solution-2-greedy-tracking-one-slowest-higher-fleet---stackalgorithm",
      "blog": "LeetCode: Stacks"
    }
  ],
  "875": [
    {
      "number": 1,
      "name": "Binary Search",
      "type": "binary-search",
      "application": "optimization-search-min-max",
      "code": "import math\n\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        \n        # Note:\n        # Find minimum int k such that Koko can eat all bananas within h hours\n        \n        # Preconditions:\n        # piles is a non empty list of positive integers\n        # h >= len(piles), h is the number of hours \n\n        # Invariant:\n        # k min speed is in the interval [left, right]\n        # Search space halves each iteration\n\n        # Search Space:\n        # Min speed: 1 banana per hour (slowest possible)       \n        # Max speed: max(piles), no pile would need > max(piles) per hour\n        left, right = 1, max(piles)\n        \n        # time complexity: iterate over n piles O(n)\n        def hours_needed(speed):\n            total_hours = 0\n            for pile in piles:\n                # Koko has fixed eating speed k\n                # if she has pile bananas and eats at k bananas/hr\n                # she will take ceil(pile/k) (cannot stop in middle of hour)\n                # 3 bananas with speed 9, will still take 1 full hour\n                total_hours += math.ceil(pile / speed)\n            return total_hours\n        \n        # binary optimization search: '<' for min k\n        # time complexity: binary search over k speeds O(log(max(piles)))\n        while left < right:\n\n            # mid speed\n            mid = (left + right) // 2\n            required_hours = hours_needed(mid)\n            \n            # Zoom In Including Mid:\n            # Mid is valid speed: can finish in h hours\n            # Discard faster speeds on right side of [left, mid, right]\n            # Include current mid in slower speed search\n            # new search interval: [left, mid]\n            if required_hours <= h:\n                right = mid\n            \n            # Zoom In Excluding Mid:\n            # Mid is invalid speed: cannot finish in h hours\n            # Discard slower speeds on lef side of [left, mid, right]\n            # Exclude current mid from faster speed search\n            # new search interval: [mid + 1, right]\n            else:\n                left = mid + 1\n        \n        # Invariant:        \n        # k min speed is in the interval [left, right]\n\n        # Loop Terminates:\n        # left == right \n        # Valid [left, right] has been reduced to one point\n        # Both left and right point to min valid k speed\n\n        # overall: time complexity O(n * log(max(piles)))\n        # overall: space complexity O(1)\n        return left",
      "questionNumber": 875,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-binary-search---binary-searchoptimization-search-min-max",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 2,
      "name": "Networking Router Analogy, Greedy Heuristic Hybrid Target Optimization Monotonic Search with Exponential Speed Doubling",
      "type": "binary-search",
      "application": "optimization-search-min-max",
      "code": "def minEatingSpeed(self, piles: List[int], h: int) -> int:\n\n        # -----------------------------------------------------\n        # Network Router Analogy:\n        # Think of Koko as a router, \n        # banana piles as incoming data packets,\n        # banana in pile as amount of data to be processed for packet p,\n        # h as the deadline (maximum allowable latency in seconds),\n        # and speed as the throughput (packets processed per second).\n\n        # Note:\n        # Greedy Start:\n        # Start speed k from the highest heuristic lower bound between three choices.\n\n        # Note:\n        # Greedy search: \n        # If total eating time exceeds h by double allowed time:\n        # increase speed k aggressively by doubling.\n        # If total eating time is close to h:\n        # increment speed k slowly by 1.\n\n        # Pros:\n        # Can outperform binary search in practice for some input with high k speeds.\n        \n        # Cons: \n        # Lacks worst case guarantees, (binary search guarantees O(log n) worst case)\n\n        # Note:\n        # Choosing Heuristics -> System Level Perspective:\n        # 1. Total bananas: Throughput -> Global Bandwidth\n        # 2. Smallest Pile: Fair Time Allocation + Small Packet -> Quick Packet Burst\n        # 3. Largest Pile: Unfair Time Allocation + Big Packet -> Bottleneck Prevention\n\n        # Good Heuristics by Constraints:\n        # Must be lower bound -> never overestimate\n        # Close to real answer -> to minimize search time\n        # Computable in O(n) time -> scalable\n        # Multiple heuristics -> different system perspectives\n\n        # Discarding Heuristics -> Bad Choices:\n        # 1. Average between piles: Does not factor time constraint, assumes infinite time\n        # 2. Max pile divided over h hours: Does not factor rest of piles, high router k speed wasted on small piles\n\n        # Choosing Heuristics Take away :\n        # Should respect at least two (or all three) key constraints, to generate a good lower bound k\n        # Packets (piles)\n        # Data size (bananas in pile)\n        # Time Constraint (h)\n    \n        # -----------------------------------------------------\n        # 3 Heuristics -> Greedy Lower Bound Starting Speed:\n\n        # ------------\n        # Heuristic 1: Banana Based Average (Throughput Constraint)\n        # Spread all bananas evenly over h available hours\n        # All bananas / hours -> baseline average k speed\n\n        # Lower Bound: No matter how time is spent between small or large piles,\n        # if k is less than totalBananas/h, all bananas will not get finished\n        # Produces small k:\n        # Underestimates when bananas are skewed into a few large piles\n        # by assuming bananas are even across piles\n        totalBananas = sum(piles)\n        speedCheck1 = math.ceil(totalBananas / h)\n\n        # ------------\n        # Heuristic 2: Hour Per Pile Based Average, Split Time Evenly (Fair time Sharing For Each Pile Constraint)\n        # Heuristic 2: Minimum Speed to Finish Smallest Pile within Split Even Time\n        # Total hours / num of piles -> equal time allocated per pile \n        # Smallest Pile / Allocated Time -> speed k needed to eat smallest pile within allocated time\n\n        # Lower Bound: If each pile gets equal time, this is the minimum speed \n        # required to finished the smallest pile without exceeding time budget\n        # Produces small k:\n        # Dividing h across numPiles, regardless of pile size, \n        # giving each pile generous time budget,\n        # and since we are testing it on the smallest pile, \n        # which doesn't need much time, makes k small\n        numPiles = len(piles)\n        evenTime = int(h/numPiles)\n        speedCheck2 = math.ceil(min(piles) / evenTime)\n\n        # ------------\n        # Heuristic 3: Biggest Pile Based Speed (Bottleneck preparing detection Constraint)\n        # Give Koko 1 hour per pile, excluding the largest one,\n        # spend the remaining time on largest pile.\n\n        # Lower Bound: Assume speed k is high enough to finish every pile in just 1 hour.\n        # That takes (numPiles - 1) hours, leaving (h - (numPiles-1)) hours.\n        # To finish the largest pile in this remaining time,\n        # k must be at least maxPile / remaining time.\n        # Otherwise, the final pile will not get finished.\n        # Produces small k:\n        # since we have many h hours remaining.\n        remainingTime = h - (numPiles - 1)\n        speedCheck3 = math.ceil(max(piles) / remainingTime)\n        \n            \n        # ------------\n        # Greedy Starting Speed: Pick the highest lower bound\n        # avoids testing extremely high speeds unnecessarily\n        # by choosing realistic starting speed\n        # and only incrementing speed\n        speed = max(speedCheck1, speedCheck2, speedCheck3)\n        \n\n        # -----------------------------------------------------\n        # Conditions:\n\n        # Preconditions:\n        # piles is a non empty list of positive integers\n        # h >= len(piles), h is the number of hours \n        # variable 'speed' starts with speed k that is a valid lower bound based on heuristics\n\n\n        # Postconditions:\n        # Returns min speed k such that koko can eat all bananas within h hours\n\n        # Invariant:\n        # min valid speed k lies in [speed, +inf]\n        # speed is monotonically increasing during search\n        # first valid time <= h: speed is guaranteed to be min due to greedy monotonic increasing search strategy\n\n        # Greedy Search:\n        # If totalTime is too large compare to h constraint, double eating k speed\n        # If totalTime is close to h constraint, increment speed k by 1\n        # monotonically increase k search speed\n\n        # phase 1 time complexity: exponential doubling O(log max(piles))\n        # phase 2 time complexity: linear scan O(max(piles))\n        while (True):\n\n            # Get hours for speed k\n            smallKTotalTime = 0\n            for pile in piles:\n                smallKTotalTime += math.ceil(pile / speed)\n\n            # Valid speed found\n            # Implies: first valid speed we encounter is the smallest one\n            if smallKTotalTime <= h:\n                return speed\n\n            # speed is much too slow\n            # totalTime is twice available h -> double speed k\n            # new search interval: [speed*2, +inf]\n            elif smallKTotalTime >= 2 * h:\n                speed *= 2\n\n            # totalTime close to required time -> increment speed by 1\n            # new search interval: [speed+1, +inf]\n            else:\n                speed += 1\n\n        # overall: time complexity O(n * log (max(piles)))\n        # overall: space complexity O(1)",
      "questionNumber": 875,
      "solutionLink": "/Notes/leetcode-binary-search#solution-2-networking-router-analogy-greedy-heuristic-hybrid-target-optimization-monotonic-search-with-exponential-speed-doubling---binary-searchoptimization-search-min-max",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "981": [
    {
      "number": 1,
      "name": "Reverse Linear Scan",
      "type": "binary-search",
      "application": "condition-adapted-binary-search",
      "code": "class TimeMap:\n\n        # Note:\n        # Stores multiple (value, timestamp) tuples per key in insertion order\n        # The 'get' function performs a reverse linear scan to find \n        # the latest time <= the query timestamp.\n        # 'get' can be slow if many timestamps per key O(m)\n\n\n        # space complexity: n is the total set calls across all keys O(n)\n        def __init__(self):\n            # key -> [(value, timestamp)]\n            self.store = {}\n\n\n        # overall: time complexity O(1) amortized\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            \n            # append to key list:  (value, timestamp)\n            if key not in self.store:\n                self.store[key] = []\n            self.store[key].append((value, timestamp))\n\n\n\n        # overall: time complexity where m is number of timestamps for this key O(m)\n        def get(self, key: str, timestamp: int) -> str:\n            \n            # if key list does not exist\n            if key not in self.store:\n                return ''\n            \n            # grab key list: [(value, timestamp)]\n            values = self.store[key]\n\n            # outer boundaries\n            i = len(values) - 1\n            \n            # Reverse linear scan:\n            # grab first valid highest timestamp <= query\n            while 0 <= i and values[i][1] > timestamp:\n                i -= 1\n\n            # not found case: index -1\n            # or\n            # timestamp is now <= query\n            return values[i][0] if i != -1 else ''\n\n\n        # overall: time complexity O(m)\n        # overall: space complexity O(n)",
      "questionNumber": 981,
      "solutionLink": "/Notes/leetcode-binary-search#solution-1-reverse-linear-scan---binary-searchcondition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 2,
      "name": "Upper Ceiling to Find First Invalid TimeStamp",
      "type": "binary-search",
      "application": "upper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
      "code": "class TimeMap:\n\n        # Note:\n        # Upper Ceiling Trick:\n        # We cannot directly optimize for 'timestamp <= target' using '<=' via this binary search.\n        # Instead, optimize for the condition 'timestamp < target' (strictly greater than).\n        # The search finds the index of the first timestamp greater than the target.\n        # After, we shift the pointer by one (left - 1) to get the largest timestamp <= target.\n\n        # Note:\n        # Stores (value, timestamp) tuples per key in insertion order (sorted by timestamp)\n        # 'get' uses binary search to find the largest timestamp <= the query timestamp.\n        # 'get' more efficient O(log m)\n\n        # space complexity: n is the total set calls across all keys O(n)\n        def __init__(self):\n            # key -> [(value, timestamp)]\n            self.store = {}\n\n        # overall: time complexity amortized O(1)\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            \n            # append to key list:  (value, timestamp)\n            if key not in self.store:\n                self.store[key] = []\n            self.store[key].append((value, timestamp))\n\n        # overall: time complexity where m is number of timestamps for this key O(log m)\n        def get(self, key: str, timestamp: int) -> str:\n\n            # Precondition:\n            # self.store[key] contains (value, timestamp) pairs sorted ascending by timestamp\n            # timestamp is an integer >= 1\n\n            # Postcondition:\n            # returns value with largest timestamp <= given timestamp\n            # returns '' if none exists\n\n            # Empty Check\n            if key not in self.store:\n                return ''\n            \n            values = self.store[key]\n            \n\n            # Upper Ceiling Binary Search Shift Trick: \n            # In order to find: highest timestamp <= query\n            # First first: query < min timestamp \n            # Then shift index: find highest timestamp <= query\n            \n            # outer boundaries\n            # intentionally start right at len(values)\n            left, right = 0, len(values)\n            \n            # Loop invariant:\n            # 1. 0 <= left <= right <= len(values)\n            # 2. forall i :: 0 <= i < left ==> values[i][1] <= timestamp\n            # 3. forall j :: right <= j < len(values) ==> values[j][1] > timestamp\n            \n            # Interpretation:\n            # all indices before 'left' are valid timestamps <= query\n            # all indices after 'right' are invalid timestamps > query\n\n            # When loop exits (left == right)\n            # left points to first invalid timestamp > query (if any)\n            # left-1 points to largest valid timestamp <= query or -1 if none exists\n\n            # time complexity: binary search over time stamps O(log(m))\n            while left < right:\n                \n                mid = (left + right) // 2\n\n                # If timestamp is greater than query timestamp -> valid\n                if values[mid][1] > timestamp:\n                    right = mid\n                \n                # If timestamp is less than or equal to query timestamp -> invalid\n                else:\n                    left = mid + 1\n\n            # Found smallest timestamp > query:\n            # If we shift index by 1 -> largest timestamp <= query:\n            # Or ''\n            return values[left - 1][0] if left != 0 else ''      \n\n        # overall: time complexity O(log m)\n        # overall: space complexity O(n)",
      "questionNumber": 981,
      "solutionLink": "/Notes/leetcode-binary-search#solution-2-upper-ceiling-to-find-first-invalid-timestamp---binary-searchupper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "number": 3,
      "name": "Floor Search Tracking Largest Valid Index With Right Pointer",
      "type": "binary-search",
      "application": "upper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
      "code": "class TimeMap:\n\n        def __init__(self):\n            self.mp = {}\n            \n\n        def set(self, key: str, value: str, timestamp: int) -> None:\n            # put a key: val -> to a timestamp\n            item = (timestamp, value)\n            if key not in self.mp:\n                self.mp[key] = []\n            \n            self.mp[key].append(item)\n\n\n        def get(self, key: str, timestamp: int) -> str:\n            \n            # Precondition:\n            # self.map[key] contains sorted (timestamp, value) pairs by ascending timestamp\n            # timestamp is an int >= 1\n\n            # Postcondition:\n            # returns value with largest timestamp <= given timestamp\n            # returns empty string if no such timestamp exists\n\n            # Empty Case\n            if key not in self.mp:\n                return ''\n\n            values = self.mp[key]\n            \n            # Edge Case:\n            # If timestamp >= end of array timestamp, return last value\n            if timestamp >= values[-1][0]:\n                return values[-1][1]\n\n            left, right = 0, len(values)-1\n\n            # Loop invariant:\n            # 1. 0 <= left <= right + 1 <= len(values)\n            # 2. All values before 'left' have timestamp <= query timestamp\n            # 3. All values after 'right' have timestamp > query timestamp\n\n            # Ensures:\n            # When left > right, right points to \n            # the largest timestamp <= query or -1 if none exists            \n            while left <= right:\n                mid = (left + right) // 2\n                time, val = values[mid]\n\n                # found target\n                if time == timestamp:\n                    return val\n\n                # if time larger than query: reduce right side\n                elif time > timestamp:\n                    right = mid - 1\n\n                # if time smaller than request: reduce left side\n                else:\n                    left = mid + 1\n                    \n            # refer to postcondition\n            return value_list[right][1] if right != -1 else ''",
      "questionNumber": 981,
      "solutionLink": "/Notes/leetcode-binary-search#solution-3-floor-search-tracking-largest-valid-index-with-right-pointer---binary-searchupper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "1448": [
    {
      "number": 1,
      "name": "BFS Iterative",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def goodNodes(self, root: TreeNode) -> int:\n        def dfs(node, max_so_far):\n            if not node:\n                return 0\n            \n            # A node is good if its value is >= max_so_far seen so far\n            good = 1 if node.val >= max_so_far else 0\n            \n            # Update max value along the path\n            new_max = max(max_so_far, node.val)\n            \n            # Recurse on left and right children\n            good += dfs(node.left, new_max)\n            good += dfs(node.right, new_max)\n            \n            return good\n        \n        return dfs(root, root.val)",
      "questionNumber": 1448,
      "solutionLink": "/Notes/leetcode-trees#solution-1-bfs-iterative---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "number": 2,
      "name": "DFS Pre Order Right-to-Left First Depth Capture",
      "type": "tree",
      "application": "dfs-pre-order-traversal",
      "code": "def goodNodes(self, root: TreeNode) -> int:\n        count = 0\n        queue = deque([(root, root.val)])  # (node, max_so_far)\n        \n        while queue:\n            node, max_so_far = queue.popleft()\n            \n            if node.val >= max_so_far:\n                count += 1\n            \n            new_max = max(max_so_far, node.val)\n            \n            if node.left:\n                queue.append((node.left, new_max))\n            if node.right:\n                queue.append((node.right, new_max))\n        \n        return count",
      "questionNumber": 1448,
      "solutionLink": "/Notes/leetcode-trees#solution-2-dfs-pre-order-right-to-left-first-depth-capture---treedfs-pre-order-traversal",
      "blog": "LeetCode: Trees"
    }
  ]
}