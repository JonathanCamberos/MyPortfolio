{
  "array": [
    {
      "type": "Array",
      "title": "In place Transformations",
      "summary": "Perform transformations or reorderings on the array without using extra space.",
      "exampleIntro": "Rotate an array to the right by k steps.",
      "codeExample": "def rotate(nums: List[int], k: int) -> None:\n        n = len(nums)\n        k %= n  # handle cases where k > n\n        \n        def reverse(start: int, end: int) -> None:\n            while start < end:\n                nums[start], nums[end] = nums[end], nums[start]\n                start += 1\n                end -= 1\n\n        reverse(0, n - 1)    # Reverse entire array\n        reverse(0, k - 1)    # Reverse first k elements\n        reverse(k, n - 1)    # Reverse remaining elements",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#array-application-in-place-transformations",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "hashmap": [
    {
      "type": "HashMap",
      "title": "Representations",
      "summary": "Using a HashMap to represent objects or data based on specific criteria.",
      "exampleIntro": "Representing a string by character frequency.",
      "codeExample": "def freqCount():\n        s = \"aabbcc\"\n        freq = {}\n        for char in s:\n            freq[char] = freq.get(char, 0) + 1\n        # freq = {'a': 2, 'b': 2, 'c': 2}",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-representations",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Grouping by Criteria",
      "summary": "Group elements based on a defined criterion, such as sorting or categorization.",
      "exampleIntro": "Grouping strings that are anagrams of each other:",
      "codeExample": "def groupAnagrams(strs):\n        anagrams = {}\n        for word in strs:\n            key = \"\".join(sorted(word))\n            if key not in anagrams:\n                anagrams[key] = []\n            anagrams[key].append(word)\n        # anagrams = {'aet': ['eat', 'tea', 'ate'], 'ant': ['tan', 'nat'], 'abt': ['bat']}",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-grouping-by-criteria",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Memoization in Dynamic Programming",
      "summary": "Store solutions to subproblems in a HashMap to avoid redundant calculations.",
      "exampleIntro": "Fibonacci number computation with memoization:",
      "codeExample": "def fib(n, memo={}):\n        if n <= 1:\n            return n\n        if n not in memo:\n            memo[n] = fib(n - 1, memo) + fib(n - 2, memo)\n        return memo[n]",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-memoization-in-dynamic-programming",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Backtracking with Caching for Pruning",
      "summary": "Use a HashMap to cache explored paths or states to prune the search space effectively.",
      "exampleIntro": "Subset Sum with caching:",
      "codeExample": "def subsetSum(nums, target):\n        # Cache to store paths that can no longer lead to valid solutions\n        cache = {}\n        result = []\n\n        def backtrack(current, index, total):\n            # Check if we've encountered this path before\n            state = (tuple(current), total)\n            if state in cache:\n                return\n            cache[state] = True\n\n            # Prune: If the total exceeds the target\n            if total > target:\n                return\n            \n            # Valid solution\n            if total == target:\n                result.append(list(current))\n                return\n\n            # Explore further candidates\n            for i in range(index, len(nums)):\n                # Choose\n                current.append(nums[i])\n                # Recurse\n                backtrack(current, i + 1, total + nums[i])\n                # Undo the choice\n                current.pop()\n\n        backtrack([], 0, 0)\n        return result",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-backtracking-with-caching-for-pruning",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Representing Relationships",
      "summary": "Model relationships between entities.",
      "exampleIntro": "Adjacency list representation of a graph:",
      "codeExample": "def graph():\n        edges = [(1, 2), (2, 3), (1, 3)]  # List of edges in the graph\n        graph = {}  # Initialize an empty hashmap to represent the graph\n\n        # Build the adjacency list\n        for u, v in edges:\n            if u not in graph:  # If the node `u` is not yet in the graph, initialize it\n                graph[u] = []\n            if v not in graph:  # If the node `v` is not yet in the graph, initialize it\n                graph[v] = []\n            graph[u].append(v)  # Add `v` to the list of neighbors for `u`\n            graph[v].append(u)  # Add `u` to the list of neighbors for `v`\n\n        # Resulting adjacency list representation\n        # graph = {1: [2, 3], 2: [1, 3], 3: [2, 1]}",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-representing-relationships-",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Logic Mapping",
      "summary": "Use a HashMap to represent problem specific logic or conditions.",
      "exampleIntro": "Map complements to indices for quick lookup:",
      "codeExample": "def twoSum(nums, target):\n        # Map to store complement -> index\n        complement_map = {}\n\n        for i, num in enumerate(nums):\n            complement = target - num\n            \n            # Check if current number is a complement of a previously seen number\n            if num in complement_map:\n                return [complement_map[num], i]\n            \n            # Store complement of current number with index for future lookup\n            complement_map[complement] = i\n\n        return []",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-logic-mapping",
      "blog": "LeetCode: Arrays and Hashing"
    },
    {
      "type": "HashMap",
      "title": "Algorithm",
      "summary": "Case where a problem that seems to require a HashMap is easily solved by an algorithm specifically made for that problem",
      "exampleIntro": "Boyer-Moore Voting Algorithm",
      "codeExample": "def majorityElement(nums: List[int]) -> int:\n    candidate = None\n    count = 0\n\n    # Phase 1: Find a candidate for the majority element\n    for num in nums:\n        if count == 0:  # Reset candidate\n            candidate = num\n        count += (1 if num == candidate else -1)\n\n    # Phase 2: Confirm the candidate (optional if majority element is guaranteed)\n    return candidate",
      "useCaseLink": "/Notes/leetcode-arrays-and-hashing#hashmap-application-algorithm",
      "blog": "LeetCode: Arrays and Hashing"
    }
  ],
  "stack": [
    {
      "type": "Stack",
      "title": "Tracking Nested or Hierarchical Structures",
      "summary": "We can track structure while iterating over an object ensuring it maintains some criteria",
      "exampleIntro": "Validate if a string containing brackets ()[]{} is properly balanced:",
      "codeExample": "def balancedParentheses(s: str) -> bool:\n        stack = []\n        pairs = {')': '(', ']': '[', '}': '{'}\n        for char in s:\n            if char in pairs.values():\n                stack.append(char)\n            elif char in pairs:\n                if not stack or stack.pop() != pairs[char]:\n                    return False\n        return not stack",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-tracking-nested-or-hierarchical-structures",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Backtracking by Tracking History or State",
      "summary": "We can use stacks in backtracking to store the state of exploration. When a branch reaches a dead end or a solution, we pop the state to return to the previous state and continue exploring other branches.",
      "exampleIntro": "Subset Sum with Backtracking",
      "codeExample": "def subset_sum(nums, target):\n        stack = [(0, [], 0)]  # (index, current_subset, current_sum)\n        result = []\n        \n        while stack:\n            index, current_subset, current_sum = stack.pop()\n            \n            if current_sum > target:  # Prune invalid paths\n                continue\n            \n            if current_sum == target:  # Valid solution\n                result.append(list(current_subset))\n                continue\n            \n            # Push new states for further exploration\n            for i in range(index, len(nums)):\n                stack.append((i + 1, current_subset + [nums[i]], current_sum + nums[i]))\n        \n        return result\n\n    # subset_sum([2, 3, 6, 7], 7) = [[7]]",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-backtracking-by-tracking-history-or-state",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Monotonic Property Maintenance",
      "summary": "A stack can maintain a monotonic property (increasing or decreasing) over a sequence while processing elements, ensuring efficient lookups or modifications.",
      "exampleIntro": "Find the Next Greater Element",
      "codeExample": "def nextGreaterElement(nums):\n        stack = []  # Stores indices of elements in decreasing order\n        result = [-1] * len(nums)  # Initialize result with -1\n        \n        for i in range(len(nums)):\n            while stack and nums[i] > nums[stack[-1]]:\n                idx = stack.pop()\n                result[idx] = nums[i]  # Found the next greater element\n            stack.append(i)\n        \n        return result\n\n    # Example: nextGreaterElement([2, 1, 2, 4, 3]) -> [4, 2, 4, -1, -1]",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-monotonic-property-maintenance",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Simulating Recursion or Call Stacks",
      "summary": "We can use a stack to emulate recursion by explicitly managing the call stack.",
      "exampleIntro": "Traverse a binary tree in preorder (root -> left -> right):",
      "codeExample": "def preorderTraversal(root):\n        if not root:\n            return []\n        \n        stack = [root]  # Start with the root node\n        result = []\n        \n        while stack:\n            node = stack.pop()  # Simulate recursion by processing the top of the stack\n            if node:\n                result.append(node.val)  # Visit the node\n                # Push right child first so the left child is processed next\n                if node.right:\n                    stack.append(node.right)\n                if node.left:\n                    stack.append(node.left)\n        \n        return result\n\n    # Example: For a tree with root → 1, left → 2, right → 3, preorderTraversal(root) -> [1, 2, 3]",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-simulating-recursion-or-call-stacks",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Expression Evaluation and Parsing",
      "summary": "We can use a stack to evaluate or parse expressions by storing operands and incrementally applying operators. This approach is well-suited for postfix and prefix notations.",
      "exampleIntro": "Post and Prefix",
      "codeExample": "def evaluatePostfix(expression):\n        stack = []  # To hold operands during evaluation\n        \n        for token in expression.split():\n            if token.isdigit():  # If it's an operand, push it to the stack\n                stack.append(int(token))\n            else:  # If it's an operator, pop two operands and apply the operator\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':  # Assuming integer division\n                    stack.append(a // b)\n        \n        return stack.pop()  # Final result is the only item left in the stack\n\n    # Example:\n    # Input: \"3 4 + 2 * 1 +\"\n    # Output: 15 (Equivalent to (3 + 4) * 2 + 1)",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-expression-evaluation-and-parsing",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Dynamic Programming State Compression",
      "summary": "We can use a stack to compress the necessary state while scanning through data, especially when enforcing a specific constraint or invariant like monotonicity. Instead of storing the entire history, we prune irrelevant elements from the stack to keep only the most useful summary of the past",
      "exampleIntro": "Given an array, partition it into the minimum number of strictly",
      "codeExample": "def min_partitions(nums):\n        stacks = []  # Each element represents the last number in a subsequence\n        \n        for num in nums:\n            placed = False\n            for i in range(len(stacks)):\n                # If we can append to subsequence i\n                if stacks[i] < num:\n                    stacks[i] = num\n                    placed = True\n                    break\n            if not placed:\n                # Start a new subsequence (partition)\n                stacks.append(num)\n        return len(stacks)\n\n    # Example usage:\n    nums = [1, 3, 2, 4, 6, 5]\n    print(min_partitions(nums))  # Output: 2",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-dynamic-programming-state-compression",
      "blog": "LeetCode: Stacks"
    },
    {
      "type": "Stack",
      "title": "Interval and Range Processing",
      "summary": "We can use stacks to efficiently process intervals or ranges, such as merging overlapping intervals, calculating spans, or finding next/previous smaller or larger elements within a range.",
      "exampleIntro": "Largest Rectangle in Histogram",
      "codeExample": "def largestRectangleArea(heights):\n        stack = []  # stores indices of bars\n        max_area = 0\n        \n        for i, h in enumerate(heights + [0]):  # Add sentinel to flush stack\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                left = stack[-1] if stack else -1\n                width = i - left - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        return max_area\n\n    # Example:\n    # Input: [2, 1, 5, 6, 2, 3]\n    # Output: 10  (largest rectangle is formed by heights 5 and 6)",
      "useCaseLink": "/Notes/leetcode-stacks#stack-application-interval-and-range-processing",
      "blog": "LeetCode: Stacks"
    }
  ],
  "two-pointers": [
    {
      "type": "Two Pointers",
      "title": "One Pointer with Auxiliary State",
      "summary": "Use a single pointer to scan linearly and keep track of additional state variables to simulate a second pointer.",
      "exampleIntro": "Move all zeros while maintaining order",
      "codeExample": "def move_zeros(nums: list[int]) -> None:\n        # `last_non_zero_found_at` tracks the position where the next non-zero\n        # element should be placed, simulating a second pointer.\n        last_non_zero_found_at = 0\n\n        for current in range(len(nums)):\n            if nums[current] != 0:\n                nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n                last_non_zero_found_at += 1\n\n    # arr = [0, 1, 0, 3, 12] \n    # move_zeros(arr)  Output: [1, 3, 12, 0, 0]",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-one-pointer-with-auxiliary-state",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Opposite Ends",
      "summary": "We can have two pointers starting at opposite ends of a list and move them inward while validating some sort of logic.",
      "exampleIntro": "Determine if a string is a palindrome",
      "codeExample": "def is_palindrome(s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    # Example:\n    print(is_palindrome(\"radar\"))  # Output: True\n    print(is_palindrome(\"hello\"))  # Output: False",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-opposite-ends",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Sliding Window",
      "summary": "We can have two pointers represent a window over a sequence that expands or shrinks to satisfy a condition.",
      "exampleIntro": "Find the length of the longest substring without repeating characters.",
      "codeExample": "def longest_unique_substring(s: str) -> int:\n        char_set = set()\n        left = 0\n        maxLength = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n            char_set.add(s[right])\n            maxLength = max(maxLength, right - left + 1)\n        \n        return maxLength\n\n    # Example:\n    print(longest_unique_substring(\"abcabcbb\"))  # Output: 3",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-sliding-window",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Fast & Slow Pointers",
      "summary": "We can have have two pointers moving at different speeds to detect cycles or find midpoints in linked lists or arrays.",
      "exampleIntro": "Detect a cycle in a linked list.",
      "codeExample": "class ListNode:\n        def __init__(self, value=0, next=None):\n            self.value = value\n            self.next = next\n\n    def has_cycle(head: ListNode) -> bool:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n    # Example:\n    # Construct a list with a cycle: 1 -> 2 -> 3 -> 4 -> 2 (cycle)\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(3)\n    node4 = ListNode(4)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node2\n    print(has_cycle(node1))  # Output: True",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-fast-slow-pointers-",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Partitioning",
      "summary": "We can have two pointers in the same array moving inward/outward to rearrange elements based on a condition.",
      "exampleIntro": "Move all zeros in an array to the end while maintaining the order of other elements",
      "codeExample": "def move_zeros(nums):\n        left, right = 0, 0\n        while right < len(nums):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n            right += 1\n        return nums\n\n    # Example:\n    print(move_zeros([0, 1, 0, 3, 12]))  # Output: [1, 3, 12, 0, 0]",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-partitioning",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Parallel Pointer Traversal",
      "summary": "We can have two pointers traversing two separate arrays in parallel to merge, compare, or find intersections.",
      "exampleIntro": "Merge two sorted arrays into one sorted array",
      "codeExample": "def merge_sorted_arrays(arr1, arr2):\n        result = []\n        i, j = 0, 0\n\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                result.append(arr1[i])\n                i += 1\n            else:\n                result.append(arr2[j])\n                j += 1\n        \n        result.extend(arr1[i:])\n        result.extend(arr2[j:])\n        return result\n\n    # Example:\n    print(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))  # Output: [1, 2, 3, 4, 5, 6]",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-parallel-pointer-traversal-",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Catchup",
      "summary": "We have two pointers traversing one array. One remains frozen, but catches up to the other after logic is complete on a subsection.",
      "exampleIntro": "Decode Two Pointer Splicing",
      "codeExample": "",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-catchup",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "K Pointer Variants",
      "summary": "We can extend the two pointer case to track k pointers simultaneously. These pointers can traverse the same list, different lists, or freeze while moving other pointers.",
      "exampleIntro": "Given an integer array nums, return all the unique triplets [nums[i], nums[j], nums[k]] that sum to 0.",
      "codeExample": "def threeSum(nums):\n        nums.sort()  # Step 1: Sort the array\n        result = []\n\n        for i in range(len(nums)):\n            # Avoid duplicates for the first element\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            # Two-pointer approach\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if current_sum == 0:\n                    result.append([nums[i], nums[left], nums[right]])\n\n                    # Move pointers and avoid duplicates\n                    left += 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    right -= 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n\n                elif current_sum < 0:\n                    left += 1  # Increase sum by moving left pointer rightward\n                else:\n                    right -= 1  # Decrease sum by moving right pointer leftward\n\n        return result\n\n    # Example usage:\n    nums = [-1, 0, 1, 2, -1, -4]\n    print(threeSum(nums))  # Output: [[-1, -1, 2], [-1, 0, 1]]",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-k-pointer-variants-",
      "blog": "LeetCode: Two Pointers"
    },
    {
      "type": "Two Pointers",
      "title": "Algorithm",
      "summary": "Case where a problem that seems to require Two Pointers is easily solved by an algorithm specifically made for that problem",
      "exampleIntro": "Manacher's Algorithm, find the longest palindromic substring",
      "codeExample": "def longestPalindrome(s: str) -> str:\n        # Preprocess the string to handle even-length palindromes\n        t = \"#\".join(f\"^{s}$\")\n        n = len(t)\n        p = [0] * n\n        center = right = 0\n\n        \n        for i in range(1, n - 1):\n            mirror = 2 * center - i  # Mirror of `i` with respect to `center`\n\n            # If within bounds of the current right boundary\n            if i < right:\n                p[i] = min(right - i, p[mirror])\n\n            # Expand around `i`\n            while t[i + p[i] + 1] == t[i - p[i] - 1]:\n                p[i] += 1\n\n            # Update the center and right boundary if the palindrome is expanded\n            if i + p[i] > right:\n                center = i\n                right = i + p[i]\n\n        # Find the maximum length palindrome\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(p))\n        start = (centerIndex - maxLen) // 2  # Convert index back to original string\n        return s[start: start + maxLen]",
      "useCaseLink": "/Notes/leetcode-two-pointers#two-pointers-application-algorithm",
      "blog": "LeetCode: Two Pointers"
    }
  ],
  "binary-search": [
    {
      "type": "Binary Search",
      "title": "Target Binary Search",
      "summary": "Using Binary Search to locate the position of a target element in a sorted list by repeatedly dividing the search interval in half.",
      "exampleIntro": "Searching for a target number in a sorted array.",
      "codeExample": "def binarySearch(nums, target):\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid  # Target found\n        elif nums[mid] < target:\n            left = mid + 1  # Search right half\n        else:\n            right = mid - 1  # Search left half\n\n    return -1  # Target not found",
      "useCaseLink": "/Notes/leetcode-binary-search#binary-search-application-target-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "type": "Binary Search",
      "title": "Multiple Layers Binary Search",
      "summary": "Applying binary search in multiple stages or layers, typically to first narrow down a substructure (i.e., row, segment, or time range), and then again within that substructure This approach is useful when data is structured in nested sorted layers.",
      "exampleIntro": "Searching for a target in a sorted 2D matrix",
      "codeExample": "def searchMatrix(matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        rows, cols = len(matrix), len(matrix[0])\n\n        # First layer: Binary search over rows to find candidate row\n        top, bottom = 0, rows - 1\n        while top <= bottom:\n            mid_row = (top + bottom) // 2\n            if matrix[mid_row][0] <= target <= matrix[mid_row][-1]:\n                break\n            elif matrix[mid_row][0] > target:\n                bottom = mid_row - 1\n            else:\n                top = mid_row + 1\n        else:\n            return False  # Target is outside all row ranges\n\n        # Second layer: Binary search within the found row\n        row = mid_row\n        left, right = 0, cols - 1\n        while left <= right:\n            mid_col = (left + right) // 2\n            if matrix[row][mid_col] == target:\n                return True\n            elif matrix[row][mid_col] < target:\n                left = mid_col + 1\n            else:\n                right = mid_col - 1\n\n        return False",
      "useCaseLink": "/Notes/leetcode-binary-search#binary-search-application-multiple-layers-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "type": "Binary Search",
      "title": "Optimization Search Min Max Binary Search",
      "summary": "Using binary search to find the smallest or largest valid value that satisfies a given constraint (e.g., minimum speed, minimum time, maximum capacity) Searches over a numeric range, not for a target, and typically uses while left < right (left == right, as a trigger) to fin the min or max boundary.",
      "exampleIntro": "Find the minimum eating speed to finish all bananas within h hours",
      "codeExample": "def minEatingSpeed(piles: List[int], h: int) -> int:\n        def hours_needed(speed):\n            return sum((pile + speed - 1) // speed for pile in piles)  # ceil\n\n        left, right = 1, max(piles)\n\n        # Optimization Search\n        while left < right:\n            mid = (left + right) // 2\n\n            # Try slower (minimization)\n            if hours_needed(mid) <= h:\n                right = mid  \n            \n            # Need faster\n            else:\n                left = mid + 1 \n\n        # Note:\n        # there is no case where left > right breaks the loop,\n        # because the condition is < and not <=,\n        # so trigger will always be:\n        # left == right\n        \n        # Smallest k that works\n        return left",
      "useCaseLink": "/Notes/leetcode-binary-search#binary-search-application-optimization-search-min-max-binary-search-",
      "blog": "LeetCode: Binary Search"
    },
    {
      "type": "Binary Search",
      "title": "Condition Adapted Binary Search",
      "summary": "Adapting search conditions of binary search to account for special problem parameters or constraints (e.g., rotated array, duplicates, bounded search). Covers problems where binary search is applied, but the standard algorithm is modified.",
      "exampleIntro": "Finding the minimum element in a rotated sorted array",
      "codeExample": "def findMin(nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n\n        # If array is not rotated (fully sorted ascending)\n        if nums[left] < nums[right]:\n            return nums[left]\n\n        # Modified binary search with parameter-based decision\n        while left < right:\n            mid = (left + right) // 2\n            \n            # Decision based on comparing mid and right elements\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n\n        # left == right points to minimum element\n        return nums[left]",
      "useCaseLink": "/Notes/leetcode-binary-search#binary-search-application-condition-adapted-binary-search",
      "blog": "LeetCode: Binary Search"
    },
    {
      "type": "Binary Search",
      "title": "Upper Ceiling or Lower Floor Trick Based on Target Binary Search",
      "summary": "Binary search cannot directly find the largest element less than or equal to a target (or similarly find the smallest elements greater than or equal to a target) in one step. Instead we search for the first element greater than the target and then simply shift one position left to get the largest element less than or equal.",
      "exampleIntro": "Find the first element less than or equal to target",
      "codeExample": "def largest_leq_shift(nums, target):\n        left, right = 0, len(nums)  # half-open interval [left, right)\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1  # move right since mid less to target\n            else:\n                right = mid     # mid > target, shrink right side\n\n        # left is now the index of first element > target\n        # so the answer is at left - 1 (if valid)\n        return nums[left - 1] if left > 0 else \"\"",
      "useCaseLink": "/Notes/leetcode-binary-search#binary-search-application-upper-ceiling-or-lower-floor-trick-based-on-target-binary-search",
      "blog": "LeetCode: Binary Search"
    }
  ],
  "sliding-window": [
    {
      "type": "Sliding Window",
      "title": "Fixed Size Window",
      "summary": "Fixed size windows help maintain a constant window of k elements while scanning through a sequence.",
      "exampleIntro": "Maximum sum of any subarray of size k",
      "codeExample": "def maxSumSubarray(nums, k):\n        window_sum = sum(nums[:k])\n        max_sum = window_sum\n        \n        for i in range(k, len(nums)):\n            window_sum += nums[i] - nums[i - k]\n            max_sum = max(max_sum, window_sum)\n        \n        return max_sum\n\n    # maxSumSubarray([1, 4, 2, 10, 2, 3, 1, 0, 20], 4) = 24",
      "useCaseLink": "/Notes/leetcode-sliding-window#sliding-window-application-fixed-size-window",
      "blog": "LeetCode: Sliding Window"
    },
    {
      "type": "Sliding Window",
      "title": "Variable Size Window",
      "summary": "Variable size windows expand and shrink dynamically depending on whether some condition or constraint is met (e.g., substring uniqueness, sum ≤ target).",
      "exampleIntro": "Longest substring without repeating characters",
      "codeExample": "def lengthOfLongestSubstring(s: str) -> int:\n        char_index = {}\n        left = max_len = 0\n        \n        for right in range(len(s)):\n            if s[right] in char_index and char_index[s[right]] >= left:\n                left = char_index[s[right]] + 1\n            \n            char_index[s[right]] = right\n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n\n    # \"abcabcbb\" → lengthOfLongestSubstring = 3",
      "useCaseLink": "/Notes/leetcode-sliding-window#sliding-window-application-variable-size-window",
      "blog": "LeetCode: Sliding Window"
    }
  ],
  "linked-list": [
    {
      "type": "Linked List",
      "title": "Linear Traversal",
      "summary": "We can traverse a linked list node by node using a single pointer. Commonly used for printing, searching, summing values, etc.",
      "exampleIntro": "Count number of nodes in the list",
      "codeExample": "def countNodes(head):\n        count = 0\n        curr = head\n        \n        while curr: \n            count += 1\n            curr = curr.next\n\n        return count",
      "useCaseLink": "/Notes/leetcode-linked-list#linked-list-application-linear-traversal",
      "blog": "LeetCode: Linked List"
    },
    {
      "type": "Linked List",
      "title": "Dummy Head Trick",
      "summary": "Using a dummy (sentinel) node simplifies edge cases in linked list operations, especially when manipulating the head node. Dummy node precedes the head, providing the uniform way to handle deletions, insertions, or merges without adding logic to handle the head.",
      "exampleIntro": "Remove nth node from end of a list using dummy head",
      "codeExample": "def removeNthFromEnd(head: Optional[ListNode], n: int) -> Optional[ListNode]:\n    \n    # dummy (sentinel) node used to point to the head\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    # Move fast pointer n+1 steps ahead to keep gap\n    for _ in range(n + 1):\n        fast = fast.next\n\n    # Move both pointers until fast reaches end\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    # Remove the nth node (slow.next)\n    slow.next = slow.next.next\n\n    # Return head dummy is pointing to (may be different from original)\n    return dummy.next",
      "useCaseLink": "/Notes/leetcode-linked-list#linked-list-application-dummy-head-trick",
      "blog": "LeetCode: Linked List"
    },
    {
      "type": "Linked List",
      "title": "Tortoise and Hare",
      "summary": "We can represent fast and slow pointers to traverse the list. Useful for splitting lists in half for sorting or palindrome checks and for checking for cycles.",
      "exampleIntro": "Return middle node in list",
      "codeExample": "def findMiddle(head):\n        slow = fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow\n\n    # If F == None: Even length list\n    # S points to start of right half\n    # Left and right halves have equal length\n\n    # If F != None: Odd length list\n    # S points to middle node (belongs to left half) \n    # Left half is longer by 1 element\n\n    # None                              S: None\n    # S^F^                              F: None\n\n    # 0     None                        S: 0\n    # S^F^                              F: 0\n\n    # 0   1   None                      S: 1\n    #     S^  F^                        F: None\n\n    # 0   1   2   None                  S: 1\n    #     S^  F^                        F: 2\n\n    # 0   1   2   3   None              S: 2\n    #         S^      F^                F: None\n\n    # 0   1   2   3   4   None          S: 2\n    #         S^      F^                F: 4\n\n    # 0   1   2   3   4   5   None      S: 3\n    #             S^          F^        F: None\n\n    # 0   1   2   3   4   5   6   None  S: 3\n    #             S^          F^        F: 6",
      "useCaseLink": "/Notes/leetcode-linked-list#linked-list-application-tortoise-and-hare",
      "blog": "LeetCode: Linked List"
    },
    {
      "type": "Linked List",
      "title": "In Place Modification",
      "summary": "Iteratively manipulate linked list during traversal for O(1) time and space.",
      "exampleIntro": "Reverse the entire list and return a new head",
      "codeExample": "def reverseList(head):\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev",
      "useCaseLink": "/Notes/leetcode-linked-list#linked-list-application-in-place-modification",
      "blog": "LeetCode: Linked List"
    }
  ],
  "tree": [
    {
      "type": "Tree",
      "title": "DFS Pre Order Recursive One Sided Top Down",
      "summary": "Traversal Order: Root -> Left -> Right (or Root -> Right -> Left) Mindset: Process the root as soon as you see it, then traverse into one subtree fully before the other Trick: I'll visit you first, then i'll deal with your kids",
      "exampleIntro": "Serialize a Binary Tree Recursive",
      "codeExample": "def preOrderSerializeRecursive(root: Optional[TreeNode]) -> str:\n        \n        def dfsPreOrder(node):\n            # Note:\n            # DFS pre order: root -> left -> right\n\n            # Base case: process leaf \n            if not node:\n                vals.append(\"N\")\n                return\n            \n            # Process root -> (DFS top down)\n            vals.append(str(node.val))\n            \n            # Note:\n            # order of recursive call determines order\n\n            # Recursive call to process -> left -> right, left deepest \n            dfsPreOrder(node.left)\n            dfsPreOrder(node.right)\n\n            # could have been: -> right -> left\n            # with deep right subtree \n            # dfsPreOrder(node.right)\n            # dfsPreOrder(node.left)\n        \n        # serialized array\n        vals = []\n\n        # recursive call at root\n        dfsPreOrder(root)\n\n        # join serialized array\n        return \",\".join(vals)\n\n    # Tree:\n    #       1\n    #      / \\\n    #     2   3\n    #        / \\\n    #       4   5\n    # Output: \"1,2,N,N,3,4,N,N,5,N,N\"",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-pre-order-recursive-one-sided-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "DFS Pre Order Iterative One Sided Top Down",
      "summary": "Traversal Order: Root -> Left -> Right (or Root -> Right -> Left) Mindset: Process the root as soon as you see it, then traverse into one subtree fully before the other Trick: I'll visit you first, then i'll deal with your kids",
      "exampleIntro": "Pre Order Serialize a Binary Tree Iterative",
      "codeExample": "def preOrderSerializeIterative(root: Optional[TreeNode]) -> str:\n        # Note:\n        # DFS pre order: root -> left -> right\n\n        # Empty Check\n        if not root:\n            return \"N\"\n\n        # iteration via stack\n        stack = [root]\n\n        # serialized array\n        vals = []\n        \n        while stack:\n\n            # dfs -> pop()\n            # bfs -> popleft()\n            currRoot = stack.pop()\n\n            # process root ->: if value\n            if currRoot:\n\n                # serialize root (dfs pre order top down)\n                vals.append(str(currRoot.val))\n                \n                # Note:\n                # order of append determines order\n\n                # Iterative process: -> left -> right\n                # append(right), append(left), as pop() will pop(left), pop(right)\n                # pop() leads to deep left subtree search \n                stack.append(currRoot.right)\n                stack.append(currRoot.left)\n\n\n                # Could have been -> right -> left\n                # leading to deep right subtree search\n                # stack.append(currRoot.left)\n                # stack.append(currRoot.right)\n            \n            # process root ->: if leaf\n            else:\n                # serialize root (dfs pre order top down)\n                vals.append(\"N\")\n        \n        # join serialized array\n        return \",\".join(vals)\n\n    # Tree:\n    #       1\n    #      / \\\n    #     2   3\n    #        / \\\n    #       4   5\n    # Output: \"1,2,N,N,3,4,N,N,5,N,N\"",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-pre-order-iterative-one-sided-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "DFS In Order Recursive One Sided Bottom Up",
      "summary": "Traversal Order: Left -> Root -> Right  (or Right -> Root -> Left) Mindset: Fully explore one side before paying attention to the root, then move to the other side Trick: I'll finish everything to your left or right before I pay attention to you",
      "exampleIntro": "Convert BST to Sorted List Recursive and Validate BST Iterative",
      "codeExample": "def bstToSortedList(root: Optional[TreeNode]) -> List[int]:\n        \n        # tracks previous value\n        prev_val = float(\"-inf\")\n            \n        def dfsInOrder(node):\n            nonlocal prev_val\n            \n            # Base case: leaf -> no value\n            if not node:\n                return True\n            \n            # recursive call to process left subtree\n            if not dfsInOrder(node.left):\n                return False\n            \n            # process node (mid-point work)\n            if node.val <= prev_val:\n                return False\n\n            # set to current value\n            prev_val = node.val\n            \n            # recursive call to process right subtree\n            return dfsInOrder(node.right)\n        \n        # recursive call on root\n        return dfsInOrder(root)\n\n        # Tree:\n        #       2\n        #      / \\\n        #     1   3\n        # isValidBST -> True",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-in-order-recursive-one-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "DFS In Order Iterative One Sided Bottom Up",
      "summary": "Traversal Order: Left -> Root -> Right  (or Right -> Root -> Left) Mindset: Fully explore one side before paying attention to the root, then move to the other side Trick: I'll finish everything to your left or right before I pay attention to you",
      "exampleIntro": "Convert BST to Sorted List Recursive and Validate BST Iterative",
      "codeExample": "def isValidBST(root: Optional[TreeNode]) -> bool:\n        \n        # tracks previous value\n        prev_val = float(\"-inf\")\n\n        # iteration via stack\n        stack = [] \n\n        # pointer to check for empty case\n        curr = root\n        \n        while stack or curr:\n            \n            # traverse left subtree of curr:\n            # will go as far left as possible\n            while curr: \n                # continue traversal down left subtree\n                stack.append(curr)\n                curr = curr.left\n            \n            # Exited loop: \n            # reached 'leaf' of left subtree\n            #     L\n            #  /     \\ \n            # leaf    ?\n                        \n            # process left, node, right:\n            # via previous left subtree node 'L' from stack\n            curr = stack.pop()\n\n            # validate\n            if curr.val <= prev_val:\n                return False\n\n            # set to current value\n            prev_val = curr.val\n            \n            # traverse right subtree\n            # (which we thus explore left, node and right subtrees again)\n            #     L\n            #  /     \\ \n            # leaf    *here*\n            curr = curr.right\n        \n        return True\n\n    # Tree:\n    #       2\n    #      / \\\n    #     1   3\n    # isValidBST -> True",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-in-order-iterative-one-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "DFS Post Order Recursive Two Sided Bottom Up",
      "summary": "Traversal Order: Left -> Right -> Root (or Right -> Left -> Root) Mindset: Fully explore both sides before processing the root. Trick: I'll finish everything to your left then right or right then left before I pay attention to you",
      "exampleIntro": "Evaluate Expression Tree Recursive and Delete Tree Iterative",
      "codeExample": "def diameterOfBinaryTree(root: Optional[TreeNode]) -> int:\n        \n        # global diameter\n        diameter = 0\n\n        def dfs(node):\n            nonlocal diameter\n\n            # Base case:\n            # no width added\n            if not node:\n                return 0\n\n            # recursive call to process left and right\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            # process node\n            diameter = max(diameter, left + right)\n\n            # pass width upwards\n            return 1 + max(left, right)\n\n        # recursive on root\n        dfs(root)\n\n        # return global diameter\n        return diameter\n\n    # Tree:\n    #         1\n    #        / \\\n    #       2   3\n    #      / \\\n    #     4   5\n    # diameterOfBinaryTree -> 3",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-post-order-recursive-two-sided-bottom-up",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "DFS Post Order Iterative Two Sided Bottom Up",
      "summary": "Traversal Order: Left -> Right -> Root (or Right -> Left -> Root) Mindset: Fully explore both sides before processing the root. Trick: I'll finish everything to your left then right or right then left before I pay attention to you",
      "exampleIntro": "Evaluate Expression Tree Recursive and Delete Tree Iterative",
      "codeExample": "def diameterOfBinaryTree(root: Optional[TreeNode]) -> int:\n\n        # Empty check\n        if not root:\n            return 0\n\n        # global width\n        diameter = 0\n\n        # iterative stack\n        stack = []\n\n        # \n        curr = root\n        lastVisited = None\n        depth_map = defaultdict(int)\n\n        while stack or curr:\n\n            # traverse left subtree of curr:\n            # will go as far left as possible\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            # check if right subtree exists\n            peek = stack[-1]\n\n            # if right subtree exists and hasn't been visited\n            if peek.right and lastVisited != peek.right:\n                node = peek.right\n\n            # process node\n            else:\n                stack.pop()\n\n                # grab width of left and right subtree if exists\n                left_depth = depth_map.get(peek.left, 0)\n                right_depth = depth_map.get(peek.right, 0)\n\n                # node diameter\n                diameter = max(diameter, left_depth + right_depth)\n\n                # store node diameter\n                depth_map[peek] = 1 + max(left_depth, right_depth)\n\n                # set last visited to current node\n                lastVisited = peek\n\n        # return width\n        return diameter\n\n    # Tree:\n    #         1\n    #        / \\\n    #       2   3\n    #      / \\\n    #     4   5\n    # diameterOfBinaryTree -> 3 (path: 4 → 2 → 5 or 4 → 2 → 1 → 3)",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-dfs-post-order-iterative-two-sided-bottom-up-",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BFS Pre Order Across Level For Level Size Based Grouping Full Across Top Down",
      "summary": "Traversal Order: Level by Level BFS visits nodes level by level, processing all nodes at a given depth before moving on to the next. Used for level order problems and shortest path calculations in unweighted graphs, as well as scenarios requiring nodes in order of distance from the root.",
      "exampleIntro": "Level order traversal of Binary Tree",
      "codeExample": "def levelOrderIterative(root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Empty check\n        if not root:\n            return []\n\n        group = []\n\n        # start with group 1: root\n        queue = deque([root])\n\n        while queue:\n\n            # grab size of curr level\n            size = len(queue)\n            level = []\n\n            # process entire level\n            for _ in range(size):\n\n                # grab node of group\n                node = queue.popleft()\n                level.append(node.val)\n\n                # append next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            # add level group to list of groups\n            groups.append(level)\n\n        # return all level groups\n        return groups\n\n    # Example:\n    # Input Tree:\n    #       1\n    #      / \\\n    #     2   3\n    #        / \\\n    #       4   5\n    # Output: [[1], [2, 3], [4, 5]]",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bfs-pre-order-across-level-for-level-size-based-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BFS Pre Order Across Level No Explicit Level Sized Grouping Full Across Top Down",
      "summary": "Traversal Order: Level by Level BFS visit nodes in breath first order. However, in some problems we don't process or store the full level at once. Instead we act on nodes individually or in partial groupings (pairs, linked neighbors, etc)",
      "exampleIntro": "Invert a Binary Tree",
      "codeExample": "def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        # start at root\n        queue = deque([root])\n        \n        while queue:\n\n            # grab nodes sequentially\n            node = queue.popleft()\n            \n            # process node\n            node.left, node.right = node.right, node.left\n            \n            # process left and right subtrees by appending to queue\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return root\n\n        # Example:\n        # Input Tree:\n        #       4\n        #      / \\\n        #     2   7\n\n        # Output Tree:\n        #       4\n        #      / \\\n        #     7   2",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bfs-pre-order-across-level-no-explicit-level-sized-grouping-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BFS Pre Order Across Level Distance from Root Full Across Top Down",
      "summary": "Traversal Order: Level by Level Distance Tracking: Each level corresponds to one distance step from the root. Used when the problem depends on minimum, maximum or some count depth.",
      "exampleIntro": "Minimum Depth of a Binary Tree",
      "codeExample": "def minDepth(root: Optional[TreeNode]) -> int:\n        from collections import deque\n        \n        # Empty Tree\n        if not root:\n            return 0\n        \n        # initialize depth value\n        queue = deque([(root, 1)])\n        \n        while queue:\n            \n            # grab current depth, increase to children\n            node, depth = queue.popleft()\n            \n            # first leaf found -> min depth \n            if not node.left and not node.right:\n                return depth\n            \n            # iterate to left and right subtrees with updated depth\n            if node.left:\n                queue.append((node.left, depth + 1))\n            if node.right:\n                queue.append((node.right, depth + 1))",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bfs-pre-order-across-level-distance-from-root-full-across-top-down",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BFS Pre Order Across Level Non-Standard Level Traversal Non Standard Full Across",
      "summary": "Traversal Order: Level by Level (but with non default ordering such as reversed, zigzag, or other patterns) Used when the traversal order of nodes at each level must follow a specific non standard pattern",
      "exampleIntro": "Binary Tree Zigzag Level Order Traversal",
      "codeExample": "def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Empty Tree\n        if not root:\n            return []\n        \n        groups = []\n\n        # iteration stack\n        queue = deque([root])\n\n        # order toggle\n        left_to_right = True\n        \n        while queue:\n\n            # for each level\n            size = len(queue)\n            level = deque()\n            \n            # Process all nodes in current level\n            for _ in range(size):\n                node = queue.popleft()\n                \n                # append order based on pattern\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.appendleft(node.val)\n                \n                # iterate by appending left and right subtrees\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # flip order for next level\n            left_to_right = not left_to_right  \n\n            # add to groups            \n            groups.append(list(level))\n\n        return groups\n\n    # Example:\n    # Input Tree:\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\   \\\n    #   4   5   6\n\n    # Output: [[1], [3, 2], [4, 5, 6]]",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bfs-pre-order-across-level-nonstandard-level-traversal-non-standard-full-across",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BST Guided Recursive Traversal",
      "summary": "Traversal Order: Top down traversal pruning half the tree at each step based on BST property Mindset: Use BST ordering to decide which subtree to recurse into Trick: Like binary search, narrow search space by recursively exploring only one subtree.",
      "exampleIntro": "Lowest Common Ancestor in BST Recursive",
      "codeExample": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    \n        # If both nodes smaller than root, recurse left subtree\n        if p.val < root.val and q.val < root.val:\n            return lowestCommonAncestor(root.left, p, q)\n\n        # If both nodes greater than root, recurse right subtree\n        elif p.val > root.val and q.val > root.val:\n            return lowestCommonAncestor(root.right, p, q)\n        \n        # Otherwise, root is split point and LCA\n        else:\n            return root",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bst-guided-recursive-traversal",
      "blog": "LeetCode: Trees"
    },
    {
      "type": "Tree",
      "title": "BST Guided Iterative Traversal",
      "summary": "Traversal Order: Top down traversal pruning half the tree at each step based on BST property Mindset: Use BST ordering to decide which subtree to iterate into Trick: Like binary search, narrow search space by iteratively exploring only one subtree.",
      "exampleIntro": "Lowest Common Ancestor in BST Iterative",
      "codeExample": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        curr = root\n\n        while curr:\n            # If both nodes smaller, go left\n            if p.val < curr.val and q.val < curr.val:\n                curr = curr.left\n\n            # If both nodes greater, go right\n            elif p.val > curr.val and q.val > curr.val:\n                curr = curr.right\n            \n            # Else, current node is LCA\n            else:\n                return curr",
      "useCaseLink": "/Notes/leetcode-trees#tree-application-bst-guided-iterative-traversal",
      "blog": "LeetCode: Trees"
    }
  ],
  "trie": [
    {
      "type": "Trie",
      "title": "Trie Insert and Search Recursive",
      "summary": "Traversal Order: Insert/Search characters one by one from root to leaf nodes Mindset: At each char, check subtrees and create new nodes if needed (insert) or check existence (search) Trick: Ill follow the string one char at a time, building or verifying the path as I go",
      "exampleIntro": "Basic Trie Insert and Search Recursive",
      "codeExample": "class TrieNode:\n    def __init__(self):\n        # Children dictionary: char -> TrieNode\n        self.children = {}\n        # Indicates if node marks end of a valid word\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        # Root node represents empty prefix\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        def insert_recursive(node: TrieNode, idx: int):\n            # Note:\n            # Base case: if index reached end of word, mark node as word end\n            if idx == len(word):\n                node.is_end_of_word = True\n                return\n            \n            ch = word[idx]\n            \n            # If no child node for current char, create one\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            \n            # Recursive call to next character\n            insert_recursive(node.children[ch], idx + 1)\n        \n        # Start recursive insertion at root and index 0\n        insert_recursive(self.root, 0)\n\n    def search(self, word: str) -> bool:\n        def search_recursive(node: TrieNode, idx: int) -> bool:\n            # Note:\n            # Base case: if index reached end, check if current node marks end of a word\n            if idx == len(word):\n                return node.is_end_of_word\n            \n            ch = word[idx]\n\n            # If character path missing, word does not exist\n            if ch not in node.children:\n                return False\n            \n            # Recursive call to next character\n            return search_recursive(node.children[ch], idx + 1)\n        \n        # Start recursive search at root and index 0\n        return search_recursive(self.root, 0)\n        \n\n    # [\"cat\", \"car\", \"dog\"]:\n\n    #             root\n    #            /    \\\n    #           c      d\n    #          /        \\\n    #         a          o\n    #        /  \\         \\\n    #        t   r         g\n    #      (end) (end)   (end)",
      "useCaseLink": "/Notes/leetcode-tries#trie-application-trie-insert-and-search-recursive",
      "blog": "LeetCode: Tries"
    }
  ],
  "heap": [
    {
      "type": "Heap",
      "title": "Top K Element Extraction",
      "summary": "We can maintain a heap to quickly retrieve the top K largest or smallest elements without fully sorting the input.",
      "exampleIntro": "Find the kth largest element in array",
      "codeExample": "def kthLargest(nums, k):\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n            if len(heap) > k:\n                heapq.heappop(heap)  # Keep only top K elements\n        return heap[0]\n\n    # Example: kthLargest([3, 2, 1, 5, 6, 4], 2) -> 5",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-top-k-element-extraction",
      "blog": "LeetCode: Heaps"
    },
    {
      "type": "Heap",
      "title": "Dual Heap Balancing Representing Secondary Property",
      "summary": "We can use two heaps, maxHeap for lower half of values and a minHeap for the upper half, to maintain a property while adding and removing elements. Pattern supports quick lookups of medians, balance points, or range constraints.",
      "exampleIntro": "Maintain median of stream.",
      "codeExample": "class MedianFinder:\n    def __init__(self):\n        self.low = []   # Max-heap (invert values)\n        self.high = []  # Min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.low, -num)\n        heapq.heappush(self.high, -heapq.heappop(self.low))\n        if len(self.low) < len(self.high):\n            heapq.heappush(self.low, -heapq.heappop(self.high))\n    \n    def findMedian(self) -> float:\n        if len(self.low) > len(self.high):\n            return -self.low[0]\n        return (-self.low[0] + self.high[0]) / 2",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-dual-heap-balancing-representing-secondary-property",
      "blog": "LeetCode: Heaps"
    },
    {
      "type": "Heap",
      "title": "K Way Merge for Sorted Streams",
      "summary": "A minHeap can efficiently merge multiple sorted lists or streams by always extracting the next smallest element across all inputs.",
      "exampleIntro": "Merge k sorted lists into one sorted lists",
      "codeExample": "def mergeKSorted(lists):\n        heap = []\n        for i, lst in enumerate(lists):\n            if lst:\n                heapq.heappush(heap, (lst[0], i, 0))\n        \n        result = []\n        while heap:\n            val, list_idx, elem_idx = heapq.heappop(heap)\n            result.append(val)\n            if elem_idx + 1 < len(lists[list_idx]):\n                heapq.heappush(heap, (lists[list_idx][elem_idx+1], list_idx, elem_idx+1))\n        return result\n\n    # mergeKSorted([[1,4,5],[1,3,4],[2,6]]) -> [1,1,2,3,4,4,5,6]",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-k-way-merge-for-sorted-streams",
      "blog": "LeetCode: Heaps"
    },
    {
      "type": "Heap",
      "title": "Best First Search or Breadth First Search with Priority",
      "summary": "A heap can drive a search algorithm where you can expand the 'best' candidate first: A*, Dijkstra's, Prims, etc. In a non negative weighted graph context: a minHeap can be used to expand on the closest node first in a This always ensures that the next node popped from the heap has the smallest known distance from the source.",
      "exampleIntro": "Dijkstra's Algorithm MinHeap",
      "codeExample": "def dijkstra(graph, start):\n    \n    # Graph: Node -> list of (neighbor, weight) tuples\n    # start: Starting node for shortest path search\n\n    # Result: \n    # dist: shortest distance from start to all other nodes\n\n    # Init all distances to infinity, \n    # except start node which has distance 0\n    dist = {node: float('inf') for node in graph}\n    dist[start] = 0\n\n    # minHeap priority queue stores tuples of (distance, node)\n    # iterate from start node and commence exploring neighbors\n    heap = [(0, start)]\n\n    # while there are nodes to process in heap\n    while heap:\n        \n        # grab node with smallest known distance from start\n        d, node = heapq.heappop(heap)\n\n        # Skip if we already have already explored a shorter\n        # path to the current node\n        if d > dist[node]:\n            continue\n\n        # Check each neighbor and see if we have found \n        # a shorter path through the current node\n        for nei, w in graph[node]:\n            \n            # grab new distance\n            nd = d + w\n\n            # if shorter path found, update and push to heap\n            if nd < dist[nei]:\n                dist[nei] = nd\n                heapq.heappush(heap, (nd, nei))\n\n    # overall: time complexity\n    # overall: space complexity\n    return dist",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-best-first-search-or-breadth-first-search-with-priority",
      "blog": "LeetCode: Heaps"
    },
    {
      "type": "Heap",
      "title": "Kth element Within Iterating Sliding Window",
      "summary": "A heap can track max/min within a sliding window efficiently when combined with lazy deletion or index tracking.",
      "exampleIntro": "Find maximum in each sliding windows",
      "codeExample": "def max_sliding_window(nums, k):\n\n        # maxHeap via minHeap with negative values\n        # initialize with first k elements\n        heap = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(heap)\n\n        # root of heap is the largest in the current window\n        res = [-heap[0][0]]\n        \n        # iterate sliding window forward\n        for i in range(k, len(nums)):\n\n            # push new element to heap\n            heapq.heappush(heap, (-nums[i], i))\n\n            # remove top element if they are outside current window\n            while heap[0][1] <= i - k:\n                heapq.heappop(heap)\n\n            # after removing out of window elements, heap root is max\n            # within the current window\n            res.append(-heap[0][0])\n\n        return res",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-kth-element-within-iterating-sliding-window",
      "blog": "LeetCode: Heaps"
    },
    {
      "type": "Heap",
      "title": "Interval Scheduling Optimization",
      "summary": "A minHeap can track the earliest finishing times among active intervals, enabling optimal scheduling of jobs or meetings without conflicts.",
      "exampleIntro": "Find the minimum number of meeting rooms required",
      "codeExample": "def minMeetingRooms(intervals):\n\n        # Sort intervals by their start time,\n        # ensures we process meetings in chronological order\n        intervals.sort(key=lambda x: x[0])\n\n        # minHeap to track end time of ongoing meetings,\n        # storing the earliest ending meeting at the top\n        heap = []\n\n        # iterate over rooms in earliest starting order\n        for start, end in intervals:\n\n            # if heap is not empty, and the earliest ending meeting the earliest meeting ends\n            # ends before or exactly when the new meeting starts,\n            # then we can remove the earliest ending meeting \n            # (essentially freeing up a room)\n            if heap and heap[0] <= start:\n                # pop meeting that ended the earliest\n                heapq.heappop(heap)\n\n            # 'start' the current meeting by pushing it to the heap\n            heapq.heappush(heap, end)\n\n        # last heap size is the number meetings running\n        # concurrently after all meetings have started\n        return len(heap)\n\n    # Example: \n    # minMeetingRooms([[0,30],[5,10],[15,20]]) -> 2",
      "useCaseLink": "/Notes/leetcode-heaps#heap-application-interval-scheduling-optimization",
      "blog": "LeetCode: Heaps"
    }
  ],
  "backtracking": [
    {
      "type": "Backtracking",
      "title": "DFS Generate All Combinations Or Subsets",
      "summary": "Traversal Order: Root -> Choices Mindset: Process the current subset as soon as you build it, then explore further elements Trick: Ill record the current subset first, then decide which elements to include next. We can explore all subsets, permutations, or combinations by recursively building solutions and backtracking when needed.",
      "exampleIntro": "Generate all subsets of a set",
      "codeExample": "def subsets(nums):\n        res = []\n        \n        def dfs_backtrack(start, path):\n\n            # Process Root -> : record current subset first\n            res.append(path[:]) \n            \n            # Process -> Choices : decide which to include/exclude\n            for i in range(start, len(nums)):\n\n                # Build: include nums[i]\n                path.append(nums[i])\n\n                # Explore: recurse to next index\n                dfs_backtrack(i + 1, path)\n\n                # Backtrack: remove last element\n                path.pop()\n        \n        dfs_backtrack(0, [])\n        return res\n\n    # Example: subsets([1,2,3]) -> [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]",
      "useCaseLink": "/Notes/leetcode-backtracking#backtracking-application-dfs-generate-all-combinations-or-subsets",
      "blog": "LeetCode: Backtracking"
    },
    {
      "type": "Backtracking",
      "title": "DFS Generate While Constraint Satisfaction",
      "summary": "Traversal Order: Root -> Choices Mindset: Build sequences step by step, only adding valid elements and backtracking when constraints are violated Tricks: Ill try to add '(' or ')' next only if rules allow, then undo if needed. As we explore all permutations, we can enforce rules in order to prune invalid branches early.",
      "exampleIntro": "Generate all valid parentheses",
      "codeExample": "def generateParenthesis(n):\n        res = []\n        \n        def dfs_backtrack(open_count, close_count, path):\n            \n            # Process Root -> : check if sequence complete\n            if len(path) == 2 * n:\n                res.append(\"\".join(path))\n                return\n            \n            # Process -> Choices : add '(' if possible\n            if open_count < n:\n                # Build\n                path.append(\"(\")\n                # Explore\n                dfs_backtrack(open_count + 1, close_count, path)\n                # Backtrack\n                path.pop()\n            \n            # Process -> Choices : add ')' if it will not break validity\n            if close_count < open_count:\n                # Build\n                path.append(\")\")\n                # Explore\n                dfs_backtrack(open_count, close_count + 1, path)\n                # Backtrack\n                path.pop()\n        \n        dfs_backtrack(0, 0, [])\n        return res\n\n    # Example: generateParenthesis(3) -> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
      "useCaseLink": "/Notes/leetcode-backtracking#backtracking-application-dfs-generate-while-constraint-satisfaction",
      "blog": "LeetCode: Backtracking"
    },
    {
      "type": "Backtracking",
      "title": "Path Finding In Search Space",
      "summary": "Traversal Order: Root -> Choices (neighboring paths) Mindset: Explore each path step by step, backtracking when reaching dead ends. Trick: Ill walk one direction fully before trying another, undoing my steps if blocked. We can explore fully explore paths, by stepping through and backtracking when reaching dead ends for different search spaces (grids, graphs, networks).",
      "exampleIntro": "Word Search in grid",
      "codeExample": "def exist(board, word):\n        rows, cols = len(board), len(board[0])\n        \n        def dfs_backtrack(r, c, idx):\n\n            # Early exit:\n            # Process Root -> : matched full word\n            if idx == len(word):\n                return True\n\n            # Early Pruning -> : check boundaries\n            if r < 0 or c < 0 or r >= rows or c >= cols:\n                return False\n\n            # Early Pruning -> : check current cell\n            if board[r][c] != word[idx]:\n                return False\n            \n\n            # Process -> Choices : explore all 4 directions\n\n            # Build: mark current cell as exploring\n            tmp, board[r][c] = board[r][c], \"#\"\n\n            # Explore: recurse to neighbor cell\n            found = (dfs_backtrack(r+1, c, idx+1) or\n                     dfs_backtrack(r-1, c, idx+1) or\n                     dfs_backtrack(r, c+1, idx+1) or\n                     dfs_backtrack(r, c-1, idx+1))\n\n            # Backtrack: Restore cell\n            board[r][c] = tmp\n            return found\n        \n        # dfs_backtrack starting from all cells\n        for r in range(rows):\n            for c in range(cols):\n                if dfs_backtrack(r, c, 0):\n                    return True\n\n        return False\n\n    # Example: exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\") -> True",
      "useCaseLink": "/Notes/leetcode-backtracking#backtracking-application-path-finding-in-search-space",
      "blog": "LeetCode: Backtracking"
    },
    {
      "type": "Backtracking",
      "title": "Combinatorial Optimization",
      "summary": "Traversal Order: Root -> Choices (column positions) Mindset: Place one queen at a time, pruning invalid columns, and backtrack when stuck Trick: Ill place a queen, explore further rows, then remove it if it leads to a conflict. We can search for an optimal solution while pruning bad candidates.",
      "exampleIntro": "N Queens Problem",
      "codeExample": "def solveNQueens(n):\n        res = []\n        cols = set()\n        diag1 = set()  # r - c\n        diag2 = set()  # r + c\n        \n        board = [[\".\"] * n for _ in range(n)]\n        \n        def dfs_backtrack(r):\n            # Process Root -> : all queens placed\n            if r == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            \n            # Process -> Choices : try each column\n            for c in range(n):\n                if c in cols or (r-c) in diag1 or (r+c) in diag2:\n                    continue\n                \n                # Build: place queen\n                board[r][c] = \"Q\"\n                cols.add(c); diag1.add(r-c); diag2.add(r+c)\n                \n                # Explore: recurse to next row\n                dfs_backtrack(r + 1)\n                \n                # Backtrack: remove queen\n                board[r][c] = \".\"\n                cols.remove(c); diag1.remove(r-c); diag2.remove(r+c)\n        \n        dfs_backtrack(0)\n        return res\n\n    # Example: solveNQueens(4) -> [\n    #   [\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],\n    #   [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]\n    # ]",
      "useCaseLink": "/Notes/leetcode-backtracking#backtracking-application-combinatorial-optimization",
      "blog": "LeetCode: Backtracking"
    },
    {
      "type": "Backtracking",
      "title": "Decision Trees And Partitioning",
      "summary": "Traversal Order: Root -> Choices (substring partitions) Mindset: Partition strings step by step, backtracking when a substring is not a palindrome Trick: Ill add a palindromic piece, explore further, then remove it if it doesn't lead to a solution. We can make binary or k-ary decision at each step, exploring all outcomes",
      "exampleIntro": "Partition a string into palindromic substrings",
      "codeExample": "def partition(s):\n        res = []\n\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n        \n        def dfs_backtrack(start, path):\n            # Process Root -> : reached end of string\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            # Process -> Choices : try all possible substrings\n            for end in range(start+1, len(s)+1):\n\n                # Constraint check: palindrome check\n                if is_palindrome(s[start:end]):\n\n                    # Build: add substring\n                    path.append(s[start:end])\n\n                    # Explore: recurse to next string\n                    dfs_backtrack(end, path)\n\n                    # Backtrack: remove substring\n                    path.pop()\n        \n        dfs_backtrack(0, [])\n        return res\n\n    # Example: partition(\"aab\") -> [[\"a\",\"a\",\"b\"], [\"aa\",\"b\"]]",
      "useCaseLink": "/Notes/leetcode-backtracking#backtracking-application-decision-trees-and-partitioning",
      "blog": "LeetCode: Backtracking"
    }
  ],
  "graph": [
    {
      "type": "Graph",
      "title": "DFS Pre Order",
      "summary": "Use pre order DFS when you need to process a node immediately before exploring its neighbors",
      "exampleIntro": "Sink islands or mark visited immediately in a grid",
      "codeExample": "def dfs_pre(r, c, grid):\n    if not (0 <= r < len(grid) and 0 <= c < len(grid[0])) or grid[r][c] == '0':\n        return\n\n    grid[r][c] = '0'  # mark visited (pre-order processing)\n\n    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n        dfs_pre(r + dr, c + dc, grid)\n\n# Example: numIslands uses pre-order DFS to flood fill",
      "useCaseLink": "/Notes/leetcode-graphs#graph-application-dfs-pre-order",
      "blog": "LeetCode: Graphs"
    },
    {
      "type": "Graph",
      "title": "DFS In Order (Binary Tree Only)",
      "summary": "Use in order DFS mainly for binary trees where left -> right order matters",
      "exampleIntro": "Extract sorted values from a BST",
      "codeExample": "def inorder(node, res):\n    if not node:\n        return\n    inorder(node.left, res)\n    res.append(node.val)  # process node in between left/right\n    inorder(node.right, res)\n\n# Example: LeetCode 98, Validate BST or BST inorder traversal",
      "useCaseLink": "/Notes/leetcode-graphs#graph-application-dfs-in-order-binary-tree-only",
      "blog": "LeetCode: Graphs"
    },
    {
      "type": "Graph",
      "title": "DFS Post Order",
      "summary": "Use post order DFS when you want to process a node after exploring all its neighbors.",
      "exampleIntro": "Calculate size of connected components or backtracking cleanup",
      "codeExample": "def dfs_post(r, c, grid):\n    if not (0 <= r < len(grid) and 0 <= c < len(grid[0])) or grid[r][c] == '0':\n        return 0\n\n    grid[r][c] = '0'  # mark visited\n    size = 1  # count current cell\n\n    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n        size += dfs_post(r + dr, c + dc, grid)\n\n    return size  # post-order: aggregate after children\n\n# Example: maxAreaOfIsland uses post-order DFS to sum area",
      "useCaseLink": "/Notes/leetcode-graphs#graph-application-dfs-post-order",
      "blog": "LeetCode: Graphs"
    },
    {
      "type": "Graph",
      "title": "BFS Level Order / Flood Fill",
      "summary": "Use BFS when you need shortest path in unweighted graphs, or to expand layers level by level.",
      "exampleIntro": "Shortest path in 2D grid:",
      "codeExample": "def bfs_shortest(grid, start):\n    queue = deque([(*start, 0)])  # (r, c, distance)\n    visited = set([start])\n\n    while queue:\n        r, c, dist = queue.popleft()\n        if grid[r][c] == 'target':\n            return dist\n\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and (nr,nc) not in visited:\n                visited.add((nr,nc))\n                queue.append((nr,nc, dist + 1))",
      "useCaseLink": "/Notes/leetcode-graphs#graph-application-bfs-level-order-flood-fill",
      "blog": "LeetCode: Graphs"
    },
    {
      "type": "Graph",
      "title": "Union Find Disjoint Set",
      "summary": "Use Union Find to efficiently track connected components in dynamic graphs.",
      "exampleIntro": "Count islands or merge friend groups",
      "codeExample": "def numIslandsUnion(grid):\n        parent = {}\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[find(x)] = find(y)\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == '1':\n                    parent[(r,c)] = (r,c)\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == '1':\n                    for dr, dc in [(1,0),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if (nr,nc) in parent:\n                            union((r,c),(nr,nc))\n        \n        roots = {find(x) for x in parent}\n        return len(roots)",
      "useCaseLink": "/Notes/leetcode-graphs#graph-application-union-find-disjoint-set",
      "blog": "LeetCode: Graphs"
    }
  ],
  "1d-dynamic-programming": [
    {
      "type": "1D Dynamic Programming",
      "title": "DFS with Caching (Padded N+1) Top Down with Memoization",
      "summary": "Pattern: Recursive DFS explores choices, memo stores results to avoid recomputation. Extra base 'padding' simplifies boundary checks. Use When: Problem naturally needs a “ground” or empty state. Recurrence: dfs(i) = dfs(i-1) + dfs(i-2)",
      "exampleIntro": "Climbing Stairs (Top Down, Padded)",
      "codeExample": "def climbStairs(n: int) -> int:\n\n        memo = {}\n\n        def dfs(i: int) -> int:\n\n            if i in memo:\n                return memo[i]\n\n            if i == 0:  # padding: ground, 1 way to do nothing\n                return 1\n            if i == 1:  # padded: first step\n                return 1\n\n            # recursive relation: sum of previous two steps\n            memo[i] = dfs(i-1) + dfs(i-2)\n            return memo[i]\n\n        return dfs(n)",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-dfs-with-caching-padded-n1-top-down-with-memoization",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "DFS with Caching (Direct N) Top Down with Memoization",
      "summary": "Pattern: Recursive DFS explores choices, memo stores results to avoid recomputation. Direct mapping aligns base cases with the first elements. Use When: Problem naturally aligns 1:1 with input array elements. Recurrence: dfs(i) = dfs(i-1) + dfs(i-2)",
      "exampleIntro": "Climbing Stairs (Top Down, Direct)",
      "codeExample": "def climbStairs(n: int) -> int:\n        \n        memo = {}\n\n        def dfs(i: int) -> int:\n\n            if i in memo:\n                return memo[i]\n\n            if i == 1:   # direct: 1st element\n                return 1\n            if i == 2:   # direct: 2nd element\n                return 2\n\n            # recursive relation: sum of previous two steps\n            memo[i] = dfs(i-1) + dfs(i-2)\n            return memo[i]\n\n        return dfs(n)",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-dfs-with-caching-direct-n-top-down-with-memoization",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Iterative Tabulation (Padded N+1) Bottom Up",
      "summary": "Pattern: Iteratively fill a DP array with extra padding for base/empty case. Use When: Problem naturally needs a “ground” or empty state and empty state was not given in original array. Recurrence: dp[i] = dp[i-1] + dp[i-2] (or problem-specific relation).",
      "exampleIntro": "Climbing Stairs (Bottom Up, Padded)",
      "codeExample": "def climbStairs(n: int):\n\n        # no length == 1 check, since using pad + 1st element\n        # 1st element will always exist, pad is made up\n\n        dp = [0] * (n + 1)  # padding:\n        dp[0] = 1           # padding: (ground, 1 way to do nothing), \n                            # does not exist in original array\n\n        dp[1] = 1           # padded: first element, n=0 -> dp[1]\n\n        for i in range(2, n + 1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        return dp[n]",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-iterative-tabulation-padded-n1-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Iterative Tabulation (Direct N) Bottom Up",
      "summary": "Pattern: Iteratively fill a DP array with direct mapping to the original array elements. Use When: Problem naturally aligns 1:1 with input array. Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
      "exampleIntro": "House Robber (Bottom Up, Direct)",
      "codeExample": "def rob(nums):\n        n = len(nums)\n\n        # length == 1 check needed since using 1st + 2nd element\n        # 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        dp = [0] * n                   # direct:\n        dp[0] = nums[0]                # direct: 1st element\n        dp[1] = max(nums[0], nums[1])  # direct: 2nd element\n\n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n        return dp[n-1]",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-iterative-tabulation-direct-n-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Optimal Iterative (Padded N+1) Rolling State Variables Bottom Up",
      "summary": "Pattern: Reduce DP array to a few variables while padding for base/ground case. Use When: Problem naturally needs a “ground” or empty state and you want O(1) space. Recurrence: curr = prev1 + prev2 -> shift forward each step.",
      "exampleIntro": "Climbing Stairs (Optimal Bottom Up, Padded)",
      "codeExample": "def climbStairs(n: int) -> int:\n\n        # no length == 1 check, since using pad + 1st element\n        # 1st element will always exist, pad is made up\n\n        # padded variables\n        prev2 = 1  # padding: ground (0 steps, 1 way to do nothing)\n        prev1 = 1  # first step\n\n        # no length check needed since prev1 and prev2 already cover n=1\n        for i in range(2, n + 1):\n            curr = prev1 + prev2\n            prev2, prev1 = prev1, curr\n\n        return prev1",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-optimal-iterative-padded-n1-rolling-state-variables-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Optimal Iterative (Direct N) Rolling State Variables Bottom Up",
      "summary": "Pattern: Reduce DP array to a few variables with direct mapping to the original array. Use When: Problem naturally aligns 1:1 with input array and O(1) space is desired. Recurrence: curr = prev1 + prev2 → shift forward each step.",
      "exampleIntro": "House Robber (Optimal Bottom Up, Direct)",
      "codeExample": "def rob(nums) -> int:\n        n = len(nums)\n        \n        # length == 1 check needed since using 1st + 2nd element\n        # 2nd element may not exist\n        if n == 1:\n            return nums[0]\n\n        prev2 = nums[0]                # direct: first element\n        prev1 = max(nums[0], nums[1])  # direct: second element\n\n        for i in range(2, n):\n            curr = max(prev1, prev2 + nums[i])\n            prev2, prev1 = prev1, curr\n\n        return prev1",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-optimal-iterative-direct-n-rolling-state-variables-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Opposite Ends Iterative (Direct N) Rolling State Variables Bottom Up",
      "summary": "Pattern: Maintain rolling cumulative products from both ends of the array to capture subarrays affected by negative numbers. Use When: Problem involves products/subarrays where negative numbers can flip the max/min, and O(1) space is desired. Recurrence: left_prod *= nums[i], right_prod *= nums[n-1-i], reset to 1 if zero.",
      "exampleIntro": "Maximum Product Subarray (Opposite Ends Rolling Variables)",
      "codeExample": "def maxProduct(nums: List[int]) -> int:\n        n = len(nums)\n        \n        # Direct Variables -> rolling left and right products\n        left_prod = right_prod = 1\n        res = float('-inf')\n\n        for i in range(n):\n            # Build From Previous -> roll from left and right ends\n            left_prod *= nums[i]\n            right_prod *= nums[n-1-i]\n\n            # Three Possibilities -> compare overall max\n            res = max(res, left_prod, right_prod)\n\n            # Direct Boundary -> reset rolling on zero\n            if left_prod == 0:\n                left_prod = 1\n            if right_prod == 0:\n                right_prod = 1\n\n        return res",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-opposite-ends-iterative-direct-n-rolling-state-variables-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "Sliding Window Iterative (Direct N) Rolling State Variables Bottom Up",
      "summary": "Pattern: Maintain a rolling DP window of fixed size instead of the full DP array to reduce space. Use When: Problem involves checking previous k states (e.g., word lengths in Word Break) and you want O(k) space instead of O(n). Recurrence: dp[i % (k+1)] = any(dp[(i-l) % (k+1)] and segment_valid for l in 1..k)                                   od *= nums[n-1-i], reset to 1 if zero.",
      "exampleIntro": "Word Break (Sliding Window Rolling Variables)",
      "codeExample": "def wordBreak(s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        \n        # Direct Length -> empty string check\n        if n == 0:\n            return True\n\n        word_set = set(wordDict)\n        max_len = max(map(len, wordDict)) if wordDict else 0\n\n        # Direct Variables -> initialize rolling DP window\n        dp = [False] * (max_len + 1)\n        dp[0] = True  # base case: empty string\n\n        # Iterate -> 1 to n\n        for i in range(1, n + 1):\n            dp[i % (max_len + 1)] = False\n\n            # Build From Previous -> look back up to max_len positions\n            for l in range(1, min(i, max_len) + 1):\n                # Three Possibilities -> valid segmentation from previous l positions\n                if dp[(i - l) % (max_len + 1)] and s[i - l:i] in word_set:\n                    dp[i % (max_len + 1)] = True\n                    break  # early stop, valid segmentation found\n\n        # Result -> final DP state\n        return dp[n % (max_len + 1)]",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-sliding-window-iterative-direct-n-rolling-state-variables-bottom-up",
      "blog": "1D Dynamic Programming"
    },
    {
      "type": "1D Dynamic Programming",
      "title": "BFS Visited Memo Level Order",
      "summary": "Pattern: Treat problem as shortest-path search; each state represents “remaining target” or “current subproblem.” Use a queue for BFS and a visited set as memoization to avoid recomputation. Use When: Problem can be framed as reaching a target with choices at each step (e.g., coin change, min steps). BFS guarantees the first solution found is minimal (shortest path). Recurrence: For each state curr, explore all valid next states curr - choice. Steps to reach next = steps[curr] + 1.",
      "exampleIntro": "Coin Change (BFS with Memo)",
      "codeExample": "def coinChange(coins, amount):\n        if amount == 0:\n            return 0\n\n        # Queue stores (remaining amount, coins used so far)\n        queue = deque([(amount, 0)])\n        visited = set([amount])  # memo: avoid revisiting same remaining amount\n\n        while queue:\n            rem, steps = queue.popleft()\n\n            # Explore choices\n            for coin in coins:\n                next_rem = rem - coin\n\n                # Early stop: minimal coins found\n                if next_rem == 0:\n                    return steps + 1\n\n                # Valid state & not visited\n                if next_rem > 0 and next_rem not in visited:\n                    visited.add(next_rem)\n                    queue.append((next_rem, steps + 1))\n\n        # Impossible to reach target\n        return -1",
      "useCaseLink": "/Notes/1d-dynamic-programming#1d-dynamic-programming-application-bfs-visited-memo-level-order",
      "blog": "1D Dynamic Programming"
    }
  ],
  "greedy": [
    {
      "type": "Greedy",
      "title": "Greedy",
      "summary": "Pattern: money!",
      "exampleIntro": "money!!",
      "codeExample": "def money!(n: int) -> int:\n\n        return n+1",
      "useCaseLink": "/Notes/greedy#greedy-application-greedy",
      "blog": "Greedy"
    }
  ],
  "intervals": [
    {
      "type": "Intervals",
      "title": "Intervals",
      "summary": "Pattern: Numbers!",
      "exampleIntro": "Numbers numbers!!",
      "codeExample": "def wow!(n: int) -> int:\n\n        return n+1",
      "useCaseLink": "/Notes/intervals#intervals-application-intervals",
      "blog": "Intervals"
    }
  ],
  "bit-manipulation": [
    {
      "type": "Bit Manipulation",
      "title": "Bit Manipulation",
      "summary": "Pattern: bits!",
      "exampleIntro": "bits numbers!!",
      "codeExample": "def bitss!(n: int) -> int:\n\n        return n+1",
      "useCaseLink": "/Notes/leetcode-bit-manipulation#bit-manipulation-application-bit-manipulation",
      "blog": "LeetCode: Bit Manipulation"
    }
  ]
}