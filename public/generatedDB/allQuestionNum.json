{
  "1": {
    "questionNum": 1,
    "questionTitle": "Two Sum I (Input Array Is Not Sorted) ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "questionTopics": [
      "Array",
      "Hash Table"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#1-two-sum-i-input-array-is-not-sorted-1---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "2": {
    "questionNum": 2,
    "questionTitle": "Add Two Numbers ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "questionTopics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#2-add-two-numbers-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "3": {
    "questionNum": 3,
    "questionTitle": "Longest Substring Without Repeating Characters ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, find the length of the longest without duplicate characters.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#3-longest-substring-without-repeating-characters-1---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "4": {
    "questionNum": 4,
    "questionTitle": "Median of Two Sorted Arrays ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "questionLink": "/Notes/leetcode-binary-search#4-median-of-two-sorted-arrays-2---hard",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "5": {
    "questionNum": 5,
    "questionTitle": "Longest Palindromic Substring ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, return the longest palindromic substring in s.",
    "questionTopics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#5-longest-palindromic-substring-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "11": {
    "questionNum": 11,
    "questionTitle": "Container With Most Water ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#11-container-with-most-water-1---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "15": {
    "questionNum": 15,
    "questionTitle": "3Sum ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Sorting",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#15-3sum-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "19": {
    "questionNum": 19,
    "questionTitle": "Remove Nth Node From End of List ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Follow up: Could you do this in one pass?",
    "questionTopics": [
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#19-remove-nth-node-from-end-of-list-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "20": {
    "questionNum": 20,
    "questionTitle": "Valid Parentheses ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a string s containing: ( ) [ ] \\{ \\}, determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.",
    "questionTopics": [
      "String",
      "Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#20-valid-parentheses-2---easy",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:46:00",
    "coldnessCount": 21
  },
  "21": {
    "questionNum": 21,
    "questionTitle": "Merge Two Sorted Lists ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#21-merge-two-sorted-lists-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "22": {
    "questionNum": 22,
    "questionTitle": "Generate Parentheses ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "questionTopics": [
      "String",
      "Stack",
      "Dynamic Programming",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-stacks#22-generate-parentheses-4---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "23": {
    "questionNum": 23,
    "questionTitle": "Merge k Sorted Lists ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "questionTopics": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "questionLink": "/Notes/leetcode-linked-list#23-merge-k-sorted-lists-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "25": {
    "questionNum": 25,
    "questionTitle": "Reverse Nodes in k-Group ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left- out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Follow-up: Can you solve the problem in O(1) extra memory space?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#25-reverse-nodes-in-kgroup-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "33": {
    "questionNum": 33,
    "questionTitle": "Search in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &leq; k &le; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#33-search-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 10
  },
  "36": {
    "questionNum": 36,
    "questionTitle": "Valid Sudoku ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#36-valid-sudoku-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "42": {
    "questionNum": 42,
    "questionTitle": "Trapping Rain Water ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#42-trapping-rain-water-3---hard",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "49": {
    "questionNum": 49,
    "questionTitle": "Group Anagrams ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#49-group-anagrams-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "74": {
    "questionNum": 74,
    "questionTitle": "Search a 2D Matrix ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-binary-search#74-search-a-2d-matrix-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 10
  },
  "76": {
    "questionNum": 76,
    "questionTitle": "Minimum Window Substring ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two strings s and t of lengths m and n respectively, return the minimum window of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#76-minimum-window-substring-2---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "84": {
    "questionNum": 84,
    "questionTitle": "Largest Rectangle in Histogram ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#84-largest-rectangle-in-histogram-2---hard",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "121": {
    "questionNum": 121,
    "questionTitle": "Best Time to Buy and Sell Stock ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#121-best-time-to-buy-and-sell-stock-4---easy",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "125": {
    "questionNum": 125,
    "questionTitle": "Valid Palindrome ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.",
    "questionTopics": [
      "Two Pointers",
      "String"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#125-valid-palindrome-3---easy",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "128": {
    "questionNum": 128,
    "questionTitle": "Longest Consecutive Sequence ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums, return the length of the longest consecutive sequence of elements. A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element You must wrtie an algorithm that runs in O(n) time.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#128-longest-consecutive-sequence-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "138": {
    "questionNum": 138,
    "questionTitle": "Copy List with Random Pointer ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.",
    "questionTopics": [
      "Hash Table",
      "Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#138-copy-list-with-random-pointer-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "141": {
    "questionNum": 141,
    "questionTitle": "Linked List Cycle ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Follow up: Can you solve it using O(1) (i.e. constant) memory?",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#141-linked-list-cycle-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "143": {
    "questionNum": 143,
    "questionTitle": "Reorder List ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given the head of a singly linked-list. The list can be represented as: There is a cycle in a linked list if there is some node in the list that can be L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "questionTopics": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#143-reorder-list-4---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "146": {
    "questionNum": 146,
    "questionTitle": "LRU Cache ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Doubly Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#146-lru-cache-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "150": {
    "questionNum": 150,
    "questionTitle": "Evaluate Reverse Polish Notation ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.",
    "questionTopics": [
      "Array",
      "Stack",
      "Math",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#150-evaluate-reverse-polish-notation-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-12T01:00:00",
    "coldnessCount": 22
  },
  "153": {
    "questionNum": 153,
    "questionTitle": "Find Minimum in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Suppose an array of length n sorted in ascending order s rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#153-find-minimum-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 10
  },
  "155": {
    "questionNum": 155,
    "questionTitle": "Min Stack ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.",
    "questionTopics": [
      "Stack",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#155-min-stack-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:53:00",
    "coldnessCount": 21
  },
  "162": {
    "questionNum": 162,
    "questionTitle": "Find Peak Element ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -inf. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#162-find-peak-element-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "167": {
    "questionNum": 167,
    "questionTitle": "Two Sum II (Input Array Is Sorted) ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#167-two-sum-ii-input-array-is-sorted-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "206": {
    "questionNum": 206,
    "questionTitle": "Reverse Linked List ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the head of a singly linked list, reverse the list, and return the reversed list. A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#206-reverse-linked-list-4---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "217": {
    "questionNum": 217,
    "questionTitle": "Contains Duplicate ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an integer array nums, return true if any value appears at least twice in the array, return false if every element is distinct.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#217-contains-duplicate-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "238": {
    "questionNum": 238,
    "questionTitle": "Product of Array Except Self ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "questionTopics": [
      "Array",
      "Prefix Sum"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#238-product-of-array-except-self-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "239": {
    "questionNum": 239,
    "questionTitle": "Sliding Window Maximum ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "questionTopics": [
      "Array",
      "Queue",
      "Sliding Window",
      "Heap (Priority Queue)",
      "Monotonic Queue"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#239-sliding-window-maximum-3---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "242": {
    "questionNum": 242,
    "questionTitle": "Valid Anagram ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#242-valid-anagram-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "271": {
    "questionNum": 271,
    "questionTitle": "String Encode and Decode ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings Please implement encode and decode. strs[i] contains only UTF-8 characters.",
    "questionTopics": [
      "Two Pointers",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#271-string-encode-and-decode-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "287": {
    "questionNum": 287,
    "questionTitle": "Find the Duplicate Number ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-linked-list#287-find-the-duplicate-number-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "347": {
    "questionNum": 347,
    "questionTitle": "Top K Elements in List ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums and an integer k, return the k most frequent element within the array. Test cases are generated such that the answer is always unique. You may return the output in any order",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#347-top-k-elements-in-list-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 24
  },
  "402": {
    "questionNum": 402,
    "questionTitle": "Remove K Digits ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
    "questionTopics": [
      "String",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#402-remove-k-digits-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "424": {
    "questionNum": 424,
    "questionTitle": "Longest Repeating Character Replacement ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#424-longest-repeating-character-replacement-1---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "567": {
    "questionNum": 567,
    "questionTitle": "Permutation in String ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#567-permutation-in-string-1---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "704": {
    "questionNum": 704,
    "questionTitle": "Binary Search ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#704-binary-search-2---easy",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 10
  },
  "739": {
    "questionNum": 739,
    "questionTitle": "Daily Temperatures ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack",
      "Two Pointer",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/leetcode-stacks#739-daily-temperatures-3---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "853": {
    "questionNum": 853,
    "questionTitle": "Car Fleet ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target. You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour. A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car. A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet. If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet. Return the number of car fleets that will arrive at the destination.",
    "questionTopics": [
      "Array",
      "Stack",
      "Sorting",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#853-car-fleet-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "875": {
    "questionNum": 875,
    "questionTitle": "Koko Eating Bananas ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Network Packet Routing",
      "Design",
      "System Level Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#875-koko-eating-bananas-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 10
  },
  "981": {
    "questionNum": 981,
    "questionTitle": "Time Based Key Value Store ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a time based key value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class: TimeMap(): Initializes the object of the data structure. void set(String key, String value, int timestamp): Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp): Returns a value such that set was called previously, with timestamp_prev &leq; timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".",
    "questionTopics": [
      "Hash Table",
      "String",
      "Binary Search",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#981-time-based-key-value-store-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  }
}