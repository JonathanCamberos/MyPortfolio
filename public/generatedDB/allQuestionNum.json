{
  "1": {
    "questionNum": 1,
    "questionTitle": "Two Sum I Not Sorted ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums and an integer target, return indices of two numbers such that they add up to target. You can assume each test case only has one solution and you may cant use the same element twice. Answer can be returned in any order.",
    "questionTopics": [
      "Array",
      "Hash Table"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#1-two-sum-i-not-sorted-1---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "2": {
    "questionNum": 2,
    "questionTitle": "Add Two Numbers ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "questionTopics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#2-add-two-numbers-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "3": {
    "questionNum": 3,
    "questionTitle": "Longest Substring Without Repeating Characters ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, find the length of the longest without duplicate characters.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#3-longest-substring-without-repeating-characters-2---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "4": {
    "questionNum": 4,
    "questionTitle": "Median of Two Sorted Arrays ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "questionLink": "/Notes/leetcode-binary-search#4-median-of-two-sorted-arrays-2---hard",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "5": {
    "questionNum": 5,
    "questionTitle": "Longest Palindromic Substring ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, return the longest palindromic substring in s.",
    "questionTopics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#5-longest-palindromic-substring-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "7": {
    "questionNum": 7,
    "questionTitle": "Reverse Integer ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "questionTopics": [
      "Math"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#7-reverse-integer-1---medium",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "10": {
    "questionNum": 10,
    "questionTitle": "Regular Expression Matching ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).",
    "questionTopics": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#10-regular-expression-matching-3---hard",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "11": {
    "questionNum": 11,
    "questionTitle": "Container With Most Water ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#11-container-with-most-water-1---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "15": {
    "questionNum": 15,
    "questionTitle": "3Sum ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Sorting",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#15-3sum-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "17": {
    "questionNum": 17,
    "questionTitle": "Letter Combinations of a Phone Number ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#17-letter-combinations-of-a-phone-number-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "19": {
    "questionNum": 19,
    "questionTitle": "Remove Nth Node From End of List ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Follow up: Could you do this in one pass?",
    "questionTopics": [
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#19-remove-nth-node-from-end-of-list-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "20": {
    "questionNum": 20,
    "questionTitle": "Valid Parentheses ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a string s containing: ( ) [ ] \\{ \\}, determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.",
    "questionTopics": [
      "String",
      "Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#20-valid-parentheses-2---easy",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:46:00",
    "coldnessCount": 79
  },
  "21": {
    "questionNum": 21,
    "questionTitle": "Merge Two Sorted Lists ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#21-merge-two-sorted-lists-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "22": {
    "questionNum": 22,
    "questionTitle": "Generate Parentheses ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "questionTopics": [
      "String",
      "Stack",
      "Dynamic Programming",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-stacks#22-generate-parentheses-4---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "23": {
    "questionNum": 23,
    "questionTitle": "Merge k Sorted Lists ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "questionTopics": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "questionLink": "/Notes/leetcode-linked-list#23-merge-k-sorted-lists-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "25": {
    "questionNum": 25,
    "questionTitle": "Reverse Nodes in k-Group ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left- out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Follow-up: Can you solve the problem in O(1) extra memory space?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#25-reverse-nodes-in-kgroup-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "33": {
    "questionNum": 33,
    "questionTitle": "Search in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &leq; k &le; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#33-search-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 68
  },
  "36": {
    "questionNum": 36,
    "questionTitle": "Valid Sudoku ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#36-valid-sudoku-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "39": {
    "questionNum": 39,
    "questionTitle": "Combination Sum ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#39-combination-sum-4---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "40": {
    "questionNum": 40,
    "questionTitle": "Combination Sum II ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#40-combination-sum-ii-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "42": {
    "questionNum": 42,
    "questionTitle": "Trapping Rain Water ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#42-trapping-rain-water-3---hard",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "43": {
    "questionNum": 43,
    "questionTitle": "Multiply Strings ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "questionTopics": [
      "Math",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#43-multiply-strings-2---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "45": {
    "questionNum": 45,
    "questionTitle": "Jump Game II ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index 0. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j) where: 0 < = j < = nums[i] and i + j < n Return the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach index n - 1.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#45-jump-game-ii-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "46": {
    "questionNum": 46,
    "questionTitle": "Permutations ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array nums of distinct integers, return all the possible . You can return the answer in any order. A permutation is a rearrangement of all the elements of an array.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#46-permutations-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "48": {
    "questionNum": 48,
    "questionTitle": "Rotate Image ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "questionTopics": [
      "Array",
      "Math",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#48-rotate-image-1---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "49": {
    "questionNum": 49,
    "questionTitle": "Group Anagrams ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word formed by rearranging the letters of a different word using all the original letters exactly once.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#49-group-anagrams-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "50": {
    "questionNum": 50,
    "questionTitle": "Pow(x, n) ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
    "questionTopics": [
      "Math",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#50-powx-n-1---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "51": {
    "questionNum": 51,
    "questionTitle": "N Queens ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#51-n-queens-1---hard",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "53": {
    "questionNum": 53,
    "questionTitle": "Maximum Subarray ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, find the with the largest sum, and return its sum. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
    "questionTopics": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/greedy#53-maximum-subarray-3---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "54": {
    "questionNum": 54,
    "questionTitle": "Spiral Matrix ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n matrix, return all elements of the matrix in spiral order.",
    "questionTopics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#54-spiral-matrix-1---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "55": {
    "questionNum": 55,
    "questionTitle": "Jump Game ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#55-jump-game-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "56": {
    "questionNum": 56,
    "questionTitle": "Merge Intervals ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "questionTopics": [
      "Array",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-intervals#56-merge-intervals-1---medium",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "57": {
    "questionNum": 57,
    "questionTitle": "Insert Interval ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it.",
    "questionTopics": [
      "Array"
    ],
    "questionLink": "/Notes/leetcode-intervals#57-insert-interval-2---medium",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "62": {
    "questionNum": 62,
    "questionTitle": "Unique Paths ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 10^9.",
    "questionTopics": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#62-unique-paths-2---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "66": {
    "questionNum": 66,
    "questionTitle": "Plus One ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits.",
    "questionTopics": [
      "Array",
      "Math"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#66-plus-one-1---easy",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "70": {
    "questionNum": 70,
    "questionTitle": "Climbing Stairs ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "questionTopics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#70-climbing-stairs-4---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "72": {
    "questionNum": 72,
    "questionTitle": "Edit Distance ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#72-edit-distance-3---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "73": {
    "questionNum": 73,
    "questionTitle": "Set Matrix Zeroes ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. Follow up: A straightforward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#73-set-matrix-zeroes-1---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "74": {
    "questionNum": 74,
    "questionTitle": "Search a 2D Matrix ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-binary-search#74-search-a-2d-matrix-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 68
  },
  "76": {
    "questionNum": 76,
    "questionTitle": "Minimum Window Substring ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two strings s and t of lengths m and n respectively, return the minimum window of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#76-minimum-window-substring-2---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "78": {
    "questionNum": 78,
    "questionTitle": "Subsets ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums of unique elements, return all possible subsets (the power set). A subset of an array is a selection of elements (possibly none) of the array. The solution set must not contain duplicate subsets. Return the solution in any order.",
    "questionTopics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-backtracking#78-subsets-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "79": {
    "questionNum": 79,
    "questionTitle": "Word Search ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "questionTopics": [
      "Array",
      "String",
      "Backtracking",
      "Depth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-backtracking#79-word-search-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "84": {
    "questionNum": 84,
    "questionTitle": "Largest Rectangle in Histogram ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#84-largest-rectangle-in-histogram-2---hard",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "90": {
    "questionNum": 90,
    "questionTitle": "Subsets II ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "questionTopics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-backtracking#90-subsets-ii-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "91": {
    "questionNum": 91,
    "questionTitle": "Decode Ways ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: \"1\" -> 'A' \"2\" -> 'B' ... \"25\" -> 'Y' \"26\" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\"). For example, \"11106\" can be decoded into: \"AAJF\" with the grouping (1, 1, 10, 6) \"KJF\" with the grouping (11, 10, 6) The grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid). Note: there may be strings that are impossible to decode. Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer.",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#91-decode-ways-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "97": {
    "questionNum": 97,
    "questionTitle": "Interleaving String ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| < = 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Note: a + b is the concatenation of strings a and b.",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#97-interleaving-string-2---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "98": {
    "questionNum": 98,
    "questionTitle": "Validate Binary Search Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). The left subtree of a node contains only nodes with keys strictly less than the node's key. The right subtree of a node contains only nodes with keys strictly greater than the node's key. Both the left and right subtrees must also be binary search trees.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#98-validate-binary-search-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "100": {
    "questionNum": 100,
    "questionTitle": "Same Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#100-same-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "102": {
    "questionNum": 102,
    "questionTitle": "Binary Tree Level Order Traversal ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "questionTopics": [
      "Tree",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#102-binary-tree-level-order-traversal-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "104": {
    "questionNum": 104,
    "questionTitle": "Maximum Depth of Binary Tree ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#104-maximum-depth-of-binary-tree-4---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "105": {
    "questionNum": 105,
    "questionTitle": "Construct Binary Tree from Pre Order and In Order Traversal ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two integer arrays pre order and in order where pre order is the pre order traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#105-construct-binary-tree-from-pre-order-and-in-order-traversal-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "110": {
    "questionNum": 110,
    "questionTitle": "Balanced Binary Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#110-balanced-binary-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "115": {
    "questionNum": 115,
    "questionTitle": "Distinct Subsequences ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#115-distinct-subsequences-3---hard",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "121": {
    "questionNum": 121,
    "questionTitle": "Best Time to Buy and Sell Stock ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#121-best-time-to-buy-and-sell-stock-4---easy",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "124": {
    "questionNum": 124,
    "questionTitle": "Binary Tree Maximum Path Sum ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",
    "questionTopics": [
      "Dynamic Programming",
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#124-binary-tree-maximum-path-sum-1---hard",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "125": {
    "questionNum": 125,
    "questionTitle": "Valid Palindrome ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters  and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.",
    "questionTopics": [
      "Two Pointers",
      "String"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#125-valid-palindrome-3---easy",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "127": {
    "questionNum": 127,
    "questionTitle": "Word Ladder ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &leq; i &leq; k is in wordList. Note that beginWord does not need to be in wordList sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Breadth First Search"
    ],
    "questionLink": "/Notes/leetcode-graphs#127-word-ladder-3---hard",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "128": {
    "questionNum": 128,
    "questionTitle": "Longest Consecutive Sequence ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums, return the length of the longest consecutive sequence of elements. A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element You must wrtie an algorithm that runs in O(n) time.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#128-longest-consecutive-sequence-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "130": {
    "questionNum": 130,
    "questionTitle": "Surrounded Regions ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: Connect: A cell is connected to adjacent cells horizontally or vertically. Region: To form a region connect every 'O' cell. Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board. To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#130-surrounded-regions-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "131": {
    "questionNum": 131,
    "questionTitle": "Palindrome Partitioning ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
    "questionTopics": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#131-palindrome-partitioning-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "133": {
    "questionNum": 133,
    "questionTitle": "Clone Graph ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node ( public int val; public List[Node] neighbors; ) Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "questionTopics": [
      "Hash Table",
      "Depth First Search",
      "Breadth First Search",
      "Graph"
    ],
    "questionLink": "/Notes/leetcode-graphs#133-clone-graph-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "134": {
    "questionNum": 134,
    "questionTitle": "Gas Station ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
    "questionTopics": [
      "Array",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#134-gas-station-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "136": {
    "questionNum": 136,
    "questionTitle": "Single Number ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.",
    "questionTopics": [
      "Array",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#136-single-number-1---easy",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "138": {
    "questionNum": 138,
    "questionTitle": "Copy List with Random Pointer ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.",
    "questionTopics": [
      "Hash Table",
      "Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#138-copy-list-with-random-pointer-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "139": {
    "questionNum": 139,
    "questionTitle": "Word Break ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Trie",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#139-word-break-4---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "141": {
    "questionNum": 141,
    "questionTitle": "Linked List Cycle ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Follow up: Can you solve it using O(1) (i.e. constant) memory?",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#141-linked-list-cycle-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "143": {
    "questionNum": 143,
    "questionTitle": "Reorder List ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given the head of a singly linked-list. The list can be represented as: There is a cycle in a linked list if there is some node in the list that can be L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "questionTopics": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#143-reorder-list-4---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "146": {
    "questionNum": 146,
    "questionTitle": "LRU Cache ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Doubly Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#146-lru-cache-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "150": {
    "questionNum": 150,
    "questionTitle": "Evaluate Reverse Polish Notation ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.",
    "questionTopics": [
      "Array",
      "Stack",
      "Math",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#150-evaluate-reverse-polish-notation-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-12T01:00:00",
    "coldnessCount": 80
  },
  "152": {
    "questionNum": 152,
    "questionTitle": "Maximum Product Subarray ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#152-maximum-product-subarray-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "153": {
    "questionNum": 153,
    "questionTitle": "Find Minimum in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Suppose an array of length n sorted in ascending order s rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#153-find-minimum-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 68
  },
  "155": {
    "questionNum": 155,
    "questionTitle": "Min Stack ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.",
    "questionTopics": [
      "Stack",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#155-min-stack-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:53:00",
    "coldnessCount": 79
  },
  "162": {
    "questionNum": 162,
    "questionTitle": "Find Peak Element ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -inf. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#162-find-peak-element-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "167": {
    "questionNum": 167,
    "questionTitle": "Two Sum II Sorted Array ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a 1 indexed array of sorted integer in non decreasing order, find two numbers that add up to a target. Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#167-two-sum-ii-sorted-array-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "190": {
    "questionNum": 190,
    "questionTitle": "Reverse Bits ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Reverse bits of a given 32 bits signed integer. Follow up: If this function is called many times, how would you optimize it?",
    "questionTopics": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#190-reverse-bits-1---easy",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "191": {
    "questionNum": 191,
    "questionTitle": "Number of 1 Bits ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight). A set bit refers to a bit in the binary representation of a number that has a value of 1. Follow up: If this function is called many times, how would you optimize it?",
    "questionTopics": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#191-number-of-1-bits-2---easy",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "198": {
    "questionNum": 198,
    "questionTitle": "House Robber ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#198-house-robber-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "199": {
    "questionNum": 199,
    "questionTitle": "Binary Tree Right Side View ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "questionTopics": [
      "Tree",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#199-binary-tree-right-side-view-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "200": {
    "questionNum": 200,
    "questionTitle": "Number of Islands ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#200-number-of-islands-4---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "202": {
    "questionNum": 202,
    "questionTitle": "Happy Number ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.",
    "questionTopics": [
      "Hash Table",
      "Math",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#202-happy-number-1---easy",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "206": {
    "questionNum": 206,
    "questionTitle": "Reverse Linked List ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the head of a singly linked list, reverse the list, and return the reversed list. A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#206-reverse-linked-list-4---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "207": {
    "questionNum": 207,
    "questionTitle": "Course Schedule ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Topological Sort"
    ],
    "questionLink": "/Notes/leetcode-graphs#207-course-schedule-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "208": {
    "questionNum": 208,
    "questionTitle": "Implement Trie (Prefix Tree) ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#208-implement-trie-prefix-tree-1---medium",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "210": {
    "questionNum": 210,
    "questionTitle": "Course Schedule II ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Topological Sort"
    ],
    "questionLink": "/Notes/leetcode-graphs#210-course-schedule-ii-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "211": {
    "questionNum": 211,
    "questionTitle": "Design Add and Search Words Data Structure ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: WordDictionary() Initializes the object. void addWord(word) Adds word to the data structure, it can be matched later. bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.",
    "questionTopics": [
      "String",
      "Depth First Search",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#211-design-add-and-search-words-data-structure-1---medium",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "212": {
    "questionNum": 212,
    "questionTitle": "Word Search II ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#212-word-search-ii-2---hard",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "213": {
    "questionNum": 213,
    "questionTitle": "House Robber II ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#213-house-robber-ii-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "215": {
    "questionNum": 215,
    "questionTitle": "Kth Largest Element in an Array ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
    "questionTopics": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Geometry",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-heaps#215-kth-largest-element-in-an-array-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "217": {
    "questionNum": 217,
    "questionTitle": "Contains Duplicate ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an integer array nums, return true if any value appears at least twice in the array, return false if every element is distinct.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#217-contains-duplicate-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-09-22T06:44:00",
    "coldnessCount": 8
  },
  "226": {
    "questionNum": 226,
    "questionTitle": "Invert Binary Tree ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the root of a binary tree, invert the tree, and return its root.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#226-invert-binary-tree-3---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "230": {
    "questionNum": 230,
    "questionTitle": "Kth Smallest Element in a BST ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#230-kth-smallest-element-in-a-bst-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "235": {
    "questionNum": 235,
    "questionTitle": "Lowest Common Ancestor of a Binary Search Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#235-lowest-common-ancestor-of-a-binary-search-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "238": {
    "questionNum": 238,
    "questionTitle": "Product of Array Except Self ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "questionTopics": [
      "Array",
      "Prefix Sum"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#238-product-of-array-except-self-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "239": {
    "questionNum": 239,
    "questionTitle": "Sliding Window Maximum ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "questionTopics": [
      "Array",
      "Queue",
      "Sliding Window",
      "Heap (Priority Queue)",
      "Monotonic Queue"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#239-sliding-window-maximum-3---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "242": {
    "questionNum": 242,
    "questionTitle": "Valid Anagram ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word using all original letters exactly once.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#242-valid-anagram-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-09-22T06:49:00",
    "coldnessCount": 8
  },
  "252": {
    "questionNum": 252,
    "questionTitle": "Meeting Rooms ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i) of the intervals non-overlapping. determine if a person could add all meetings to their schedule without any conflicts.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-intervals#252-meeting-rooms-1---easy",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "253": {
    "questionNum": 253,
    "questionTitle": "Meeting Rooms II ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), find the minimum number of days required to schedule all meetings without any conflicts.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-intervals#253-meeting-rooms-ii-1---medium",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "261": {
    "questionNum": 261,
    "questionTitle": "Graph Valid Tree ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-graphs#261-graph-valid-tree-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "268": {
    "questionNum": 268,
    "questionTitle": "Missing Number ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Math",
      "Binary Search",
      "Bit Manipulation",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#268-missing-number-2---easy",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "269": {
    "questionNum": 269,
    "questionTitle": "Alien Dictionary ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "There is a foreign language which uses the latin alphabet, but the order among letters is not \"a\", \"b\", \"c\" ... \"z\" as in English. You receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language. Derive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return any of them. A string a is lexicographically smaller than a string b if either of the following is true: The first letter where they differ is smaller in a than in b. a is a prefix of b and a.length < b.length.",
    "questionTopics": [
      "Breadth First Search",
      "Graph",
      "Topological Sort"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#269-alien-dictionary-1---hard",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "271": {
    "questionNum": 271,
    "questionTitle": "String Encode and Decode ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design an algorithm to encode a list of strings to a single string and a decode algorithm to decode the single string back to the original list of strings, strs[i] contains only UTF-8 characters.",
    "questionTopics": [
      "Two Pointers",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#271-string-encode-and-decode-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "286": {
    "questionNum": 286,
    "questionTitle": "Walls and Gates ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a (m) x (n 2D) grid initialized with these three possible values: -1 - A water cell that can not be traversed. 0 - A treasure chest. INF - A land cell that can be traversed. We use the integer 2^31 - 1 = 2147483647 to represent INF. Fill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest then the value should remain INF. Assume the grid can only be traversed up, down, left, or right. Modify the grid in-place.",
    "questionTopics": [
      "Hash Table",
      "Depth First Search",
      "Breadth First Search",
      "Graph"
    ],
    "questionLink": "/Notes/leetcode-graphs#286-walls-and-gates-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "287": {
    "questionNum": 287,
    "questionTitle": "Find the Duplicate Number ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-linked-list#287-find-the-duplicate-number-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "295": {
    "questionNum": 295,
    "questionTitle": "Find Median from Data Stream ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. For example, for arr = [2,3,4], the median is 3. For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5. Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.",
    "questionTopics": [
      "Two Pointers",
      "Design",
      "Sorting",
      "Heap (Priority Queue)",
      "Data Stream"
    ],
    "questionLink": "/Notes/leetcode-heaps#295-find-median-from-data-stream-1---hard",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "297": {
    "questionNum": 297,
    "questionTitle": "Serialize and Deserialize Binary Tree ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. ou do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
    "questionTopics": [
      "String",
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Design",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#297-serialize-and-deserialize-binary-tree-2---hard",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "300": {
    "questionNum": 300,
    "questionTitle": "Longest Increasing Subsequence ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return the length of the longest strictly increasing subsequence. Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#300-longest-increasing-subsequence-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "309": {
    "questionNum": 309,
    "questionTitle": "Best Time to Buy and Sell Stock with Cool Down ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day). Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#309-best-time-to-buy-and-sell-stock-with-cool-down-3---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "312": {
    "questionNum": 312,
    "questionTitle": "Burst Balloons ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#312-burst-balloons-3---hard",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "322": {
    "questionNum": 322,
    "questionTitle": "Coin Change ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Breadth First Search"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#322-coin-change-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "323": {
    "questionNum": 323,
    "questionTitle": "Number of Connected Components in an Undirected Graph ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph. The nodes are numbered from 0 to n - 1. Return the total number of connected components in that graph.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-graphs#323-number-of-connected-components-in-an-undirected-graph-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "329": {
    "questionNum": 329,
    "questionTitle": "Longest Increasing Path in a Matrix ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Matrix"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#329-longest-increasing-path-in-a-matrix-3---hard",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "332": {
    "questionNum": 332,
    "questionTitle": "Reconstruct Itinerary ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
    "questionTopics": [
      "Depth First Search",
      "Graph",
      "Eulerian Circuit"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#332-reconstruct-itinerary-1---hard",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "338": {
    "questionNum": 338,
    "questionTitle": "Counting Bits ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an integer n, return an array ans of length n + 1 such that for each i (0 < = i < = n), ans[i] is the number of 1's in the binary representation of i.",
    "questionTopics": [
      "Dynamic Programming",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#338-counting-bits-2---easy",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "347": {
    "questionNum": 347,
    "questionTitle": "Top K Elements in List ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums and an integer k, return the k most frequent element within the array. Test cases are generated such that the answer is always unique. You may return the output in any order",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#347-top-k-elements-in-list-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 82
  },
  "355": {
    "questionNum": 355,
    "questionTitle": "Design Twitter ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed. Implement the Twitter class: Twitter() Initializes your twitter object. void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId. List[Integer] getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent. void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId. void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Heap (Priority Queue)"
    ],
    "questionLink": "/Notes/leetcode-heaps#355-design-twitter-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "371": {
    "questionNum": 371,
    "questionTitle": "Sum of Two Integers ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
    "questionTopics": [
      "Math",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-bit-manipulation#371-sum-of-two-integers-1---medium",
    "blog": "LeetCode: Bit Manipulation",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "402": {
    "questionNum": 402,
    "questionTitle": "Remove K Digits ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
    "questionTopics": [
      "String",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#402-remove-k-digits-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "416": {
    "questionNum": 416,
    "questionTitle": "Partition Equal Subset Sum ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#416-partition-equal-subset-sum-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "417": {
    "questionNum": 417,
    "questionTitle": "Pacific Atlantic Water Flow ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "questionTopics": [
      "Array",
      "Breadth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#417-pacific-atlantic-water-flow-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "424": {
    "questionNum": 424,
    "questionTitle": "Longest Repeating Character Replacement ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#424-longest-repeating-character-replacement-1---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "435": {
    "questionNum": 435,
    "questionTitle": "Non Overlapping Intervals ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-intervals#435-non-overlapping-intervals-1---medium",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "494": {
    "questionNum": 494,
    "questionTitle": "Target Sum ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\". Return the number of different expressions that you can build, which evaluates to target.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#494-target-sum-3---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "518": {
    "questionNum": 518,
    "questionTitle": "Coin Change II ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to fit into a signed 32-bit integer.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#518-coin-change-ii-3---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "543": {
    "questionNum": 543,
    "questionTitle": "Diameter of Binary Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#543-diameter-of-binary-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "567": {
    "questionNum": 567,
    "questionTitle": "Permutation in String ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#567-permutation-in-string-2---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "572": {
    "questionNum": 572,
    "questionTitle": "Subtree of Another Tree ::5::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "String Matching",
      "Binary Tree",
      "Hash Function"
    ],
    "questionLink": "/Notes/leetcode-trees#572-subtree-of-another-tree-5---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "621": {
    "questionNum": 621,
    "questionTitle": "Task Scheduler ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label. Return the minimum number of CPU intervals required to complete all tasks.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)",
      "Counting",
      "Computer Architecture Scheduling"
    ],
    "questionLink": "/Notes/leetcode-heaps#621-task-scheduler-3---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "647": {
    "questionNum": 647,
    "questionTitle": "Palindromic Substrings ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.",
    "questionTopics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#647-palindromic-substrings-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "678": {
    "questionNum": 678,
    "questionTitle": "Valid Parenthesis String ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid. The following rules define a valid string: Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
    "questionTopics": [
      "String",
      "Dynamic Programming",
      "Stack",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#678-valid-parenthesis-string-2---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "684": {
    "questionNum": 684,
    "questionTitle": "Redundant Connection ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Graph"
    ],
    "questionLink": "/Notes/leetcode-graphs#684-redundant-connection-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "695": {
    "questionNum": 695,
    "questionTitle": "Max Area of Island ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#695-max-area-of-island-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "703": {
    "questionNum": 703,
    "questionTitle": "Kth Largest Element in a Stream ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores. You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores. Implement the KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums. int add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.",
    "questionTopics": [
      "Tree",
      "Design",
      "Binary Search Tree",
      "Heap (Priority Queue)",
      "Binary Tree",
      "Data Stream"
    ],
    "questionLink": "/Notes/leetcode-heaps#703-kth-largest-element-in-a-stream-1---easy",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "704": {
    "questionNum": 704,
    "questionTitle": "Binary Search ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#704-binary-search-2---easy",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 68
  },
  "739": {
    "questionNum": 739,
    "questionTitle": "Daily Temperatures ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/leetcode-stacks#739-daily-temperatures-3---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "743": {
    "questionNum": 743,
    "questionTitle": "Network Delay Time ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#743-network-delay-time-1---medium",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "746": {
    "questionNum": 746,
    "questionTitle": "Min Cost Climbing Stairs ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#746-min-cost-climbing-stairs-4---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "763": {
    "questionNum": 763,
    "questionTitle": "Partition Labels ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a string s. We want to partition the string string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.",
    "questionTopics": [
      "Hash Table",
      "Two Pointers",
      "String",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#763-partition-labels-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "778": {
    "questionNum": 778,
    "questionTitle": "Swim in Rising Water ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). It starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#778-swim-in-rising-water-1---hard",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "787": {
    "questionNum": 787,
    "questionTitle": "Cheapest Flights Within K Stops ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that pricei. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.",
    "questionTopics": [
      "Dynamic Programming",
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#787-cheapest-flights-within-k-stops-1---medium",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "846": {
    "questionNum": 846,
    "questionTitle": "Hand of Straights ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Greedy",
      "Sorting"
    ],
    "questionLink": "/Notes/greedy#846-hand-of-straights-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "853": {
    "questionNum": 853,
    "questionTitle": "Car Fleet ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target. You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour. A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car. A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet. If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet. Return the number of car fleets that will arrive at the destination.",
    "questionTopics": [
      "Array",
      "Stack",
      "Sorting",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#853-car-fleet-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "875": {
    "questionNum": 875,
    "questionTitle": "Koko Eating Bananas ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Network Packet Routing",
      "Design",
      "System Level Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#875-koko-eating-bananas-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 68
  },
  "973": {
    "questionNum": 973,
    "questionTitle": "K Closest Points to Origin ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of points where points[i] = [x_i, y_i] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance: sqrt((x_1, x-2)^2 + (y_1 + y_2)^2) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
    "questionTopics": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Geometry",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-heaps#973-k-closest-points-to-origin-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "981": {
    "questionNum": 981,
    "questionTitle": "Time Based Key Value Store ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a time based key value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class: TimeMap(): Initializes the object of the data structure. void set(String key, String value, int timestamp): Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp): Returns a value such that set was called previously, with timestamp_prev &leq; timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".",
    "questionTopics": [
      "Hash Table",
      "String",
      "Binary Search",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#981-time-based-key-value-store-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "994": {
    "questionNum": 994,
    "questionTitle": "Rotting Oranges ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "questionTopics": [
      "Array",
      "Breadth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#994-rotting-oranges-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1046": {
    "questionNum": 1046,
    "questionTitle": "Last Stone Weight ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &leq; y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.",
    "questionTopics": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "questionLink": "/Notes/leetcode-heaps#1046-last-stone-weight-1---easy",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1137": {
    "questionNum": 1137,
    "questionTitle": "Nth Tribonacci Number ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.",
    "questionTopics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#1137-nth-tribonacci-number-3---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1143": {
    "questionNum": 1143,
    "questionTitle": "Longest Common Subsequence ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". A common subsequence of two strings is a subsequence that is common to both strings.",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/2d-dynamic-programming#1143-longest-common-subsequence-3---medium",
    "blog": "2D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1448": {
    "questionNum": 1448,
    "questionTitle": "Count Good Nodes in Binary Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#1448-count-good-nodes-in-binary-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1584": {
    "questionNum": 1584,
    "questionTitle": "Min Cost to Connect All Points ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
    "questionTopics": [
      "Array",
      "Union Find",
      "Graph",
      "Minimum Spanning Tree"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#1584-min-cost-to-connect-all-points-1---medium",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1631": {
    "questionNum": 1631,
    "questionTitle": "Path With Minimum Effort ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort. A route's effort is the maximum absolute difference in heights between two consecutive cells of the route. Return the minimum effort required to travel from the top- left cell to the bottom-right cell.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-advanced-graphs#1631-path-with-minimum-effort-1---medium",
    "blog": "LeetCode: Advanced Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1851": {
    "questionNum": 1851,
    "questionTitle": "Minimum Interval to Include Each Query ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti < = queries[j] < = righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Line Sweep",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "questionLink": "/Notes/leetcode-intervals#1851-minimum-interval-to-include-each-query-3---hard",
    "blog": "LeetCode: Intervals",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1899": {
    "questionNum": 1899,
    "questionTitle": "Merge Triplets to Form Target Triplet ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain. To obtain target, you may apply the following operation on triplets any number of times (possibly zero): Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)]. For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]. Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",
    "questionTopics": [
      "Array",
      "Greedy"
    ],
    "questionLink": "/Notes/greedy#1899-merge-triplets-to-form-target-triplet-1---medium",
    "blog": "Greedy",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "2013": {
    "questionNum": 2013,
    "questionTitle": "Detect Squares ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a stream of points on the X-Y plane. Design an algorithm that: Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points. Given a query point, counts the number of ways such that the three points and the query point form an axis-aligned square with positive area. An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis. Implement the DetectSquares class: DetectSquares() Initializes the object with an empty data structure. void add(int[] point) Adds a new point point = [x, y] to the data structure. int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Design",
      "Counting"
    ],
    "questionLink": "/Notes/leetcode-math-and-geometry#2013-detect-squares-1---medium",
    "blog": "LeetCode: Math and Geometry",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  }
}