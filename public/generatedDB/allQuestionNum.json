{
  "1": {
    "questionNum": 1,
    "questionTitle": "Two Sum I (Input Array Is Not Sorted) ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "questionTopics": [
      "Array",
      "Hash Table"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#1-two-sum-i-input-array-is-not-sorted-1---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "2": {
    "questionNum": 2,
    "questionTitle": "Add Two Numbers ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "questionTopics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#2-add-two-numbers-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "3": {
    "questionNum": 3,
    "questionTitle": "Longest Substring Without Repeating Characters ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, find the length of the longest without duplicate characters.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#3-longest-substring-without-repeating-characters-2---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "4": {
    "questionNum": 4,
    "questionTitle": "Median of Two Sorted Arrays ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "questionLink": "/Notes/leetcode-binary-search#4-median-of-two-sorted-arrays-2---hard",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "5": {
    "questionNum": 5,
    "questionTitle": "Longest Palindromic Substring ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, return the longest palindromic substring in s.",
    "questionTopics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#5-longest-palindromic-substring-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "11": {
    "questionNum": 11,
    "questionTitle": "Container With Most Water ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#11-container-with-most-water-1---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "15": {
    "questionNum": 15,
    "questionTitle": "3Sum ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Sorting",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#15-3sum-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "17": {
    "questionNum": 17,
    "questionTitle": "Letter Combinations of a Phone Number ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#17-letter-combinations-of-a-phone-number-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "19": {
    "questionNum": 19,
    "questionTitle": "Remove Nth Node From End of List ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Follow up: Could you do this in one pass?",
    "questionTopics": [
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#19-remove-nth-node-from-end-of-list-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "20": {
    "questionNum": 20,
    "questionTitle": "Valid Parentheses ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a string s containing: ( ) [ ] \\{ \\}, determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.",
    "questionTopics": [
      "String",
      "Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#20-valid-parentheses-2---easy",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:46:00",
    "coldnessCount": 48
  },
  "21": {
    "questionNum": 21,
    "questionTitle": "Merge Two Sorted Lists ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#21-merge-two-sorted-lists-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "22": {
    "questionNum": 22,
    "questionTitle": "Generate Parentheses ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "questionTopics": [
      "String",
      "Stack",
      "Dynamic Programming",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-stacks#22-generate-parentheses-4---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "23": {
    "questionNum": 23,
    "questionTitle": "Merge k Sorted Lists ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "questionTopics": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "questionLink": "/Notes/leetcode-linked-list#23-merge-k-sorted-lists-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "25": {
    "questionNum": 25,
    "questionTitle": "Reverse Nodes in k-Group ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left- out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Follow-up: Can you solve the problem in O(1) extra memory space?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#25-reverse-nodes-in-kgroup-2---hard",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "33": {
    "questionNum": 33,
    "questionTitle": "Search in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &leq; k &le; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#33-search-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 37
  },
  "36": {
    "questionNum": 36,
    "questionTitle": "Valid Sudoku ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#36-valid-sudoku-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "39": {
    "questionNum": 39,
    "questionTitle": "Combination Sum ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#39-combination-sum-4---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "40": {
    "questionNum": 40,
    "questionTitle": "Combination Sum II ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#40-combination-sum-ii-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "42": {
    "questionNum": 42,
    "questionTitle": "Trapping Rain Water ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#42-trapping-rain-water-3---hard",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "46": {
    "questionNum": 46,
    "questionTitle": "Permutations ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array nums of distinct integers, return all the possible . You can return the answer in any order. A permutation is a rearrangement of all the elements of an array.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#46-permutations-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "49": {
    "questionNum": 49,
    "questionTitle": "Group Anagrams ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#49-group-anagrams-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "51": {
    "questionNum": 51,
    "questionTitle": "N Queens ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "questionTopics": [
      "Array",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#51-n-queens-1---hard",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "70": {
    "questionNum": 70,
    "questionTitle": "Climbing Stairs ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "questionTopics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#70-climbing-stairs-4---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "74": {
    "questionNum": 74,
    "questionTitle": "Search a 2D Matrix ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-binary-search#74-search-a-2d-matrix-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 37
  },
  "76": {
    "questionNum": 76,
    "questionTitle": "Minimum Window Substring ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given two strings s and t of lengths m and n respectively, return the minimum window of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#76-minimum-window-substring-2---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "78": {
    "questionNum": 78,
    "questionTitle": "Subsets ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums of unique elements, return all possible subsets (the power set). A subset of an array is a selection of elements (possibly none) of the array. The solution set must not contain duplicate subsets. Return the solution in any order.",
    "questionTopics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-backtracking#78-subsets-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "79": {
    "questionNum": 79,
    "questionTitle": "Word Search ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "questionTopics": [
      "Array",
      "String",
      "Backtracking",
      "Depth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-backtracking#79-word-search-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "84": {
    "questionNum": 84,
    "questionTitle": "Largest Rectangle in Histogram ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#84-largest-rectangle-in-histogram-2---hard",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "90": {
    "questionNum": 90,
    "questionTitle": "Subsets II ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "questionTopics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-backtracking#90-subsets-ii-1---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "91": {
    "questionNum": 91,
    "questionTitle": "Decode Ways ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: \"1\" -> 'A' \"2\" -> 'B' ... \"25\" -> 'Y' \"26\" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\"). For example, \"11106\" can be decoded into: \"AAJF\" with the grouping (1, 1, 10, 6) \"KJF\" with the grouping (11, 10, 6) The grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid). Note: there may be strings that are impossible to decode. Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer.",
    "questionTopics": [
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#91-decode-ways-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "98": {
    "questionNum": 98,
    "questionTitle": "Validate Binary Search Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). The left subtree of a node contains only nodes with keys strictly less than the node's key. The right subtree of a node contains only nodes with keys strictly greater than the node's key. Both the left and right subtrees must also be binary search trees.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#98-validate-binary-search-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "100": {
    "questionNum": 100,
    "questionTitle": "Same Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#100-same-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "102": {
    "questionNum": 102,
    "questionTitle": "Binary Tree Level Order Traversal ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "questionTopics": [
      "Tree",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#102-binary-tree-level-order-traversal-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "104": {
    "questionNum": 104,
    "questionTitle": "Maximum Depth of Binary Tree ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#104-maximum-depth-of-binary-tree-4---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "105": {
    "questionNum": 105,
    "questionTitle": "Construct Binary Tree from Pre Order and In Order Traversal ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two integer arrays pre order and in order where pre order is the pre order traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#105-construct-binary-tree-from-pre-order-and-in-order-traversal-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "110": {
    "questionNum": 110,
    "questionTitle": "Balanced Binary Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#110-balanced-binary-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "121": {
    "questionNum": 121,
    "questionTitle": "Best Time to Buy and Sell Stock ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#121-best-time-to-buy-and-sell-stock-4---easy",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "124": {
    "questionNum": 124,
    "questionTitle": "Binary Tree Maximum Path Sum ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",
    "questionTopics": [
      "Dynamic Programming",
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#124-binary-tree-maximum-path-sum-1---hard",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "125": {
    "questionNum": 125,
    "questionTitle": "Valid Palindrome ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.",
    "questionTopics": [
      "Two Pointers",
      "String"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#125-valid-palindrome-3---easy",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "127": {
    "questionNum": 127,
    "questionTitle": "Word Ladder ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &leq; i &leq; k is in wordList. Note that beginWord does not need to be in wordList sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Breadth First Search"
    ],
    "questionLink": "/Notes/leetcode-graphs#127-word-ladder-3---hard",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "128": {
    "questionNum": 128,
    "questionTitle": "Longest Consecutive Sequence ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums, return the length of the longest consecutive sequence of elements. A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element You must wrtie an algorithm that runs in O(n) time.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#128-longest-consecutive-sequence-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "130": {
    "questionNum": 130,
    "questionTitle": "Surrounded Regions ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: Connect: A cell is connected to adjacent cells horizontally or vertically. Region: To form a region connect every 'O' cell. Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board. To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#130-surrounded-regions-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "131": {
    "questionNum": 131,
    "questionTitle": "Palindrome Partitioning ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
    "questionTopics": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "questionLink": "/Notes/leetcode-backtracking#131-palindrome-partitioning-2---medium",
    "blog": "LeetCode: Backtracking",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "133": {
    "questionNum": 133,
    "questionTitle": "Clone Graph ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node ( public int val; public List[Node] neighbors; ) Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "questionTopics": [
      "Hash Table",
      "Depth First Search",
      "Breadth First Search",
      "Graph"
    ],
    "questionLink": "/Notes/leetcode-graphs#133-clone-graph-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "138": {
    "questionNum": 138,
    "questionTitle": "Copy List with Random Pointer ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.",
    "questionTopics": [
      "Hash Table",
      "Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#138-copy-list-with-random-pointer-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "139": {
    "questionNum": 139,
    "questionTitle": "Word Break ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Trie",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#139-word-break-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "141": {
    "questionNum": 141,
    "questionTitle": "Linked List Cycle ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Follow up: Can you solve it using O(1) (i.e. constant) memory?",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "questionLink": "/Notes/leetcode-linked-list#141-linked-list-cycle-2---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "143": {
    "questionNum": 143,
    "questionTitle": "Reorder List ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given the head of a singly linked-list. The list can be represented as: There is a cycle in a linked list if there is some node in the list that can be L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "questionTopics": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#143-reorder-list-4---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "146": {
    "questionNum": 146,
    "questionTitle": "LRU Cache ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Doubly Linked List"
    ],
    "questionLink": "/Notes/leetcode-linked-list#146-lru-cache-2---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "150": {
    "questionNum": 150,
    "questionTitle": "Evaluate Reverse Polish Notation ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.",
    "questionTopics": [
      "Array",
      "Stack",
      "Math",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#150-evaluate-reverse-polish-notation-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-12T01:00:00",
    "coldnessCount": 49
  },
  "152": {
    "questionNum": 152,
    "questionTitle": "Maximum Product Subarray ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#152-maximum-product-subarray-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "153": {
    "questionNum": 153,
    "questionTitle": "Find Minimum in Rotated Sorted Array ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Suppose an array of length n sorted in ascending order s rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#153-find-minimum-in-rotated-sorted-array-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 37
  },
  "155": {
    "questionNum": 155,
    "questionTitle": "Min Stack ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.",
    "questionTopics": [
      "Stack",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-stacks#155-min-stack-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": "2025-07-13T04:53:00",
    "coldnessCount": 48
  },
  "162": {
    "questionNum": 162,
    "questionTitle": "Find Peak Element ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -inf. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#162-find-peak-element-1---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "167": {
    "questionNum": 167,
    "questionTitle": "Two Sum II Sorted Array ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#167-two-sum-ii-sorted-array-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "198": {
    "questionNum": 198,
    "questionTitle": "House Robber ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#198-house-robber-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "199": {
    "questionNum": 199,
    "questionTitle": "Binary Tree Right Side View ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "questionTopics": [
      "Tree",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#199-binary-tree-right-side-view-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "200": {
    "questionNum": 200,
    "questionTitle": "Number of Islands ::4::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#200-number-of-islands-4---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "206": {
    "questionNum": 206,
    "questionTitle": "Reverse Linked List ::4::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the head of a singly linked list, reverse the list, and return the reversed list. A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "questionTopics": [
      "Linked List",
      "Recursion"
    ],
    "questionLink": "/Notes/leetcode-linked-list#206-reverse-linked-list-4---easy",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "207": {
    "questionNum": 207,
    "questionTitle": "Course Schedule ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Topological Sort"
    ],
    "questionLink": "/Notes/leetcode-graphs#207-course-schedule-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "208": {
    "questionNum": 208,
    "questionTitle": "Implement Trie (Prefix Tree) ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#208-implement-trie-prefix-tree-1---medium",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "210": {
    "questionNum": 210,
    "questionTitle": "Course Schedule II ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Topological Sort"
    ],
    "questionLink": "/Notes/leetcode-graphs#210-course-schedule-ii-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "211": {
    "questionNum": 211,
    "questionTitle": "Design Add and Search Words Data Structure ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: WordDictionary() Initializes the object. void addWord(word) Adds word to the data structure, it can be matched later. bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.",
    "questionTopics": [
      "String",
      "Depth First Search",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#211-design-add-and-search-words-data-structure-1---medium",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "212": {
    "questionNum": 212,
    "questionTitle": "Word Search II ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "questionLink": "/Notes/leetcode-tries#212-word-search-ii-2---hard",
    "blog": "LeetCode: Tries",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "213": {
    "questionNum": 213,
    "questionTitle": "House Robber II ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#213-house-robber-ii-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "215": {
    "questionNum": 215,
    "questionTitle": "Kth Largest Element in an Array ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
    "questionTopics": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Geometry",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-heaps#215-kth-largest-element-in-an-array-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "217": {
    "questionNum": 217,
    "questionTitle": "Contains Duplicate ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an integer array nums, return true if any value appears at least twice in the array, return false if every element is distinct.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#217-contains-duplicate-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "226": {
    "questionNum": 226,
    "questionTitle": "Invert Binary Tree ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the root of a binary tree, invert the tree, and return its root.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#226-invert-binary-tree-3---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "230": {
    "questionNum": 230,
    "questionTitle": "Kth Smallest Element in a BST ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#230-kth-smallest-element-in-a-bst-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "235": {
    "questionNum": 235,
    "questionTitle": "Lowest Common Ancestor of a Binary Search Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#235-lowest-common-ancestor-of-a-binary-search-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "238": {
    "questionNum": 238,
    "questionTitle": "Product of Array Except Self ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "questionTopics": [
      "Array",
      "Prefix Sum"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#238-product-of-array-except-self-2---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "239": {
    "questionNum": 239,
    "questionTitle": "Sliding Window Maximum ::3::",
    "questionDifficulty": "Hard",
    "questionBlurb": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "questionTopics": [
      "Array",
      "Queue",
      "Sliding Window",
      "Heap (Priority Queue)",
      "Monotonic Queue"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#239-sliding-window-maximum-3---hard",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "242": {
    "questionNum": 242,
    "questionTitle": "Valid Anagram ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#242-valid-anagram-2---easy",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "261": {
    "questionNum": 261,
    "questionTitle": "Graph Valid Tree ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-graphs#261-graph-valid-tree-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "271": {
    "questionNum": 271,
    "questionTitle": "String Encode and Decode ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings Please implement encode and decode. strs[i] contains only UTF-8 characters.",
    "questionTopics": [
      "Two Pointers",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-two-pointers#271-string-encode-and-decode-2---medium",
    "blog": "LeetCode: Two Pointers",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "287": {
    "questionNum": 287,
    "questionTitle": "Find the Duplicate Number ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.",
    "questionTopics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Bit Manipulation"
    ],
    "questionLink": "/Notes/leetcode-linked-list#287-find-the-duplicate-number-3---medium",
    "blog": "LeetCode: Linked List",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "295": {
    "questionNum": 295,
    "questionTitle": "Find Median from Data Stream ::1::",
    "questionDifficulty": "Hard",
    "questionBlurb": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. For example, for arr = [2,3,4], the median is 3. For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5. Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.",
    "questionTopics": [
      "Two Pointers",
      "Design",
      "Sorting",
      "Heap (Priority Queue)",
      "Data Stream"
    ],
    "questionLink": "/Notes/leetcode-heaps#295-find-median-from-data-stream-1---hard",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "297": {
    "questionNum": 297,
    "questionTitle": "Serialize and Deserialize Binary Tree ::2::",
    "questionDifficulty": "Hard",
    "questionBlurb": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. ou do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
    "questionTopics": [
      "String",
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Design",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#297-serialize-and-deserialize-binary-tree-2---hard",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "300": {
    "questionNum": 300,
    "questionTitle": "Longest Increasing Subsequence ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return the length of the longest strictly increasing subsequence. Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#300-longest-increasing-subsequence-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "322": {
    "questionNum": 322,
    "questionTitle": "Coin Change ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.",
    "questionTopics": [
      "Array",
      "Dynamic Programming",
      "Breadth First Search"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#322-coin-change-3---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "323": {
    "questionNum": 323,
    "questionTitle": "Number of Connected Components in an Undirected Graph ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph. The nodes are numbered from 0 to n - 1. Return the total number of connected components in that graph.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Graph",
      "Union Find"
    ],
    "questionLink": "/Notes/leetcode-graphs#323-number-of-connected-components-in-an-undirected-graph-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "347": {
    "questionNum": 347,
    "questionTitle": "Top K Elements in List ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums and an integer k, return the k most frequent element within the array. Test cases are generated such that the answer is always unique. You may return the output in any order",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-arrays-and-hashing#347-top-k-elements-in-list-3---medium",
    "blog": "LeetCode: Arrays and Hashing",
    "lastSubmittedDate": "2025-07-10T08:20:00",
    "coldnessCount": 51
  },
  "355": {
    "questionNum": 355,
    "questionTitle": "Design Twitter ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed. Implement the Twitter class: Twitter() Initializes your twitter object. void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId. List[Integer] getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent. void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId. void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
    "questionTopics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Heap (Priority Queue)"
    ],
    "questionLink": "/Notes/leetcode-heaps#355-design-twitter-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "402": {
    "questionNum": 402,
    "questionTitle": "Remove K Digits ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
    "questionTopics": [
      "String",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#402-remove-k-digits-1---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "416": {
    "questionNum": 416,
    "questionTitle": "Partition Equal Subset Sum ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#416-partition-equal-subset-sum-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "417": {
    "questionNum": 417,
    "questionTitle": "Pacific Atlantic Water Flow ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "questionTopics": [
      "Array",
      "Breadth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#417-pacific-atlantic-water-flow-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "424": {
    "questionNum": 424,
    "questionTitle": "Longest Repeating Character Replacement ::1::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#424-longest-repeating-character-replacement-1---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "543": {
    "questionNum": 543,
    "questionTitle": "Diameter of Binary Tree ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#543-diameter-of-binary-tree-2---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "567": {
    "questionNum": 567,
    "questionTitle": "Permutation in String ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",
    "questionTopics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "questionLink": "/Notes/leetcode-sliding-window#567-permutation-in-string-2---medium",
    "blog": "LeetCode: Sliding Window",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "572": {
    "questionNum": 572,
    "questionTitle": "Subtree of Another Tree ::5::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "String Matching",
      "Binary Tree",
      "Hash Function"
    ],
    "questionLink": "/Notes/leetcode-trees#572-subtree-of-another-tree-5---easy",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "621": {
    "questionNum": 621,
    "questionTitle": "Task Scheduler ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label. Return the minimum number of CPU intervals required to complete all tasks.",
    "questionTopics": [
      "Array",
      "Hash Table",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)",
      "Counting",
      "Computer Architecture Scheduling"
    ],
    "questionLink": "/Notes/leetcode-heaps#621-task-scheduler-3---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "647": {
    "questionNum": 647,
    "questionTitle": "Palindromic Substrings ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.",
    "questionTopics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#647-palindromic-substrings-2---medium",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "684": {
    "questionNum": 684,
    "questionTitle": "Redundant Connection ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
    "questionTopics": [
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Graph"
    ],
    "questionLink": "/Notes/leetcode-graphs#684-redundant-connection-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "695": {
    "questionNum": 695,
    "questionTitle": "Max Area of Island ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.",
    "questionTopics": [
      "Array",
      "Depth First Search",
      "Breadth First Search",
      "Union Find",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#695-max-area-of-island-3---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "703": {
    "questionNum": 703,
    "questionTitle": "Kth Largest Element in a Stream ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores. You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores. Implement the KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums. int add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.",
    "questionTopics": [
      "Tree",
      "Design",
      "Binary Search Tree",
      "Heap (Priority Queue)",
      "Binary Tree",
      "Data Stream"
    ],
    "questionLink": "/Notes/leetcode-heaps#703-kth-largest-element-in-a-stream-1---easy",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "704": {
    "questionNum": 704,
    "questionTitle": "Binary Search ::2::",
    "questionDifficulty": "Easy",
    "questionBlurb": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "questionTopics": [
      "Array",
      "Binary Search"
    ],
    "questionLink": "/Notes/leetcode-binary-search#704-binary-search-2---easy",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 37
  },
  "739": {
    "questionNum": 739,
    "questionTitle": "Daily Temperatures ::3::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "questionTopics": [
      "Array",
      "Stack",
      "Monotonic Stack",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/leetcode-stacks#739-daily-temperatures-3---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "746": {
    "questionNum": 746,
    "questionTitle": "Min Cost Climbing Stairs ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.",
    "questionTopics": [
      "Array",
      "Dynamic Programming"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#746-min-cost-climbing-stairs-3---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "853": {
    "questionNum": 853,
    "questionTitle": "Car Fleet ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target. You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour. A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car. A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet. If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet. Return the number of car fleets that will arrive at the destination.",
    "questionTopics": [
      "Array",
      "Stack",
      "Sorting",
      "Monotonic Stack"
    ],
    "questionLink": "/Notes/leetcode-stacks#853-car-fleet-2---medium",
    "blog": "LeetCode: Stacks",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "875": {
    "questionNum": 875,
    "questionTitle": "Koko Eating Bananas ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.",
    "questionTopics": [
      "Array",
      "Binary Search",
      "Network Packet Routing",
      "Design",
      "System Level Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#875-koko-eating-bananas-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": "2025-07-24T09:01:00",
    "coldnessCount": 37
  },
  "973": {
    "questionNum": 973,
    "questionTitle": "K Closest Points to Origin ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given an array of points where points[i] = [x_i, y_i] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance: sqrt((x_1, x-2)^2 + (y_1 + y_2)^2) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
    "questionTopics": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Geometry",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "questionLink": "/Notes/leetcode-heaps#973-k-closest-points-to-origin-2---medium",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "981": {
    "questionNum": 981,
    "questionTitle": "Time Based Key Value Store ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Design a time based key value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class: TimeMap(): Initializes the object of the data structure. void set(String key, String value, int timestamp): Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp): Returns a value such that set was called previously, with timestamp_prev &leq; timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".",
    "questionTopics": [
      "Hash Table",
      "String",
      "Binary Search",
      "Design"
    ],
    "questionLink": "/Notes/leetcode-binary-search#981-time-based-key-value-store-2---medium",
    "blog": "LeetCode: Binary Search",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "994": {
    "questionNum": 994,
    "questionTitle": "Rotting Oranges ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "questionTopics": [
      "Array",
      "Breadth First Search",
      "Matrix"
    ],
    "questionLink": "/Notes/leetcode-graphs#994-rotting-oranges-2---medium",
    "blog": "LeetCode: Graphs",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1046": {
    "questionNum": 1046,
    "questionTitle": "Last Stone Weight ::1::",
    "questionDifficulty": "Easy",
    "questionBlurb": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &leq; y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.",
    "questionTopics": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "questionLink": "/Notes/leetcode-heaps#1046-last-stone-weight-1---easy",
    "blog": "LeetCode: Heaps",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1137": {
    "questionNum": 1137,
    "questionTitle": "Nth Tribonacci Number ::3::",
    "questionDifficulty": "Easy",
    "questionBlurb": "The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.",
    "questionTopics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "questionLink": "/Notes/1d-dynamic-programming#1137-nth-tribonacci-number-3---easy",
    "blog": "1D Dynamic Programming",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  },
  "1448": {
    "questionNum": 1448,
    "questionTitle": "Count Good Nodes in Binary Tree ::2::",
    "questionDifficulty": "Medium",
    "questionBlurb": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.",
    "questionTopics": [
      "Tree",
      "Depth First Search",
      "Breadth First Search",
      "Binary Tree"
    ],
    "questionLink": "/Notes/leetcode-trees#1448-count-good-nodes-in-binary-tree-2---medium",
    "blog": "LeetCode: Trees",
    "lastSubmittedDate": null,
    "coldnessCount": -1
  }
}