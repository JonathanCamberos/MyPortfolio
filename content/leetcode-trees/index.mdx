---
title: "LeetCode: Trees"
description: "trees"
image: "../../public/Notes/tree.png"
publishedAt: "2025-05-01"
updatedAt: "2025-05-01"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Tree Intro

### What is a Tree

Trees are hierachical data structures representing relationships
between entities, often in a parent-child format.

### Properties of a Tree

Trees are a special type of graph, characterized by:

1. Nodes: The entities (ex: values, objects)

2. Edges: The connections between the entities. A tree with n nodes has n - 1 edges.

3. Root: The top-most node, with no parent

4. Leaves: Nodes with no children 

5. Height: The number of edges on the longest path from the root to a leaf

6. Depth: The number of edges from the root to a specific node

7. No Cycles: Trees do not contain cycles

8. Single Paths: Trees have exactly one path between any two nodes

Tree:
```python
      1
     / \
    2   3
       / \
      4   5
```

### Tree Representations

Trees can be represented in multiple formats:

1. Adjacency Matrix: Used for general trees or graphs

2. Parent Array: Store each child -> parent, in an array

3. Linked Node Structure: Common in Binary Trees (TreeNode with left and right)

For full notes on representations:
please see [graph representations](/Notesleetcode-graphs#graph-representations)

### Tree Math
Height of a perfect binary tree with n nodes: log(n+1)-1

Nodes in perfect binary tree of height h: 2^(h+1) -1

Max nodes at level l: 2^l

Edges = Nodes - 1

### Common Tree Types

1. Binary Tree:
Each node has at most two children left and right.
Most LeetCode problems use this form.

2. Binary Search Tree (BST):
Type of binary tree where: 
Left subtree val < Node val < Right subtree val

Allows efficient search, insertion, and deletion.

3. Balanced Binary Tree (AVL, Red-Black)
Type of binary tree where: 
Height difference (balance factor) is kept small,
ensuring the height stays O(log n).

This prevents BST from degrading to a linked list in worst case

4. Complete Binary Tree
Type of binary tree where: 
All levels are filled except possibly the last, which is filled from left to right.

5. Full Binary Tree
Type of binary tree where:
Each node has either 0 or 2 children

6. Perfect Binary Tree
Type of binary tree where:
All internal nodes have 2 children and all leaves are at the same level.

7. N-ary Tree
Type of tree where:
Each node can have up to N children

### Balanced Trees 
Balanced trees are binary search trees that maintain their height
close to O(log n) by rebalancing themselves during insertion() and deletion().

Without balancing, a BST can degrade to a linked list: height(O(n)) if the
elements are inserted in sorted order

This is done by limiting the height difference (balance factor) 
between left and right subtrees.

Common Balanced Trees:

1. AVL Tree:
Strict balancing. Balance factor at each node is in [-1, 0, 1]. 
Rotations restore balance after insert/delete

2. Red Black Tree:
Looser balancing with colour properties.
Guarantees height &leq; 2 * log(n+1)

3. B- Trees / B+ Trees:
Multi way balanced trees used in databases and filesystems
for efficient range queries

| Operation     | BST (Unbalanced) | Balanced BST |
|---------------|------------------|--------------|
| Search        | O(n)             | O(log n)     |
| Insert/Delete | O(n)             | O(log n)     |


### Tree Traversal Overview
Given a Tree, and the task to traverse it,
there a two fundamental search strategies that all others stem from. 

### Depth First Search Traversal (DFS)
Traversal Order: 
Goes as deep as possible before backtracking
(either recursively via function calls or iteratively via stack)

Can process in pre, in, or post order:

Pre: Root -> Left -> Right

In: Left -> Root -> Right

Post: Left -> Right -> Root

### Breadth First Search Traversal (BFS)
Traversal Order: 
Explores nodes level by level

Will queue nodes for next level, count how many exist, 
and process all nodes for that level by iterating 
exactly level_size times popping each from the queue, thus popping all 
nodes for a specific level.

### Specialized Traversals
- Morris Traversal:
In order traversal with O(1) extra space by temporarily modifying tree pointers.

- Threaded Binary Tree:
Uses null child pointers to store predecessor/successor pointers to enable O(1) traversal.

### Tree Search Rule of Thumb:
Pre, In, Post, order traversal -> DFS (recursive usually, iterative stack based)

Level Order Traversal -> BFS (iterative) queue based

### Tree Application: DFS Pre order Traversal
Pre order traversal visits nodes in Root -> Left -> Right order.
Commonly used when we need to process a node before its children.

Ex: Serialize a Binary Tree (Recursive + Iterative)
```python
    # Recursive Preorder
    def serializeRecursive(root: Optional[TreeNode]) -> str:
        def dfs(node):
            if not node:
                vals.append("N")
                return
            vals.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        
        vals = []
        dfs(root)
        return ",".join(vals)

    # Iterative Preorder (stack)
    def serializeIterative(root: Optional[TreeNode]) -> str:
        if not root:
            return "N"

        stack = [root]
        vals = []
        while stack:
            node = stack.pop()
            if node:
                vals.append(str(node.val))
                stack.append(node.right)
                stack.append(node.left)
            else:
                vals.append("N")
        return ",".join(vals)

    # Example Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS In order Traversal
In order nodes in Left -> Root -> Right order.
Useful for processing sorted trees from a Binary Search Tree

Ex: Convert BST to Sorted List (Recursive) & Validate BST (Iterative)
```python 
    # Recursive Inorder
    def bstToSortedList(root: Optional[TreeNode]) -> List[int]:
        res = []
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            res.append(node.val)
            inorder(node.right)
        inorder(root)
        return res

    # Iterative Inorder
    def isValidBST(root: Optional[TreeNode]) -> bool:
        stack = []
        prev_val = float("-inf")
        curr = root
        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            if curr.val <= prev_val:
                return False
            prev_val = curr.val
            curr = curr.right
        return True

    # Example BST:
    #       2
    #      / \
    #     1   3
    # bstToSortedList -> [1, 2, 3]
    # isValidBST -> True
```

### Tree Application: DFS Post order Traversal
Post order visits nodes in Left → Right → Root order.
 Useful for cleanup or evaluation problems (process children before parent).

Ex: Evaluate Expression Tree (Recursive) & Delete Tree (Iterative)
```python
# Recursive Postorder
    def evaluateTree(root: Optional[TreeNode]) -> int:
        if not root.left and not root.right:
            return int(root.val)
        left_val = evaluateTree(root.left)
        right_val = evaluateTree(root.right)
        if root.val == "+":
            return left_val + right_val
        elif root.val == "-":
            return left_val - right_val
        elif root.val == "*":
            return left_val * right_val
        elif root.val == "/":
            return int(left_val / right_val)

    # Iterative Postorder
    def deleteTree(root: Optional[TreeNode]) -> None:
        if not root:
            return
        stack, output = [root], []
        while stack:
            node = stack.pop()
            output.append(node)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        while output:
            node = output.pop()
            del node

    # Example:
    # Expression Tree:
    #       "+"
    #      /   \
    #     3     "*"
    #          /   \
    #         2     4
    # evaluateTree -> 11
    #
    # DeleteTree on:
    #       1
    #      / \
    #     2   3
    # Deletion order: 2, 3, 1
```

### Tree Application: BFS Iterative Queue Based
BFS visits nodes level by level, processing all nodes at a given depth 
before moving on to the next.
Used for level order problems and shortest path calculations in unweighted graphs,
as well as scenarios requiring nodes in order of distance from the root.

Ex: Level order traversal of Binary Tree
```python
    def levelOrderIterative(root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            level_nodes = []

            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level_nodes)

        return result

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: [[1], [2, 3], [4, 5]]
```

### Tree Application: Modification
Tree structure is altered by rearranging nodes or pointers,
rather than simply traversing or querying.

Ex: Invert Binary Tree (DFS Recursive + BFS Iterative)
```python
# DFS Recursive (Postorder style)
def invertTreeDFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
        return None
    # Recursively invert left and right subtrees
    left_inverted = invertTreeDFS(root.left)
    right_inverted = invertTreeDFS(root.right)
    # Swap left and right children
    root.left, root.right = right_inverted, left_inverted
    return root

# BFS Iterative
from collections import deque

def invertTreeBFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
        return None
    queue = deque([root])
    while queue:
        node = queue.popleft()
        # Swap children
        node.left, node.right = node.right, node.left
        # Add children to queue if they exist
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return root

# Example Tree:
#       4
#      / \
#     2   7
#    / \ / \
#   1  3 6  9
#
# Inverted Tree:
#       4
#      / \
#     7   2
#    / \ / \
#   9  6 3  1
```

### Tree Application: MinHeap
Use a MinHeap, a type of binary tree, to maintain the smallest or
highest-priority elements efficiently. 

Ex: Find the Top K Frequent Elements in a List
```python
    def topKFrequent(nums: List[int], k: int) -> List[int]:
        from collections import defaultdict
        import heapq

        # Step 1: Frequency count for each unique integer
        count = defaultdict(int)  # O(m) space complexity for m unique integers
        for num in nums:  # O(n) time complexity to iterate over n integers
            count[num] += 1

        # Step 2: Use a MinHeap to track the k most frequent elements
        minHeap = []  # O(k) space complexity for k elements
        for num, freq in count.items():  # O(m) time complexity for m unique integers
            heapq.heappush(minHeap, (freq, num))  # O(log k) for each insertion
            if len(minHeap) > k:  # Ensure heap size remains k
                heapq.heappop(minHeap)  # O(log k) for each removal

        # Step 3: Extract the elements from the heap
        return [num for freq, num in minHeap]  # O(k) time complexity to extract results

    # Example:
    # Input: nums = [1, 1, 1, 2, 2, 3], k = 2
    # Output: [1, 2]
```


## 226. Invert Binary Tree ::1:: - Easy

Topics:  Tree, Depth-First Search, Breadth-First Search, Binary Tree

### Intro
> Given the root of a binary tree, invert the tree, and return its root.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [4,2,7,1,3,6,9] | [4,7,2,9,6,3,1] |
| root = [2,1,3] | [2,3,1] |
| root = [] | [] |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-100 &le; Node.val &le; 100

### Abstraction
Invert the binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: BFS Iterative - Tree/Modification
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # 1. BFS iterative approach inverts nodes level by level
        # 2. Queue stores nodes to process
        # 3. For each node:
        #    - Swap left and right children
        #    - Add non-null children to queue
        # 4. Continues until all levels processed
        
        if not root:
            return None
        
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            # Swap left and right children
            node.left, node.right = node.right, node.left
            
            # Add children to queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Implicit Sliding Window Tracking Min Price and Max Profit - Tree/Modification
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # 1. BFS iterative approach inverts nodes level by level
        # 2. Queue stores nodes to process
        # 3. For each node:
        #    - Swap left and right children
        #    - Add non-null children to queue
        # 4. Continues until all levels processed
        
        if not root:
            return None
        
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            # Swap left and right children
            node.left, node.right = node.right, node.left
            
            # Add children to queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |