---
title: "LeetCode: Trees"
description: "trees"
image: "../../public/Notes/tree.png"
publishedAt: "2025-08-05"
updatedAt: "2025-08-05"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Tree Intro

### What is a Tree

Trees are hierarchical data structures representing relationships
between entities, often in a parent-child format.

### Tree Characteristics

Trees are a special type of graph, characterized by:

1. Nodes: The entities (ex: values, objects)

2. Edges: The connections between the entities. A tree with n nodes has n - 1 edges.

3. Root: The top-most node, with no parent

4. Leaves: Nodes with no children 

5. Height: The number of edges on the longest path from the root to a leaf

6. Depth: The number of edges from the root to a specific node

7. No Cycles: Trees do not contain cycles

8. Single Paths: Trees have exactly one path between any two nodes

```
      1
     / \
    2   3
       / \
      4   5
```

### Tree Representations

Trees can be represented in multiple formats:

1. Adjacency Matrix: Used for general trees or graphs

2. Parent Array: Store each child -> parent, in an array

3. Linked Node Structure: Common in Binary Trees (TreeNode with left and right)

For full notes on representations:
please see [graph representations](/Notesleetcode-graphs#graph-representations)

### Tree Math
Height of a perfect binary tree with n nodes: log(n+1)-1

Nodes in perfect binary tree of height h: 2^(h+1) -1

Max nodes at level l: 2^l

Edges = Nodes - 1

### Common Tree Types

1. Binary Tree:
Each node has at most two children left and right.
Most LeetCode problems use this form.

2. Binary Search Tree (BST):
Type of binary tree where: 
Left subtree val < Node val < Right subtree val

Allows efficient search, insertion, and deletion.

3. Balanced Binary Tree (AVL, Red-Black)
Type of binary tree where: 
Height difference (balance factor) is kept small,
ensuring the height stays O(log n).

This prevents BST from degrading to a linked list in worst case

4. Complete Binary Tree
Type of binary tree where: 
All levels are filled except possibly the last, which is filled from left to right.

5. Full Binary Tree
Type of binary tree where:
Each node has either 0 or 2 children

6. Perfect Binary Tree
Type of binary tree where:
All internal nodes have 2 children and all leaves are at the same level.

7. N-ary Tree
Type of tree where:
Each node can have up to N children

### Balanced Trees 
Balanced trees are binary search trees that maintain their height
close to O(log n) by rebalancing themselves during insertion() and deletion().

Without balancing, a BST can degrade to a linked list: height(O(n)) if the
elements are inserted in sorted order

This is done by limiting the height difference (balance factor) 
between left and right subtrees.

Common Balanced Trees:

1. AVL Tree:
Strict balancing. Balance factor at each node is in [-1, 0, 1]. 
Rotations restore balance after insert/delete

2. Red Black Tree:
Looser balancing with colour properties.
Guarantees height &leq; 2 * log(n+1)

3. B- Trees / B+ Trees:
Multi way balanced trees used in databases and filesystems
for efficient range queries

| Operation     | BST (Unbalanced) | Balanced BST |
|---------------|------------------|--------------|
| Search        | O(n)             | O(log n)     |
| Insert/Delete | O(n)             | O(log n)     |


### Tree Traversal Overview
Given a Tree, and the task to traverse it,
there a two fundamental search strategies that all others stem from. 

### Depth First Search Traversal (DFS)
Traversal Order: 
Goes as deep as possible before backtracking
(either recursively via function calls or iteratively via stack)

Can process in pre, in, or post order:

Pre: Root -> Left -> Right

In: Left -> Root -> Right

Post: Left -> Right -> Root

### Breadth First Search Traversal (BFS)
Traversal Order: 
Explores nodes level by level

Will queue nodes for next level, count how many exist, 
and process all nodes for that level by iterating 
exactly level_size times popping each from the queue, thus popping all 
nodes for a specific level.

### Specialized Traversals
- Morris Traversal:
In order traversal with O(1) extra space by temporarily modifying tree pointers.

- Threaded Binary Tree:
Uses null child pointers to store predecessor/successor pointers to enable O(1) traversal.

### Tree Search Rule of Thumb
Pre, In, Post, order traversal -> DFS (recursive usually, iterative stack based)

Level Order Traversal -> BFS (iterative) queue based

### Tree Application: DFS Pre Order Traversal Top Down
Traversal Order: Root -> Left -> Right.
Top Down: Root is processed immediately, then we move deeper.
Used when a node's work must be done before processing its children.

Ex: Serialize a Binary Tree Recursive and Iterative
```python
    def serializeRecursive(root: Optional[TreeNode]) -> str:
        
        def dfsPreOrder(node):

            # Base Case: 
            # At leaf, label with 'N'
            if not node:
                vals.append("N")
                return
            
            # Process Root (top-down work)
            # add to serialized array
            vals.append(str(node.val))
            
            # Process Left and Right Subtree
            dfsPreOrder(node.left)
            dfsPreOrder(node.right)
        
        # array representing tree
        vals = []

        # start recursive Top Down at Head Root
        dfsPreOrder(root)

        # join array representation of tree and return
        return ",".join(vals)

    # Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS Pre Order Iterative Top Down
Traversal Order: Root -> Left -> Right.
Top Down: Root is processed immediately, then we move deeper.
Used when a node's work must be done before processing its children.

Ex: Serialize a Binary Tree Recursive and Iterative
```python
    def serializeIterative(root: Optional[TreeNode]) -> str:

        # Empty Check
        if not root:
            return "N"

        # start iteration over tree, with root
        stack = [root]
        # array representing tree
        vals = []
        
        # iterate over all nodes of tree
        while stack:

            # grab current root
            currRoot = stack.pop()

            # Node Case:
            # current root being processed
            if currRoot:

                # Process Root (top-down work)
                vals.append(str(currRoot.val))
                
                # Push Right then Left (stack pops left first)
                stack.append(currRoot.right)
                stack.append(currRoot.left)
            
            # Leaf Case: 
            # At leaf, label with 'N'
            else:
                vals.append("N")
        
        # join values of tree and return
        return ",".join(vals)

    # Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS In Order Recursive Mid Point
Traversal Order: Left -> Root -> Right
Mid Point: Left is processed, then Root, followed by Right 
Used when a node's work must be done after visiting the left subtree
but before visiting the right subtree.

Ex: Convert BST to Sorted List Recursive and Validate BST Iterative
```python
    def bstToSortedList(root: Optional[TreeNode]) -> List[int]:
        
        def dfsInOrder(node):
            if not node:
                return
            
            # Process Left Subtree
            dfsInOrder(node.left)
            
            # Process Root (midpoint work)
            res.append(node.val)
            
            # Process Right Subtree
            dfsInOrder(node.right)
        
        dfsInOrder(root)
        return res

    # Tree:
    #       2
    #      / \
    #     1   3
    # bstToSortedList -> [1, 2, 3]
```

### Tree Application: DFS In Order Iterative Mid Point
Traversal Order: Left -> Root -> Right
Mid Point: Left is processed, then Root, followed by Right 
Used when a node's work must be done after visiting the left subtree
but before visiting the right subtree.

Ex: Convert BST to Sorted List Recursive and Validate BST Iterative
```python
    def isValidBST(root: Optional[TreeNode]) -> bool:
        
        # Track the previously visited value to ensure ascending order
        prev_val = float("-inf")

        # stack for DFS
        stack = [] 

        # current pointer starting at root
        curr = root
        
        while stack or curr:
            
            # Traverse as far left as possible
            while curr:
                # push curr root onto stack, 
                # update curr root -> left subtree,
                # explore new root (left)
                stack.append(curr)
                curr = curr.left
            
            # Exited Loop: Reached Leaf on Left Subtree
            #     L
            #  /     \ 
            # leaf    ?
                        
            # Grab previous Left Subtree Root (from the stack)
            curr = stack.pop()

            # Validate that current value is greater than previous
            if curr.val <= prev_val:
                return False

            # Update to current node's value
            prev_val = curr.val
            
            # Move to the right subtree
            # (which will eventually push more left children if they exist)
            #     L
            #  /     \ 
            # leaf    *here*
            curr = curr.right
        
        return True

    # Tree:
    #       2
    #      / \
    #     1   3
    # isValidBST -> True
```

### Tree Application: DFS Post Order Recursive Bottom Up
Traversal Order: Left -> Right -> Root
Bottom Up: Left and Right children are processed, followed by Root
Useful when a node's work depends on fully processed children. 

Ex: Evaluate Expression Tree Recursive and Delete Tree Iterative
```python
    def evaluateTree(root: Optional[TreeNode]) -> int:
    
        def dfsPostOrder(node):
            
            # Leaf case
            if not node.left and not node.right:
                return int(node.val)
            
            # Process Left Subtree
            left_val = dfsPostOrder(node.left)
            
            # Process Right Subtree
            right_val = dfsPostOrder(node.right)
            
            # Process Root (bottom-up work)
            if node.val == "+":
                return left_val + right_val
            elif node.val == "-":
                return left_val - right_val
            elif node.val == "*":
                return left_val * right_val
            elif node.val == "/":
                return int(left_val / right_val)
        
        return dfsPostOrder(root)

    # Expression Tree:
    #       "+"
    #      /   \
    #     3     "*"
    #          /   \
    #         2     4
    # evaluateTree -> 11
```

### Tree Application: DFS Post Order Iterative Bottom Up
Traversal Order: Left -> Right -> Root
Bottom Up: Left and Right children are processed, followed by Root
Useful when a node's work depends on fully processed children. 

Ex: Evaluate Expression Tree Recursive and Delete Tree Iterative
```python
    def postorderTraversal(root: Optional[TreeNode]) -> None:
        
        # Empty check
        if not root:
            return 0
        
        # stack for dfs
        stack = []

        # start at head root
        curr = root

        # last visited to avoid repeat visits
        lastVisited = None

        # store evaluated values for nodes
        value_map = {}
        
        while stack or curr:

            # Process Left Subtree:
            # Traverse as far left as possible -> push left node for later process
            while curr:
                stack.append(curr)
                curr = curr.left
            
            # iteration 1 curr: reached leaf of a left subtree
            # iteration 2 stack: recursed to root previous push during left exploration
            peekNode = stack[-1]
            
            # Process Right Subtree:
            # If right child exists and hasn't been processed -> explore right
            if peekNode.right and lastVisited != peekNode.right:
                curr = peekNode.right
                
            # Process Root:
            # Both left and right have been processed 
            else:

                # pop root from previously pushed during left exploration
                stack.pop()
                
                # Both left and right are None:
                # peekNode -> Leaf node (operand)
                if not peekNode.left and not peekNode.right:
                    value_map[peekNode] = int(peekNode.val)
                
                # Else: 
                # peekNode -> Non Leaf Node (operator)
                else:

                    # grab processed left and right values
                    left_val = value_map.get(peekNode.left, 0)
                    right_val = value_map.get(peekNode.right, 0)
                    
                    # compute: current node map -> value
                    if peekNode.val == "+":
                        value_map[peekNode] = left_val + right_val
                    elif peekNode.val == "-":
                        value_map[peekNode] = left_val - right_val
                    elif peekNode.val == "*":
                        value_map[peekNode] = left_val * right_val
                    elif peekNode.val == "/":
                        value_map[peekNode] = int(left_val / right_val)
                
                # update visited (to avoid duplicate visits)
                lastVisited = peekNode
        
        # return final computed value
        return value_map[root]

    # Expression Tree:
    #       "+"
    #      /   \
    #     3     "*"
    #          /   \
    #         2     4
    # evaluateTree -> 11
```


### Tree Application: BFS Iterative Level Size Based Grouping Processing
Traversal Order: Level by Level
BFS visits nodes level by level, processing all nodes at a given depth 
before moving on to the next.
Used for level order problems and shortest path calculations in unweighted graphs,
as well as scenarios requiring nodes in order of distance from the root.

Ex: Level order traversal of Binary Tree
```python
    # ----------------------------------------
    # Iterative
    def levelOrderIterative(root: Optional[TreeNode]) -> List[List[int]]:
        
        # Empty check
        if not root:
            return []

        result = []
        queue = deque([root])

        # 
        while queue:
            level_size = len(queue)
            level_nodes = []

            # Process all nodes in current level
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level_nodes)

        return result

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: [[1], [2, 3], [4, 5]]
```

### Tree Application: BFS Iterative No Explicit Level Sized Grouping Processing
Traversal Order: Level by Level
BFS visit nodes in breath first order.
However, in some problems we don't process or store the full level at once.
Instead we act on nodes individually or in partial groupings (pairs, linked neighbors, etc)

Ex: Invert a Binary Tree
```python
    # ----------------------------------------
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        # BFS - no explicit full level processing
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            # Swap left and right children
            node.left, node.right = node.right, node.left
            
            # Add children to queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return root

        # Example:
        # Input Tree:
        #       4
        #      / \
        #     2   7
        # Output Tree:
        #       4
        #      / \
        #     7   2
```

### Tree Application: BFS Iterative Distance from Root Matters
Traversal Order: Level by Level
Distance Tracking: Each level corresponds to one distance step from the root.
Used when the problem depends on minimum, maximum or some count depth.

Ex: Minimum Depth of a Binary Tree
```python
    # ----------------------------------------
    # Why BFS with Distance Tracking?
    # BFS naturally explores nodes by distance from the root.
    # The first leaf node encountered gives the minimum depth.
    # Boils down to BFS where level number = distance.

    # ----------------------------------------
    # Iterative BFS with Depth Tracking
    def minDepth(root: Optional[TreeNode]) -> int:
        from collections import deque
        
        # Empty Tree
        if not root:
            return 0
        
        queue = deque([(root, 1)])  # store (node, depth)
        
        # BFS until first leaf is found
        while queue:
            node, depth = queue.popleft()
            
            # Leaf found: return depth
            if not node.left and not node.right:
                return depth
            
            # Add children with updated depth
            if node.left:
                queue.append((node.left, depth + 1))
            if node.right:
                queue.append((node.right, depth + 1))
```

### Tree Application: BFS Iterative State Changes Propagate Outward
Traversal Order: Level by Level
State Propagation: Changes spread outward in BFS "waves" from a source node.
Used when state changes spread level by level (burning, infection)

Ex: Infection Spread in Binary Tree
```python
    # ----------------------------------------
    # Why BFS for State Propagation?
    # State changes (infection, burning) spread to direct neighbors each step.
    # BFS naturally handles wave-like outward spreading by levels.
    # Boils down to BFS from the source with time = levels.

    # ----------------------------------------
    # Iterative BFS for Propagation
    def amountOfTime(root: Optional[TreeNode], start: int) -> int:
        from collections import defaultdict, deque
        
        # Step 1: Build adjacency list (treat tree as undirected graph)
        graph = defaultdict(list)
        
        def dfs(node):
            if not node:
                return
            if node.left:
                graph[node.val].append(node.left.val)
                graph[node.left.val].append(node.val)
                dfs(node.left)
            if node.right:
                graph[node.val].append(node.right.val)
                graph[node.right.val].append(node.val)
                dfs(node.right)
        
        dfs(root)
        
        # Step 2: BFS starting from infected node
        visited = set([start])
        queue = deque([(start, 0)])
        time = 0
        
        while queue:
            node, time = queue.popleft()
            
            # Spread to neighbors
            for nei in graph[node]:
                if nei not in visited:
                    visited.add(nei)
                    queue.append((nei, time + 1))
        
        return time
```

### Tree Application: BFS Iterative Non-Standard Level Traversal
Traversal ORder: Level by Level (but with non default ordering such as reversed, zigzag, or other patterns)
Used when the traversal order of nodes at each level must follow a specific 
non standard pattern

Ex: Binary Tree Zigzag Level Order Traversal
```python
    # ----------------------------------------
    # Why BFS for Non-Standard Level Traversal?
    # BFS visits nodes level by level, making it simple to apply 
    # transformations (reversals, zigzags, diagonal skips, etc.) 
    # before storing each level.
    # Boils down to BFS level grouping + order transformation.

    # ----------------------------------------
    # Iterative BFS with Zigzag Example
    def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]:
        from collections import deque
        
        # Empty Tree
        if not root:
            return []
        
        result = []
        queue = deque([root])
        left_to_right = True  # toggle for order
        
        while queue:
            level_size = len(queue)
            level_nodes = deque()
            
            # Process all nodes in current level
            for _ in range(level_size):
                node = queue.popleft()
                
                # Append based on pattern
                if left_to_right:
                    level_nodes.append(node.val)
                else:
                    level_nodes.appendleft(node.val)
                
                # Add children for next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(list(level_nodes))
            left_to_right = not left_to_right  # flip order for next level
        
        return result

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #    / \   \
    #   4   5   6
    # Output: [[1], [3, 2], [4, 5, 6]]
```

### Tree Application: BFS Iterative Per Level Aggregation
Traversal Order: Level by Level
BFS naturally groups nodes by level, making it useful when each 
level's value must be combined into an aggregate value (sum, average, product, etc)

Ex: Average of Levels in a Binary Tree
```python
    # ----------------------------------------
    # Why BFS for Per-Level Aggregation?
    # BFS processes all nodes in a level before moving to the next, 
    # making it easy to compute per-level aggregates in one pass.
    # Boils down to BFS level grouping + aggregate computation.

    # ----------------------------------------
    # Iterative BFS with Per-Level Average
    def averageOfLevels(root: Optional[TreeNode]) -> List[float]:
        from collections import deque
        
        # Empty Tree
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            level_sum = 0
            
            # Process all nodes in current level
            for _ in range(level_size):
                node = queue.popleft()
                level_sum += node.val
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            # Compute average for level
            result.append(level_sum / level_size)
        
        return result

    # Example:
    # Input Tree:
    #       3
    #      / \
    #     9   20
    #        /  \
    #       15   7
    # Output: [3.0, 14.5, 11.0]
```


### Tree Application: Modification
Tree structure is altered by rearranging nodes or pointers,
rather than simply traversing or querying.

Ex: Invert Binary Tree (DFS Recursive + BFS Iterative)
```python
    # ----------------------------------------
    # DFS Recursive (Postorder style)

    def invertTreeDFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        # Recursively invert left and right subtrees
        left_inverted = invertTreeDFS(root.left)
        right_inverted = invertTreeDFS(root.right)
        # Swap left and right children
        root.left, root.right = right_inverted, left_inverted
        return root

    # ----------------------------------------
    # BFS Iterative

    def invertTreeBFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        queue = deque([root])
        while queue:
            node = queue.popleft()
            # Swap children
            node.left, node.right = node.right, node.left
            # Add children to queue if they exist
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return root

    # ----------------------------------------
    # Result of recursive and iterative:

    # Tree:
    #       4
    #      / \
    #     2   7
    #    / \ / \
    #   1  3 6  9
    
    # Inverted Tree:
    #       4
    #      / \
    #     7   2
    #    / \ / \
    #   9  6 3  1
```

### Tree Application: MinHeap
Use a MinHeap, a type of binary tree, to maintain the smallest or
highest-priority elements efficiently. 

Ex: Find the Top K Frequent Elements in a List
```python
    def topKFrequent(nums: List[int], k: int) -> List[int]:
        from collections import defaultdict
        import heapq

        # Step 1: Frequency count for each unique integer
        count = defaultdict(int)  # O(m) space complexity for m unique integers
        for num in nums:  # O(n) time complexity to iterate over n integers
            count[num] += 1

        # Step 2: Use a MinHeap to track the k most frequent elements
        minHeap = []  # O(k) space complexity for k elements
        for num, freq in count.items():  # O(m) time complexity for m unique integers
            heapq.heappush(minHeap, (freq, num))  # O(log k) for each insertion
            if len(minHeap) > k:  # Ensure heap size remains k
                heapq.heappop(minHeap)  # O(log k) for each removal

        # Step 3: Extract the elements from the heap
        return [num for freq, num in minHeap]  # O(k) time complexity to extract results

    # Example:
    # Input: nums = [1, 1, 1, 2, 2, 3], k = 2
    # Output: [1, 2]
```


## 226. Invert Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the root of a binary tree, invert the tree, and return its root.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [4,2,7,1,3,6,9] | [4,7,2,9,6,3,1] |
| root = [2,1,3] | [2,3,1] |
| root = [] | [] |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-100 &le; Node.val &le; 100

### Abstraction
Invert the binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive - Tree/DFS Post Order Traversal
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: DFS recursive approach inverts subtrees from bottom up (postorder)
        # 1. Base case: return None if node is null
        # 2. Left -> Right: Recursively invert subtree
        # 3. Root: Swap left and right children
        # Result: Original tree has been inverted

        # Base case:
        # reached empty TreeNode
        if not root:
            return None

        # Process Left + Right:
        # Recursive calls to invert the left and right subtrees
        left_inverted = self.invertTree(root.left)
        right_inverted = self.invertTree(root.right)

        # Process Root:
        # Swap left and right children
        root.left = right_inverted
        root.right = left_inverted

        # overall: time complexity O(n)
        # overall: space complexity O(h), O(log n) for balanced tree
        return root
```

### Solution 2: BFS Iterative - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: BFS iterative approach inverts nodes level by level
        # 1. Queue stores nodes to process
        # 2. While Queue is non empty
        # 3. Process Root: 
        #    Pop() from queue 
        #    Swap left and right children
        #    Push() left and right children to queue for processing
        # Result: Tree reverse in place
        
        # Empty tree check
        if not root:
            return None
        
        # dfs Queue:
        queue = deque([root])
        
        # queue hold nodes to be processed
        # time complexity: iterate over tree by queuing nodes, level by level O(n)
        while queue:

            # Grab Root:
            # pop() from queue -> curr root
            currRoot = queue.popleft()
            
            # Process Root:
            # Swap left and right children
            currRoot.left, currRoot.right = currRoot.right, currRoot.left
            
            # Process Left and Right subtrees:
            # add left and right to dfs queue
            if currRoot.left:
                queue.append(currRoot.left)
            if currRoot.right:
                queue.append(currRoot.right)
        
        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 104. Maximum Depth of Binary Tree ::3:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> A binary tree's maximum depth is the number of nodes along 
> the longest path from the root node down to the farthest leaf node.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | 3 |
| root = [1,null,2] | 2 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the max depth of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive Bottom Up Children Depth - Tree/DFA Post Order Traversal
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # Idea: DFS postorder traversal (Left -> Right -> Root)
        # 1. Process depth of left subtree
        # 2. Process depth of right subtree
        # 3. Process results at root
        # Result: Natural Bottom Up solution (need children results to compute root)
        
        if not root:
            return 0
        
        # Process left and right children
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        
        # Process Root
        return 1 + max(left_depth, right_depth)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: BFS Iterative Count By Level Width - Tree/BFS Iterative Full Level Processing
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. BFS iterative approach calculates depth level-by-level
        # 2. Queue stores nodes in current level
        # 3. For each level:
        #    - process all nodes at current depth
        #    - add their children to queue
        # 4. Increment depth after processing each level
        
        if not root:
            return 0
        
        queue = deque([root])
        depth = 0
        
        while queue:
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth += 1
        
        # overall: time complexity
        # overall: space complexity
        return depth
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |




### Solution 3: DFS Iterative Carry Down Depth Val - Tree/DFA Post Order Traversal
```python
    # Note:
    # 1. DFS iterative approach simulates recursion using a stack
    # 2. Each stack entry stores (node, current depth)
    # 3. Update max_depth when visiting each node
    # 4. Works like Postorder — compute children before root aggregation
    
    if not root:
        return 0
    
    stack = [(root, 1)]
    max_depth = 0
    
    while stack:
        node, depth = stack.pop()
        if node:
            # Update maximum depth
            max_depth = max(max_depth, depth)
            
            # Push children with incremented depth
            stack.append((node.left, depth + 1))
            stack.append((node.right, depth + 1))
    
    return max_depth
```

## 543. Diameter of Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given the root of a binary tree, return the length of the diameter of the tree.
> The diameter of a binary tree is the length of the longest path between any 
> two nodes in a tree. This path may or may not pass through the root.
> The length of a path between two nodes is represented by the number of
> edges between them. 

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3,4,5] | 3 |
| root = [1,2] | 1 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the diameter of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive Post order - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. Post order DFS: compute height of subtrees bottom-up
        # 2. At each node:
        #    - Compute left height
        #    - Compute right height
        #    - Update diameter as max(left_height + right_height)
        # 3. Return diameter after full traversal
        # Results: longest path in terms of edges between any two nodes

        self.diameter = 0
        
        def dfs(node):
            if not node:
                return 0
            
            # Heights of left and right subtrees
            left_height = dfs(node.left)
            right_height = dfs(node.right)
            
            # Update diameter at this node
            self.diameter = max(self.diameter, left_height + right_height)
            
            # Height of subtree rooted at this node
            return 1 + max(left_height, right_height)
        
        dfs(root)
        return self.diameter
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive Optimized Return Tuple - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. Combine diameter & height calculation in single DFS call
        # 2. Each call returns tuple: (height, diameter)
        # 3. Avoid global variable by computing max in recursion
        # Results: same O(n) but cleaner function interface
        
        def dfs(node):
            if not node:
                return 0, 0  # (height, diameter)
            
            left_height, left_diam = dfs(node.left)
            right_height, right_diam = dfs(node.right)
            
            # Diameter at this node
            curr_diam = left_height + right_height
            
            # Best diameter so far
            max_diam = max(curr_diam, left_diam, right_diam)
            
            # Height of subtree
            return 1 + max(left_height, right_height), max_diam
        
        return dfs(root)[1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 110. Balanced Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given a binary tree, determine if it is height-balanced. 

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | true |
| root = [1,2,2,3,3,null,null,4,4] | false |
| root = [] | true |
 
Constraints:

The number of nodes in the tree is in the range [0, 5000]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if a binary tree is height balanced.
A height-balanced binary tree is a binary tree in which the 
depth of the two subtrees of every node never differs by more than one.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive Post order - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Post order DFS computes height bottom-up
        # 2. At each node:
        #    - Compute left height
        #    - Compute right height
        #    - Check if balance condition holds: abs(left - right) <= 1
        # 3. Use -1 as sentinel to propagate imbalance early
        # Results: returns False immediately when imbalance is detected

        def dfs(node):
            if not node:
                return 0  # height
            
            left_height = dfs(node.left)
            if left_height == -1:
                return -1  # imbalance detected
            
            right_height = dfs(node.right)
            if right_height == -1:
                return -1  # imbalance detected
            
            if abs(left_height - right_height) > 1:
                return -1  # imbalance detected
            
            return 1 + max(left_height, right_height)
        
        return dfs(root) != -1
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive Post order with Tuple - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Post order DFS returns tuple: (is_balanced, height)
        # 2. Combines height + balance check without sentinel value
        # 3. Each call checks:
        #    - Left subtree balance
        #    - Right subtree balance
        #    - Current node balance
        # Results: cleaner return, same complexity
        
        def dfs(node):
            if not node:
                return True, 0  # (is_balanced, height)
            
            left_bal, left_height = dfs(node.left)
            if not left_bal:
                return False, 0
            
            right_bal, right_height = dfs(node.right)
            if not right_bal:
                return False, 0
            
            balanced = abs(left_height - right_height) <= 1
            return balanced, 1 + max(left_height, right_height)
        
        return dfs(root)[0]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 100. Same Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the roots of two binary trees p and q, write a function to
> check if they are the same or not.
> Two binary trees are considered the same if they are
> structurally identical, and the nodes have the same value.

|  Example Input           | Output |  
| ---------------- | ------ | 
| p = [1,2,3], q = [1,2,3] | true |
| p = [1,2], q = [1,null,2] | false |
| p = [1,2,1], q = [1,1,2] | false |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if two different binary trees match.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Pre order) - Tree/DFS Pre order Traversal
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # 1. DFS Pre order: Compare current node values, then recurse on children
        # 2. Base cases:
        #    - If both nodes are None => trees match at this branch
        #    - If one node is None or values mismatch => trees differ
        # 3. Recurse left and right; both must match
        
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative (Queue) - Tree/BFS Iterative Queue Based
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # 1. BFS: Compare trees level-by-level
        # 2. Use queue to store node pairs from p and q
        # 3. For each pair:
        #    - Both None => continue
        #    - One None or value mismatch => return False
        #    - Enqueue children in parallel
        # Results: Early termination if mismatch found
        
        queue = deque([(p, q)])
        
        while queue:
            node1, node2 = queue.popleft()
            
            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False
            
            queue.append((node1.left, node2.left))
            queue.append((node1.right, node2.right))
        
        return True
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 572. Subtree of Another Tree ::3:: - Easy

Topics:  Tree, Depth First Search, String Matching, Binary Tree, Hash Function

### Intro
> Given the roots of two binary trees root and subRoot, return true if 
> there is a subtree of root with the same structure and node values of 
> subRoot and false otherwise.
> A subtree of a binary tree tree is a tree that consists of a node in 
> tree and all of this node's descendants. The tree tree could also be
> considered as a subtree of itself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,4,5,1,2], subRoot = [4,1,2] | true |
| root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] | false |
 
Constraints:

The number of nodes in the root tree is in the range [1, 2000].

The number of nodes in the subRoot tree is in the range [1, 1000].

-10<sup>4</sup> &le; root.val &le; 10<sup>4</sup>

-10<sup>4</sup> &le; subRoot.val &le; 10<sup>4</sup>


### Abstraction
Determine binary tree tree2 is a subtree of binary tree tree1.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Pre order Traversal) - Tree/DFS Pre order Traversal
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. DFS Pre order traversal of `root`
        # 2. At each node in `root`:
        #    - Check if subtree matches starting here using helper isSameTree
        #    - Recurse to left and right
        # 3. Early exit if a match is found

        def isSameTree(s, t):
            if not s and not t:
                return True
            if not s or not t or s.val != t.val:
                return False
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)
        
        if not subRoot:
            return True
        if not root:
            return False
        
        if isSameTree(root, subRoot):
            return True
        
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative (Queue) - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. BFS level order traversal of `root`
        # 2. For each node:
        #    - If value matches subRoot root, run isSameTree
        # 3. Uses queue to iterate nodes iteratively

        def isSameTree(s, t):
            if not s and not t:
                return True
            if not s or not t or s.val != t.val:
                return False
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)

        if not subRoot:
            return True
        if not root:
            return False
        
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if node.val == subRoot.val and isSameTree(node, subRoot):
                return True
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: DFS + Serialization String Matching - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Use DFS preorder traversal to serialize both trees
        # 2. Each value is wrapped with a leading comma to prevent accidental partial matches
        #    (e.g., "2" in "12" would match incorrectly without boundaries)
        # 3. Compare serialized subRoot string as substring of root serialization
        # 4. If subRoot serialization is found in root serialization, subRoot is a subtree

        def serialize(node):
            if not node:
                return ",N"  # "N" represents None
            return f",{node.val}" + serialize(node.left) + serialize(node.right)

        return serialize(subRoot) in serialize(root)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |




