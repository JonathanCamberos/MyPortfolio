---
title: "LeetCode: Trees"
description: "trees"
image: "../../public/Notes/tree.png"
publishedAt: "2025-08-05"
updatedAt: "2025-08-05"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Tree Intro

### What is a Tree

Trees are hierarchical data structures representing relationships
between entities, often in a parent-child format.

### Tree Characteristics

Trees are a special type of graph, characterized by:

1. Nodes: The entities (ex: values, objects)

2. Edges: The connections between the entities. A tree with n nodes has n - 1 edges.

3. Root: The top-most node, with no parent

4. Leaves: Nodes with no children 

5. Height: The number of edges on the longest path from the root to a leaf

6. Depth: The number of edges from the root to a specific node

7. No Cycles: Trees do not contain cycles

8. Single Paths: Trees have exactly one path between any two nodes

```
      1
     / \
    2   3
       / \
      4   5
```

### Tree Representations

Trees can be represented in multiple formats:

1. Adjacency Matrix: Used for general trees or graphs

2. Parent Array: Store each child -> parent, in an array

3. Linked Node Structure: Common in Binary Trees (TreeNode with left and right)

For full notes on representations:
please see [graph representations](/Notesleetcode-graphs#graph-representations)

### Tree Math
Height of a perfect binary tree with n nodes: log(n+1)-1

Nodes in perfect binary tree of height h: 2^(h+1) -1

Max nodes at level l: 2^l

Edges = Nodes - 1

### Common Tree Types

1. Binary Tree:
Each node has at most two children left and right.
Most LeetCode problems use this form.

2. Binary Search Tree (BST):
Type of binary tree where: 
Left subtree val < Node val < Right subtree val

Allows efficient search, insertion, and deletion.

3. Balanced Binary Tree (AVL, Red-Black)
Type of binary tree where: 
Height difference (balance factor) is kept small,
ensuring the height stays O(log n).

This prevents BST from degrading to a linked list in worst case

4. Complete Binary Tree
Type of binary tree where: 
All levels are filled except possibly the last, which is filled from left to right.

5. Full Binary Tree
Type of binary tree where:
Each node has either 0 or 2 children

6. Perfect Binary Tree
Type of binary tree where:
All internal nodes have 2 children and all leaves are at the same level.

7. N-ary Tree
Type of tree where:
Each node can have up to N children

### Balanced Trees 
Balanced trees are binary search trees that maintain their height
close to O(log n) by rebalancing themselves during insertion() and deletion().

Without balancing, a BST can degrade to a linked list: height(O(n)) if the
elements are inserted in sorted order

This is done by limiting the height difference (balance factor) 
between left and right subtrees.

Common Balanced Trees:

1. AVL Tree:
Strict balancing. Balance factor at each node is in [-1, 0, 1]. 
Rotations restore balance after insert/delete

2. Red Black Tree:
Looser balancing with colour properties.
Guarantees height &leq; 2 * log(n+1)

3. B- Trees / B+ Trees:
Multi way balanced trees used in databases and filesystems
for efficient range queries

| Operation     | BST (Unbalanced) | Balanced BST |
|---------------|------------------|--------------|
| Search        | O(n)             | O(log n)     |
| Insert/Delete | O(n)             | O(log n)     |


### Tree Traversal Overview
Given a Tree, and the task to traverse it,
there a two fundamental search strategies that all others stem from. 

### Depth First Search Traversal (DFS)
Traversal Order: 
Goes as deep as possible before backtracking
(either recursively via function calls or iteratively via stack)

Can process in pre, in, or post order:

Pre: Root -> Left -> Right

In: Left -> Root -> Right

Post: Left -> Right -> Root

### Breadth First Search Traversal (BFS)
Traversal Order: 
Explores nodes level by level

Will queue nodes for next level, count how many exist, 
and process all nodes for that level by iterating 
exactly level_size times popping each from the queue, thus popping all 
nodes for a specific level.

### Specialized Traversals
- Morris Traversal:
In order traversal with O(1) extra space by temporarily modifying tree pointers.

- Threaded Binary Tree:
Uses null child pointers to store predecessor/successor pointers to enable O(1) traversal.

### Tree Search Rule of Thumb
Pre, In, Post, order traversal -> DFS (recursive usually, iterative stack based)

Level Order Traversal -> BFS (iterative) queue based

### Tree Application: DFS Pre Order Traversal Top Down
Traversal Order: Root -> Left -> Right.
Top Down: Root is processed immediately, then we move deeper.
Used when a node's work must be done before processing its children.

Ex: Serialize a Binary Tree Recursive and Iterative
```python
    def serializeRecursive(root: Optional[TreeNode]) -> str:
        
        def dfsPreOrder(node):

            # Base case: process leaf 
            if not node:
                vals.append("N")
                return
            
            # Process node (top-down work)
            vals.append(str(node.val))
            
            # Recursive call to process left and right subtree
            dfsPreOrder(node.left)
            dfsPreOrder(node.right)
        
        # serialized array
        vals = []

        # recursive call at root
        dfsPreOrder(root)

        # join serialized array
        return ",".join(vals)

    # Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS Pre Order Iterative Top Down
Traversal Order: Root -> Left -> Right.
Top Down: Root is processed immediately, then we move deeper.
Used when a node's work must be done before processing its children.

Ex: Serialize a Binary Tree Recursive and Iterative
```python
    def serializeIterative(root: Optional[TreeNode]) -> str:

        # Empty Check
        if not root:
            return "N"

        # iteration via stack
        stack = [root]

        # serialized array
        vals = []
        
        while stack:

            # pop: Last In First Out
            # leads to deep search (dfs)
            currRoot = stack.pop()

            # process node
            if currRoot:

                # process node (top-down work)
                vals.append(str(currRoot.val))
                
                # push to stack, for iterative process left and right
                stack.append(currRoot.right)
                stack.append(currRoot.left)
            
            # process leaf
            else:
                vals.append("N")
        
        # join serialized array
        return ",".join(vals)

    # Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS In Order Recursive Mid Point
Traversal Order: Left -> Root -> Right
Mid Point: Left is processed, then Root, followed by Right 
Used when a node's work must be done after visiting the left subtree
but before visiting the right subtree.

Ex: Convert BST to Sorted List Recursive and Validate BST Iterative
```python
    def bstToSortedList(root: Optional[TreeNode]) -> List[int]:
        
        # tracks previous value
        prev_val = float("-inf")
            
        def dfsInOrder(node):
            nonlocal prev_val
            
            # Base case: leaf -> no value
            if not node:
                return True
            
            # recursive call to process left subtree
            if not dfsInOrder(node.left):
                return False
            
            # process node (mid-point work)
            if node.val <= prev_val:
                return False

            # set to current value
            prev_val = node.val
            
            # recursive call to process right subtree
            return dfsInOrder(node.right)
        
        # recursive call on root
        return dfsInOrder(root)

        # Tree:
        #       2
        #      / \
        #     1   3
        # isValidBST -> True
```

### Tree Application: DFS In Order Iterative Mid Point
Traversal Order: Left -> Root -> Right
Mid Point: Left is processed, then Root, followed by Right 
Used when a node's work must be done after visiting the left subtree
but before visiting the right subtree.

Ex: Convert BST to Sorted List Recursive and Validate BST Iterative
```python
    def isValidBST(root: Optional[TreeNode]) -> bool:
        
        # tracks previous value
        prev_val = float("-inf")

        # iteration via stack
        stack = [] 

        # pointer to check for empty case
        curr = root
        
        while stack or curr:
            
            # traverse left subtree of curr:
            # will go as far left as possible
            while curr: 
                # continue traversal down left subtree
                stack.append(curr)
                curr = curr.left
            
            # Exited loop: 
            # reached 'leaf' of left subtree
            #     L
            #  /     \ 
            # leaf    ?
                        
            # process left, node, right:
            # via previous left subtree node 'L' from stack
            curr = stack.pop()

            # validate
            if curr.val <= prev_val:
                return False

            # set to current value
            prev_val = curr.val
            
            # traverse right subtree
            # (which we thus explore left, node and right subtrees again)
            #     L
            #  /     \ 
            # leaf    *here*
            curr = curr.right
        
        return True

    # Tree:
    #       2
    #      / \
    #     1   3
    # isValidBST -> True
```

### Tree Application: DFS Post Order Recursive Bottom Up
Traversal Order: Left -> Right -> Root
Bottom Up: Left and Right children are processed, followed by Root
Useful when a node's work depends on fully processed children. 

Ex: Evaluate Expression Tree Recursive and Delete Tree Iterative
```python
    def diameterOfBinaryTree(root: Optional[TreeNode]) -> int:
        
        # global diameter
        diameter = 0

        def dfs(node):
            nonlocal diameter

            # Base case:
            # no width added
            if not node:
                return 0

            # recursive call to process left and right
            left = dfs(node.left)
            right = dfs(node.right)

            # process node
            diameter = max(diameter, left + right)

            # pass width upwards
            return 1 + max(left, right)

        # recursive on root
        dfs(root)

        # return global diameter
        return diameter

    # Tree:
    #         1
    #        / \
    #       2   3
    #      / \
    #     4   5
    # diameterOfBinaryTree -> 3
```

### Tree Application: DFS Post Order Iterative Bottom Up
Traversal Order: Left -> Right -> Root
Bottom Up: Left and Right children are processed, followed by Root
Useful when a node's work depends on fully processed children. 

Ex: Evaluate Expression Tree Recursive and Delete Tree Iterative
```python
    def diameterOfBinaryTree(root: Optional[TreeNode]) -> int:

        # Empty check
        if not root:
            return 0

        # global width
        diameter = 0

        # iterative stack
        stack = []

        # 
        curr = root
        lastVisited = None
        depth_map = defaultdict(int)

        while stack or curr:

            # traverse left subtree of curr:
            # will go as far left as possible
            while curr:
                stack.append(curr)
                curr = curr.left

            # check if right subtree exists
            peek = stack[-1]

            # if right subtree exists and hasn't been visited
            if peek.right and lastVisited != peek.right:
                node = peek.right

            # process node
            else:
                stack.pop()

                # grab width of left and right subtree if exists
                left_depth = depth_map.get(peek.left, 0)
                right_depth = depth_map.get(peek.right, 0)

                # node diameter
                diameter = max(diameter, left_depth + right_depth)

                # store node diameter
                depth_map[peek] = 1 + max(left_depth, right_depth)

                # set last visited to current node
                lastVisited = peek

        # return width
        return diameter

    # Tree:
    #         1
    #        / \
    #       2   3
    #      / \
    #     4   5
    # diameterOfBinaryTree -> 3 (path: 4 → 2 → 5 or 4 → 2 → 1 → 3)
```


### Tree Application: BFS Iterative Level Size Based Grouping Processing
Traversal Order: Level by Level
BFS visits nodes level by level, processing all nodes at a given depth 
before moving on to the next.
Used for level order problems and shortest path calculations in unweighted graphs,
as well as scenarios requiring nodes in order of distance from the root.

Ex: Level order traversal of Binary Tree
```python
    def levelOrderIterative(root: Optional[TreeNode]) -> List[List[int]]:
        
        # Empty check
        if not root:
            return []

        group = []

        # start with group 1: root
        queue = deque([root])

        while queue:

            # grab size of curr level
            size = len(queue)
            level = []

            # process entire level
            for _ in range(size):

                # grab node of group
                node = queue.popleft()
                level.append(node.val)

                # append next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # add level group to list of groups
            groups.append(level)

        # return all level groups
        return groups

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: [[1], [2, 3], [4, 5]]
```

### Tree Application: BFS Iterative No Explicit Level Sized Grouping Processing
Traversal Order: Level by Level
BFS visit nodes in breath first order.
However, in some problems we don't process or store the full level at once.
Instead we act on nodes individually or in partial groupings (pairs, linked neighbors, etc)

Ex: Invert a Binary Tree
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        # start at root
        queue = deque([root])
        
        while queue:

            # grab nodes sequentially
            node = queue.popleft()
            
            # process node
            node.left, node.right = node.right, node.left
            
            # process left and right subtrees by appending to queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return root

        # Example:
        # Input Tree:
        #       4
        #      / \
        #     2   7

        # Output Tree:
        #       4
        #      / \
        #     7   2
```

### Tree Application: BFS Iterative Distance from Root
Traversal Order: Level by Level
Distance Tracking: Each level corresponds to one distance step from the root.
Used when the problem depends on minimum, maximum or some count depth.

Ex: Minimum Depth of a Binary Tree
```python
    def minDepth(root: Optional[TreeNode]) -> int:
        from collections import deque
        
        # Empty Tree
        if not root:
            return 0
        
        # initialize depth value
        queue = deque([(root, 1)])
        
        while queue:
            
            # grab current depth, increase to children
            node, depth = queue.popleft()
            
            # first leaf found -> min depth 
            if not node.left and not node.right:
                return depth
            
            # iterate to left and right subtrees with updated depth
            if node.left:
                queue.append((node.left, depth + 1))
            if node.right:
                queue.append((node.right, depth + 1))
```


### Tree Application: BFS Iterative Non-Standard Level Traversal
Traversal Order: Level by Level (but with non default ordering such as reversed, zigzag, or other patterns)
Used when the traversal order of nodes at each level must follow a specific 
non standard pattern

Ex: Binary Tree Zigzag Level Order Traversal
```python
    def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]:
        
        # Empty Tree
        if not root:
            return []
        
        groups = []

        # iteration stack
        queue = deque([root])

        # order toggle
        left_to_right = True
        
        while queue:

            # for each level
            size = len(queue)
            level = deque()
            
            # Process all nodes in current level
            for _ in range(size):
                node = queue.popleft()
                
                # append order based on pattern
                if left_to_right:
                    level.append(node.val)
                else:
                    level.appendleft(node.val)
                
                # iterate by appending left and right subtrees
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            # flip order for next level
            left_to_right = not left_to_right  

            # add to groups            
            groups.append(list(level))

        return groups

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #    / \   \
    #   4   5   6

    # Output: [[1], [3, 2], [4, 5, 6]]
```

## 226. Invert Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the root of a binary tree, invert the tree, and return its root.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [4,2,7,1,3,6,9] | [4,7,2,9,6,3,1] |
| root = [2,1,3] | [2,3,1] |
| root = [] | [] |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-100 &le; Node.val &le; 100

### Abstraction
Invert the binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive - Tree/DFS Post Order Traversal
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: DFS recursive approach inverts subtrees from bottom up (postorder)
        # 1. Base case: return None if node is null
        # 2. Left -> Right: Recursively invert subtree
        # 3. Root: Swap left and right children
        # Result: Original tree has been inverted

        # Base case:
        # reached empty TreeNode
        if not root:
            return None

        # Process Left + Right:
        # Recursive calls to invert the left and right subtrees
        left_inverted = self.invertTree(root.left)
        right_inverted = self.invertTree(root.right)

        # Process Root:
        # Swap left and right children
        root.left = right_inverted
        root.right = left_inverted

        # overall: time complexity O(n)
        # overall: space complexity O(h), O(log n) for balanced tree
        return root
```

### Solution 2: BFS Iterative - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: BFS iterative approach inverts nodes level by level
        # 1. Queue stores nodes to process
        # 2. While Queue is non empty
        # 3. Process Root: 
        #    Pop() from queue 
        #    Swap left and right children
        #    Push() left and right children to queue for processing
        # Result: Tree reverse in place
        
        # Empty tree check
        if not root:
            return None
        
        # dfs Queue:
        queue = deque([root])
        
        # queue hold nodes to be processed
        # time complexity: iterate over tree by queuing nodes, level by level O(n)
        while queue:

            # Grab Root:
            # pop() from queue -> curr root
            currRoot = queue.popleft()
            
            # Process Root:
            # Swap left and right children
            currRoot.left, currRoot.right = currRoot.right, currRoot.left
            
            # Process Left and Right subtrees:
            # add left and right to dfs queue
            if currRoot.left:
                queue.append(currRoot.left)
            if currRoot.right:
                queue.append(currRoot.right)
        
        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 104. Maximum Depth of Binary Tree ::3:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> A binary tree's maximum depth is the number of nodes along 
> the longest path from the root node down to the farthest leaf node.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | 3 |
| root = [1,null,2] | 2 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the max depth of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Post Order Recursive Bottom Up Children Depth - Tree/DFA Post Order Traversal
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # DFS post order traversal: left -> right -> root
        # 1. Process depth of left and right subtrees
        # 2. Process node by grabbing max(left, right)
        # Result: max depth of tree
        
        # Base case:
        # leaf -> depth of 0
        if not root:
            return 0
        
        # process left and right children
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        
        # process root
        return 1 + max(left_depth, right_depth)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: DFS Pre Order Iterative Carry Down Depth Val - Tree/DFA Pre Order Traversal
```python
    # Note:
    # DFS pre order iterative: root -> left -> right
    # 1. Each stack entry stores (node, current depth)
    # 2. Update max_depth when visiting each node
    # 3. Works like Post order — compute children before root aggregation
    # Result: deepest level updated global counter -> max depth
    
    # Empty check
    if not root:
        return 0
    
    # iterative stack
    stack = [(root, 1)]

    # global depth
    max_depth = 0
    
    while stack:

        # process node
        node, depth = stack.pop()

        # non leaf node
        if node:

            # update maximum depth
            max_depth = max(max_depth, depth)
            
            # process left and right subtrees
            stack.append((node.left, depth + 1))
            stack.append((node.right, depth + 1))
    
    # overall: time complexity
    # overall: space complexity
    return max_depth
```

### Solution 3: BFS Iterative Count By Level Width - Tree/BFS Iterative Full Level Processing
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # BFS iterative: count number of levels
        # 1. Queue will store nodes in current level
        # 2. For each level:
        #      process all nodes
        #      add next level to queue
        #      add to global depth counter after processing full level
        # Result: number of levels -> max depth
        
        # Empty check
        if not root:
            return 0
        
        # iterative stack
        queue = deque([root])

        # global depth
        depth = 0
        
        while queue:

            # curr level size
            size = len(queue)
            for _ in range(size):

                # process all nodes in level
                node = queue.popleft()

                # append next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # finished processing level, add to depth counter
            depth += 1
        
        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return depth
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 543. Diameter of Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given the root of a binary tree, return the length of the diameter of the tree.
> The diameter of a binary tree is the length of the longest path between any 
> two nodes in a tree. This path may or may not pass through the root.
> The length of a path between two nodes is represented by the number of
> edges between them. 

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3,4,5] | 3 |
| root = [1,2] | 1 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the diameter of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Post Order Recursive Global Diameter - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # DFS post order: left -> right -> root
        # 1. Process left and right subtrees width
        # 2. Process node by max(left width, right width)
        # Result: longest path in terms of edges between any two nodes

        diameter = 0
        
        def dfs(node):
            nonlocal diameter

            # Base case:
            # no width added
            if not node:
                return 0
            
            # Heights/Length of left and right subtrees
            left_len = dfs(node.left)
            right_len = dfs(node.right)
            
            # check final diameter connecting left and right subtrees
            diameter = max(diameter, left_len + right_len)

            # continue longer subtree upwards for potential longer diameter
            add_edge = 1 + max(left_len, right_len)

            return add_edge
        
        # recursive call on root
        dfs(root)

        # overall: time complexity
        # overall: space complexity
        return diameter
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive Optimized Passed Tuple Diameter - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # DFS post order: left -> right -> root
        # 1. Process left and right subtrees width
        # 2. Process node by max(left width, right width)
        # Result: longest path in terms of edges between any two nodes
        
        def dfs(node):

            # Base case:
            # no width added
            if not node:
                return 0, 0
            
            # recursive call to process left and right subtrees
            # grab longest diameter for each subtree
            left_len, left_diameter = dfs(node.left)
            right_len, right_diameter = dfs(node.right)
            
            # Diameter at this node connected left and right subtrees length
            curr_diam = left_len + right_len
            
            # max diameter between curr node, left subtree, and right subtree
            max_diam = max(curr_diam, left_diameter, right_diameter)
            
            # continue longer subtree upwards for potential longer diameter
            add_edge = 1 + max(left_len, right_len)
            
            return (add_edge, max_diam)
        
        return dfs(root)[1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 110. Balanced Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given a binary tree, determine if it is height-balanced. 
> A height-balanced binary tree is a binary tree in which the depth 
> of the two subtrees of every node never differs by more than one.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | true |
| root = [1,2,2,3,3,null,null,4,4] | false |
| root = [] | true |
 
Constraints:

The number of nodes in the tree is in the range [0, 5000]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if a binary tree is height balanced.
A height-balanced binary tree is a binary tree in which the 
depth of the two subtrees of every node never differs by more than one.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive Post order - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # DFS post order: left -> right -> root
        # 1. At each node:
        #    process left and right subtrees
        #    validate balance: abs(left - right) <= 1
        # 2. Throw -1 imbalance error
        # Results: detect imbalance

        def dfs(node):

            # Base case:
            # start adding height upwards
            if not node:
                return 0
            
            # recursive call to process left and right subtrees
            left_height = dfs(node.left)
            right_height = dfs(node.right)

            # pass imbalance upwards
            if left_height == -1:
                return -1         
            if right_height == -1:
                return -1
            
            # process node by checking for imbalance between left and right subtrees
            if abs(left_height - right_height) > 1:
                return -1
            
            # add to height and pass up
            return 1 + max(left_height, right_height)
        
        # check if any imbalance error pass upwards

        # overall: time complexity
        # overall: space complexity
        return dfs(root) != -1
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive Post order with Tuple - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # DFS post order: left -> right -> root
        # 1. At each node:
        #    process left and right subtrees
        #    validate balance: abs(left - right) <= 1
        # 2. Throw -1 imbalance error
        # Results: detect imbalance
        
        def dfs(node):

            # Base case: leaf -> balanced:true, height:0
            if not node:
                return (True, 0)
            
            # recursive call to process left and right subtrees:
            # is_balanced, height 
            (left_bal, left_height) = dfs(node.left)
            (right_bal, right_height) = dfs(node.right)

            # continue propagating error up
            if not left_bal:
                return False, 0
            if not right_bal:
                return False, 0
            
            # process node: validate balance
            balanced = abs(left_height - right_height) <= 1

            # continue propagating result up
            return (balanced, 1 + max(left_height, right_height))
        
        # overall: time complexity
        # overall space complexity
        return dfs(root)[0]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 100. Same Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the roots of two binary trees p and q, write a function to
> check if they are the same or not.
> Two binary trees are considered the same if they are
> structurally identical, and the nodes have the same value.

|  Example Input           | Output |  
| ---------------- | ------ | 
| p = [1,2,3], q = [1,2,3] | true |
| p = [1,2], q = [1,null,2] | false |
| p = [1,2,1], q = [1,1,2] | false |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if two different binary trees match.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Pre Order Recursive - Tree/DFS Pre order Traversal
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # DFS pre order recursive: root -> left -> right
        # 2. Process node:
        #    if both nodes are 'None' -> trees match
        #    if only one node is 'None' -> trees differ
        #    if values mismatch -> trees differ
        # 3. Process left and right subtrees
        # Result: determine is trees match
        
        # Process node: validate match

        # Base case: both nodes are 'None'
        if not p and not q:
            return True

        # Base case: only one node is 'None' -> trees differ
        if not p or not q:
            return False

        # Base case: node values differ -> trees differ
        if p.val != q.val:
            return False
        
        # Recursive call to process left and right subtrees:
        match = (self.isSameTree(p.left, q.left) and 
                self.isSameTree(p.right, q.right))

        # propagate upwards
        return match
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative - Tree/BFS Iterative Queue Based
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # BFS Iterate: level by level
        # 1. Queue will store nodes from both trees
        # 2. Process node:
        #    Pop pair of elements
        #    if both nodes are 'None' -> trees match
        #    if only one node is 'None' -> trees differ
        #    if values mismatch -> trees differ
        # 3. Process next level
        # Result: determine is trees match
        
        # iterative stack
        queue = deque([(p, q)])
        
        while queue:

            # tree node pairs
            node1, node2 = queue.popleft()
            
            # Base case: both nodes are 'None'
            if not node1 and not node2:
                continue
            
            # Base case: node values differ -> trees differ
            if not node1 or not node2
                return False
            
            # Base case: node values differ -> trees differ
            if node1.val != node2.val:
                return False
            
            # add next level pairs
            queue.append((node1.left, node2.left))
            queue.append((node1.right, node2.right))
        
        # trees match

        # overall: time complexity
        # overall: space complexity
        return True
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 572. Subtree of Another Tree ::3:: - Easy

Topics:  Tree, Depth First Search, String Matching, Binary Tree, Hash Function

### Intro
> Given the roots of two binary trees root and subRoot, return true if 
> there is a subtree of root with the same structure and node values of 
> subRoot and false otherwise.
> A subtree of a binary tree tree is a tree that consists of a node in 
> tree and all of this node's descendants. The tree tree could also be
> considered as a subtree of itself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,4,5,1,2], subRoot = [4,1,2] | true |
| root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] | false |
 
Constraints:

The number of nodes in the root tree is in the range [1, 2000].

The number of nodes in the subRoot tree is in the range [1, 1000].

-10<sup>4</sup> &le; root.val &le; 10<sup>4</sup>

-10<sup>4</sup> &le; subRoot.val &le; 10<sup>4</sup>


### Abstraction
Determine binary tree tree2 is a subtree of binary tree tree1.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Pre Order Recursive - Tree/DFS Pre order Traversal
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # DFS pre order: root -> left -> right
        # 1. Process node
        #    Check if subtree matches isSameTree()
        # 2. Process left and right subtrees
        # Result: validate if match found

        # same as above
        def isSameTree(s, t):
            # Base case: 
            # leaf -> node match
            if not s and not t:
                return True

            # no match: propagate upwards
            if not s or not t:
                return False
            if s.val != t.val:
                return False
            
            # process subtrees
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)
        
        # Empty check:
        # empty subRoot is always a subtree
        if not subRoot:
            return True

        # Empty check:
        # empty root cannot have subtrees
        if not root:
            return False
        
        # recursive call over root and subRoot
        if isSameTree(root, subRoot):
            return True
        
        # process root left and right subtrees
        match = self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot) 

        return match
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # BFS order: level by level
        # 1. For each node:
        #    - If value matches subRoot root, run isSameTree
        # 3. Uses queue to iterate nodes iteratively

        def isSameTree(s, t):

            # Base case: leaf -> match
            if not s and not t:
                return True

            # no longer match: propagate error upwards
            if not s or not t:
                return False  
            if s.val != t.val:
                return False
            
            # validate subtrees
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)

        # Empty check:
        # empty subRoot is always a subtree
        if not subRoot:
            return True

        # Empty check:
        # empty root cannot have subtrees
        if not root:
            return False
        
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if node.val == subRoot.val and isSameTree(node, subRoot):
                return True
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: DFS + Serialization String Matching - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # DFS pre order: root -> left -> right
        # 1. Node values with leading comma
        #    ("2" in "12" would match incorrectly without boundaries)
        # 2. Check if serialized subRoot is substring of serialized root
        # Result: checks if tree is subtree

        def serialize(node):
            if not node:
                return ",N"  # "N" represents None
            return f",{node.val}" + serialize(node.left) + serialize(node.right)

        serializedSubRoot = serialize(subRoot)
        serializedRoot = serialize(root)

        return serializedSubRoot in serializedRoot
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 235. Lowest Common Ancestor of a Binary Search Tree ::2:: - Medium

Topics:  Tree, Depth First Search, Binary Search Tree, Binary Tree

### Intro
> Given a binary search tree (BST), find the lowest common 
> ancestor (LCA) node of two given nodes in the BST.
> According to the definition of LCA on Wikipedia: 
> “The lowest common ancestor is defined between
> two nodes p and q as the lowest node in T that has both p and q as descendants 
> (where we allow a node to be a descendant of itself).”

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 | 6 |
| root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 | 2 |
| root = [2,1], p = 2, q = 1 | 2 |
 
Constraints:

The number of nodes in the root tree is in the range [1, 10<sup>5</sup>].

-10<sup>4</sup> &le; root.val &le; 10<sup>4</sup>

All Node.val are unique.

p != q

p and q will exist in the BST.

### Abstraction
Find lowest node that has both p and q in their subtree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive BST Traversal  - Tree/DFS Pre order Traversal
```python
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        
        # Note:
        # continue traversing down left and irght subtrees to find 
        
        # p and q are smaller -> LCA is in left subtree
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)

        # p and q are smaller -> LCA is in right subtree
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        
        # p and q are in different subtrees -> current node is LCA
        else:
            return root

        # overall: time complex
        # overall: space complex
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Iterative BST Traversal  - Tree/DFS Pre order Traversal
```python
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        
        curr = root
        while curr:

            # p and q are smaller -> LCA is in left subtree
            if p.val < curr.val and q.val < curr.val:
                curr = curr.left  # Both on left

            # p and q are larger -> LCA is in right subtree
            elif p.val > curr.val and q.val > curr.val:
                curr = curr.right

            # p and q are in different subtrees -> current node is LCA
            else:
                return curr
        
        # overall: time complex
        # overall: space complex
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 102. Binary Tree Level Order Traversal ::2:: - Medium

Topics:  Tree, Breadth First Search, Binary Tree

### Intro
> Given the root of a binary tree, return the level order traversal 
> of its nodes' values. (i.e., from left to right, level by level).


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | [[3],[9,20],[15,7]] |
| root = [1] | [[1]] |
| root = [] | [] |
 
Constraints:

The number of nodes in the root tree is in the range [1, 2000].

-1000 &leq; Node.val &leq; 1000

### Abstraction
Traverse a tree and return list of nodes grouped by level.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: BFS Iterative - Tree/DFS Pre order Traversal
```python
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        
        # Empty check
        if not root:
            return []
        
        groups = []
        queue = deque([root])  # start with root
        
        while queue:
            # grab size of current level
            size = len(queue)
            level = []
            
            # process each node in this level
            for _ in range(size):
                node = queue.popleft()
                level.append(node.val)
                
                # enqueue children for next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            groups.append(level)
        
        return groups
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Pre Order Recursive - Tree/DFS Pre order Traversal
```python
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        
        groups = []
        
        def dfs(node, depth):
            if not node:
                return
            
            # expand groups list if new depth reached
            if len(groups) == depth:
                groups.append([])
            
            groups[depth].append(node.val)
            
            # recurse left and right children
            dfs(node.left, depth + 1)
            dfs(node.right, depth + 1)
        
        dfs(root, 0)
        return groups
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 199. Binary Tree Right Side View ::2:: - Medium

Topics:  Tree, Breadth First Search, Binary Tree

### Intro
> Given the root of a binary tree, imagine yourself standing on 
> the right side of it, return the values of the nodes you can 
> see ordered from top to bottom.


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3,null,5,null,4] | [1,3,4] |
| root = [1,2,3,4,null,null,null,5] | [1,3,4,5] |
| root = [1,null,3] | [1,3] |
| root = [] | [] |
 
Constraints:

The number of nodes in the root tree is in the range [1, 100].

-100 &leq; Node.val &leq; 100

### Abstraction
Given a tree, if you were to stand on the right side, return all nodes
that you would have a direct line of sight to (not hidden by right-er nodes)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: BFS Iterative - Tree/DFS Pre order Traversal
```python
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            for i in range(level_size):
                node = queue.popleft()
                # If this is the last node in the current level, capture it
                if i == level_size - 1:
                    result.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        
        return result

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Pre Order Right-to-Left First Depth Capture  - Tree/DFS Pre order Traversal
```python
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        
        result = []
        
        def dfs(node, depth):
            if not node:
                return
            # If visiting this depth for the first time, this is the rightmost node
            if depth == len(result):
                result.append(node.val)
            dfs(node.right, depth + 1)  # Prioritize right child
            dfs(node.left, depth + 1)   # Then left child
        
        dfs(root, 0)
        return result

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 1448. Count Good Nodes in Binary Tree ::2:: - Medium

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given a binary tree root, a node X in the tree is  
> named good if in the path from root to X there are no nodes 
> with a value greater than X.
> Return the number of good nodes in the binary tree.


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,1,4,3,null,1,5] | 4 |
| root = [3,3,null,4,2] | 3 |
| root = [1] | 1 |
 
Constraints:

The number of nodes in the root tree is in the range [1, 10<sup>5</sup>].

Each node's value is between [-10<sup>4</sup>, 10<sup>4</sup>]

### Abstraction
Given a tree, a node is good if in the path between itself and the root
there is no node that is larger than it.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: BFS Iterative - Tree/DFS Pre order Traversal
```python
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, max_so_far):
            if not node:
                return 0
            
            # A node is good if its value is >= max_so_far seen so far
            good = 1 if node.val >= max_so_far else 0
            
            # Update max value along the path
            new_max = max(max_so_far, node.val)
            
            # Recurse on left and right children
            good += dfs(node.left, new_max)
            good += dfs(node.right, new_max)
            
            return good
        
        return dfs(root, root.val)

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Pre Order Right-to-Left First Depth Capture  - Tree/DFS Pre order Traversal
```python
    def goodNodes(self, root: TreeNode) -> int:
        count = 0
        queue = deque([(root, root.val)])  # (node, max_so_far)
        
        while queue:
            node, max_so_far = queue.popleft()
            
            if node.val >= max_so_far:
                count += 1
            
            new_max = max(max_so_far, node.val)
            
            if node.left:
                queue.append((node.left, new_max))
            if node.right:
                queue.append((node.right, new_max))
        
        return count

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 98. Validate Binary Search Tree ::2:: - Medium

Topics:  Tree, Depth First Search, Binary Search Tree, Binary Tree

### Intro
> Given the root of a binary tree, determine if it is a 
> valid binary search tree (BST).
> The left subtree of a node contains only nodes with 
> keys strictly less than the node's key.
> The right subtree of a node contains only nodes with keys 
> strictly greater than the node's key.
> Both the left and right subtrees must also be binary search trees.


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [2,1,3] | true |
| root = [5,1,4,null,null,3,6] | false |
 
Constraints:

The number of nodes in the root tree is in the range [1, 10<sup>4</sup>].

-2<sup>31</sup> &leq; Node.val &leq; 2<sup>31</sup>-1

### Abstraction
Given a tree, determine if tree is a valid BST. Where value of nodes
is always: left.val &leq; root.val &leq; right.val 

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS with Range Limits - Tree/DFS Pre order Traversal
```python
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # Helper DFS function with valid value range constraints
        def dfs(node, low, high):
            if not node:
                return True  # Reached leaf, no violations

            # If current node violates BST property -> invalid
            if not (low < node.val < high):
                return False

            # Left subtree must have values < node.val
            # Right subtree must have values > node.val
            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)

        # Start with infinite bounds
        return dfs(root, float('-inf'), float('inf'))

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Pre Order Right-to-Left First Depth Capture  - Tree/DFS Pre order Traversal
```python
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.prev = None  # Stores last visited node value

        def inorder(node):
            if not node:
                return True

            # Inorder: Left -> Node -> Right
            if not inorder(node.left):
                return False

            # Current node must be greater than previous inorder value
            if self.prev is not None and node.val <= self.prev:
                return False
            self.prev = node.val

            return inorder(node.right)

        return inorder(root)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 230. Kth Smallest Element in a BST ::2:: - Medium

Topics:  Tree, Depth First Search, Binary Search Tree, Binary Tree

### Intro
> Given the root of a binary search tree, and an integer k,
> return the kth smallest value (1-indexed) of 
> all the values of the nodes in the tree.
> Follow up: If the BST is modified often (i.e., we can do insert and
> delete operations) and you need to find the kth smallest frequently,
> how would you optimize?


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,1,4,null,2], k = 1 | 1 |
| root = [5,3,6,2,4,null,null,1], k = 3 | 3 |
 
Constraints:

The number of nodes in the root tree is n 

1 &leq; k &leq; n &leq; 10<sup>4</sup>

0 &leq; Node.val &leq; 10<sup>4</sup>

### Abstraction
Given a BST, find the kth smallest node. 

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: In Order Traversal Early Stop  - Tree/DFS Pre order Traversal
```python
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.k = k
        self.result = None
        
        def inorder(node):
            if not node or self.result is not None:
                return
            
            inorder(node.left)
            
            self.k -= 1
            if self.k == 0:
                self.result = node.val
                return
            
            inorder(node.right)
        
        inorder(root)
        return self.result

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Pre Order Right-to-Left First Depth Capture  - Tree/DFS Pre order Traversal
```python
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        stack = []
        while True:
            while root:
                stack.append(root)
                root = root.left
            
            root = stack.pop()
            k -= 1
            if k == 0:
                return root.val
            
            root = root.right
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: DFS Pre Order Right-to-Left First Depth Capture  - Tree/DFS Pre order Traversal
```python
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # Postorder: compute size of subtree, and store left subtree size
        def compute_sizes(node):
            if not node:
                return 0
            left_size = compute_sizes(node.left)
            right_size = compute_sizes(node.right)
            # attach attribute to the node instance
            node.left_count = left_size
            return left_size + right_size + 1

        compute_sizes(root)

        # Now query using left_count (no recursion needed)
        node = root
        while node:
            left_count = getattr(node, "left_count", 0)
            if k == left_count + 1:
                return node.val
            elif k <= left_count:
                node = node.left
            else:
                k -= (left_count + 1)
                node = node.right

        return None  # not reached if 1 <= k <= n
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 105. Construct Binary Tree from Preorder and Inorder Traversal ::2:: - Medium

Topics:  Array, Hash Table, Divide and Conquer, Tree, Binary Tree

### Intro
> Given two integer arrays pre order and in order where 
> pre order is the pre order traversal of a binary tree and 
> inorder is the inorder traversal of the same tree, 
> construct and return the binary tree.


|  Example Input           | Output |  
| ---------------- | ------ | 
| preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] | [3,9,20,null,null,15,7] |
| preorder = [-1], inorder = [-1] | [-1] |
 
Constraints:

1 &leq; preorder.length &leq; 3000

inorder.length == preorder.length

-3000 &leq; preorder[i], inorder[i] &leq; 3000

Each value or inorder also appears in preorder.

preorder is guaranteed to be the preorder traversal of the tree.

inorder is guaranteed to be the inorder traversal of the tree.

### Abstraction
Create original free given pre and post order traversals.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive Build with Hash Map  - Tree/DFS Pre order Traversal
```python
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # Step 1: Map each value to its index in inorder for O(1) lookups
        inorder_index_map = {val: idx for idx, val in enumerate(inorder)}

        # Step 2: Preorder index pointer (to track root positions)
        self.pre_idx = 0

        def array_to_tree(left, right):
            # Base case: no elements to construct the subtree
            if left > right:
                return None

            # Step 3: Get root value from preorder
            root_val = preorder[self.pre_idx]
            self.pre_idx += 1

            # Create the root node
            root = TreeNode(root_val)

            # Step 4: Recursively build left & right subtrees
            root.left = array_to_tree(left, inorder_index_map[root_val] - 1)
            root.right = array_to_tree(inorder_index_map[root_val] + 1, right)

            return root

        # Step 5: Build the tree from full range
        return array_to_tree(0, len(inorder) - 1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative Using Stack - Tree/DFS Pre order Traversal
```python
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        
        root = TreeNode(preorder[0])
        stack = [root]
        inorder_index = 0
        
        for i in range(1, len(preorder)):
            node = stack[-1]
            preorder_val = preorder[i]
            
            # If the last node in stack is not equal to current inorder,
            # then the next preorder value is in the left subtree.
            if node.val != inorder[inorder_index]:
                node.left = TreeNode(preorder_val)
                stack.append(node.left)
            else:
                # Otherwise, pop nodes from the stack while the node's value
                # matches inorder and move inorder_index forward.
                while stack and stack[-1].val == inorder[inorder_index]:
                    node = stack.pop()
                    inorder_index += 1
                
                # The next preorder value is the right child of the last popped node
                node.right = TreeNode(preorder_val)
                stack.append(node.right)
        
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 124. Binary Tree Maximum Path Sum ::1:: - Hard

Topics:  Dynamic Programming, Tree, Depth First Search, Binary Tree

### Intro
> A path in a binary tree is a sequence of nodes where each pair of 
> adjacent nodes in the sequence has an edge connecting them. A 
> node can only appear in the sequence at most once. Note that 
> the path does not need to pass through the root.
> The path sum of a path is the sum of the node's values in the path.
> Given the root of a binary tree, return the maximum path sum of 
> any non-empty path.


|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3] | 6 |
| root = [-10,9,20,null,null,15,7] | 42 |
 
Constraints:

The number of nodes in the tree is in the range [1, 3 * 10<sup>4</sup>]

-1000 &leq; Node.val &leq; 1000

### Abstraction
Given a tree, find the path that produces the max sum.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Post-Order + Global Max Tracker  - Tree/DFS Pre order Traversal
```python
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        max_sum = float('-inf')

        def dfs(node):
            nonlocal max_sum

            if not node:
                return 0

            # Get max gain from left and right subtree; ignore negative gains by max with 0
            left_gain = max(dfs(node.left), 0)
            right_gain = max(dfs(node.right), 0)

            # Current max path including both children and current node
            current_path_sum = node.val + left_gain + right_gain

            # Update global max sum if current path is better
            max_sum = max(max_sum, current_path_sum)

            # Return max gain to parent (single path)
            return node.val + max(left_gain, right_gain)

        dfs(root)
        return max_sum
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 297. Serialize and Deserialize Binary Tree ::2:: - Hard

Topics:  String, Tree, Depth First Search, Breadth First Search, Design, Binary Tree

### Intro
> Serialization is the process of converting a data structure or 
> object into a sequence of bits so that it can be stored in a file 
> or memory buffer, or transmitted across a network connection 
> link to be reconstructed later in the same or another computer environment.
> Design an algorithm to serialize and deserialize a binary tree. 
> There is no restriction on how your serialization/deserialization 
> algorithm should work. You just need to ensure 
> that a binary tree can be serialized to a string and this string 
> can be deserialized to the original tree structure.
> Clarification: The input/output format is the same as
> how LeetCode serializes a binary tree. ou do not necessarily need 
> to follow this format, so please be creative and come up with 
> different approaches yourself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3,null,null,4,5] | [1,2,3,null,null,4,5] |
| root = [] | [] |
 
Constraints:

The number of nodes in the tree is in the range [1, 10<sup>4</sup>]

-1000 &leq; Node.val &leq; 1000

### Abstraction
Create a serialize and deserialize functions for trees

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: iterative
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Post-Order + Global Max Tracker  - Tree/DFS Pre order Traversal
```python
class Codec:

    def serialize(self, root):
        vals = []

        def dfs(node):
            if not node:
                vals.append("N")
                return
            vals.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return ",".join(vals)
        

    def deserialize(self, data):
        vals = deque(data.split(","))

        def dfs():
            if not vals:
                return None
            val = vals.popleft()
            if val == "N":
                return None

            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node

        return dfs()
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
