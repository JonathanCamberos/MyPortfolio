---
title: "LeetCode: Trees"
description: "trees"
image: "../../public/Notes/tree.png"
publishedAt: "2025-08-05"
updatedAt: "2025-08-05"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Tree Intro

### What is a Tree

Trees are hierarchical data structures representing relationships
between entities, often in a parent-child format.

### Tree Characteristics

Trees are a special type of graph, characterized by:

1. Nodes: The entities (ex: values, objects)

2. Edges: The connections between the entities. A tree with n nodes has n - 1 edges.

3. Root: The top-most node, with no parent

4. Leaves: Nodes with no children 

5. Height: The number of edges on the longest path from the root to a leaf

6. Depth: The number of edges from the root to a specific node

7. No Cycles: Trees do not contain cycles

8. Single Paths: Trees have exactly one path between any two nodes

```
      1
     / \
    2   3
       / \
      4   5
```

### Tree Representations

Trees can be represented in multiple formats:

1. Adjacency Matrix: Used for general trees or graphs

2. Parent Array: Store each child -> parent, in an array

3. Linked Node Structure: Common in Binary Trees (TreeNode with left and right)

For full notes on representations:
please see [graph representations](/Notesleetcode-graphs#graph-representations)

### Tree Math
Height of a perfect binary tree with n nodes: log(n+1)-1

Nodes in perfect binary tree of height h: 2^(h+1) -1

Max nodes at level l: 2^l

Edges = Nodes - 1

### Common Tree Types

1. Binary Tree:
Each node has at most two children left and right.
Most LeetCode problems use this form.

2. Binary Search Tree (BST):
Type of binary tree where: 
Left subtree val < Node val < Right subtree val

Allows efficient search, insertion, and deletion.

3. Balanced Binary Tree (AVL, Red-Black)
Type of binary tree where: 
Height difference (balance factor) is kept small,
ensuring the height stays O(log n).

This prevents BST from degrading to a linked list in worst case

4. Complete Binary Tree
Type of binary tree where: 
All levels are filled except possibly the last, which is filled from left to right.

5. Full Binary Tree
Type of binary tree where:
Each node has either 0 or 2 children

6. Perfect Binary Tree
Type of binary tree where:
All internal nodes have 2 children and all leaves are at the same level.

7. N-ary Tree
Type of tree where:
Each node can have up to N children

### Balanced Trees 
Balanced trees are binary search trees that maintain their height
close to O(log n) by rebalancing themselves during insertion() and deletion().

Without balancing, a BST can degrade to a linked list: height(O(n)) if the
elements are inserted in sorted order

This is done by limiting the height difference (balance factor) 
between left and right subtrees.

Common Balanced Trees:

1. AVL Tree:
Strict balancing. Balance factor at each node is in [-1, 0, 1]. 
Rotations restore balance after insert/delete

2. Red Black Tree:
Looser balancing with colour properties.
Guarantees height &leq; 2 * log(n+1)

3. B- Trees / B+ Trees:
Multi way balanced trees used in databases and filesystems
for efficient range queries

| Operation     | BST (Unbalanced) | Balanced BST |
|---------------|------------------|--------------|
| Search        | O(n)             | O(log n)     |
| Insert/Delete | O(n)             | O(log n)     |


### Tree Traversal Overview
Given a Tree, and the task to traverse it,
there a two fundamental search strategies that all others stem from. 

### Depth First Search Traversal (DFS)
Traversal Order: 
Goes as deep as possible before backtracking
(either recursively via function calls or iteratively via stack)

Can process in pre, in, or post order:

Pre: Root -> Left -> Right

In: Left -> Root -> Right

Post: Left -> Right -> Root

### Breadth First Search Traversal (BFS)
Traversal Order: 
Explores nodes level by level

Will queue nodes for next level, count how many exist, 
and process all nodes for that level by iterating 
exactly level_size times popping each from the queue, thus popping all 
nodes for a specific level.

### Specialized Traversals
- Morris Traversal:
In order traversal with O(1) extra space by temporarily modifying tree pointers.

- Threaded Binary Tree:
Uses null child pointers to store predecessor/successor pointers to enable O(1) traversal.

### Tree Search Rule of Thumb
Pre, In, Post, order traversal -> DFS (recursive usually, iterative stack based)

Level Order Traversal -> BFS (iterative) queue based

### Tree Application: DFS Pre Order Traversal
Traversal Order: Root -> Left -> Right.
Top Down: Root is processed immediately, then we move deeper.
Used when a node's work must be done before processing its children.

Ex: Serialize a Binary Tree Recursive and Iterative
```python
    # ----------------------------------------
    # Recursive Pre Order
    def serializeRecursive(root: Optional[TreeNode]) -> str:
        def dfs(node):

            # Base Case: 
            # At leaf, label with 'N'
            if not node:
                vals.append("N")
                return
            
            # Process Root (top-down work)
            # add to serialized array
            vals.append(str(node.val))
            
            # Process Left Subtree
            dfs(node.left)
            
            # Process Right Subtree
            dfs(node.right)
        
        # array representing tree
        vals = []
        dfs(root)

        # join values of tree and return
        return ",".join(vals)

    # ----------------------------------------
    # Iterative Pre Order (stack)
    def serializeIterative(root: Optional[TreeNode]) -> str:

        # Empty Check
        if not root:
            return "N"

        # start iteration over tree, with root
        stack = [root]
        # array representing tree
        vals = []
        
        # iterate over all nodes of tree
        while stack:

            # grab current root
            currRoot = stack.pop()

            # Node Case:
            # current root being processed
            if currRoot:

                # Process Root (top-down work)
                vals.append(str(currRoot.val))
                
                # Push Right then Left (stack pops left first)
                stack.append(currRoot.right)
                stack.append(currRoot.left)
            
            # Leaf Case: 
            # At leaf, label with 'N'
            else:
                vals.append("N")
        
        # join values of tree and return
        return ",".join(vals)

    # ----------------------------------------
    # Result of recursive and iterative:

    # Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: "1,2,N,N,3,4,N,N,5,N,N"
```

### Tree Application: DFS In Order Traversal
Traversal Order: Left -> Root -> Right
Mid Point: Left is processed, then Root, followed by Right 
Used when a node's work must be done after visiting the left subtree
but before visiting the right subtree.

Ex: Convert BST to Sorted List Recursive and Validate BST Iterative
```python
    # Recursive In Order
    def bstToSortedList(root: Optional[TreeNode]) -> List[int]:
        res = []
    
        def inOrder(node):
            if not node:
                return
            
            # Process Left Subtree
            inOrder(node.left)
            
            # Process Root (midpoint work)
            res.append(node.val)
            
            # Process Right Subtree
            inOrder(node.right)
        
        inOrder(root)
        return res

    # Iterative In order
    def isValidBST(root: Optional[TreeNode]) -> bool:
        stack = []
        prev_val = float("-inf")
        curr = root
        
        while stack or curr:
            # Traverse Left Subtree
            while curr:
                stack.append(curr)
                curr = curr.left
            
            # Process Root (midpoint work)
            curr = stack.pop()
            if curr.val <= prev_val:
                return False
            prev_val = curr.val
            
            # Traverse Right Subtree
            curr = curr.right
        
        return True

    # Example BST:
    #       2
    #      / \
    #     1   3
    # bstToSortedList -> [1, 2, 3]
    # isValidBST -> True
```

### Tree Application: DFS Post Order Traversal
Traversal Order: Left -> Right -> Root
Bottom Up: Left and Right children are processed, followed by Root
Useful when a node's work depends on fully processed children. 

Ex: Evaluate Expression Tree Recursive and Delete Tree Iterative
```python
    # Recursive Post Order
    def evaluateTree(root: Optional[TreeNode]) -> int:
        if not root.left and not root.right:
            return int(root.val)

        # Process Left Subtree
        left_val = evaluateTree(root.left)
        
        # Process Right Subtree
        right_val = evaluateTree(root.right)
        
        # Process Root (bottom-up work)
        if root.val == "+":
            return left_val + right_val
        elif root.val == "-":
            return left_val - right_val
        elif root.val == "*":
            return left_val * right_val
        elif root.val == "/":
            return int(left_val / right_val)

    # Iterative Post Order
    def deleteTree(root: Optional[TreeNode]) -> None:
        if not root:
        return
    
        stack, output = [root], []
        
        while stack:
            node = stack.pop()
            output.append(node)
            
            # Push children to process them before root
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        
        # Process Root (bottom-up: delete after children)
        while output:
            node = output.pop()
            del node

    # Example:
    # Expression Tree:
    #       "+"
    #      /   \
    #     3     "*"
    #          /   \
    #         2     4
    # evaluateTree -> 11
    #
    # DeleteTree on:
    #       1
    #      / \
    #     2   3
    # Deletion order: 2, 3, 1
```

### Tree Application: BFS Iterative Full Level Processing
BFS visits nodes level by level, processing all nodes at a given depth 
before moving on to the next.
Used for level order problems and shortest path calculations in unweighted graphs,
as well as scenarios requiring nodes in order of distance from the root.

Ex: Level order traversal of Binary Tree
```python
    def levelOrderIterative(root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            level_nodes = []

            # Process all nodes in current level
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level_nodes)

        return result

    # Example:
    # Input Tree:
    #       1
    #      / \
    #     2   3
    #        / \
    #       4   5
    # Output: [[1], [2, 3], [4, 5]]
```

### Tree Application: BFS Iterative No Explicit Full Level Processing
BFS visit nodes in breath first order.
However, in some problems we don't process or store the full level at once.
Instead we act on nodes individually or in partial groupings (pairs, linked neighbors, etc)

Ex: Invert a Binary Tree
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        # BFS - no explicit full level processing
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            # Swap left and right children
            node.left, node.right = node.right, node.left
            
            # Add children to queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return root

        # Example:
        # Input Tree:
        #       4
        #      / \
        #     2   7
        # Output Tree:
        #       4
        #      / \
        #     7   2
```

### Tree Application: Modification
Tree structure is altered by rearranging nodes or pointers,
rather than simply traversing or querying.

Ex: Invert Binary Tree (DFS Recursive + BFS Iterative)
```python
# DFS Recursive (Postorder style)
def invertTreeDFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
        return None
    # Recursively invert left and right subtrees
    left_inverted = invertTreeDFS(root.left)
    right_inverted = invertTreeDFS(root.right)
    # Swap left and right children
    root.left, root.right = right_inverted, left_inverted
    return root

# BFS Iterative
from collections import deque

def invertTreeBFS(root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
        return None
    queue = deque([root])
    while queue:
        node = queue.popleft()
        # Swap children
        node.left, node.right = node.right, node.left
        # Add children to queue if they exist
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return root

# Example Tree:
#       4
#      / \
#     2   7
#    / \ / \
#   1  3 6  9
#
# Inverted Tree:
#       4
#      / \
#     7   2
#    / \ / \
#   9  6 3  1
```

### Tree Application: MinHeap
Use a MinHeap, a type of binary tree, to maintain the smallest or
highest-priority elements efficiently. 

Ex: Find the Top K Frequent Elements in a List
```python
    def topKFrequent(nums: List[int], k: int) -> List[int]:
        from collections import defaultdict
        import heapq

        # Step 1: Frequency count for each unique integer
        count = defaultdict(int)  # O(m) space complexity for m unique integers
        for num in nums:  # O(n) time complexity to iterate over n integers
            count[num] += 1

        # Step 2: Use a MinHeap to track the k most frequent elements
        minHeap = []  # O(k) space complexity for k elements
        for num, freq in count.items():  # O(m) time complexity for m unique integers
            heapq.heappush(minHeap, (freq, num))  # O(log k) for each insertion
            if len(minHeap) > k:  # Ensure heap size remains k
                heapq.heappop(minHeap)  # O(log k) for each removal

        # Step 3: Extract the elements from the heap
        return [num for freq, num in minHeap]  # O(k) time complexity to extract results

    # Example:
    # Input: nums = [1, 1, 1, 2, 2, 3], k = 2
    # Output: [1, 2]
```


## 226. Invert Binary Tree ::4:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the root of a binary tree, invert the tree, and return its root.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [4,2,7,1,3,6,9] | [4,7,2,9,6,3,1] |
| root = [2,1,3] | [2,3,1] |
| root = [] | [] |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-100 &le; Node.val &le; 100

### Abstraction
Invert the binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive - Tree/DFS Pre Order Traversal
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: DFS recursive inverts subtrees from bottom up
        # 1. Base case: return None if node is null
        # 2. Swap left and right children at each node
        # 3. Recurse into left and right children
        # 4. Returns inverted root
        # Result: Original tree has been inverted
        
        # Base case:
        # empty tree -> curr at leaf -> do nothing
        if not root:
            return None
        
        # Process Root: 
        # Swap left and right children
        root.left, root.right = root.right, root.left
        
        # Process Left + Right: 
        # Recursive calls to invert the left and right subtrees
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        # overall: time complexity O(n)
        # overall: space complexity O(h), O(log n) for balanced tree
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: DFS Recursive - Tree/DFS In Order Traversal
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: DFS recursive approach using in order traversal
        # 1. Traverse original left subtree first
        # 2. Swap left and right children at current node
        # 3. Traverse the new left subtree (originally the right)
        # Result: Tree inverted in place using in order order
        
        # Base case:
        if not root:
            return None
        
        # Process Left:
        # Recursive call to invert left subtree
        self.invertTree(root.left)
        
        # Process Root:
        # Swap left and right children
        root.left, root.right = root.right, root.left
        
        # Process Right:
        # Recursive call to invert right subtree (now left)
        self.invertTree(root.left)
        
        # overall: time complexity O(n)
        # overall: space complexity O(h), balanced tree O(log n), skewed tree O(n)
        return root
```


### Solution 3: DFS Recursive - Tree/DFS Post Order Traversal
```python
    def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: DFS recursive approach inverts subtrees from bottom up (postorder)
        # 1. Base case: return None if node is null
        # 2. Recursively invert left subtree
        # 3. Recursively invert right subtree
        # 4. Swap left and right children of current node
        # 5. Return inverted root
        # Result: Original tree has been inverted

        if not root:
            return None

        # Process Left + Right:
        # Recursive calls to invert the left and right subtrees
        left_inverted = invertTree(root.left)
        right_inverted = invertTree(root.right)

        # Process Root:
        # Swap left and right children
        root.left = right_inverted
        root.right = left_inverted

        # overall: time complexity O(n)
        # overall: space complexity O(h), O(log n) for balanced tree
        return root
```

### Solution 4: BFS Iterative - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # Note:
        # Idea: BFS iterative approach inverts nodes level by level
        # 1. Queue stores nodes to process
        # 2. For curr root pop() from queue:
        #    Swap left and right children
        #    Add non None children to queue
        # 3. Continue while queue non empty
        
        # Empty tree check
        if not root:
            return None
        
        # Queue to support BFS
        queue = deque([root])
        
        # time complexity: iterate over tree, level by level O(n)
        while queue:

            # grab curr root, oldest TreeNode, First In First Out
            currRoot = queue.popleft()
            
            # Swap left and right children
            currRoot.left, currRoot.right = currRoot.right, currRoot.left
            
            # iterate over tree:
            # Add non None children to queue
            if currRoot.left:
                queue.append(currRoot.left)
            if currRoot.right:
                queue.append(currRoot.right)
        
        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return root
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 104. Maximum Depth of Binary Tree ::4:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> A binary tree's maximum depth is the number of nodes along 
> the longest path from the root node down to the farthest leaf node.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | 3 |
| root = [1,null,2] | 2 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the max depth of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive - Tree/DFA Pre order Traversal
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. DFS recursive approach calculates depth from leaf upward
        # 2. Base case: if node is None, depth = 0
        # 3. Recursive case:
        #    - depth_left = depth of left subtree
        #    - depth_right = depth of right subtree
        #    - depth = 1 + max(depth_left, depth_right)
        # 4. Returns depth of root as final result
        
        def dfs(node, depth):
            if not node:
                return depth
            return max(
                dfs(node.left, depth + 1),
                dfs(node.right, depth + 1)
            )
    
    return dfs(root, 0)

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: DFS Recursive - Tree/DFA In Order Traversal
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.max_depth = 0
        
        def inorder(node, depth):
            if not node:
                return

            # Go left first
            inorder(node.left, depth + 1)
             # "Visit" root
            self.max_depth = max(self.max_depth, depth + 1)
            # Go right
            inorder(node.right, depth + 1)
        
        inorder(root, 0)
        return self.max_depth
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: DFS Recursive - Tree/DFA Post Order Traversal
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # Idea: DFS postorder traversal (Left → Right → Root)
        # 1. Compute depth of left subtree
        # 2. Compute depth of right subtree
        # 3. Combine results at root
        # This is naturally bottom-up since we process children first
        
        if not root:
            return 0
        
        # Traverse left and right children
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        
        return 1 + max(left_depth, right_depth)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |




### Solution 4: BFS Iterative - Tree/BFS Iterative Full Level Processing
```python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. BFS iterative approach calculates depth level-by-level
        # 2. Queue stores nodes in current level
        # 3. For each level:
        #    - process all nodes at current depth
        #    - add their children to queue
        # 4. Increment depth after processing each level
        
        if not root:
            return 0
        
        queue = deque([root])
        depth = 0
        
        while queue:
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth += 1
        
        # overall: time complexity
        # overall: space complexity
        return depth
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 543. Diameter of Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given the root of a binary tree, return the length of the diameter of the tree.
> The diameter of a binary tree is the length of the longest path between any 
> two nodes in a tree. This path may or may not pass through the root.
> The length of a path between two nodes is represented by the number of
> edges between them. 

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [1,2,3,4,5] | 3 |
| root = [1,2] | 1 |
 
Constraints:

The number of nodes in the tree is in the range [0, 10<sup>4</sup>]

-100 &le; Node.val &le; 100

### Abstraction
Find the diameter of a binary tree.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Post order) - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. Post order DFS: compute height of subtrees bottom-up
        # 2. At each node:
        #    - Compute left height
        #    - Compute right height
        #    - Update diameter as max(left_height + right_height)
        # 3. Return diameter after full traversal
        # Results: longest path in terms of edges between any two nodes

        self.diameter = 0
        
        def dfs(node):
            if not node:
                return 0
            
            # Heights of left and right subtrees
            left_height = dfs(node.left)
            right_height = dfs(node.right)
            
            # Update diameter at this node
            self.diameter = max(self.diameter, left_height + right_height)
            
            # Height of subtree rooted at this node
            return 1 + max(left_height, right_height)
        
        dfs(root)
        return self.diameter
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive (Optimized Return Tuple) - Tree/DFS Post order Traversal
```python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Note:
        # 1. Combine diameter & height calculation in single DFS call
        # 2. Each call returns tuple: (height, diameter)
        # 3. Avoid global variable by computing max in recursion
        # Results: same O(n) but cleaner function interface
        
        def dfs(node):
            if not node:
                return 0, 0  # (height, diameter)
            
            left_height, left_diam = dfs(node.left)
            right_height, right_diam = dfs(node.right)
            
            # Diameter at this node
            curr_diam = left_height + right_height
            
            # Best diameter so far
            max_diam = max(curr_diam, left_diam, right_diam)
            
            # Height of subtree
            return 1 + max(left_height, right_height), max_diam
        
        return dfs(root)[1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 110. Balanced Binary Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Binary Tree

### Intro
> Given a binary tree, determine if it is height-balanced. 

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,9,20,null,null,15,7] | true |
| root = [1,2,2,3,3,null,null,4,4] | false |
| root = [] | true |
 
Constraints:

The number of nodes in the tree is in the range [0, 5000]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if a binary tree is height balanced.
A height-balanced binary tree is a binary tree in which the 
depth of the two subtrees of every node never differs by more than one.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Post order) - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Post order DFS computes height bottom-up
        # 2. At each node:
        #    - Compute left height
        #    - Compute right height
        #    - Check if balance condition holds: abs(left - right) <= 1
        # 3. Use -1 as sentinel to propagate imbalance early
        # Results: returns False immediately when imbalance is detected

        def dfs(node):
            if not node:
                return 0  # height
            
            left_height = dfs(node.left)
            if left_height == -1:
                return -1  # imbalance detected
            
            right_height = dfs(node.right)
            if right_height == -1:
                return -1  # imbalance detected
            
            if abs(left_height - right_height) > 1:
                return -1  # imbalance detected
            
            return 1 + max(left_height, right_height)
        
        return dfs(root) != -1
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: DFS Recursive (Post order with Tuple) - Tree/DFS Post order Traversal
```python
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Post order DFS returns tuple: (is_balanced, height)
        # 2. Combines height + balance check without sentinel value
        # 3. Each call checks:
        #    - Left subtree balance
        #    - Right subtree balance
        #    - Current node balance
        # Results: cleaner return, same complexity
        
        def dfs(node):
            if not node:
                return True, 0  # (is_balanced, height)
            
            left_bal, left_height = dfs(node.left)
            if not left_bal:
                return False, 0
            
            right_bal, right_height = dfs(node.right)
            if not right_bal:
                return False, 0
            
            balanced = abs(left_height - right_height) <= 1
            return balanced, 1 + max(left_height, right_height)
        
        return dfs(root)[0]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 100. Same Tree ::2:: - Easy

Topics:  Tree, Depth First Search, Breadth First Search, Binary Tree

### Intro
> Given the roots of two binary trees p and q, write a function to
> check if they are the same or not.
> Two binary trees are considered the same if they are
> structurally identical, and the nodes have the same value.

|  Example Input           | Output |  
| ---------------- | ------ | 
| p = [1,2,3], q = [1,2,3] | true |
| p = [1,2], q = [1,null,2] | false |
| p = [1,2,1], q = [1,1,2] | false |
 
Constraints:

The number of nodes in the tree is in the range [0, 100]

-10<sup>4</sup> &le; Node.val &le; 10<sup>4</sup>

### Abstraction
Determine if two different binary trees match.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Pre order) - Tree/DFS Pre order Traversal
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # 1. DFS Pre order: Compare current node values, then recurse on children
        # 2. Base cases:
        #    - If both nodes are None => trees match at this branch
        #    - If one node is None or values mismatch => trees differ
        # 3. Recurse left and right; both must match
        
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative (Queue) - Tree/BFS Iterative Queue Based
```python
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Note:
        # 1. BFS: Compare trees level-by-level
        # 2. Use queue to store node pairs from p and q
        # 3. For each pair:
        #    - Both None => continue
        #    - One None or value mismatch => return False
        #    - Enqueue children in parallel
        # Results: Early termination if mismatch found
        
        queue = deque([(p, q)])
        
        while queue:
            node1, node2 = queue.popleft()
            
            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False
            
            queue.append((node1.left, node2.left))
            queue.append((node1.right, node2.right))
        
        return True
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 572. Subtree of Another Tree ::3:: - Easy

Topics:  Tree, Depth First Search, String Matching, Binary Tree, Hash Function

### Intro
> Given the roots of two binary trees root and subRoot, return true if 
> there is a subtree of root with the same structure and node values of 
> subRoot and false otherwise.
> A subtree of a binary tree tree is a tree that consists of a node in 
> tree and all of this node's descendants. The tree tree could also be
> considered as a subtree of itself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| root = [3,4,5,1,2], subRoot = [4,1,2] | true |
| root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] | false |
 
Constraints:

The number of nodes in the root tree is in the range [1, 2000].

The number of nodes in the subRoot tree is in the range [1, 1000].

-10<sup>4</sup> &le; root.val &le; 10<sup>4</sup>

-10<sup>4</sup> &le; subRoot.val &le; 10<sup>4</sup>


### Abstraction
Determine binary tree tree2 is a subtree of binary tree tree1.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DFS Recursive (Pre order Traversal) - Tree/DFS Pre order Traversal
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. DFS Pre order traversal of `root`
        # 2. At each node in `root`:
        #    - Check if subtree matches starting here using helper isSameTree
        #    - Recurse to left and right
        # 3. Early exit if a match is found

        def isSameTree(s, t):
            if not s and not t:
                return True
            if not s or not t or s.val != t.val:
                return False
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)
        
        if not subRoot:
            return True
        if not root:
            return False
        
        if isSameTree(root, subRoot):
            return True
        
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: BFS Iterative (Queue) - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. BFS level order traversal of `root`
        # 2. For each node:
        #    - If value matches subRoot root, run isSameTree
        # 3. Uses queue to iterate nodes iteratively

        def isSameTree(s, t):
            if not s and not t:
                return True
            if not s or not t or s.val != t.val:
                return False
            return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)

        if not subRoot:
            return True
        if not root:
            return False
        
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if node.val == subRoot.val and isSameTree(node, subRoot):
                return True
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: DFS + Serialization String Matching - Tree/BFS Iterative No Explicit Full Level Processing
```python
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Note:
        # 1. Use DFS preorder traversal to serialize both trees
        # 2. Each value is wrapped with a leading comma to prevent accidental partial matches
        #    (e.g., "2" in "12" would match incorrectly without boundaries)
        # 3. Compare serialized subRoot string as substring of root serialization
        # 4. If subRoot serialization is found in root serialization, subRoot is a subtree

        def serialize(node):
            if not node:
                return ",N"  # "N" represents None
            return f",{node.val}" + serialize(node.left) + serialize(node.right)

        return serialize(subRoot) in serialize(root)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


