---
title: "Intervals"
description: "intervals"
image: "../../public/Notes/intervals.png"
publishedAt: "2025-09-29"
updatedAt: "2025-09-29" 
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---

## Intervals Intro

### What are Intervals

Numbers!

### Intervals IRL

Numbers!

### Intervals Application: Intervals
Pattern: Numbers! 

Ex: Numbers numbers!!
```python
    def wow!(n: int) -> int:

        return n+1
```

## 57. Insert Interval ::2:: - Medium

Topics:  Array

### Intro
> You are given an array of non-overlapping intervals intervals 
> where intervals[i] = [starti, endi] represent the start and 
> the end of the ith interval and intervals is sorted in ascending 
> order by starti. You are also given an interval newInterval = [start, end]
> that represents the start and end of another interval.
> Insert newInterval into intervals such that intervals is still
> sorted in ascending order by starti and intervals still does not 
> have any overlapping intervals (merge overlapping intervals if necessary).
> Return intervals after the insertion.
> Note that you don't need to modify intervals in-place. You can
> make a new array and return it.

|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [[1,3],[6,9]], newInterval = [2,5] | [[1,5],[6,9]] |
| intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] | [[1,2],[3,10],[12,16]] |

Constraints:

0 &leq; intervals.length &leq; 10<sup>4</sup>

intervals[i].length == 2 

0 &leq; starti &leq; endi &leq; 10<sup>5</sup>

intervals is sorted by starti in ascending order

newInterval.length == 2 

0 &leq; start &leq; end &leq; 10<sup>5</sup>

### Abstraction
Given a list of sorted, non-overlapping intervals and a new interval, 
insert the new interval and merge any overlaps so that the resulting list 
remains sorted and non-overlapping.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        # Note:
        # Greedy merge
        # 0. Direct Length -> empty intervals, just return [newInterval]
        # 1. Process root -> iterate through intervals
        # 2. Explore Choices:
        #    - Current interval ends before newInterval starts -> add as is
        #    - Current interval starts after newInterval ends -> add newInterval, then rest
        #    - Overlapping intervals -> merge into newInterval
        # 3. Result -> merged list of intervals
        
        result = []
        i = 0
        n = len(intervals)
        start, end = newInterval

        # Step 1: add all intervals that end before newInterval starts
        while i < n and intervals[i][1] < start:
            result.append(intervals[i])
            i += 1

        # Step 2: merge overlapping intervals
        while i < n and intervals[i][0] <= end:
            start = min(start, intervals[i][0])
            end = max(end, intervals[i][1])
            i += 1
        result.append([start, end])

        # Step 3: add remaining intervals
        while i < n:
            result.append(intervals[i])
            i += 1

        return result
```


### Solution 2: array 2 - Intervals/Intervals
```python
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        # Note:
        # Greedy / Linear Scan
        # 0. Direct Boundary -> handle empty intervals
        # 1. Process root -> iterate through existing intervals
        # 2. Explore Choices:
        #    - Current interval ends before newInterval starts -> keep as is
        #    - Current interval starts after newInterval ends -> insert newInterval here
        #    - Current interval overlaps newInterval -> merge intervals
        # 3. Build -> append intervals to result array
        # 4. Result -> merged list of non-overlapping intervals including newInterval

        n = len(intervals)
        merged = []
        i = 0
        intervalAdded = False

        # Iterate through intervals
        while i < n:
            curr = intervals[i]

            # Case 1: No overlap, current interval ends before newInterval starts
            if curr[1] < newInterval[0]:
                merged.append(curr)
                i += 1

            # Case 2: No overlap, current interval starts after newInterval ends
            elif curr[0] > newInterval[1]:
                merged.append(newInterval)
                merged.append(curr)
                intervalAdded = True
                i += 1
                break

            # Case 3: Overlapping intervals -> merge
            else:
                newStart = min(newInterval[0], curr[0])
                newEnd = max(newInterval[1], curr[1])
                i += 1
                # Merge with any subsequent overlapping intervals
                while i < n and intervals[i][0] <= newEnd:
                    newEnd = max(newEnd, intervals[i][1])
                    i += 1
                merged.append([newStart, newEnd])
                intervalAdded = True
                break

        # Append remaining intervals after insertion/merging
        merged += intervals[i:]

        # If newInterval was never added (it belongs at the end)
        if not intervalAdded:
            merged.append(newInterval)

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return merged
```



## 56. Merge Intervals ::1:: - Medium

Topics:  Array, Sorting

### Intro
> Given an array of intervals where intervals[i] = [starti, endi], 
> merge all overlapping intervals, and return an array of the
> non-overlapping intervals that cover all the intervals in the input.

|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [[1,3],[2,6],[8,10],[15,18]] | [[1,6],[8,10],[15,18]] |
| intervals = [[1,4],[4,5]] | [[1,5]] |
| intervals = [[4,7],[1,4]] | [[1,7]] |

Constraints:

1 &leq; intervals.length &leq; 10<sup>4</sup>

intervals[i].length == 2 

0 &leq; starti &leq; endi &leq; 10<sup>5</sup>

### Abstraction
Given a list of non sorted, overlapping intervals, 
merge all overlapping intervals.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # Note:
        # Greedy / Sorting approach
        # 0. Direct Boundary -> empty input returns empty list
        # 1. Process root -> sort intervals by start time
        # 2. Build -> iterate through sorted intervals, merging overlapping ones
        # 3. Explore Choices -> if current interval overlaps previous, merge; else, append
        # 4. Result -> list of merged, non-overlapping intervals

        if not intervals:
            return []

        # Step 1: sort intervals by start time
        intervals.sort(key=lambda x: x[0])

        merged = [intervals[0]]  # initialize with first interval

        # Step 2: iterate through sorted intervals
        for i in range(1, len(intervals)):
            current = intervals[i]
            last_merged = merged[-1]

            # Step 3: overlapping intervals -> merge
            if current[0] <= last_merged[1]:
                last_merged[1] = max(last_merged[1], current[1])
            else:
                # non-overlapping -> add new interval
                merged.append(current)

        # overall: time complexity O(n log n) due to sorting
        # overall: space complexity O(n) for merged list
        return merged 
```


## 435. Non Overlapping Intervals ::1:: - Medium

Topics:  Array, Dynamic Programming, Greedy, Sorting

### Intro
> Given an array of intervals intervals where 
> intervals[i] = [starti, endi], 
> return the minimum number of intervals you need to remove to make the rest 
> of the intervals non-overlapping.
> Note that intervals which only touch at a point are non-overlapping. 
> For example, [1, 2] and [2, 3] are non-overlapping.


|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [[1,2],[2,3],[3,4],[1,3]] | 1 |
| intervals = [[1,2],[1,2],[1,2]] | 2 |
| intervals = [[1,2],[2,3]] | 0 |

Constraints:

1 &leq; intervals.length &leq; 10<sup>5</sup>

intervals[i].length == 2 

-5 * 10<sup>4</sup> &leq; starti &lt; endi &leq; 5 * 10<sup>4</sup>

### Abstraction
Given a list intervals, determine the minimum number of intervals
needed to be removed ot make the intervals non overlapping

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # Note:
        # Greedy / Sorting approach
        # 0. Direct boundary -> empty or single interval: no removals needed
        # 1. Sort intervals by end time
        # 2. Process root -> iterate through intervals
        # 3. Build -> track end of last kept interval
        # 4. Explore choices -> if current interval overlaps last, remove it
        # 5. Result -> count of removed intervals

        if not intervals:
            return 0

        # Step 1: sort intervals by end time (earliest finishing first)
        intervals.sort(key=lambda x: x[1])

        # Step 2: initialize
        end = intervals[0][1]  # end of the first interval we keep
        removals = 0

        # Step 3: iterate through the rest
        for i in range(1, len(intervals)):
            start_i, end_i = intervals[i]

            # Step 4: check overlap
            if start_i < end:
                # current interval overlaps -> remove it
                removals += 1
            else:
                # no overlap -> update end to current interval's end
                end = end_i

        # Step 5: return number of removals
        return removals
```


### Solution 2: array 2 - Intervals/Intervals
```python
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        res = 0
        prevEnd = intervals[0][1]

        for start, end in intervals[1:]:
            if start >= prevEnd:
                prevEnd = end
            else:
                res += 1
                prevEnd = min(end, prevEnd)
        return res
```

### Solution 3: array 3 - Intervals/Intervals
```python
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n <= 1:
            return 0

        intervals.sort(key=itemgetter(1))  # sort by end
        keep = 0
        end = float("-inf")
        for s, e in intervals:             # no slicing (no extra list)
            if s >= end:                   # non-overlapping -> keep it
                keep += 1
                end = e
        return n - keep                    # deletions = total - kept

```



## 252. Meeting Rooms ::1:: - Easy

Topics:  Array, Dynamic Programming, Greedy, Sorting

### Intro
> Given an array of meeting time interval objects consisting of 
> start and end times 
> [[start_1,end_1],[start_2,end_2],...] (start_i < end_i)
> of the intervals non-overlapping.
> determine if a person could add all meetings to
> their schedule without any conflicts.


|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [(0,30),(5,10),(15,20)] | false |
| intervals = [(5,8),(9,15)] | false |

Constraints:

0 &leq; intervals.length &leq; 500

0 &leq; intervals[i].start &lt; intervals[i].end &leq; 1000000


### Abstraction
Given a list of intervals representing meetings,
determine if a person can make it to all meetings without conflicts.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        # Direct boundary -> empty or single meeting: always feasible
        if not intervals:
            return True

        # Sort intervals by start time
        intervals.sort(key=lambda x: x.start)

        # Check for overlaps
        for i in range(1, len(intervals)):
            if intervals[i].start < intervals[i-1].end:
                return False

        return True
```

## 253. Meeting Rooms II ::1:: - Medium

Topics:  Array, Dynamic Programming, Greedy, Sorting

### Intro
> Given an array of meeting time interval objects consisting of 
> start and end times 
> [[start_1,end_1],[start_2,end_2],...] (start_i < end_i),
> find the minimum number of days required to schedule 
> all meetings without any conflicts.


|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [(0,40),(5,10),(15,20)] | 2 |
| intervals = [(4,9)] | 1 |

Constraints:

0 &leq; intervals.length &leq; 500

0 &leq; intervals[i].start &lt; intervals[i].end &leq; 1000000


### Abstraction
Given a list of intervals representing meetings,
determine the minimum number of rooms or 'days' required to schedule all
the meetings without conflicts.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        # Note:
        # Greedy + Min-Heap
        # 0. Direct boundary -> empty intervals require 0 rooms
        # 1. Sort intervals by start time
        # 2. Use a min-heap to track meeting end times
        # 3. Iterate intervals:
        #    - if current meeting starts after earliest ending, reuse room (pop heap)
        #    - push current meeting end time into heap
        # 4. Result -> size of heap = min rooms required

        if not intervals:
            return 0

        # Sort intervals by start time
        intervals.sort(key=lambda x: x.start)

        # Min-heap to track current meeting end times
        import heapq
        heap = []

        for interval in intervals:
            # Reuse room if possible
            if heap and interval.start >= heap[0]:
                heapq.heappop(heap)
            # Push current meeting end time
            heapq.heappush(heap, interval.end)

        # Number of rooms = maximum simultaneous meetings
        return len(heap)
```

## 1851. Minimum Interval to Include Each Query ::1:: - Hard

Topics:  Array, Binary Search, Line Sweep, Sorting, Heap (Priority Queue)

### Intro
> You are given a 2D integer array intervals, where 
> intervals[i] = [lefti, righti] describes the ith interval 
> starting at lefti and ending at righti (inclusive). The size 
> of an interval is defined as the number of integers it contains, 
> or more formally righti - lefti + 1.
> You are also given an integer array queries. The answer to 
> the jth query is the size of the smallest interval i such 
> that lefti < = queries[j] < = righti. If no such interval 
> exists, the answer is -1.
> Return an array containing the answers to the queries.


|  Example Input           | Output |  
| ---------------- | ------ | 
| intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] | [3,3,1,4] |
| intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] | [2,-1,4,6] |

Constraints:

1 &leq; intervals.length &leq; 10<sup>5</sup>

1 &leq; queries.length &leq; 10<sup>5</sup>

intervals[i].length == 2

1 &leq; lefti &lt; righti &leq; 10<sup>7</sup>

1 &leq; queries[j] &leq; 10<sup>7</sup>


### Abstraction
For a list of intervals and a list of queries, determine for 
each query the smallest interval that covers it. If no interval 
covers a query, return -1.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: array - Intervals/Intervals
```python
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        # Note:
        # Greedy + Heap
        # 0. Direct Boundary -> empty inputs handled implicitly
        # 1. Sort intervals by start
        # 2. Sort queries but store original indices
        # 3. Iterate queries in ascending order
        # 4. Add intervals starting before or at query to min-heap (by size)
        # 5. Remove intervals ending before query
        # 6. Result -> if heap non-empty, top is smallest interval covering query, else -1

        # Step 1: sort intervals by start
        intervals.sort(key=lambda x: x[0])

        # Step 2: sort queries with indices
        sorted_queries = sorted([(q, i) for i, q in enumerate(queries)])

        res = [-1] * len(queries)
        heap = []  # min-heap: (size, end)
        j = 0      # pointer for intervals

        # Step 3: iterate queries in ascending order
        for q_val, q_idx in sorted_queries:

            # Step 4: add intervals whose start <= query to heap
            while j < len(intervals) and intervals[j][0] <= q_val:
                start, end = intervals[j]
                size = end - start + 1
                heapq.heappush(heap, (size, end))
                j += 1

            # Step 5: remove intervals whose end < query
            while heap and heap[0][1] < q_val:
                heapq.heappop(heap)

            # Step 6: record result
            if heap:
                res[q_idx] = heap[0][0]

        # overall: time complexity O(n log n + q log n)
        # overall: space complexity O(n)
        return res
```

### Solution 2: array 2 - Intervals/Intervals
```python
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        # Note:
        # Greedy + Heap
        # 0. Direct Boundary -> empty inputs handled implicitly
        # 1. Sort intervals by start
        # 2. Sort queries but maintain original indices using a map
        # 3. Iterate queries in ascending order
        # 4. Add intervals starting before or at query to min-heap (by size)
        # 5. Remove intervals ending before query
        # 6. Result -> if heap non-empty, top is smallest interval covering query, else -1

        # Step 1: sort intervals by start
        intervals.sort(key=lambda x: x[0])

        res_map = defaultdict(int)
        min_heap = []
        i = 0

        # Step 2 & 3: iterate queries in ascending order
        for q in sorted(queries):

            # Step 4: push all intervals starting <= query into heap
            while i < len(intervals) and intervals[i][0] <= q:
                l, r = intervals[i]
                heapq.heappush(min_heap, (r - l + 1, r))  # (size, end)
                i += 1

            # Step 5: pop intervals ending before query
            while min_heap and min_heap[0][1] < q:
                heapq.heappop(min_heap)

            # Step 6: record result
            res_map[q] = min_heap[0][0] if min_heap else -1

        # Map results back to original query order
        return [res_map[q] for q in queries]

```

































