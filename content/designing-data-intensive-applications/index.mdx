---
title: "Designing Data Intensive Applications"
description: "designing data intensive applications"
image: "../../public/Notes/ddia-2.png"
publishedAt: "2025-09-18"
updatedAt: "2025-09-18"
author: "jonathancamberos"
isPublished: true
tags:
- system design
---


## Preface

> Hello! all of this will be in short hand form, to avoid rewriting the textbook from scratch.
> Additionally, I am reading/writing this in my vscode, i know i know, editing text in vscode,
> an editor for code, WITH CODE IN THE NAME, disgraceful, buttt the rest of my LeetCode notes
> are here so ¯\\_(ツ)_/¯.
> As such, the notes look much prettier (and colored in vscode, if you want to read along, 
> plz check my github)

### Intro

Backend swe's have new common buzz words relating
to the storage and processing of data.

NoSQL! BIG DATA! Web scale, Sharing, EvEnTuAl CoNsIsTeNcY, ACID!!! (no not the drug)
The Cap Theorem, Clooooud services, (you get the point).

Data intensive applications are pushing the boundaries of what is possible
by inventing new buzzwords, strategies, and technologies.

Fortunately, regardless of the rapid change
basic principles remain true no matter what tool or version you are using.

We are here to learn the 'why' of those basic principles.

The goal of these notes is to organize shorthand to learn these concepts.

### Who Should Read This Book?

> Fellow developers, old friends, random strangers on the internet who
> have stumbled upon my chicken scratch of notes. Welcome all!

But again, if you are backend these notes are for you.

1. **Role wise, this is for** 

- **software engineers**: the builders

- **software architects**: the designers

- basically **anybody** making decisions on the 
architecture of the systems you are building.

- for people with natural curiosity for what is going on under the hood,
rule number 1: its never magic (thanks bobby ;) )
rule number 2: i will not bail you out of jail (also thank you bobby, rip cmsc417 gang)

2. **App wise, this is for** 

- **scalable data systems**: (e.g., supporting web or mobile apps with millions of users)

- **minimizing downtime**: (e.g., making apps available)

- **maintainable systems**: (e.g., making systems easier scale and update as technologies change)

3. **Counter Argument wise, this is for**

- when someone complains "you're not google or amazon, stop worrying about scale
and just use a relational database". You can **slap them with a fish and say**
"fair, while building for scale you don't need is wasted effort, it may lock you
into an inflexible design. You should know its important to choose the right tool 
for the job and while relational databases are important, they are not the final word
on dealing with data". They will then view you as a worthy advisory and challenge
you to a fight to the death (dont forget what you learned in your 4 years of computer science
undergrad and give them the classic fork() and os.kill_child() leading to instant victory, for
legal reasons this is a joke please dont stop reading its like 4 in the morning im sorry,
also if you laughed at that youre a nerd :) )


### Scope Of This Book

> Again, the *architecture* of data systems.

We cover the principles and tradeoffs to data systems 
and explore design decisions taken by different products.

We leave deployment, operations, security, management, and other areas,
to be covered by other books.

### Outline Of This Book

> 1. Part I: The Basics: our bearings, and definitions

We define the fundamental ideas for the design of data intensive applications.

|  Chapter  | Topic |
| -------- | --------------- |
| 1 | Top down point of view. What are we trying to achieve? Reliability, scalability, maintainability. |
| 2 | Start by comparing different data models and query languages, and see how they are appropriate to different situations |
| 3 | Storage engines. How databases arrange data on disk so that we can find it again efficiently |
| 4 | Formats for data encoding (serialization) and evolution of schemas over time |



> 2. Part II: From a single machine to a distributed system

Shift from single machine to distributed across multiple machines, 
as often necessary for scalability, and discuss variety of unique challenges

|  Chapter  | Topic |
| -------- | --------------- |
| 5 | Replication |
| 6 | Partitioning and sharding |
| 7 | Transactions |
| 8 | Dive into more details on the problems prevalent with distributed systems |
| 9 | What is means to achieve consistency and consensus in a distributed system |

> 3. Part III: Heterogeneous systems, where no one data base can do it all

Learn about systems that derive some datasets from other datasets.
in heterogenous systems, when no one database can do everything well.
Applications need to connect different databases, caches, indexes and so on.

|  Chapter  | Topic |
| -------- | --------------- |
| 10 | Batch processing approach to derived data. |
| 11 | Build upon batch processing with stream processing. |
| 12 | Tape everything together and discuss approaches for building reliable, scalable, and maintainable applications in the future. |

### References and Further Reading

> Nothing new here!

Most of everything in this book has been said before!
Free references and links as we go along.


## Part I: Foundations of Data Systems

### Intro

> The first four chapters go through the fundamental ideas that apply to all data systems,
> whether running on a single machine or distributed across a cluster of machines.

1. **Chapter 1:**

- Define terminology and approach we will use.
- Define words like reliability, scalability, and maintainability
- Explain how we try to achieve these goals.

2. **Chapter 2:**

- Compare data models and query languages.
- See how different models are fit different situations.

3. **Chapter 3:**

- Look at internals of storage engines.
- Look at how database put data on disk.
- Different storage engines are optimized for different workloads.
- Choosing the right one can have a huge effect on performance.

4. Chapter 4: 

- Compare formats of data encoding/serialization
- Examine in an environment where application requirements change and schemas need to adapt over time.

### Reliable, Scalable, and Maintainable Applications

> Many applications today are data intensive, as opposed to compute intensive.
> Raw CPU power is rarely a limiting factor vs the amount of data, complexity of data, 
> and speed at which it is changing.

Data intensive applications are typically built from standard building blocks for 
functionality, not limited to but including:

- **Databases**: Storing data, for other apps or later use 

- **Caches**: Remember result of expensive operations, to speed up reads

- **Search Indexes**: Allowing users to search data by keywords or filter in various ways

- **Batch Process**: Periodically crunching a large amount of accumulated data

Again, obvious yes, but thats the point!

These data systems are such a **successful abstraction** that most **sane** engineers wouldn't 
think of writing a new data storage engine from scratch because perfectly good ones already exists.

But again, right tool for the right job.
While there are many database systems, each have different characteristics
as different applications have different requirements.

### Thinking About Data Systems

> Why do we lump databases, queues, caches, etc, each with different patterns, performance, 
> and implementations under the umbrella term data systems?
> Why am I starting each section with a quote?
> Do I have voices in my head?!? Maybe...
> But still, the umbrella makes it confusing!

New tools for data storage and processing emerged leading to trouble
as traditional categories fad and boundaries blur.

1. **Redis: **both datastores and message queue
2. **Apache Kafka: **both message queues with database durability

No single tool can meet all data processing and storage needs as applications
have such demanding and wide ranging requirements.

As no single tool can meet all data processing and storage needs, work is broken down
into tasks, that can be performed on a single tool, which itself is using multiple tools.

> Take an API

An API usually hides implementation details from clients, and thus, becomes a 
special purpose data system from smaller, general purpose components.

We could even add guarantees such as cache will be invalidated and updated on writes so
clients see consistent results, which leads wrappers to become responsible for
both data storage and system design.

But now even more questions arise! How do you provide good performance?
How do we handle increase in load? etc. Lets put that in our back pocket (ignore) 
for now and continue.

Lets jump into our main sections, reliability, scalability, and maintainability.

### Reliability

> The system should continue to work correctly (performing the correct function at the
> desired level of performance) even in the face of *gasp adversity*, either 
> hardware or software faults, human error, etc..

wow

### Scalability

> As the system grows (in data volume, traffic volume, or complexity), there should be a
> reasonable solution to deal with that growth

this

### Maintainability

> Specifically over time, different people will build, work, and add to the system 
> (engineering and operations, both maintaining behavior and adapting the system),
> and they should all be able to work on it *productively* 
> (obviously ignoring the unavoidable knife fights over code comment style)

notes


