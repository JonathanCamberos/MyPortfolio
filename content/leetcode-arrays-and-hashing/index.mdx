---
title: "LeetCode: Arrays & Hashing"
description: "Arrays & Hashing"
image: "../../public/blogs/code_3.jpg"
publishedAt: "2024-08-14"
updatedAt: "2025-05-21"
author: "jonathancamberos"
isPublished: true
tags:
- data structures & algorithms
---

## Arrays & Hashing Intro:

Leetcode problems with elegant solutions using hashing. 

### What is a Hashmap
A dictionary is just a direct mapping of keys->values:

dictionary: ['a': 2, 'b': 2...] 

A Hashmap is just a dictionary that maps keys->values using a hash function.
Hashmaps aka Hashtables, is a common use case for hashing.
We choose hashing to maximize randomness and minimize collisions between elements to keys.

### Hashing benefits
Hashing is simply a function. It takes in an input, and spits out an output.
As an example, we could use mod as a function:

1 mod (3) = 1

2 mod (3) = 2

3 mod (3) = 0

4 mod (3) = 1

In our case, this is could be our function for our hashmap, but it would lead to high collisions and low randomness
as there are only 3 possible key results: 0, 1, and 2.
Thus, Hashmaps are only efficient as the choosen function.

With a good Hash function:
Hash tables are O(1)
In this case, every element gets its own unique key.
Looking inside this key would be immediate O(1)

With a bad Hash function:
Hash tables are O(n). (say our function maps everything to the value of 2)
In this case, too many elements (every element) were hashed into the same key (value of 2).
Looking inside this key would be the same as traversing a list, O(n) 

### Balancing
Balancing occurs when a hash table has passed its set load factor.

Load Factor = n/m
Where n: num of elements, m: num of slots

Thus, when certain fraction of the table size, say 0.75% full, the table must increase in size and rehash/reinsert every element. 

The efficiency of a hash table decreases significally without balancing, as this leads to increased collisions as the table fills up.
Additionally, increased collions leads to increased time to resolving collisions, as we must traverse in inner list to find the element.
Operations like search, insert, and delete, degrade from O(1) on average to O(n) in the worst case.

When rehashing, we must rehash every element with the new hash function. 
It is expensive as we get O(n) for resizing and reinserting n elements.

Usually, when the load factor is reached, the table size doubles to 2n.
And usually, a common load factor is 0.75 or 75% full.
Finally, we must rehash every element leading to:
[(double table size * load factor) - current n elements] = 

(2n * 0.75) - n  =

1.5n - n =

0.5n =

n/2 = additional space after rebalancing

### Application
Hashmaps having quick O(1) average time for insert(), lookup(), and delete(), 
are great for storing key pairs of lists of elements to perform more complex tasks 
where performance in time and space complexity are important.

Lets see some examples.

## 217. Contains Duplicate - Easy

### Intro
> Given an integer array nums, return true if any value appears at least twice in the array, 
> return false if every element is distinct.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,2,3,1] | true   |
| nums = [1,2,3,4] | false  |  
| nums = [1,1,1,3,3,4,3,2,4,2] | true |
 
### Constraints
Array Length: 1 &le; nums.length &le; 10<sup>5</sup>

Integer Size: -10<sup>9</sup>  &le; nums[i] &le; 10<sup>9</sup> 


### Abstraction
Given a list of elements, we need to check if any of those elements are duplicated.

Time Lower Bound: 
We are required to traverse the list to peak at every element at least once, best possible time complexity is O(n).

Space Upper Bound: 
If we want to track every element, best space complexity is O(n)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force | O(n<sup>2</sup>) | O(1) | For each pair of elements, we compare them, leading to quadratic number of comparison O(n<sup>2</sup>)  | No additional memory is allocated O(1) |
| Hashmap | O(n) | O(n) | Iterate over every element O(n), with O(1) lookup and insertion into the map, leading to linear time O(n) | We store each each element in a hashmap, which requires additional memory proportional to the number of elements O(n) |
| Hashset | O(n) | O(n) | Same logic as Hashmap | Same logic as Hashmap |


### Brute Force
```python
    def containsDuplicate_bruteforce(self, nums: List[int]) -> bool:
        # compare every element, with every element
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j]:
                    return True
        return False
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer Loop | O(n) | O(1) | Iteration over the list takes linear time O(n) | No additional memory is allocated O(1) |
| Inner Loop | O(n<sup>2</sup>) | O(1) | For each element in the outer loop, the inner loop iterates through all subsequent elements with Big(O) is O(n<sup>2</sup>). Derivation [here](/blogs/common-formulas#brute-case-double-for-loop) | No additional memory is allocated O(1) |
| Comparison | O(1) | O(1) | Each pair of elements is compared in constant time O(1) | No additional memory is needed for comparisons O(1) |
| Overall | O(n<sup>2</sup>) | O(1) | The inner loop dominates leading to O(n<sup>2</sup>) time complexity.| No additional memory was allocated leading to constant O(1) space complexity. | 


### Solution 1: Hashmap
```python
    def containsDuplicate_hashmap(self, nums: List[int]) -> bool:
        # hashmap, subtype of dictionary
        seen = {}
        # for every element, check if element count >= 1
        for num in nums:
            if num in seen and seen[num] >= 1:
                return True
            seen[num] = seen.get(num, 0) + 1
        return False
```
```python
    def containsDuplicate_defaultdict(sef, nums: List[int]) -> bool:
        # defaultdict automatically initializes missing keys to 0
        seen = defaultdict(int)
        for num in nums:
            if seen[num] >= 1:
                return True
            seen[num] += 1
        return False
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration + Insertion | O(n) | O(n) | Iteration over the list takes linear time O(n) with insertion into Hashmap in O(1) time. Iteration dominates O(n). | Hashmap grows proportional to the number of unique elements. Worst case O(n) |
| Lookup | O(1) | O(1) | Each loopup is O(1), performed once per element | Lookup operations do not require additional memory allocation. |
| Overall | O(n) | O(n) | Iteration dominates over insertion for time complexity linearly for O(n) | Memory allocation for Hashmap dominates leading to O(n) space complexity.  | 


### Solution 2: Hashset

```python
    def containsDuplicate_hashset(self, nums: List[int]) -> bool:
        # hashset
        seen = set()
        # for every eleemnt, check if element present in hashset
        for n in nums:
           if n in seen:
              return True
           seen.add(n)
        return False
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration + Insertion | O(n) | O(n) | Iteration over the list takes linear time O(n) with insertion into Hashset in O(1) time. Iteration dominates O(n). | Hashset grows proportional to the number of unique elements. Worst case O(n) |
| Lookup | O(1) | O(1) | Lookup operation O(1), performed once per element, is still O(1) | Lookup operations do not require additional memory allocation. O(1) |
| Overall | O(n) | O(n) | Iteration dominates over insertion for time complexity linearly for O(n) | Memory allocation for Hashset dominates leading to O(n) space complexity.  | 


## 242. Valid Anagram - Easy

### Intro

> Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.


|  Example Input 'S'  | Example Input 'T' | Output |  
| ------------------- | ----------------- | ------ | 
| "anagram"           | "nagaram"         | true   |
| "rat"               | "car"             | false  |  


### Constraints

String Length: 1 &le; s.length, t.length &le; 5 * 104

Characters: s and t consist of lowercase English letters

### Abstraction

Given a string, we represent its character count as a Hashmap.
We then validate it to the second string character count.

Time Lower Bound: We are required to traverse both strings to peak at every element at least once, best possible time complexity is O(n).

Space Upper Bound: If we want to track every element, best space complexity is O(n)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force | O(n log n) | O(n) | Sorting an individual string O(n log n) dominates as comparing strings by character sequentially is linear O(n) | No additional memory is allocated O(1) |
| Hashmap | O(n) | O(n) | Iteration over the list takes linear time O(n), with O(1) lookup and insertion into the map, leading to linear time O(n) | We store each each element in a hashmap, which requires memory proportional to the number of elements O(n) |
| Hashmap (array of 26) | O(n) | O(n) | Same as logic as Hashmap | Same as logic as Hashmap |

### Brute Force
```python
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
            # Implementing merge sort
        def merge_sort(string):
            if len(string) <= 1:
                return string
            
            mid = len(string) // 2
            left = merge_sort(string[:mid])
            right = merge_sort(string[mid:])
            
            return merge(left, right)
        
        def merge(left, right):
            sorted_list = []
            i = j = 0
            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    sorted_list.append(left[i])
                    i += 1
                else:
                    sorted_list.append(right[j])
                    j += 1
            sorted_list.extend(left[i:])
            sorted_list.extend(right[j:])
            return sorted_list

        # Sort both strings and compare
        sorted_s = merge_sort(list(s))
        sorted_t = merge_sort(list(t))
        return sorted_s == sorted_t
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Sorting | O(n log n) | O(n) | Sorting the strings involves recursively dividing the input and merging them back leading to O(n log n) time complexity. Merge sort derivation [here](/blogs/common-formulas#merge-sort). | Temporary arrays are used during merging, leading to O(n) space |
| Comparison | O(n) | O(1) | Comparing the sorted strings character by-element takes linear time | No additional memory is allocated O(1) |
| Overall | O(n log n) | O(n) | Sorting dominates the time complexity as comparison adds negligible overhead leading to O(n log n) time complexity. | Temporary arrays required for merge sort is proportional to input size leading to O(n) space complexity. |


### Solution 1: Hashmap

```python
    def isAnagram(self, s: str, t: str) -> bool:
        # hashmap
        count = defaultdict(int)
        for x in s:
           count[x] += 1
        for x in t:
           count[x] -= 1
        for value in count.values():
           if value != 0:
               return False
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Building Map + Insertion | O(n) | O(n) | Iterating over the first string takes linear time O(n) with O(1) insertion. | Hashmap size depends on the number of unique characters in the input. Worst case O(n) |
| Editing Map | O(n) | O(1) | Iterating over the second string to edit the Hashset takes linear time O(n) | No additional memory is allocated O(1) |
| Verification | O(n) | O(1) | Iterating over the Hashmap takes linear time O(n) | No additional memory is allocated O(1) |
| Overall | O(n) | O(n) | Character counting and verification result in O(3n) which Big(O) abstracts to O(n). | Memory allocation for Hashmap dominates leading to O(n) space complexity |

### Solution 2: Hashmap (array of 26)
```python
    def isAnagram(self, s: str, t: str) -> bool:
        # hashmap (as an array)
        count = [0] * 26
        for x in s:
           count[ord(x) - ord('a')] += 1
        for x in t:
           count[ord(x) - ord('a')] -= 1
        for value in count:
           if value != 0:
              return False
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Building Array | O(n) | O(1) | Iterating over the first string to populate the Array takes linear time O(n) | Fixed-sized array of 26 elements is used O(1) |
| Editing Array | O(n) | O(1) | Iterating over the second string to edit the Array takes linear time O(n) | No additional memory is allocated O(1) |
| Verification | O(n) | O(1) | Iterating over the Array takes linear time O(n) | No additional memory is allocated O(1) |
| Overall | O(n) | O(1) |  counting and verification result in O(3n) which Big(O) abstracts to O(n) | Space usage optimal due to a constant size array O(1) |



## 1. Two Sum - Easy

### Intro
> Given an array of integers nums and an integer target, return indices of the two numbers
> such that they add up to target. You may assume that each input would have exactly one solution, 
> and you may not use the same element twice. You can return the answer in any order.

|  nums[]         | Target    | Output |  
| --------------- | ----------| ------ | 
| [2,7,11,15]     | 9         | [0,1]  |
| [3,2,4]         | 6         | [1,2]  |  
| [3,3]           | 6         | [0,1]  |

### Constraints
Only one valid answer exists

length: 2 &le; nums.length &le; 10^4

target: -10^9 &le; target &le; 10^9

### Abstraction
We must find a combination of two elements in the array that add up to the target. 

Lets say we were to iterate over the array linearly in O(n). 
At any given moment, if we are pointing to some index n, 
we would only have half of a potential solution. We would still need to confirm that a second element adds up to target. 

Note that during this linear iteration, we would still have access to the target.

Since we are finding (target = currNum + complement) we can do (target - currNum = complement) 
and get the second half of the solution.
If this complement is present in the Array, then that is our final solution. 
Our next step is finding that complement.

Since we are traversing the array, we can build up a hashset of elements we have seen, and use these as a 
complement -> key -> index mapper for future elmements.

The pattern to find the pair is is to iterate, grab element in array, caluclate the complement, 
and check if complement is inside hashset.

Finally, since the question asks us to return the index of the pair, we must use a Hashmap with
(element, index) where element is the complement that maps to the it's index in the Array.

Time Lower Bound: We are required to traverse the list to peak at every element at least once, best possible time complexity is O(n).

Space Upper Bound: If we want to track every element/complement, best space complexity is O(n)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap 1-pass |  |  |  |  |


### Brute Force
```python
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        # iterate over list comparing every element to each other
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
              if nums[i] + nums[j] == target:
                   return [i, j]
        return []
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer Loop | O(n) | O(1) | Iterates over the array once for each element O(n) | No additional memory is allocated O(1) |
| Inner Loop | O(n) | O(1) | For each element in the outer loop, iterates through all remaining elements O(n<sup>2</sup>)  | No additional memory is allocated O(1) |
| Summation | O(1) | O(1) | Summing two numbers takes constant time O(1) | No additional space is needed for summation. |
| Comparison | O(1) | O(1) | Each pair of elements is compared in constant time O(1) | No additional space is needed for comparisons O(1) |
| Overall | O(n<sup>2</sup>) | O(1) | The nested loops result in O(n<sup>2</sup>) time complexity. Derivation of average case is found O(n<sup>2</sup>) is found [here](/blogs/common-formulas#brute-case-double-for-loop). | No additional space was allocated, so it is independent of input size O(1) | 


### Solution 1: Hashmap 1-pass
```python
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        # map of {complement: index, complement: index...}
        tracking = {}
 
        for i in range (len(nums)):

            # grab curr complement -> (target = nums[i] + complement)  
            complement = target - nums[i]

            # if complement has been tracked
            if complement in tracking:
                
                # [curr_index, complement_index]
                return [i, tracking[complement]]
    
            # if miss, track currElement as potential complement
            tracking[nums[i]] = i

        return []
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Building Hashmap | O(n) | O(n) | Iterating over the first string to populate a Hashmap takes linear time O(n) | Hashmap size is proportional to the number of unique integers. Worst case O(n). |
| Lookup | O(1) | O(1) | Each lookup operation takes constant O(1) time. | Lookups do not require additional memory. |
| Insertion | O(1) | O(n) |Each insertion operation takes constant O(1) time. | Hashmap size is proportional to the number of unique integers. Worst case O(n). |
| Overall | O(n) | O(n) | Iterating dominates time complexity leading to linear O(n) time complexity. | Memory allocation for Hashmap dominates leading to O(n) space complexity. |


## 49. Group Anagrams - Medium

### Intro
> Given an array of strings strs, group the anagrams together. You can return the answer in any order.
> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, 
> typically using all the original letters exactly once.

|  Input                                   | Output                                      |  
| ---------------------------------------- | ------------------------------------------- | 
| ["eat","tea","tan","ate","nat","bat"]    | [["bat"],["nat","tan"],["ate","eat","tea"]] |
| [""]                                     | [[""]]
| ["a"]                                    | [["a"]]           


### Constraints
strs[i] consists of lowercase English letters


### Abstraction
There are different ways to solve this problem. 

One premise is that a string can be represented as a Hashmap of character counts.
We could then use the Hashmaps as keys which would group anagrams in a list of strings:
Hashmap(Hashmap(char_count) -> [anagram list string]) 

Another premise is we could sort the string and use that as the key: 
Hashmap ( sorted_string -> [[unsorted anagram string group]])

Time Lower Bound: We are required to traverse the list to peak at every string at least once O(n). We also need to calculate character frequencies to determine anagrams O(k). Best possible time complexity is O(n * k).

Space Upper Bound: If we want to track every character count Hashmap per every string, best space complexity is O(n * k)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force | O(n<sup>2</sup> * k) | O(1) | For each string O(n), compares with every other string O(n), to check if they are anagrams O(k).  | Stores temporary intermediate groups in a list |
| Merge sort | O(n * k log k) | O(n * k) | Sorting each string with merge sort takes O(k log k). Iterating over all strings takes linear O(n). | Requires storage for sorted strings O(k) for O(n) strings, groups are stored in memory |
| Hashmap | O(n * k) | O(n * k) | Iterates over n strings O(n) and computes character count O(k) per string | Uses hashmap where each string O(n) requires O(k) for the key.|

### Brute Force
Not shown in code as is inefficient with O(n<sup>2</sup> k). It checks each string against every other
for inequality.

### Solution 1: Sort Grouping - Merge sort
```python 
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        
        # merge sort algorithm
        def mergeSort(word):
        
            if len(word) <= 1:
                return word
            
            mid = len(word) // 2
            
            left = mergeSort(word[:mid])
            right = mergeSort(word[mid:])
            
            sorted = []
            
            i = j = 0
            
            while i < len(left) and j < len(right):
                if left[i] < right[j]:
                    sorted.append(left[i])
                    i += 1
                else:
                    sorted.append(right[j])
                    j += 1
            
            sorted.extend(left[i:])
            sorted.extend(right[j:])
            
            return ''.join(sorted_word)
    
        anaGroup = {}
        
        for word in strs:
            sorted = mergeSort(word)
            if sorted in hashmap:
                hashmap[sorted].append(word)
            else:
                hashmap[sorted] = [word]
        
        return list(anaGroup.values())
``` 

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Sorting |  |  |  |  |
| Iteration |  |  |  |  |
| Lookup | |  |  |  |
| Overall |  |  |  |   |


### Solution 2: Hashmap -> Tuple Key Grouping
```python
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        
        # <tuple char count key -> [anagram group list]>
        anaGroup = {}

        for word in strs:
            
            # Assuming only lowercase English letters
            char_count = [0] * 26  
            
            for char in word:
                char_count[ord(char) - ord('a')] += 1
            
            # Use tuple of counts as key
            key = tuple(char_count)  
            
            # Initialize a list for this key if it doesn't exist
            if key not in anaGroup:
                anaGroup[key] = []  

            # Add the current word to the corresponding key group
            anaGroup[key].append(word)  

        return list(anaGroup.values())
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Hashmap Building |  |  |  |  |
| Iteration |  |  |  |  |
| Lookup | |  |  |  |
| Overall |  |  |  |   |

### Solution 3: Hashmap -> Manual Key Grouping

```python
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:

        anaGroup = {}

        for word in strs:
            # Initialize character count for all lowercase English letters
            char_count = [0] * 26
            
            # Count the characters in the word
            for char in word:
                char_count[ord(char) - ord('a')] += 1
            
            # Create a unique string key manually, instead of tuple(char_count)
            key = ""
            for count in char_count:
                key += str(count) + "#"  # Add a separator to distinguish between counts

            # Group the word into the hashmap based on the key
            if key not in anaGroup:
                anaGroup[key] = []  # Initialize a list for this key if it doesn't exist
            anaGroup[key].append(word)  # Add the current word to the corresponding key group

        return list(anaGroup.values())
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Hashmap Building |  |  |  |  |
| Iteration |  |  |  |  |
| Lookup | |  |  |  |
| Overall |  |  |  |   |

## 347. Top K Elements in List - Medium

### Intro
> Given an integer array nums and an integer k, return the k most frequent element within the array. 
> Test cases are generated such that the answer is always unique. You may return the output in any order

|  Input             | k     | Output    |  
| -------------------| ----- | --------- | 
| [1,2,2,3,3,3,3]    | 2     | [2,3]     |
| [7,7]              | 1     | [7]       |

### Constraints
most frequent: 1 &le; k &le; number of distinct elements in nums
size: -1000 &le; nums[i] &le; 1000

### Abstraction
To find the k most frequent elements, we must first create an occurrence counter for each element in the list.
Now that we have the count, we just grab the top k highest occurring elements. 

Here the are a few ways to implement that.

Time Lower Bound: 

Space Upper Bound: 


### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap |  |  |  |  |

### Brute Force

### Solution 1: Stack/PushPop

```python
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # occurence char hashmap 
        freq = defaultdict(int)
        for n in nums:
            freq[n] += 1
            
        # heap replaces smaller occur w/ higher occur while maintaining size <= k
        heap = []
        for key, count in freq.items():
            if len(heap) == k:
                heappushpop(heap, (count, key))
            else:
                heappush(heap, (count, key))
        return [item[1] for item in heap]
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Hashmap Building |  |  |  |  |
| Iteration |  |  |  |  |
| Lookup | |  |  |  |
| Overall |  |  |  |   |

### Solution 2: Bucket Sort

```python
    def topKFrequent(self, nums: List[int], k:int) -> List[int]:
            
        # occurrence hashmap 
        num_count = {}
        for key in nums:
            num_count[key] = 1 + num_count.get(key, 0)

        # list comprehension - create len() empty buckets 
        num_buckets = len(nums) + 1  # empty list requires at least 1 bucket
        freq_buckets = [[] for i in range(num_buckets)]

        # sort into buckets 
        for num, occurrences in num_count.items():
            freq_buckets[occurrences].append(num)

        res = []

        # decreasing for loop, starting by grabbing highest bucket
        for i in range(len(freq_buckets) - 1, 0, -1):
            
            # grabbing elements in curr bucket
            for num in freq_buckets[i]:
                res.append(num)
                
                # check if kth reached
                if len(res) == k:
                    return res
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Hashmap Building |  |  |  |  |
| Iteration |  |  |  |  |
| Lookup | |  |  |  |
| Overall |  |  |  |   |


## 271. String Encode and Decode - Medium

### Intro

> Design an alogirthm to encode a list of strings to a single string.
> The encoded string is then decoded back to the original list of strings
> Please implement `encode` and `decode`

|  Input                           | Output                              |  
| -------------------------------- | ----------------------------------- | 
| ["leet", "code", "love", "you"]  | ["leet", "code", "love", "you"]     |
| ["we", "say", ":", "yes"]        | ["we", "say", ":", "yes"]           |

### Contraints

### Abstraction
This is leaning into being a design problem. 

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap |  |  |  |  |

### Solution 1: i & j pointers

```python 
class Solution:

    # example: "5#hello3#bye"
    
    def encode(self, strs: List[str]):
        ans = "" 
        for word in strs:
            ans += str(len(word)) + "#" + word

        return ans
    
    # decode above pattern
    def decode(self, s: str):
        ans = []
        i = 0

        # complete until end of encoded string
        while i < len(s):
            j = i

            # find the #
            while s[j] != "#":
                j += 1
            
            # anything left will be int
            length = int(s[i:j])

            # point to start of string
            i = j + 1 

            # point to +1 after string (for substringing)
            j = i + length

            # grab string 
            ans.append(s[i:j])

            # start of next section
            i = j

        return ans
```

Seemingly a confusing problem, since we are designing the encoding method we 
can make it as simple as possible. 


## 238. Product of Array Except Self - Medium

### Intro
>Given an integer array nums, return an array answer such that answer[i] is 
>equal to the product of all the elements of nums except nums[i].
>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
>You must write an algorithm that runs in O(n) time and without using the division 
>operation.

|  Input         | Output          |  
| -------------- | --------------- | 
| [1,2,3,4]      | [24,12,8,6]     |
| [-1,1,0,-3,3]  | [0,0,9,0,0]     |

### Constraints
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer

### Abstraction
The statement as always seems more complex that the breakdown.
Given a list of nums, return a list of nums that is the product of the array except itself.

So, for som num n, the result should be the product of all the numbers to the left of it,
times the product of all the numbers to the right of it:

| 0 ... n-1 |  `n` | n+1 ... len(nums)-1 |

| product | `n` | product | 

We will call the `prefix the product on the left side` and the `postfix the product on the right side`.

If we traverse the array from left to right, we can `calculate the prefix and place it in the result array`.

For the postfix, since we cant just store and grab the postfix as we go (the `previously calculated prefix is already stored
in the array`). We just `need an extra integer to store the current postfix` and use this to generate the result we need.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap |  |  |  |  |

### Solution 1:  Prefix & Postfix
```python
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        
        # create result array 
        res = [1] * (len(nums))

        # prefix for nth is product of (0 ... (n-1))
        for i in range(1, len(nums)):
            prefix = res[i-1] * nums[i-1]  # prefix of curr num  = (previous prefix * nums[i-1])
            res[i] = prefix                # set prefix for curr num

        # need holder as array is not set to 1
        postfix = 1 # postfix of next num

        # postfix for nth is product of (n+1 .... (len(nums)-1))
        for i in range(len(nums) - 1, -1, -1):
            res[i] = res[i] * postfix     # set postfix for curr num
            postfix = nums[i] * postfix   # postfix of next num
        return res
```


## 36. Valid Sudoku - Medium

### Intro
> Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
> Each row must contain the digits 1-9 without repetition.
> Each column must contain the digits 1-9 without repetition.
> Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

### Constraints
A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.


|  Input         | Output          |  
| -------------- | --------------- | 
|                |                 | 

### Abstraction
Here, we are looking for duplicates much like the original `217. Contains Duplicates`.

The only difference here, is that we are looking for duplicates in 3 sets along the rows, columns, and 3x3 squares.

So we simply create sets for all of these groups and as we traverse the board, we check for duplicates

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap |  |  |  |  |

### Solution 1: defaultdict()
```python 
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = defaultdict(set)
        rows = defaultdict(set)
        squares = defaultdict(set) # tuple key = (r /3, c /3)

        for r in range(9):
            for c in range(9):
                
                tmp = board[r][c]

                if tmp == ".":
                    continue
                
                if (tmp in rows[r] or 
                    tmp in cols[c] or 
                    tmp in squares[(r // 3, c // 3)] ):
                    return False
                
                cols[c].add(tmp)
                rows[r].add(tmp)
                squares[(r // 3, c // 3)].add(tmp)

        return True
```

### Solution 2: Faster Manual []
```python
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows = [[], [], [], [], [], [], [], [], []]
        col = [[], [], [], [], [], [], [], [], []]
        boxes = [[], [], [], [], [], [], [], [], []]

        for i in range(9):
            for j in range(9):
                tmp = board[i][j]
                if tmp != ".":    
                    box = 3 * (i//3) + (j//3)
                    if (tmp in rows[i] or 
                       tmp in col[j]  or 
                       tmp in boxes[box]):
                        return False

                    col[j].append(tmp)
                    rows[i].append(tmp)
                    boxes[box].append(tmp)

        return True
```

Solution 2 ends up being faster than Solution 1:

While sets are generally more efficient for larger and more dynamic data due to constant-time 
lookups and insertions, for a fixed-size 9x9 board like this, the overhead introduced by defaultdict and 
set operations can make the list-based approach faster in practice. 


## 128. Longest Consecutive Sequence - Medium

### Intro
> Given an array of integers nums, return the length of the longest consecutive sequence of elements.
> A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than 
> the previous element
> You must wrtie an algorithm that runs in O(n) time.

|  Input                    | Output  |  
| ------------------------- | ------- | 
| [2, 20, 4, 10, 3, 4, 5]   | 4       | 
| [0, 3, 2, 5, 4, 6, 1, 1]  | 7       |


### Constraints

### Abstraction
As usual, our goal is to translate this problem into something that is easier. 

A longest consecutive sequence on a number line would look like this:

[ 12, 1, 13, 0, 7, 2, 3, 11, 4] ---> 

| 0 1 2 3 4 |  ..... | 7 | ..... | 11 12 13 | 

Here, it is very simple to see what is the longest sequence.
Now the question is how to translate into this.
A set would be the easiest as we can simply check if some element exists 

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  | |
| Hashmap |  |  |  |  |

### Solution 1: Set abstraction
```python
def longestConsecutive(self, nums: List[int]) -> int: 
    numSet = set(nums)
    longest = 0
    for i in numSet:
        # found start of a sequence (left most element)
        if (i - 1) not in numSet: 
            currLen = 1
            while (i + currLen) in numSet:
                currLen += 1 
            longest = max(longest, currLen)

    return longest        
```
