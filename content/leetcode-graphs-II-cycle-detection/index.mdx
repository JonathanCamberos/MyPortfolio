---
title: "LeetCode: Graphs II Cycle Detection"
description: "advanced graphs"
image: "../../public/Notes/cycle-detection.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Cycle Detection Algorithm Intro

## Intro
Cycle Detection in a graph determines whether the graph contains a loop,
a path that starts and ends at the same vertex.

In directed graphs, cycles follow the direction of edges
In undirected graphs, cycles are formed if a vertex is 
reachable through a path other than its parent

Fundamental in graph validation, scheduling, and dependency resolution.

## Graph Requirements
1. Directed or Undirected
2. Represented Using:
    - Adjacency List
    - Adjacency Matrix

## Output
True or False whether a cycle exists
Optionally, can return that actual cycle path

## Video Animation
Cycle Detection: https://www.youtube.com/watch?v=tg96sZqhXyU

## Undirected Pseudo Code
```python
    def has_cycle_undirected(graph):
        visited = set()

        def dfs(node, parent):
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor, node):
                        return True
                elif neighbor != parent:
                    return True
            return False

        for node in graph:
            if node not in visited:
                if dfs(node, -1):
                    return True
        return False
```

## Directed Pseudo Code
```python
    def has_cycle_directed(graph):
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbor in graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

## Time Complexity
Each vertex visited once
Each edge processed once

O(V + E)

## Space Complexity
Visited set: O(V)
Recursion Stack/Call Stack: O(V)

## IRL Use Case
- Deadlock Detection in OS
    Detect circular wait conditions among processes
- Dependency Management
    Detect Circular Library or Module dependencies


# 207. Course Schedule ::2:: - Medium

Topics:  Depth First Search, Breadth First Search, Graph, Topological Sort

## Intro
> There are a total of numCourses courses you have to take, 
> labeled from 0 to numCourses - 1. You are given an array 
> prerequisites where prerequisites[i] = [ai, bi] 
> indicates that you must take course bi first if you want to 
> take course ai.
> For example, the pair [0, 1], indicates that to take
> course 0 you have to first take course 1.
> Return true if you can finish all courses. Otherwise, 
> return false.


|  Example Input           | Output |  
| ---------------- | ------ | 
| numCourses = 2, prerequisites = [[1,0]] | true |
| numCourses = 2, prerequisites = [[1,0],[0,1]] | false |

Constraints:

1 &leq; numCourses &leq; 2000

0 &leq; prerequisites.length &leq; 5000

prerequisites[i].length == 2

0 &leq; ai, bi &lt; numCourses

All the pairs prerequisites[i] are unique.

## Abstraction
Given a number of courses and prerequisites, 
determine if you can finish all courses.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: Recursive DFS Cycle Detection - Graph/something
```python
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        
        # Note:
        # 1. Build a graph from prerequisites (course -> list of courses depending on it).
        # 2. Use DFS to detect cycles.
        #    visited[course] = 0: unvisited
        #    visited[course] = 1: visiting (currently in recursion stack)
        #    visited[course] = 2: visited (safe, no cycles in this path)
        # 3. If a cycle is found, return False (cannot finish all courses).
        # 4. Otherwise, all courses can be completed.

        # Build graph
        graph = {i: [] for i in range(numCourses)}
        for course, prereq in prerequisites:
            graph[prereq].append(course)

        # State array
        # 0 = unvisited, 1 = visiting, 2 = visited
        visited = [0] * numCourses

        def dfs(course):
            # Early Prune -> cycle detected
            if visited[course] == 1:
                return False
            # Late Prune -> already processed
            if visited[course] == 2:
                return True

            # Process Root -> mark as visiting
            visited[course] = 1

            # Process Candidates -> traverse neighbors
            for nei in graph[course]:
                if not dfs(nei):
                    return False
            
            # LAte Prune -> mark as visited
            visited[course] = 2
            return True

        # Process Roots -> traverse all courses
        for c in range(numCourses):
            if not dfs(c):
                return False

        # All courses processed, no cycles

        # overall: time complexity
        # overall: space complexity
        return True
```

## Solution 2: Iterative BFS Topological Sort - Graph/something
```python
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        
        # Note:
        # 1. Build graph (course -> list of dependent courses) and indegree array.
        # 2. BFS from courses with indegree 0 (no prerequisites).
        # 3. Reduce indegree of neighbors; add to queue when indegree becomes 0.
        # 4. Count processed courses; if count == numCourses, return True.

        # Init graph and indegree
        indegree = [0] * numCourses
        graph = {i: [] for i in range(numCourses)}
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            indegree[course] += 1

        # Process Roots -> start with courses without prerequisites (0 indegree)
        queue = deque([i for i in range(numCourses) if indegree[i] == 0])
        count = 0

        # Process Candidates -> BFS topological sort
        while queue:
            curr = queue.popleft()
            count += 1
            for nei in graph[curr]:
                indegree[nei] -= 1
                # Early Prune -> neighbor ready to process
                if indegree[nei] == 0:
                    queue.append(nei)

        # Late Prune -> if all courses processed, no cycles
        return count == numCourses
```


# 210. Course Schedule II ::3:: - Medium

Topics:  Depth First Search, Breadth First Search, Graph, Topological Sort

## Intro
> There are a total of numCourses courses you have to take,
> labeled from 0 to numCourses - 1. You are given an array 
> prerequisites where prerequisites[i] = [ai, bi] 
> indicates that you must take course bi first if you want to 
> take course ai.
> For example, the pair [0, 1], indicates that to take 
> course 0 you have to first take course 1.
> Return the ordering of courses you should take to finish all 
> courses. If there are many valid answers, return any of them. 
> If it is impossible to finish all courses, return an empty 
> array.


|  Example Input           | Output |  
| ---------------- | ------ | 
| numCourses = 2, prerequisites = [[1,0]] | [0,1] |
| numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] | [0,2,1,3] |
| numCourses = 1, prerequisites = [] | [0] |

Constraints:

1 &leq; numCourses &leq; 2000

0 &leq; prerequisites.length &leq; numCourses * (numCourses-1)

prerequisites[i].length == 2

0 &leq; ai, bi &lt; numCourses

ai != bi

All the pairs prerequisites[i] are distinct.

## Abstraction
Given a number of courses and prerequisites, 
determine if you can finish all courses, 
and return the order to finish all courses.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: DFS Topological Sort with Cycle Detection - Graph/something
```python
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        # Note:
        # 1. Build graph (prereq -> list of courses that depend on it).
        # 2. Use DFS to perform topological sort and detect cycles.
        #    visited[course] = 0: unvisited
        #    visited[course] = 1: visiting
        #    visited[course] = 2: visited
        # 3. Append course to result post DFS (postorder).
        # 4. If a cycle is detected, return [].
        # 5. Reverse postorder to get valid course order.
        
        # Graph setup
        graph = {i: [] for i in range(numCourses)}
        for course, prereq in prerequisites:
            graph[prereq].append(course)

        # Status array
        visited = [0] * numCourses  # 0 = unvisited, 1 = visiting, 2 = visited
        res = []
        self.is_possible = True

        def dfs(course):
            # Early Prune -> cycle detected
            if visited[course] == 1:
                self.is_possible = False
                return

            # Late Prune -> already processed
            if visited[course] == 2:
                return

            # Process Root -> mark as visited
            visited[course] = 1

            # Process Choices -> neighbors and dependent courses
            for nei in graph[course]:
                dfs(nei)

                # Early exit if cycle
                if not self.is_possible:
                    return

            # Post order append
            visited[course] = 2
            res.append(course)

        # Iterate over all Roots
        for c in range(numCourses):
            if visited[c] == 0:
                dfs(c)
                if not self.is_possible:
                    return []

        # Reverse post order to get correct order
        return res[::-1]
```

## Solution 2: BFS Topological Sort - Graph/something
```python
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        # Note:
        # 1. Build graph (prereq -> dependent courses) and indegree array.
        # 2. BFS from courses with indegree 0 (roots).
        # 3. For each root, decrement indegree of neighbors.
        # 4. Add neighbor to queue if indegree becomes 0.
        # 5. Return order if all courses processed, else [] (cycle detected).
        
        # Graph and indegree setup
        indegree = [0] * numCourses
        graph = {i: [] for i in range(numCourses)}

        for course, prereq in prerequisites:
            graph[prereq].append(course)
            indegree[course] += 1

        # Process Roots -> courses with no prerequisites
        queue = deque([i for i in range(numCourses) if indegree[i] == 0])
        res = []

        while queue:
            curr = queue.popleft()
            res.append(curr)

            # Early Choices -> decrement indegree of neighbors 
            for nei in graph[curr]:
                indegree[nei] -= 1

                # Early Prune -> add to queue when indegree is 0
                if indegree[nei] == 0:
                    queue.append(nei)

        # Check for cycles -> if all courses processed
        return res if len(res) == numCourses else []
```
