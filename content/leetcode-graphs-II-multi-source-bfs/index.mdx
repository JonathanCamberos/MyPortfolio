---
title: "LeetCode: Graphs II Multi Source BFS"
description: "advanced graphs"
image: "../../public/Notes/multi-source-bfs.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Multi Source BFS Algorithm Intro

## Intro
Multi Source BFS is an extension of Breadth First Search where we start BFS 
simultaneously from multiple source nodes.

It is commonly used to propagate distance or spread signals from multiple starting
points and find shortest distances to all nodes or earliest reach times.

Unlike regular BFS single source, we enqueue all sources initially
and expand layer by layer

## Graph Requirements
1. Unweighted or uniformly weighted graph (BFS gives shortest paths in unweighted graphs)
2. Directed or Undirected
3. Represented Using:
    - Adjacency List
    - Adjacency Matrix

## Output
Shortest distance from the nearest source node to every other node

Can also track levels or earliest arrival times from any source

Useful for problems like 'spread of infection' or 'fire spread'

## Video Animation
Multi Source BFS: ?

## Pseudo Code
```python
    def multi_source_bfs(graph, sources):

        visited = set(sources)
        distance = {node: 0 for node in sources}  # Distance from nearest source
        queue = deque(sources)

        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    distance[neighbor] = distance[node] + 1
                    queue.append(neighbor)

        return distance
```

## Time Complexity
Each node is visited at most once
Each edge is processed at most once

O(V + E)


## Space Complexity
Queue: O(V)
Visited Set: O(V)
Distance Map: O(V)

O(V)


## IRL Use Case
- Fire/Contamination Spread Simulation
    Track earliest time fire or infection reaches each point from multiple starting locations

- Network Signal Propagation
    Spread from multiple routers in a network


# 994. Rotting Oranges ::2:: - Medium

Topics:  Array, Breadth First Search, Matrix

## Intro
> You are given an m x n grid where each cell can have one of 
> three values:
> 0 representing an empty cell,
> 1 representing a fresh orange, or
> 2 representing a rotten orange.
> Every minute, any fresh orange that is 4-directionally adjacent to 
> a rotten orange becomes rotten.
> Return the minimum number of minutes that must elapse until no
> cell has a fresh orange. If this is impossible, return -1.


|  Example Input           | Output |  
| ---------------- | ------ | 
| grid = [[2,1,1],[1,1,0],[0,1,1]] | 4 |
| grid = [[2,1,1],[0,1,1],[1,0,1]] | -1 |
| grid = [[0,2]] | 0 |

Constraints:

m == grid.length

n == grid[i].length

1 &leq; m, n &leq; 10

grid[i][j] is 0, 1, or 2.

## Abstraction
Given a grid with oranges, return how much time until no fresh oranges remain.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: Iterative BFS Rotten Multi Source with Global Minutes Overwrite - Graph/something
```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        # Note:
        # 1. Start BFS from all initially rotten oranges (multi-source BFS)
        # 2. Each BFS level = 1 minute of rotting spread
        # 3. Track fresh oranges count, decrement when they rot
        # 4. Return minutes if all fresh rot, else -1

        # Empty check
        if not grid:
            return -1

        # boundaries
        m, n = len(grid), len(grid[0])

        # count
        fresh = 0

        # time
        minutes = 0

        # iterative queue
        queue = deque()

        # set up multi source BFS
        for r in range(m):
            for c in range(n):

                # Append Rotten Source to BFS
                if grid[r][c] == 2:
                    # (row, col, minute)
                    queue.append((r, c, 0))
                
                # Add to fresh count
                elif grid[r][c] == 1:
                    fresh += 1

        # iterate over rotten sources
        while queue:

            # next rotten orange
            # minutes will be overwritten by pop,
            # last pop will have the longest and final minute count
            r, c, minutes = queue.popleft()

            # Process Choices -> 
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc

                # Early Prune -> : valid boundary and fresh orange
                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                    grid[nr][nc] = 2
                    fresh -= 1
                    
                    # add to time and pass down
                    queue.append((nr, nc, minutes + 1))

        # total time taken if no oranges remain, else fresh orange remain so -1
        res = minutes if fresh == 0 else -1

        # overall: time complexity
        # overall: space complexity
        return res
```

## Solution 2: Iterative BFS Rotten Multi Source with Level Processing Minutes Trigger - Graph/something
```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        
        # Note:
        # 1. Instead of storing time in queue, process BFS by levels
        # 2. Each level of queue expansion corresponds to +1 minute
        # 3. Track number of fresh oranges, ensure all rot or return -1

        # Empty check
        if not grid:
            return -1

        # boundaries
        m, n = len(grid), len(grid[0])

        # count
        fresh = 0

        # time
        minutes = 0

        # iterative
        queue = deque()

        # set up multi source BFS
        for r in range(m):
            for c in range(n):

                # append rotten source to queue
                if grid[r][c] == 2:
                    queue.append((r, c))

                # add to fresh count
                elif grid[r][c] == 1:
                    fresh += 1

        # iterate over rotten sources
        while queue and fresh > 0:

            # Process roots -> process all sources at this level
            for _ in range(len(queue)):

                # next candidate
                r, c = queue.popleft()

                # Process Choices -> : visit neighbors
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc

                    # Early Pruning -> valid bounds and fresh fruit
                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                        grid[nr][nc] = 2
                        fresh -= 1

                        # add next rotten source to queue
                        queue.append((nr, nc))

            # iterate tick for next source level
            minutes += 1

        # total time taken if no oranges remain, else fresh orange remain so -1
        res = minutes if fresh == 0 else -1

        # overall: time complexity
        # overall: space complexity
        return res
```

