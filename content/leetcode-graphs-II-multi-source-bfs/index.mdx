---
title: "LeetCode: Graphs II Multi Source BFS"
description: "advanced graphs"
image: "../../public/Notes/multi-source-bfs.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Multi Source BFS Algorithm Intro

## Intro
Multi Source BFS is an extension of Breadth First Search where we start BFS 
simultaneously from multiple source nodes.

It is commonly used to propagate distance or spread signals from multiple starting
points and find shortest distances to all nodes or earliest reach times.

Unlike regular BFS single source, we enqueue all sources initially
and expand layer by layer

## Graph Requirements
1. Unweighted or uniformly weighted graph (BFS gives shortest paths in unweighted graphs)
2. Directed or Undirected
3. Represented Using:
    - Adjacency List
    - Adjacency Matrix

## Output
Shortest distance from the nearest source node to every other node

Can also track levels or earliest arrival times from any source

Useful for problems like 'spread of infection' or 'fire spread'

## Video Animation
Multi Source BFS: ?

## Pseudo Code
```python
    def multi_source_bfs(graph, sources):

        visited = set(sources)
        distance = {node: 0 for node in sources}  # Distance from nearest source
        queue = deque(sources)

        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    distance[neighbor] = distance[node] + 1
                    queue.append(neighbor)

        return distance
```

## Time Complexity
Each node is visited at most once
Each edge is processed at most once

O(V + E)


## Space Complexity
Queue: O(V)
Visited Set: O(V)
Distance Map: O(V)

O(V)


## IRL Use Case
- Fire/Contamination Spread Simulation
    Track earliest time fire or infection reaches each point from multiple starting locations

- Network Signal Propagation
    Spread from multiple routers in a network


# 994. Rotting Oranges ::2:: - Medium

Topics:  Array, Breadth First Search, Matrix

## Intro
> You are given an m x n grid where each cell can have one of 
> three values:
> 0 representing an empty cell,
> 1 representing a fresh orange, or
> 2 representing a rotten orange.
> Every minute, any fresh orange that is 4-directionally adjacent to 
> a rotten orange becomes rotten.
> Return the minimum number of minutes that must elapse until no
> cell has a fresh orange. If this is impossible, return -1.


|  Example Input           | Output |  
| ---------------- | ------ | 
| grid = [[2,1,1],[1,1,0],[0,1,1]] | 4 |
| grid = [[2,1,1],[0,1,1],[1,0,1]] | -1 |
| grid = [[0,2]] | 0 |

Constraints:

m == grid.length

n == grid[i].length

1 &leq; m, n &leq; 10

grid[i][j] is 0, 1, or 2.

## Abstraction
Given a grid with oranges, return how much time until no fresh oranges remain.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: [Multi Source BFS] Iterative BFS Rotten Multi Source with Global Minutes Overwrite - Graph/something
```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        
        # Multi Source BFS (Time Stored In Queue)
        # Determine minimum minutes required for all fresh oranges to rot

        # Idea:
        # - Start BFS from ALL rotten oranges simultaneously
        # - Each expansion spreads rot to neighbors
        # - Time (minutes) is carried inside queue state

        # BFS Property:
        # First time an orange is visited = earliest minute it rots

        # Edge Case + Setup

        # Empty Check: no time
        if not grid:
            return -1

        # boundaries
        # sc: O(1)
        m, n = len(grid), len(grid[0])

        # Count Fresh Oranges
        fresh = 0

        # Final Elapsed Time
        minutes = 0

        # Iterative Queue Holds: (row, col, minute)
        # sc: O(m*n)
        queue = deque()

        # Multi Source Setup
        # Iterate across all cells
        # tc: O(m*n)
        for r in range(m):
            for c in range(n):

                # Append ALL rotten oranges as BFS roots
                if grid[r][c] == 2:
                    # add rotten orange as (row, col, minute)
                    queue.append((r, c, 0))
                
                # Add to fresh count
                elif grid[r][c] == 1:
                    fresh += 1

        # BFS Traversal:
        # Each poop represents earliest time this cell rots
        # tc: O(m*n) each cell processed once
        while queue:

            # Process Root
            r, c, minutes = queue.popleft()

            # Process Choices:
            # 4 direction spread
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc

                # Early Prune:
                # valid bounds + fresh orange
                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:

                    # Rot orange immediately
                    grid[nr][nc] = 2
                    fresh -= 1
                    
                    # Pass next minute down BFS
                    queue.append((nr, nc, minutes + 1))

        # Final Validation:
        # if fresh oranges remain, they are unreachable
        res = minutes if fresh == 0 else -1

        # overall: tc O(m*n)
        # overall: sc O(m*n)
        return res
```

## Solution 2: [Multi Source BFS] Iterative BFS Rotten Multi Source with Level Processing Minutes Trigger - Graph/something
```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        
        # Multi Source BFS (Time Stored In Queue)
        # Determine minimum minutes required for all fresh oranges to rot

        # Idea:
        # - Start BFS from ALL rotten oranges simultaneously
        # - Each expansion spreads rot to neighbors
        # - Time (minutes) is carried inside queue state

        # BFS Property:
        # First time an orange is visited = earliest minute it rots

        # Edge Case + Setup

        # Empty Check: no time
        if not grid:
            return -1

        # boundaries
        # sc: O(1)
        m, n = len(grid), len(grid[0])

        # Count Fresh Oranges
        fresh = 0

        # Final Elapsed Time
        minutes = 0

        # Iterative Queue Holds: (row, col, minute)
        # sc: O(m*n)
        queue = deque()

        # Multi Source Setup
        # Iterate across all cells
        # tc: O(m*n)
        for r in range(m):
            for c in range(n):

                # Append ALL rotten oranges as BFS roots
                if grid[r][c] == 2:
                    # add rotten orange as (row, col, minute)
                    queue.append((r, c, 0))
                
                # Add to fresh count
                elif grid[r][c] == 1:
                    fresh += 1

        # BFS Traversal:
        # Each poop represents earliest time this cell rots
        # tc: O(m*n) each cell processed once
        while queue and fresh > 0:

            # Process Multiple Roots:
            # All sources at this level
            for _ in range(len(queue)):

                # Process current root
                r, c = queue.popleft()

                # Process Choices:
                # 4 direction spread
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc

                    # Early Pruning:
                    # Valid bounds and fresh fruit
                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:

                        # Rot orange immediately
                        grid[nr][nc] = 2
                        fresh -= 1

                        # Add next rotten source to queue
                        queue.append((nr, nc))

            # Iterate global minutes tick for next source level
            minutes += 1

        # Final Validation:
        # if fresh oranges remain, they are unreachable
        res = minutes if fresh == 0 else -1

        # overall: tc O(m*n)
        # overall: sc O(m*n)
        return res
```

# 286. Walls and Gates ::2:: - Medium

Topics:  Hash Table, Depth First Search, Breadth First Search, Graph

## Intro
> You are given a (m) x (n 2D) grid initialized with 
> these three possible values:
> -1 - A water cell that can not be traversed.
> 0 - A treasure chest.
> INF - A land cell that can be traversed. 
> We use the integer 2^31 - 1 = 2147483647 to represent INF.
> Fill each land cell with the distance to its nearest 
> treasure chest. If a land cell cannot reach a
> treasure chest then the value should remain INF.
> Assume the grid can only be traversed up, down, 
> left, or right.
> Modify the grid in-place.

|  Example Input           | Output |  
| ---------------- | ------ | 
| look at diagram | look at diagram |

Constraints:

m == grid.length

n == grid[i].length

1 &leq; m, n &leq; 100

grid[i][j] is one of [-1, 0, 2147483647]

## Abstraction
Given grid, fill each land grid with the distance to the nearest treasure.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: Multi Source BFS - Graph/something
```python
    def islandsAndTreasure(self, grid: List[List[int]]) -> None:
        if not grid:
            return

        m, n = len(grid), len(grid[0])
        INF = 2147483647
        q = deque()

        # Step 1: Collect all treasure chests (multi-source roots)
        for r in range(m):
            for c in range(n):
                if grid[r][c] == 0:
                    q.append((r, c))

        # Step 2: BFS flood fill
        while q:
            r, c = q.popleft()

            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc

                # Late Candidate Prune: out of bounds or not INF
                if not (0 <= nr < m and 0 <= nc < n):
                    continue
                if grid[nr][nc] != INF:
                    continue

                # Process Root: update distance from nearest treasure
                grid[nr][nc] = grid[r][c] + 1

                # Process Choices: explore neighbor
                q.append((nr, nc))

        # overall: time O(m * n), space O(m * n) (queue worst-case)
```


