---
title: "LeetCode: Linked List"
description: "linked list"
image: "../../public/Notes/linked-list.png"
publishedAt: "2025-05-07"
updatedAt: "2025-05-07"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Linked List Intro:

Leetcode problems with elegant solutions using a linked list.

## 206. Reverse Linked List ::2:: - Easy

Topics:  Linked List, Recursion

### Intro
> Given the head of a singly linked list, reverse the list, and return the reversed list.
> A linked list can be reversed either iteratively or recursively. Could you implement both?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # Note:
        # With recursive Linked Lists:
        # A good way to think about the problem, is that you have access
        # to the list in reverse order, so what actions do you need to
        # take in order to reverse the list, while traversing the list
        # from back to front

        # Base case: 
        # If current list is empty or has only one node -> this node becomes the new head
        if head == None or head.next == None:
            return head

        # Recursion: reverse the rest of the list (head.next to end)
        # After Recursion: new_head is new head of reverse list (tail of original list)
        new_head = self.reverseList(head.next)

        # Recursion Part 1: Reverse Flow of next element (by adding head <- head.next)
        # After recursion: Point second Element to Original Head
        head.next.next = head

        # Recursion Part 2: Reverse Flow of curr element (by adding None <- head), as current head may be first element in original list
        # After recursion: point first element in original list to None
        head.next = None

        # Continue passing back new head (last element from original list), from the deepest recursive call

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return new_head 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Recursive Clean (Learning Not) - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next:
            return head

        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return new_head 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: Iterative - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # Setting prev pointing to None (end of reversed list)
        prev = None

        # Starting at head
        curr = head

        # while _ is not None
        # time complexity: iterate over list of n length O(n)
        while curr != None:

            # Grab next node, before disconnecting
            next_node = curr.next  

            # Disconnect and Reverse Flow: 
            # <- prev    curr -> next 
            # <- prev <- curr    next 
            curr.next = prev      

            # Advance both prev and curr
            prev = curr            
            curr = next_node       


        # Loop exits: 
        # val: (val)  (None)
        # node: prev -> curr

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return prev  
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 4: Iterative Clean (Learning Not) - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        prev = None
        curr = head

        while curr:

            next_node = curr.next  

            curr.next = prev      

            prev = curr            
            curr = next_node       

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return prev  
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |




## 21. Merge Two Sorted Lists ::3:: - Easy

Topics:  Linked List, Recursion

### Intro
> You are given the heads of two sorted linked lists list1 and list2.
> Merge the two lists into one sorted list. The list should be made by splicing 
> together the nodes of the first two lists. Return the head of the merged linked list.

|  Example Input           | Output |  
| ---------------- | ------ | 
| list1 = [1,2,4], list2 = [1,3,4] | [1,1,2,3,4,4] |
| list1 = [], list2 = [] | [] |  
| list1 = [], list2 = [0] | [0] |  

 
Constraints:

The number of nodes in the list is the range [0, 50].

-100 &leq; Node.val &leq; 100

Both list1 and list2 are sorted in non-decreasing order.

### Abstraction
Given two sorted linked lists, merge and return head of merged list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # Base case: one of the lists is empty
        if not list1:
            return list2
        if not list2:
            return list1

        # Pick smaller head node and recurse
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(-1)  # Dummy node to simplify edge cases
        tail = dummy          # Tail pointer to build result list

        # Traverse both lists while both have nodes
        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1     # Append smaller node
                list1 = list1.next    # Advance list1
            else:
                tail.next = list2
                list2 = list2.next    # Advance list2
            tail = tail.next          # Move tail

        # At most one of list1 or list2 is non-empty at this point
        tail.next = list1 if list1 else list2

        return dummy.next  # Skip dummy and return actual merged head
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: Iterative - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(-101) # the next of this will start off the new list
        cur = dummy

        while list1 and list2:
            if list1.val <= list2.val:
                cur.next = list1
                cur = list1
                list1 = list1.next
            else:
                cur.next = list2
                cur = list2
                list2 = list2.next
        
        if not list1:
            cur.next = list2
        else:
            cur.next = list1
        

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 141. Linked List Cycle ::2:: - Easy

Topics:  Hash Table, Linked List, Two Pointers

### Intro
> Given head, the head of a linked list, determine if the linked list has a cycle in it.
> There is a cycle in a linked list if there is some node in the list that can be
> reached again by continuously following the next pointer. 
> Internally, pos is used to denote the index of the node that tail's next pointer is
> connected to. Note that pos is not passed as a parameter.
> Return true if there is a cycle in the linked list. Otherwise, return false.
> Follow up: Can you solve it using O(1) (i.e. constant) memory?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Track Visited Notes - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()
        curr = head
        
        while curr:
            if curr in visited:
                return True
            visited.add(curr)
            curr = curr.next
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



### Solution 2: Floyd Cycle Detection Tortoise and Hare - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                return True
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 143. Reorder List ::3:: - Medium

Topics:  Linked List, Two Pointers, Stack, Recursion

### Intro
> You are given the head of a singly linked-list. The list can be represented as:
> There is a cycle in a linked list if there is some node in the list that can be
> L0 → L1 → … → Ln - 1 → Ln
> Reorder the list to be on the following form:
> L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
> You may not modify the values in the list's nodes. Only nodes themselves may be changed.

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4] | [1,4,2,3] |
| head = [1,2,3,4,5] | [1,5,2,4,3] |  
 
Constraints:

The number of nodes in the list is the range [1, 5 * 10<sup>4</sup>].

1 &leq; Node.val &leq; 1000

### Abstraction
Given a linked list, order it in values tending towards middle.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Stack - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head or not head.next:
            return

        stack = []
        curr = head
        while curr:
            stack.append(curr)
            curr = curr.next

        n = len(stack)
        curr = head
        for _ in range(n // 2):
            tail = stack.pop()
            tail.next = curr.next
            curr.next = tail
            curr = tail.next

        # Set final node to point to None
        if curr:
            curr.next = None
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Two Pointer - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head or not head.next:
            return

        # Step 1: Find middle
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # Step 2: Reverse second half
        prev = None
        curr = slow.next
        slow.next = None  # split the list
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt

        # Step 3: Merge two halves
        first, second = head, prev
        while second:
            tmp1 = first.next
            tmp2 = second.next
            first.next = second
            second.next = tmp1
            first = tmp1
            second = tmp2
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: Optimal Two Pointer - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:
        # Finding the middle of linked list
        slow = fast = head

        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next

        second_half = slow.next
        slow.next = None
        current_node = second_half
        prev = None

        # Reverse the second half
        while current_node:
            next_node = current_node.next
            current_node.next = prev
            prev = current_node
            current_node = next_node
    
        # Merge 2 halfs
        f_half = head
        s_half = prev

        while s_half:
            tmp1, tmp2 = f_half.next, s_half.next
            f_half.next = s_half
            s_half.next = tmp1
            f_half, s_half = tmp1, tmp2

```

## 19. Remove Nth Node From End of List ::2:: - Medium

Topics:  Linked List, Two Pointers

### Intro
> Given the head of a linked list, remove the nth node from
> the end of the list and return its head.
> Follow up: Could you do this in one pass?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5], n = 2 | [1,2,3,5] |
| head = [1], n = 1 | [] |  
| head = [1,2], n = 1 | [1] |
 
Constraints:

The number of nodes in the list is sz.

1 &leq; sz &leq; 30

0 &leq; Node.val &leq; 100

1 &leq; n &leq; sz

### Abstraction
Given a linked list, remove nth node and return head of list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Two Pass Solution - Linked List/Simple Traversal
```python
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # First pass: get length
        length = 0
        current = head
        while current:
            length += 1
            current = current.next
        
        # Second pass: remove (length - n)th node from beginning
        dummy = ListNode(0, head)
        current = dummy
        for _ in range(length - n):
            current = current.next
        
        current.next = current.next.next
        return dummy.next

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: One Pass Solution - Linked List/Simple Traversal
```python
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        fast = slow = dummy
        
        # Move fast n + 1 steps to maintain gap between fast and slow
        for _ in range(n + 1):
            fast = fast.next
        
        # Move both pointers until fast reaches the end
        while fast:
            fast = fast.next
            slow = slow.next
        
        # Remove the nth node
        slow.next = slow.next.next
        return dummy.next 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 138. Copy List with Random Pointer ::3:: - Medium

Topics:  Hash Table, Linked List

### Intro
> A linked list of length n is given such that each node contains an 
> additional random pointer, which could point to any node in the list, or null.
> Construct a deep copy of the list. The deep copy should consist of 
> exactly n brand new nodes, where each new node has its value set to  
> the value of its corresponding original node. Both the next and 
> random pointer of the new nodes should point to new nodes in the 
> copied list such that the pointers in the original list and copied list 
> represent the same list state. None of the pointers in the new list 
> should point to nodes in the original list.
> For example, if there are two nodes X and Y in the original list, where 
> X.random --> Y, then for the corresponding two nodes x and y in 
> the copied list, x.random --> y.
> Return the head of the copied linked list.
> The linked list is represented in the input/output as a list of n nodes. 
> Each node is represented as a pair of [val, random_index] where:
> val: an integer representing Node.val
> random_index: the index of the node (range from 0 to n-1) that
> the random pointer points to, or null if it does not point to any node.
> Your code will only be given the head of the original linked list.

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [[7,null],[13,0],[11,4],[10,2],[1,0]] | [[7,null],[13,0],[11,4],[10,2],[1,0]] |
| head = [[1,1],[2,1]] | [[1,1],[2,1]] |  
| head = [[3,null],[3,0],[3,null]] | [[3,null],[3,0],[3,null]] |
 
Constraints:

0 &leq; n &leq; 1000

-10<sup>4</sup> &leq; Node.val &leq; 10<sup>4</sup>

Node.random is null or is pointing to some node in the linked list.

### Abstraction
Given a linked list where each node has an additional random node pointers, create a deep copy.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Hash table - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None

        # Dictionary to hold old node -> new node mapping
        old_to_new = {}

        # Step 1: Copy all nodes (without wiring next/random yet)
        curr = head
        while curr:
            copy = Node(curr.val)
            old_to_new[curr] = copy
            curr = curr.next

        # Step 2: Assign next and random pointers
        curr = head
        while curr:
            copy = old_to_new[curr]
            copy.next = old_to_new.get(curr.next)
            copy.random = old_to_new.get(curr.random)
            curr = curr.next

        # Return the deep copy of the head node
        return old_to_new[head]
```

### Solution 2: Memoize Hashmap - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        copyList = Node(0)
        pointer = copyList
        memo = {}

        while head:
            # Get or create the copy of the current node
            node = memo.get(head)
            if not node:
                node = Node(head.val)
                memo[head] = node

            # Get or create the copy of the random node
            if head.random:
                random = memo.get(head.random)
                if not random:
                    random = Node(head.random.val)
                    memo[head.random] = random
                node.random = random

            # Link the new node to the copied list
            copyList.next = node

            # Move forward
            head = head.next
            copyList = copyList.next

        return pointer.next
``` 

### Solution 3: In Place Interleaving Technique - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None

        # Step 1: Interleave original and copied nodes
        curr = head
        while curr:
            copy = Node(curr.val)
            copy.next = curr.next
            curr.next = copy
            curr = copy.next

        # Step 2: Assign random pointers to copied nodes
        curr = head
        while curr:
            if curr.random:
                curr.next.random = curr.random.next
            curr = curr.next.next

        # Step 3: Separate the copied list from the original
        curr = head
        copy_head = head.next
        while curr:
            copy = curr.next
            curr.next = copy.next
            if copy.next:
                copy.next = copy.next.next
            curr = curr.next

        return copy_head
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 2. Add Two Numbers ::2:: - Medium

Topics:  Linked List, Math, Recursion

### Intro
> You are given two non-empty linked lists representing two 
> non-negative integers. The digits are stored in reverse 
> order, and each of their nodes contains a single digit. Add 
> the two numbers and return the sum as a linked list.
> You may assume the two numbers do not contain any leading 
> zero, except the number 0 itself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| l1 = [2,4,3], l2 = [5,6,4] | [7,0,8] |
| l1 = [0], l2 = [0] | [0] |  
| l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] | [8,9,9,9,0,0,0,1] |
 
Constraints:

The number of nodes in each linked list is in the range [1, 100].

0 &leq; Node.val &leq; 9

It is guaranteed that the list represents a number that does not have leading zeros.

### Abstraction
Given a two linked lists representing numbers, return the sum.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def dfs(n1, n2, carry):
            if not n1 and not n2 and carry == 0:
                return None

            v1 = n1.val if n1 else 0
            v2 = n2.val if n2 else 0
            total = v1 + v2 + carry

            node = ListNode(total % 10)
            node.next = dfs(n1.next if n1 else None,
                            n2.next if n2 else None,
                            total // 10)
            return node

        return dfs(l1, l2, 0)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Iterative - Linked List/Simple Traversal
```python
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode()
        curr = dummy
        carry = 0

        # Traverse both lists and handle carry
        while l1 or l2 or carry:
            v1 = l1.val if l1 else 0
            v2 = l2.val if l2 else 0

            total = v1 + v2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            # Move pointers
            curr = curr.next
            if l1: l1 = l1.next
            if l2: l2 = l2.next

        return dummy.next

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 287. Find the Duplicate Number ::3:: - Medium

Topics:  Array, Two Pointers, Binary Search, Bit Manipulation

### Intro
> Given an array of integers nums containing n + 1 integers 
> where each integer is in the range [1, n] inclusive.
> There is only one repeated number in nums, return  
> this repeated number.
> You must solve the problem without modifying the array 
> nums and using only constant extra space.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,3,4,2,2] | 2 |
| nums = [3,1,3,4,2] | 3 |  
| nums = [3,3,3,3,3] | 3 |
 
Constraints:

1 &leq; n &leq; 10<sup>5</sup>

nums.length == n + 1

1 &leq; nums[i] &leq; n

All the integers in nums appear only once except for precisely one integer which appears two or more times.

### Abstraction
Given list, return which number is a duplicate.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Bit Manipulation  - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums) - 1
        ans = 0
        max_bit = max(num.bit_length() for num in nums)

        for bit in range(max_bit):
            mask = 1 << bit
            count_nums = sum((num & mask) > 0 for num in nums)
            count_range = sum((i & mask) > 0 for i in range(1, n + 1))

            if count_nums > count_range:
                ans |= mask

        return ans

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Binary Search on Value Range  - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        left, right = 1, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            count = sum(num <= mid for num in nums)

            if count > mid:
                right = mid
            else:
                left = mid + 1

        return left
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: Floyd Tortoise and Hare - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        # Phase 1: Detect the cycle
        slow = nums[0]
        fast = nums[0]

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        # Phase 2: Find the entrance to the cycle
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]

        return slow
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 146. LRU Cache ::2:: - Medium

Topics:  Hash Table, Linked List, Design, Doubly Linked List

### Intro
> Design a data structure that follows the constraints of a 
> Least Recently Used (LRU) cache.
> Implement the LRUCache class:
> LRUCache(int capacity) Initialize the LRU cache with
> positive size capacity.
> int get(int key) Return the value of the key if the key exists,
> otherwise return -1.
> void put(int key, int value) Update the value of the key if the 
> key exists. Otherwise, add the key-value pair to the cache. If the 
> number of keys exceeds the capacity from this operation, evict the 
> least recently used key.
> The functions get and put must each run in O(1) average time complexity.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,3,4,2,2] | 2 |
| nums = [3,1,3,4,2] | 3 |  
| nums = [3,3,3,3,3] | 3 |
 
Constraints:

1 &leq; capacity &leq; 3000

0 &leq; key &leq; 10<sup>4</sup>

0 &leq; value &leq; 10<sup>5</sup>

At most 2 * 10<sup>5</sup> calls will be made to get and put.

### Abstraction
Design an efficient LRU cache using linked lists.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Doubly Linked List with Hashmap  - Linked List/Simple Traversal
```python
class Node:
    def __init__(self, key: int, val: int):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        # Dummy head and tail to avoid edge condition checks
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    # Remove a node from the list
    def _remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next = nxt
        nxt.prev = prev

    # Insert a node right after the head
    def _insert_at_front(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # Move the accessed node to the front
        node = self.cache[key]
        self._remove(node)
        self._insert_at_front(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        node = Node(key, value)
        self.cache[key] = node
        self._insert_at_front(node)
        if len(self.cache) > self.capacity:
            # Remove the LRU node from the list and map
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Ordered Dict  - Linked List/Simple Traversal
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # Move to end to mark as recently used
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)  # Pop least recently used
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 23. Merge k Sorted Lists ::3:: - Hard

Topics:  Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort

### Intro
> You are given an array of k linked-lists lists, each linked-list is 
> sorted in ascending order.
> Merge all the linked-lists into one sorted linked-list and return it.

|  Example Input           | Output |  
| ---------------- | ------ | 
| lists = [[1,4,5],[1,3,4],[2,6]] | [1,1,2,3,4,4,5,6] |
| lists = [] | [] |  
| lists = [[]] | [] |
 
Constraints:

k == lists.length 

0 &leq; k &leq; 10<sup>4</sup>

0 &leq; lists[i].length &leq; 500

-10<sup>4</sup> &leq; lists[i][j] &leq; 10<sup>4</sup>

lists[i] is sorted in ascending order.

The sum of lists[i].length will not exceed 10<sup>4</sup>

### Abstraction
Given a list of sorted linked lists, combine into one sorted linked list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Min Heap Priority Queue  - Linked List/Simple Traversal
```python
from heapq import heappush, heappop

class Solution:

    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        min_heap = []

        # Push (value, index, node) into heap
        for i, node in enumerate(lists):
            if node:
                heappush(min_heap, (node.val, i, node))  # Use i to avoid comparing ListNode directly

        dummy = tail = ListNode(0)

        while min_heap:
            val, i, node = heappop(min_heap)
            tail.next = node
            tail = tail.next
            if node.next:
                heappush(min_heap, (node.next.val, i, node.next))  # Keep i the same for this list

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Merge Sort  - Linked List/Simple Traversal
```python
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists: return None
        if len(lists) == 1: return lists[0]

        def mergeTwo(l1, l2):
            dummy = tail = ListNode(0)
            while l1 and l2:
                if l1.val < l2.val:
                    tail.next, l1 = l1, l1.next
                else:
                    tail.next, l2 = l2, l2.next
                tail = tail.next
            tail.next = l1 or l2
            return dummy.next

        while len(lists) > 1:
            merged = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if i + 1 < len(lists) else None
                merged.append(mergeTwo(l1, l2))
            lists = merged

        return lists[0]

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: Flatten All and Sort  - Linked List/Simple Traversal
```python
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for l in lists:
            while l:
                nodes.append(l.val)
                l = l.next
        nodes.sort()

        dummy = tail = ListNode(0)
        for val in nodes:
            tail.next = ListNode(val)
            tail = tail.next

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 25. Reverse Nodes in k-Group ::3:: - Hard

Topics:  Linked List, Recursion

### Intro
> Given the head of a linked list, reverse the nodes of the list k at a 
> time, and return the modified list.
> k is a positive integer and is less than or equal to the length of the
> linked list. If the number of nodes is not a multiple of k then left-
> out nodes, in the end, should remain as it is.
> You may not alter the values in the list's nodes, only nodes 
> themselves may be changed.
> Follow-up: Can you solve the problem in O(1) extra memory space?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5], k = 2 | [2,1,4,3,5] |
| head = [1,2,3,4,5], k = 3 | [3,2,1,4,5] |  
 
Constraints:

The number of nodes in the list is n.
1 &leq; k &leq; n &leq; 5000

0 &leq; Node.val &leq; 1000

-10<sup>4</sup> &leq; lists[i][j] &leq; 10<sup>4</sup>

lists[i] is sorted in ascending order.

The sum of lists[i].length will not exceed 10<sup>4</sup>

### Abstraction
Given a linked lists, and group size k, reverse as many groups of k length as possible.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive  - Linked List/Simple Traversal
```python
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Check if there are at least k nodes ahead
        count = 0
        node = head
        while node and count < k:
            node = node.next
            count += 1
        if count < k:
            return head  # less than k nodes, return head as is
        
        # Reverse first k nodes
        prev = None
        current = head
        for _ in range(k):
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        
        # head is now the tail of reversed group
        # recursively process remaining nodes starting at current
        head.next = self.reverseKGroup(current, k)
        
        return prev  # prev is new head of reversed group
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative  - Linked List/Simple Traversal
```python
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Helper function to reverse a linked list segment [start, end)
        def reverse(start: ListNode, end: ListNode) -> ListNode:
            prev = None
            current = start
            while current != end:
                nxt = current.next
                current.next = prev
                prev = current
                current = nxt
            return prev  # New head of reversed segment

        dummy = ListNode(0)
        dummy.next = head
        group_prev = dummy

        while True:
            kth = group_prev
            # Find the k-th node from group_prev
            for _ in range(k):
                kth = kth.next
                if not kth:
                    return dummy.next  # Less than k nodes remain, done

            group_next = kth.next
            # Reverse group [group_prev.next, kth]
            prev = group_next
            curr = group_prev.next
            # Reverse using pointer reassignments:
            for _ in range(k):
                nxt = curr.next
                curr.next = prev
                prev = curr
                curr = nxt

            # Connect previous group to the reversed group
            tail = group_prev.next
            group_prev.next = prev
            group_prev = tail
```
