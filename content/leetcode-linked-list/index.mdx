---
title: "LeetCode: Linked List"
description: "linked list"
image: "../../public/Notes/linked-list.png"
publishedAt: "2025-05-07"
updatedAt: "2025-05-07"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Linked List Intro:

Leetcode problems with elegant solutions using a linked list.

### What is a Linked List
A linked list is a linear data structure where each element (node) points to the next.
It does not offer direct index access like arrays, as all traversal is pointer based.

### Why Use a Linked List
Linked lists are ideal for:
- Memory efficient manipulation (no resizing like arrays)
- Representing dynamic data structures (stacks, queues, etc)
- Insertions and deletions in constant O(1) time (if the node is known)

### Linked List Application: Linear Traversal
We can traverse a linked list node by node using a single pointer.
Commonly used for printing, searching, summing values, etc.

Ex: Count number of nodes in the list
```python
    def countNodes(head):
        count = 0
        curr = head
        
        while curr: 
            count += 1
            curr = curr.next

        return count
```

### Linked List Application: Tortoise and Hare
We can represent fast and slow pointers to traverse the list.
Useful for splitting lists in half for sorting or palindrome checks 
and for checking for cycles.

Ex: Return middle node in list
```python
    def findMiddle(head):
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        return slow
```

### Linked List Application: In Place Modification
Iteratively manipulate linked list during traversal for
O(1) time and space.

Ex: Reverse the entire list and return a new head
```python
    def reverseList(head):
        prev = None
        curr = head

        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node

        return prev
```



## 206. Reverse Linked List ::4:: - Easy

Topics:  Linked List, Recursion

### Intro
> Given the head of a singly linked list, reverse the list, and return the reversed list.
> A linked list can be reversed either iteratively or recursively. Could you implement both?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # Note:
        # With recursive Linked Lists:
        # A good way to think about the problem, is that you have access
        # to the list in reverse order, so what actions do you need to
        # take in order to reverse the list, while traversing the list
        # from back to front

        # Base case: 
        # If current list is empty or has only one node -> this node becomes the new head
        if head == None or head.next == None:
            return head

        # Recursion: reverse the rest of the list (head.next to end)
        # After Recursion: new_head is new head of reverse list (tail of original list)
        new_head = self.reverseList(head.next)

        # Recursion Part 1: Reverse Flow of next element (by adding head <- head.next)
        # After recursion: Point second Element to Original Head
        head.next.next = head

        # Recursion Part 2: Reverse Flow of curr element (by adding None <- head), as current head may be first element in original list
        # After recursion: point first element in original list to None
        head.next = None

        # Continue passing back new head (last element from original list), from the deepest recursive call

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return new_head 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Recursive Clean (Learning Not) - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next:
            return head

        new_head = self.reverseList(head.next)
        
        head.next.next = head
        head.next = None

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return new_head 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: Iterative - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # Setting prev pointing to None (end of reversed list)
        prev = None

        # Starting at head
        curr = head

        # while _ is not None
        # time complexity: iterate over list of n length O(n)
        while curr != None:

            # Grab next node, before disconnecting
            next_node = curr.next  

            # Disconnect and Reverse Flow: 
            # <- prev    curr -> next 
            # <- prev <- curr    next 
            curr.next = prev      

            # Advance both prev and curr
            prev = curr            
            curr = next_node       


        # Loop exits: 
        # val: (val)  (None)
        # node: prev -> curr

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return prev  
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 4: Iterative Clean (Learning Not) - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        prev = None
        curr = head

        while curr:

            next_node = curr.next  

            curr.next = prev      

            prev = curr            
            curr = next_node       

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return prev  
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |




## 21. Merge Two Sorted Lists ::2:: - Easy

Topics:  Linked List, Recursion

### Intro
> You are given the heads of two sorted linked lists list1 and list2.
> Merge the two lists into one sorted list. The list should be made by splicing 
> together the nodes of the first two lists. Return the head of the merged linked list.

|  Example Input           | Output |  
| ---------------- | ------ | 
| list1 = [1,2,4], list2 = [1,3,4] | [1,1,2,3,4,4] |
| list1 = [], list2 = [] | [] |  
| list1 = [], list2 = [0] | [0] |  

 
Constraints:

The number of nodes in the list is the range [0, 50].

-100 &leq; Node.val &leq; 100

Both list1 and list2 are sorted in non-decreasing order.

### Abstraction
Given two sorted linked lists, merge and return head of merged list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        
        # Note:
        # Building merged list from right to left,
        # connecting current node and passing back as we go
        
        # Base case: 
        # One of the lists is empty,
        # return second list for the .next
        if not list1:
            return list2
        if not list2:
            return list1

        # Recursive Call:
        # Point smaller val -> rest of list
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

        # overall: time complexity O(n)
        # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative Sentinel Anchor - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        
        # Note:
        # DummyHead is used to enter the iterative loop cleanly
        # without handling first node assigning case
        
        # sentinel anchor for real head
        dummyHead = ListNode(-1)  

        # curr node of list
        tail = dummy          

        # Traverse both lists while both have nodes
        # time complexity: iterate over both lists O(m + n)
        while list1 and list2:

            # grab smaller value between list1 and list2
            if list1.val < list2.val:
                
                # append and iterate list1
                tail.next = list1     
                list1 = list1.next   
            else:
                # append and iterate list2
                tail.next = list2
                list2 = list2.next    

            # 1st iteration: dummyHead/tail no longer point to same obj
            # nth iteration: iterate tail to whatever the next_node is
            tail = tail.next          

        # At least one list is non empty at this point:
        # point tail to rest of list
        if list1:
            tail.next = list1
        else 
            tail.next = list2

        # Jump to merged head using dummyHead

        # overall: time complexity O(m + n)
        # overall: space complexity O(1)
        return dummyHead.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 141. Linked List Cycle ::2:: - Easy

Topics:  Hash Table, Linked List, Two Pointers

### Intro
> Given head, the head of a linked list, determine if the linked list has a cycle in it.
> There is a cycle in a linked list if there is some node in the list that can be
> reached again by continuously following the next pointer. 
> Internally, pos is used to denote the index of the node that tail's next pointer is
> connected to. Note that pos is not passed as a parameter.
> Return true if there is a cycle in the linked list. Otherwise, return false.
> Follow up: Can you solve it using O(1) (i.e. constant) memory?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Track Visited Notes - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        
        # Note:
        # Track visited nodes to check for repeats (cycles)
        
        # Nodes are stored by obj reference,
        # perfect for cycle detection
        visited = set()

        # start of iteration
        curr = head
        
        # time complexity: iterate over list of n length O(n)
        while curr:

            # repeated node: (cycle detected)
            if curr in visited:
                return True

            # add and continue iteration
            visited.add(curr)
            curr = curr.next
        
        # no repeat nodes (no cycles)

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Floyd Cycle Detection Tortoise and Hare - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        
        # Note:
        # If no cycle: fast pointer will hit None (end of list)
        # If cycle: once both fast and slow pointer enter cycle of size k,
        # fast pointer will lap and hit slow pointer within k steps

        # set pointers
        slow, fast = head, head
        
        # time complexity: iterate over list 
        while fast and fast.next:

            # move both slow and fast pointers
            slow = slow.next
            fast = fast.next.next
            
            # check if match (cycle detected)
            if slow == fast:
                return True

        # reached end of list (no cycle detected)
        
        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 143. Reorder List ::3:: - Medium

Topics:  Linked List, Two Pointers, Stack, Recursion

### Intro
> You are given the head of a singly linked-list. The list can be represented as:
> There is a cycle in a linked list if there is some node in the list that can be
> L0 → L1 → … → Ln - 1 → Ln
> Reorder the list to be on the following form:
> L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
> You may not modify the values in the list's nodes. Only nodes themselves may be changed.

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4] | [1,4,2,3] |
| head = [1,2,3,4,5] | [1,5,2,4,3] |  
 
Constraints:

The number of nodes in the list is the range [1, 5 * 10<sup>4</sup>].

1 &leq; Node.val &leq; 1000

### Abstraction
Given a linked list, order it in values tending towards middle.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Slow.next Explicit Set Tail of Final List Two Way Disconnect Iteration Reversal - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:

        # Note:
        # 1. Use Tortoise Hare to find the middle
        # 2. Reverse second half of list in place
        # 3. Merges first half and reverse second half alternating
        # Result: Fully in place reordering

        # slow -> middle
        slow, fast = head, head
        while fast and fast.next:
            # slow travels half distance vs fast pointer
            slow = slow.next
            fast = fast.next.next

        # Prepare prev to be tail of reversed right half:
        prev = None

        # Explicit disconnect:
        # grab head of right half
        curr = slow.next

        # Explicit Disconnect:
        # Set tail for final merged list: slow -> None
        # Invariant: Now due to slow, left will always be equal or longer than right
        slow.next = None 

        # Reverse second half of list
        while curr:
            # grab next
            next_node = curr.next
            # reverse flow
            curr.next = prev
            # iterate 
            prev = curr
            curr = next_node

        # iterate over left half and reversed right half
        left, right = head, prev

        # right half is always equal or shorter than the left half (by 1 node at most)
        while right:
            # grab next before disconnect
            next_left, next_right = left.next, right.next
            # alternate flow
            left.next = right
            right.next = next_left
            # iterate left and right half -> connect next_nodes
            left, right = next_left, next_right

        
        # overall: time complexity O(n)
        # overall: space complexity O(1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Extra Slow Brainteaser in Right List One Way Disconnection Reversal - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:

        # Note
        # 1. Use Tortoise and Hare to find midpoint.
        # 2. Reverse the second half in place (without disconnecting manually)
        # 3. Merge first and reversed second half alternating nodes
        # Optimization: avoids slow.next = None
        # by leveraging final reversal pointer

        # slow -> middle
        slow, fast = head, head
        while fast and fast.next:
            # slow travels half distance vs fast pointer: iterate references in memory
            fast = fast.next.next
            slow = slow.next
        
        # Prepare prev to be tail of reversed right half:
        prev = None

        # One Way Disconnect:
        # Set tail for final merged list: slow -> None
        # Set extra slow for right list: <- slow <- right first element
        curr = slow

        # while curr != last element
        # Reverse second half of list:
        while curr:
            # grab next before disconnect
            next_node = curr.next
            # reverse flow
            curr.next = prev
            # iterate reference in memory
            prev = curr
            curr = next_node

        # Notice: 
        # Thus: to avoid double add slow: while curr != slow:
        left, right = head, prev

        # exit when we hit extra slow in right list,
        # slow in left list is aligned with last elem in right list
        # None <- Slow <- Last elem
        # iterate over right list
        while right != slow:
            next_left, next_right = left.next, right.next
            left.next = right
            right.next = next_left
            left, right = next_left, next_right

        # Notice:
        # curr.next impedes slow to be hit from the right hand list,
        # therefore we add slow via the left list (since prev_slow -> slow),
        # is still pointing to slow
        
        # overall: time complexity O(n)
        # overall: space complexity O(1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: Stack - Linked List/Simple Traversal
```python
    def reorderList(self, head: Optional[ListNode]) -> None:

        # Note:
        # Store right half nodes in a stack to allow reverse access
        # The put right half in between alternating left half nodes
        # l1 -> r1 -> l2 -> etc..

        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # stack for reverse access via pop()
        # space complexity: store list of n length O(n)
        stack = []

        # iterate over second half of list
        curr = slow 
        
        # push right half of nodes to stack
        # time complexity: iterate over list of n length O(n)
        while curr:
            stack.append(curr)
            curr = curr.next

        # forward iteration over list 
        left = head

        # time complexity: iterate over stack O(n)
        while left != slow:

            # grab right half node element
            right = stack.pop()

            # place right half node in between left half curr and curr.next: 
            # curr -> tail -> curr.next 
            right.next = left.next
            left.next = right

            # iterate left half of list
            left = right.next

        # Notice:
        # final iteration: node -> slow -> slow

        # non empty list: Set last element -> None
        if left:
            left.next = None

        # overall: time complexity O(n)
        # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 19. Remove Nth Node From End of List ::2:: - Medium

Topics:  Linked List, Two Pointers

### Intro
> Given the head of a linked list, remove the nth node from
> the end of the list and return its head.
> Follow up: Could you do this in one pass?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5], n = 2 | [1,2,3,5] |
| head = [1], n = 1 | [] |  
| head = [1,2], n = 1 | [1] |
 
Constraints:

The number of nodes in the list is sz.

1 &leq; sz &leq; 30

0 &leq; Node.val &leq; 100

1 &leq; n &leq; sz

### Abstraction
Given a linked list, remove nth node and return head of list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Two Pass Solution - Linked List/Simple Traversal
```python
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # First pass: get length
        length = 0
        current = head
        while current:
            length += 1
            current = current.next
        
        # Second pass: remove (length - n)th node from beginning
        dummy = ListNode(0, head)
        current = dummy
        for _ in range(length - n):
            current = current.next
        
        current.next = current.next.next
        return dummy.next

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: One Pass Solution - Linked List/Simple Traversal
```python
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        fast = slow = dummy
        
        # Move fast n + 1 steps to maintain gap between fast and slow
        for _ in range(n + 1):
            fast = fast.next
        
        # Move both pointers until fast reaches the end
        while fast:
            fast = fast.next
            slow = slow.next
        
        # Remove the nth node
        slow.next = slow.next.next
        return dummy.next 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 138. Copy List with Random Pointer ::3:: - Medium

Topics:  Hash Table, Linked List

### Intro
> A linked list of length n is given such that each node contains an 
> additional random pointer, which could point to any node in the list, or null.
> Construct a deep copy of the list. The deep copy should consist of 
> exactly n brand new nodes, where each new node has its value set to  
> the value of its corresponding original node. Both the next and 
> random pointer of the new nodes should point to new nodes in the 
> copied list such that the pointers in the original list and copied list 
> represent the same list state. None of the pointers in the new list 
> should point to nodes in the original list.
> For example, if there are two nodes X and Y in the original list, where 
> X.random --> Y, then for the corresponding two nodes x and y in 
> the copied list, x.random --> y.
> Return the head of the copied linked list.
> The linked list is represented in the input/output as a list of n nodes. 
> Each node is represented as a pair of [val, random_index] where:
> val: an integer representing Node.val
> random_index: the index of the node (range from 0 to n-1) that
> the random pointer points to, or null if it does not point to any node.
> Your code will only be given the head of the original linked list.

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [[7,null],[13,0],[11,4],[10,2],[1,0]] | [[7,null],[13,0],[11,4],[10,2],[1,0]] |
| head = [[1,1],[2,1]] | [[1,1],[2,1]] |  
| head = [[3,null],[3,0],[3,null]] | [[3,null],[3,0],[3,null]] |
 
Constraints:

0 &leq; n &leq; 1000

-10<sup>4</sup> &leq; Node.val &leq; 10<sup>4</sup>

Node.random is null or is pointing to some node in the linked list.

### Abstraction
Given a linked list where each node has an additional random node pointers, create a deep copy.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Hash table - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None

        # Dictionary to hold old node -> new node mapping
        old_to_new = {}

        # Step 1: Copy all nodes (without wiring next/random yet)
        curr = head
        while curr:
            copy = Node(curr.val)
            old_to_new[curr] = copy
            curr = curr.next

        # Step 2: Assign next and random pointers
        curr = head
        while curr:
            copy = old_to_new[curr]
            copy.next = old_to_new.get(curr.next)
            copy.random = old_to_new.get(curr.random)
            curr = curr.next

        # Return the deep copy of the head node
        return old_to_new[head]
```

### Solution 2: Memoize Hashmap - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        copyList = Node(0)
        pointer = copyList
        memo = {}

        while head:
            # Get or create the copy of the current node
            node = memo.get(head)
            if not node:
                node = Node(head.val)
                memo[head] = node

            # Get or create the copy of the random node
            if head.random:
                random = memo.get(head.random)
                if not random:
                    random = Node(head.random.val)
                    memo[head.random] = random
                node.random = random

            # Link the new node to the copied list
            copyList.next = node

            # Move forward
            head = head.next
            copyList = copyList.next

        return pointer.next
``` 

### Solution 3: In Place Interleaving Technique - Linked List/Simple Traversal
```python
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None

        # Step 1: Interleave original and copied nodes
        curr = head
        while curr:
            copy = Node(curr.val)
            copy.next = curr.next
            curr.next = copy
            curr = copy.next

        # Step 2: Assign random pointers to copied nodes
        curr = head
        while curr:
            if curr.random:
                curr.next.random = curr.random.next
            curr = curr.next.next

        # Step 3: Separate the copied list from the original
        curr = head
        copy_head = head.next
        while curr:
            copy = curr.next
            curr.next = copy.next
            if copy.next:
                copy.next = copy.next.next
            curr = curr.next

        return copy_head
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 2. Add Two Numbers ::2:: - Medium

Topics:  Linked List, Math, Recursion

### Intro
> You are given two non-empty linked lists representing two 
> non-negative integers. The digits are stored in reverse 
> order, and each of their nodes contains a single digit. Add 
> the two numbers and return the sum as a linked list.
> You may assume the two numbers do not contain any leading 
> zero, except the number 0 itself.

|  Example Input           | Output |  
| ---------------- | ------ | 
| l1 = [2,4,3], l2 = [5,6,4] | [7,0,8] |
| l1 = [0], l2 = [0] | [0] |  
| l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] | [8,9,9,9,0,0,0,1] |
 
Constraints:

The number of nodes in each linked list is in the range [1, 100].

0 &leq; Node.val &leq; 9

It is guaranteed that the list represents a number that does not have leading zeros.

### Abstraction
Given a two linked lists representing numbers, return the sum.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def dfs(n1, n2, carry):
            if not n1 and not n2 and carry == 0:
                return None

            v1 = n1.val if n1 else 0
            v2 = n2.val if n2 else 0
            total = v1 + v2 + carry

            node = ListNode(total % 10)
            node.next = dfs(n1.next if n1 else None,
                            n2.next if n2 else None,
                            total // 10)
            return node

        return dfs(l1, l2, 0)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Iterative - Linked List/Simple Traversal
```python
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode()
        curr = dummy
        carry = 0

        # Traverse both lists and handle carry
        while l1 or l2 or carry:
            v1 = l1.val if l1 else 0
            v2 = l2.val if l2 else 0

            total = v1 + v2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            # Move pointers
            curr = curr.next
            if l1: l1 = l1.next
            if l2: l2 = l2.next

        return dummy.next

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 287. Find the Duplicate Number ::3:: - Medium

Topics:  Array, Two Pointers, Binary Search, Bit Manipulation

### Intro
> Given an array of integers nums containing n + 1 integers 
> where each integer is in the range [1, n] inclusive.
> There is only one repeated number in nums, return  
> this repeated number.
> You must solve the problem without modifying the array 
> nums and using only constant extra space.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,3,4,2,2] | 2 |
| nums = [3,1,3,4,2] | 3 |  
| nums = [3,3,3,3,3] | 3 |
 
Constraints:

1 &leq; n &leq; 10<sup>5</sup>

nums.length == n + 1

1 &leq; nums[i] &leq; n

All the integers in nums appear only once except for precisely one integer which appears two or more times.

### Abstraction
Given list, return which number is a duplicate.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Bit Manipulation  - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums) - 1
        ans = 0
        max_bit = max(num.bit_length() for num in nums)

        for bit in range(max_bit):
            mask = 1 << bit
            count_nums = sum((num & mask) > 0 for num in nums)
            count_range = sum((i & mask) > 0 for i in range(1, n + 1))

            if count_nums > count_range:
                ans |= mask

        return ans

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Binary Search on Value Range  - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        left, right = 1, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            count = sum(num <= mid for num in nums)

            if count > mid:
                right = mid
            else:
                left = mid + 1

        return left
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 3: Floyd Tortoise and Hare - Linked List/Simple Traversal
```python
    def findDuplicate(self, nums: List[int]) -> int:
        # Phase 1: Detect the cycle
        slow = nums[0]
        fast = nums[0]

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        # Phase 2: Find the entrance to the cycle
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]

        return slow
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 146. LRU Cache ::2:: - Medium

Topics:  Hash Table, Linked List, Design, Doubly Linked List

### Intro
> Design a data structure that follows the constraints of a 
> Least Recently Used (LRU) cache.
> Implement the LRUCache class:
> LRUCache(int capacity) Initialize the LRU cache with
> positive size capacity.
> int get(int key) Return the value of the key if the key exists,
> otherwise return -1.
> void put(int key, int value) Update the value of the key if the 
> key exists. Otherwise, add the key-value pair to the cache. If the 
> number of keys exceeds the capacity from this operation, evict the 
> least recently used key.
> The functions get and put must each run in O(1) average time complexity.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,3,4,2,2] | 2 |
| nums = [3,1,3,4,2] | 3 |  
| nums = [3,3,3,3,3] | 3 |
 
Constraints:

1 &leq; capacity &leq; 3000

0 &leq; key &leq; 10<sup>4</sup>

0 &leq; value &leq; 10<sup>5</sup>

At most 2 * 10<sup>5</sup> calls will be made to get and put.

### Abstraction
Design an efficient LRU cache using linked lists.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Doubly Linked List with Hashmap  - Linked List/Simple Traversal
```python
class Node:
    def __init__(self, key: int, val: int):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        # Dummy head and tail to avoid edge condition checks
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    # Remove a node from the list
    def _remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next = nxt
        nxt.prev = prev

    # Insert a node right after the head
    def _insert_at_front(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # Move the accessed node to the front
        node = self.cache[key]
        self._remove(node)
        self._insert_at_front(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        node = Node(key, value)
        self.cache[key] = node
        self._insert_at_front(node)
        if len(self.cache) > self.capacity:
            # Remove the LRU node from the list and map
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 2: Ordered Dict  - Linked List/Simple Traversal
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # Move to end to mark as recently used
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)  # Pop least recently used
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 23. Merge k Sorted Lists ::3:: - Hard

Topics:  Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort

### Intro
> You are given an array of k linked-lists lists, each linked-list is 
> sorted in ascending order.
> Merge all the linked-lists into one sorted linked-list and return it.

|  Example Input           | Output |  
| ---------------- | ------ | 
| lists = [[1,4,5],[1,3,4],[2,6]] | [1,1,2,3,4,4,5,6] |
| lists = [] | [] |  
| lists = [[]] | [] |
 
Constraints:

k == lists.length 

0 &leq; k &leq; 10<sup>4</sup>

0 &leq; lists[i].length &leq; 500

-10<sup>4</sup> &leq; lists[i][j] &leq; 10<sup>4</sup>

lists[i] is sorted in ascending order.

The sum of lists[i].length will not exceed 10<sup>4</sup>

### Abstraction
Given a list of sorted linked lists, combine into one sorted linked list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Min Heap Priority Queue  - Linked List/Simple Traversal
```python
from heapq import heappush, heappop

class Solution:

    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        min_heap = []

        # Push (value, index, node) into heap
        for i, node in enumerate(lists):
            if node:
                heappush(min_heap, (node.val, i, node))  # Use i to avoid comparing ListNode directly

        dummy = tail = ListNode(0)

        while min_heap:
            val, i, node = heappop(min_heap)
            tail.next = node
            tail = tail.next
            if node.next:
                heappush(min_heap, (node.next.val, i, node.next))  # Keep i the same for this list

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Merge Sort  - Linked List/Simple Traversal
```python
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists: return None
        if len(lists) == 1: return lists[0]

        def mergeTwo(l1, l2):
            dummy = tail = ListNode(0)
            while l1 and l2:
                if l1.val < l2.val:
                    tail.next, l1 = l1, l1.next
                else:
                    tail.next, l2 = l2, l2.next
                tail = tail.next
            tail.next = l1 or l2
            return dummy.next

        while len(lists) > 1:
            merged = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if i + 1 < len(lists) else None
                merged.append(mergeTwo(l1, l2))
            lists = merged

        return lists[0]

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: Flatten All and Sort  - Linked List/Simple Traversal
```python
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for l in lists:
            while l:
                nodes.append(l.val)
                l = l.next
        nodes.sort()

        dummy = tail = ListNode(0)
        for val in nodes:
            tail.next = ListNode(val)
            tail = tail.next

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 25. Reverse Nodes in k-Group ::3:: - Hard

Topics:  Linked List, Recursion

### Intro
> Given the head of a linked list, reverse the nodes of the list k at a 
> time, and return the modified list.
> k is a positive integer and is less than or equal to the length of the
> linked list. If the number of nodes is not a multiple of k then left-
> out nodes, in the end, should remain as it is.
> You may not alter the values in the list's nodes, only nodes 
> themselves may be changed.
> Follow-up: Can you solve the problem in O(1) extra memory space?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5], k = 2 | [2,1,4,3,5] |
| head = [1,2,3,4,5], k = 3 | [3,2,1,4,5] |  
 
Constraints:

The number of nodes in the list is n.
1 &leq; k &leq; n &leq; 5000

0 &leq; Node.val &leq; 1000

-10<sup>4</sup> &leq; lists[i][j] &leq; 10<sup>4</sup>

lists[i] is sorted in ascending order.

The sum of lists[i].length will not exceed 10<sup>4</sup>

### Abstraction
Given a linked lists, and group size k, reverse as many groups of k length as possible.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive  - Linked List/Simple Traversal
```python
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Check if there are at least k nodes ahead
        count = 0
        node = head
        while node and count < k:
            node = node.next
            count += 1
        if count < k:
            return head  # less than k nodes, return head as is
        
        # Reverse first k nodes
        prev = None
        current = head
        for _ in range(k):
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        
        # head is now the tail of reversed group
        # recursively process remaining nodes starting at current
        head.next = self.reverseKGroup(current, k)
        
        return prev  # prev is new head of reversed group
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative  - Linked List/Simple Traversal
```python
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Helper function to reverse a linked list segment [start, end)
        def reverse(start: ListNode, end: ListNode) -> ListNode:
            prev = None
            current = start
            while current != end:
                nxt = current.next
                current.next = prev
                prev = current
                current = nxt
            return prev  # New head of reversed segment

        dummy = ListNode(0)
        dummy.next = head
        group_prev = dummy

        while True:
            kth = group_prev
            # Find the k-th node from group_prev
            for _ in range(k):
                kth = kth.next
                if not kth:
                    return dummy.next  # Less than k nodes remain, done

            group_next = kth.next
            # Reverse group [group_prev.next, kth]
            prev = group_next
            curr = group_prev.next
            # Reverse using pointer reassignments:
            for _ in range(k):
                nxt = curr.next
                curr.next = prev
                prev = curr
                curr = nxt

            # Connect previous group to the reversed group
            tail = group_prev.next
            group_prev.next = prev
            group_prev = tail
```
