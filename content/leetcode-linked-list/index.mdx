---
title: "LeetCode: Linked List"
description: "linked list"
image: "../../public/Notes/linked-list.png"
publishedAt: "2025-05-07"
updatedAt: "2025-05-07"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Linked List Intro:

Leetcode problems with elegant solutions using a linked list.

## 206. Reverse Linked List ::2:: - Easy

Topics:  Linked List, Recursion

### Intro
> Given the head of a singly linked list, reverse the list, and return the reversed list.
> A linked list can be reversed either iteratively or recursively. Could you implement both?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # Base case: if head is None or only one node left
        if not head or not head.next:
            return head

        # Recursively reverse the rest of the list
        new_head = self.reverseList(head.next)

        # Reverse the current pointer
        head.next.next = head
        head.next = None

        return new_head  # Return new head from the deepest recursive call
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



### Solution 2: Iterative - Linked List/Simple Traversal
```python
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        # prev initially points to None (end of reversed list)
        prev = None
        curr = head

        # time complexity: iterate over list of n length O(n)
        while curr:

            # Temporarily store next node
            next_node = curr.next  
            # Reverse current node's pointer
            curr.next = prev      

            # Move prev one step forward
            prev = curr            
            # Move curr one step forward
            curr = next_node       

        # prev is the new head after reversal

        # overall: time complexity
        # overall: space complexity
        return prev  
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## 21. Merge Two Sorted Lists ::3:: - Easy

Topics:  Linked List, Recursion

### Intro
> You are given the heads of two sorted linked lists list1 and list2.
> Merge the two lists into one sorted list. The list should be made by splicing 
> together the nodes of the first two lists. Return the head of the merged linked list.

|  Example Input           | Output |  
| ---------------- | ------ | 
| list1 = [1,2,4], list2 = [1,3,4] | [1,1,2,3,4,4] |
| list1 = [], list2 = [] | [] |  
| list1 = [], list2 = [0] | [0] |  

 
Constraints:

The number of nodes in the list is the range [0, 50].

-100 &leq; Node.val &leq; 100

Both list1 and list2 are sorted in non-decreasing order.

### Abstraction
Given two sorted linked lists, merge and return head of merged list.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # Base case: one of the lists is empty
        if not list1:
            return list2
        if not list2:
            return list1

        # Pick smaller head node and recurse
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Solution 2: Iterative - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(-1)  # Dummy node to simplify edge cases
        tail = dummy          # Tail pointer to build result list

        # Traverse both lists while both have nodes
        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1     # Append smaller node
                list1 = list1.next    # Advance list1
            else:
                tail.next = list2
                list2 = list2.next    # Advance list2
            tail = tail.next          # Move tail

        # At most one of list1 or list2 is non-empty at this point
        tail.next = list1 if list1 else list2

        return dummy.next  # Skip dummy and return actual merged head
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 3: Iterative - Linked List/Simple Traversal
```python
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(-101) # the next of this will start off the new list
        cur = dummy

        while list1 and list2:
            if list1.val <= list2.val:
                cur.next = list1
                cur = list1
                list1 = list1.next
            else:
                cur.next = list2
                cur = list2
                list2 = list2.next
        
        if not list1:
            cur.next = list2
        else:
            cur.next = list1
        

        return dummy.next
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

## 141. Linked List Cycle ::1:: - Easy

Topics:  Hash Table, Linked List, Two Pointers

### Intro
> Given head, the head of a linked list, determine if the linked list has a cycle in it.
> There is a cycle in a linked list if there is some node in the list that can be
> reached again by continuously following the next pointer. 
> Internally, pos is used to denote the index of the node that tail's next pointer is
> connected to. Note that pos is not passed as a parameter.
> Return true if there is a cycle in the linked list. Otherwise, return false.
> Follow up: Can you solve it using O(1) (i.e. constant) memory?

|  Example Input           | Output |  
| ---------------- | ------ | 
| head = [1,2,3,4,5] | [5,4,3,2,1] |
| head = [1,2] | [2,1] |  
| head = [] | [] |  

 
Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 &leq; Node.val &leq; 5000

### Abstraction
Given a linked list, reverse it iteratively and recursively.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Track Visited Notes - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()
        curr = head
        
        while curr:
            if curr in visited:
                return True
            visited.add(curr)
            curr = curr.next
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



### Solution 2: Floyd Cycle Detection Tortoise and Hare - Linked List/Simple Traversal
```python
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                return True
        
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

