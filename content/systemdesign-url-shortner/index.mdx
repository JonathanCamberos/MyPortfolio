---
title: "Design: URL Shortener"
description: "url shortener"
image: "../../public/Notes/url-shortener.png"
publishedAt: "2025-10-13"
updatedAt: "2025-10-13"
author: "jonathancamberos"
isPublished: true
tags:
- system design
---

## 1. Design Bit.ly

Topics: Scaling Reads

## Functional Requirements ::2::

> Features needed to satisfy the needs of the user.

### In Scope

1. Users should be able to submit a long URL and receive a shortened URL.

- Optionally, users should be able to specify a custom alias.

- Optionally, users should be able to specify an expiration date.

2. Users should be able to access the original URL by using the shortened URL.

### Out of Scope

1. User authentication and account management

2. Analytics on link clicks (e.g., click counts, geographic data).


## Non Functional Requirements ::4::

> Specifications about how a system operates, rather than what tasks it performs.
> Defines system attributes like scalability, latency, security, availability,
> and are often framed as specific benchmarks.
> (e.g., system's ability to handle 100 million daily active users,
> response to queries within 200 milliseconds)

### Benchmarks

1. System should ensure uniqueness for short codes (no two long URLs should
map to the same short URL)

2. Redirection should occur with minimal delay (< 100 ms)

3. System should be reliable and available 99.99% of the time
(availability > consistency)

4. System should scale to support 1B shortened URLs and 100M DAU

### Out of Scope

1. Data consistency in real time analytics

2. Advanced security features like spam detection and malicious URL filtering.

Note: 
The important consideration in this system is the imbalance 
between reads and writes.
The ratio is skewed towards reads, 
since users will more frequently access shortened URLs vs create new ones.
(e.g., average pf 1000 reads to 1 create).
Our caching strategies, database choices, and architecture
will revolve around this.

## Set Up

### Entities

> The core objects or concepts within a system which define its 
> functionality and data.

In our case simple, but still good to list out.
The core entities are the long URL, short URL, and user.

### API: the delivery framework ::2::

> The contract between the client and the server
> and first point of reference in high level design.

We simply use a REST API and map the requirement to the correct HTTP method:
- POST: Create a new resource
- GET: Read an existing resource
- PUT: Update an existing resource
- DELETE: Delete an existing resource

In our case, functional requirements and end points map 1:1 for 
create short url -> POST and get long url -> GET.

1. POST: Generate a new short URL

A POST endpoint to intake the long URL, 
optional alias, optional expiration date, and return the short URL.

```json
// Generate short URL from long URL
Request: POST/{long_url}
Body:
    {
        "long_url": "https://www.example.com/some/very/long/url",
        "custom_alias": "optional_custom_alias",
        "expiration_date": "optional_expiration_date"
    }
    
Response: HTTP/1.1 201 Created
Body:
    {
        "short_url": "http://short.ly/abc123"
    }
```

2. GET: Retrieve an existing long URL

A GET endpoint that intakes the short url,
and redirects the user to the original long URL.

```json
// Using short URL, redirect to original long URL
Request: GET/{short_url}

Response: HTTP 302 Redirect to the original long URL
```


## High Level Design Functional Requirement 1: User submits a long URL and receives a short URL

High level design for short url creation.

Core components high level:
1. Client: Users interact with system through web or mobile app
2. Primary Server: Receives requests from client and handles logic
3. Database: Stores mapping of short URLs to long URLs, user generated aliases, and expiration dates

### POST Diagram
```python
User submits a long URL and receives a short URL():

                            +--------+
Request:                    | Client |          Response:
POST/urls                   +--------+          HTTP 201: Created 
{                               ^               {
    "long_url": ...             |                   "short_url": "http://short.ly/abc123"
    "custom_alias": ...         |               }
    "expiration_date": ...      |                or 
}                               |               HTTP 400/409/500 (failure)
                                |               {
                                |                   "error": "..."
                                |               }
                                v                   
                        +------------------+
Write():                | Primary Server   |    On Success: 
1) generate short URL   +------------------+        Return short URL
2) SQL Query (INSERT)           ^               On Failure:
                                |                   Return error msg
                                |
                                |
                                v
                            +-----------+
Urls Table                  | Database  |    SQL Insert: 
{                           +-----------+    INSERT INTO Urls (...)     
    string short_url                                
    string original_url                             
    datetime creation_time                          
    datetime expiration_time                        
    created_by                                      
}
```

### POST Processing Logic


1. Client Request()

Client sends a POST request to */urls*:
Sends long URL, custom alias, expiration dates.

2. Primary Server processes Request() 

Validates that is a real URL (to avoid unnecessary shortening),
via open-source library like is-url or our own validation

Validates that it does not already exist in our system (to avoid collisions),
via querying our database to check if long URL is already present

3. Primary Server Validation()

If URL is valid and does not already exist, we can generate a short URL
Abstract this to magic function for now

If user specified alias, we can use that as short code

4. Primary Server Insert Database()

Once short URL is generated, we insert it into our database
Store short URL, long URL, and expiration date

5. Primary Server Response()

Return short URL to client.
Send back response to client with short URL.


## High Level Design Functional Requirement 2: User can access original long URL by using short URL

High level design for redirection to the original long url.

### GET Diagram

```python
User requests a short URL and is redirected to the original URL:

                                +--------+
Request:                        | Client |          Response:
GET/lookup                      +--------+          HTTP 302: Found
{                                   ^               {
    "short_url" : ...               |                   "Location": "https://www.example.com/"
}                                   |               }
                                    |               or
                                    |               HTTP 404/410/500 (failure)
                                    |               {
                                    |                   "error": "..."
                                    |               }
                                    v
                            +------------------+
Read():                     | Primary Server   |    On Success:
1) QUERY short URL          +------------------+        Return 302 redirect
2) Redirect on match                ^               On Failure:
                                    |                   Return error msg
                                    |
                                    |
                                    v
                                +-----------+
Urls Table                      | Database  |    SQL Query:
{                               +-----------+    SELECT * FROM Urls WHERE short_url_code = ...
    string short_url                                
    string original_url                             
    datetime creation_time                          
    datetime expiration_time                        
    created_by                                      
}
```

### GET Processing Logic

1. User Request()

User browser sends a GET request to serve with short URL *GET /abc123*

2. Primary Server Processes Request()

Primary server receives this request and looks up the short code in database

3. Primary Server Lookup and Validation()

If short code is found and not expired, server retrieves corresponding long URL.


4. Primary Server Response()

Server sends HTTP redirect response to user's browser, sending it to long URL.
There are two main HTTP redirects we could use for this purpose:

- HTTP/1.1 301 (Permanent Redirect):
Indicate resource has permanently moved to target URL, which will typically
cause browsers to cache this responses, leading to future requests for
the short URL to go directly to the long URL, bypassing the server.

- HTTP/1.1 302 (Temporary Redirect):
Indicate resource has temporary moved to target URL, which browsers
do not cache this response, leading to future requests for the short URL 
to go through our primary server first.

We will use 302 redirect because:

- Prevents browser caching and gives us direct control over redirection 
process, in case we need to update or expire links as needed

- Allows us to track click statistics for each short URL, since it is
forced to go through our primary server


## Deep Dive 1: Short and Unique Urls

### Ensuring URLS are unique

The constraints we need to ensure:

1. Each short URLs should be unique
2. Keep short URLs as short as possible
3. Efficiently generate short URLs

### Bad Solution: Long URL Prefix

Approach:

The simplest thing we could do is take a prefix of the input as the short code.

```h
www.linkedin.com/ -> www.short.ly/www.link
```

Challenges: 

This would break constraint 1. as different URLs could have the same short URL.


### Good Solution: Random Number Generator or Hash Function

Approach:

To add entropy (randomness) to ensure our codes our unique, we could
try a random number generator or hash function.

Challenges:

Even with entropy, there is a non negligible changes of generating duplicate
short codes, due to our constraint 2 of short codes.
Tis leads to a necessity of either generating longer short codes (breaking 
constraint 2) or adding a check for already existing code which becomes a 
bottleneck as the system scales (breaking constraint 3)

### Great Solution: Unique Counter with Base62 Encoding

Approach:

One solution to guaranteeing no collisions is to increment a counter for each 
new url. We would then take the output and encode it using base62 encoding
to ensure short representation.

Each counter value would be unique which then eliminates the risk of collisions.

Challenges: 

In a distributed environment, maintaining a single global counter can be 
challenging due to synchronization issues. 
All instances of our primary server would need to agree on the counter value.

Challenges:

With length, if we have 1B urls, when base62 encoded will lead to 6 character
strings. 

So we would need to move to 7 character codes once we hit the trillions.


## Deep Dive 2: Fast Redirection to Original URL

### Ensuring user redirection is fast

When dealing with a large database of shortened URLs,
our constraints are:

1. Find the right match quickly for smooth user experience
2. Add optimization to avoid 'full table scans' checking every 
single pair of short and original URLs in the database

### Good Solution: Add an Index

### Great Solution: Implementing an In Memory Cache (e.g, Redis)

### Great Solution: Leveraging Content Deliver Networks (CDNs) and Edge Computing


## Deep Dives: Scaling to 1B shortened URLs and 100M DAU
