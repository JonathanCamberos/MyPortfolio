---
title: "LeetCode: Binary Search"
description: "binary search"
image: "../../public/Notes/binary-search.png"
publishedAt: "2025-05-03"
updatedAt: "2025-05-03"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Binary Search Intro:

Leetcode problems with elegant solutions using binary search. 

### What is Binary Search
Binary Search is a divide and conquer algorithm for searching 
sorted lists.

It works by creating a middle value, comparing middle value to the target
in order to split the search space in half, then searching the 
left or right side accordingly

### Why Use Binary Search
Since binary search eliminates half the search space each step it each 
O(log n) time complexity as well as O(1) space complexity for iterative 
and O(log n) for recursive due to the call stack. 

This is an improvement from linear search which takes O(n) time.


### Binary Search Application: Searching
Using Binary Search to locate the position of a target element 
in a sorted list by repeatedly dividing the search interval in half.

Ex: Searching for a target number in a sorted array.
```python
    def binarySearch(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid  # Target found
        elif nums[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half

    return -1  # Target not found
```

### Binary Search Application: Layered Binary Search
Applying binary search in multiple stages or layers, typically to 
first narrow down a substructure (i.e., row, segment, or time range), 
and then again within that substructure

This approach is useful when data is structured in nested sorted layers.

Ex: Searching for a target in a sorted 2D matrix
```python
    def searchMatrix(matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False

        rows, cols = len(matrix), len(matrix[0])

        # First layer: Binary search over rows to find candidate row
        top, bottom = 0, rows - 1
        while top <= bottom:
            mid_row = (top + bottom) // 2
            if matrix[mid_row][0] <= target <= matrix[mid_row][-1]:
                break
            elif matrix[mid_row][0] > target:
                bottom = mid_row - 1
            else:
                top = mid_row + 1
        else:
            return False  # Target is outside all row ranges

        # Second layer: Binary search within the found row
        row = mid_row
        left, right = 0, cols - 1
        while left <= right:
            mid_col = (left + right) // 2
            if matrix[row][mid_col] == target:
                return True
            elif matrix[row][mid_col] < target:
                left = mid_col + 1
            else:
                right = mid_col - 1

        return False
```

## 704. Binary Search ::2:: - Easy

Topics:  Array, Binary Search

### Intro
> Given an array of integers nums which is sorted in ascending order, 
> and an integer target, write a function to search target in nums.
> If target exists, then return its index. Otherwise, return -1.
> You must write an algorithm with O(log n) runtime complexity.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [-1,0,3,5,9,12] target = 9 | 4 |
| nums = [-1,0,3,5,9,12], target = 2 | -1  |  
 
Constraints:

1 &leq; nums.length &leq; 10<sup>4</sup>

-10<sup>4</sup> &le; nums[i], target &le; 10<sup>4</sup>

All the integers in nums are unique

nums is sorted in ascending order


### Abstraction
Given a sorted list of elements, find the target

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug: (iterating element-wise)
```python
```

### Solution 1: Recursive Binary Search - Binary Search/Searching
```python
    def search(self, nums: List[int], target: int) -> int:
        
        # Note:
        # Recursive binary search calls itself with smaller range

        def helper(left: int, right: int) -> int:
            # base case: target not found
            if left > right:
                return -1

            mid = (left + right) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                return helper(mid + 1, right)
            else:
                return helper(left, mid - 1)

        # time complexity: each call halves the search space O(log n)
        # space complexity: call stack grows with depth O(log n)
        result = helper(0, len(nums) - 1)

        # overall: time complexity O(log n)
        # overall: space complexity O(log n)
        return result
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Variable assigning | O(1) | O(1) | Initializing variables in constant O(1) | No additional memory allocation for constant variables O(1) |
| Recursive Binary Search | O(log n) | O(log n) | Search space is halved on each recursive call O(log n) | Call stack grows to depth O(log n) |
| Overall | O(log n) | O(log n) | Binary search over sorted list dominates, leading to O(log n) | Stack memory used for recursive calls dominates, leading to O(log n) |

### Solution 2: Iterative Binary Search - Binary Search/Searching
```python
    def search(self, nums: List[int], target: int) -> int:
        
        # Note:
        # simple binary search

        # space complexity: simple variables in constant O(1)
        left, right = 0, len(nums)-1

        # time complexity: split search area per iteration O(log n)
        # space complexity: iterative search, no call stack, O(1)
        while left <= right:
            
            mid = (left+right)//2
            
            # found target, return
            if nums[mid] == target:
                return mid

            # search right side of subsection
            elif nums[mid] < target:
                left = mid + 1
            
            # search left side of subsection
            else: 
                right = mid - 1

        # overall: time complexity O(log n)
        # overall: space complexity O(1)
        return -1
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Variable assigning | O(1) | O(1) | Initializing variables in constant O(1) | No additional memory allocation for constant variables O(1) |
| Iterative Binary Search | O(log n) | O(1) | Loop halves the search space on each iteration O(log n) | No additional memory allocation beyond loop variables O(1) |
| Overall | O(log n) | O(1) | Binary search over sorted array O(log n) | No additional memory allocation O(1) |







## 74. Search a 2D Matrix ::1:: - Easy

Topics:  Array, Binary Search, Matrix

### Intro
> You are given an m x n integer matrix matrix with the following two properties:
> Each row is sorted in non-decreasing order.
> The first integer of each row is greater than the last integer of the previous row.
> Given an integer target, return true if target is in matrix or false otherwise.
> You must write a solution in O(log(m * n)) time complexity.

|  Example Input   | Output |  
| ---------------- | ------ | 
| matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 | true |
| matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 | false  |  
 
Constraints:

m == matrix.length
n == matrix[i].length

1 &leq; m, n &leq; 100

-10<sup>4</sup> &le; matrix[i][j], target &le; 10<sup>4</sup>

### Abstraction
Given a sorted matrix, check if target is in matrix

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |

| Bug | Error |
| --- | ----- |
|  |  | 

### Brute Force: (iterative)
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug: (iterating element-wise)
```python
```

### Solution 1: Flattened Matrix Binary Search - Binary Search/Searching
```python
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        
        # Note:
        # Treats the 2D matrix as a sorted 1D array by flattening indices.
        # Uses binary search on the 1D index space,
        # and converts indices to 2D coordinates with the helper function.
        # This approach runs in O(log(m * n)) time and O(1) space.
        
        # 
        def index_to_coords(index: int, cols: int) -> tuple[int, int]:
            # Convert 1D index to 2D matrix coordinates (row, col)
            row = index // cols
            col = index % cols
            return row, col

        # Check empty matrix
        if not matrix or not matrix[0]:
            return False

        # initialize matrix size
        rows, cols = len(matrix), len(matrix[0])

        # flattened 2D matrix ends
        left, right = 0, rows * cols - 1

        # time complexity: binary search on flattened 2D matrix [0,(m*n)-1] O(log(m*n))
        # space complexity: constant variables O(1)
        while left <= right:
            mid = (left + right) // 2
            row, col = index_to_coords(mid, cols)
            mid_value = matrix[row][col]

            # check if target
            if mid_value == target:
                return True
            
            # check right space
            elif mid_value < target:
                left = mid + 1
            
            # check left space
            else:
                right = mid - 1

        # overall time complexity: O(log(m*n))
        # overall space complexity: O(1)
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Binary search 1D index | O(log (m*n)) = O(log(m) + log(n)) | O(1) | Binary search over full flattened matrix treated as 1D O(log (m*n)) | No additional memory allocation |


### Solution 2: Two Phase Binary Search Row and Column - Binary Search/Searching
```python
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        
        # Note:
        # Performs two separate binary searches:
        # 1. Binary Search over rows to locate potential row
        # 2. Binary Search within that row to find the target
        
        # diagram:
        # matrix = [
        # [ 1,  3,  5],   # row 0
        # [ 7,  9, 11],   # row 1
        # [13, 15, 17],   # row 2
        # ]

        # Check if empty
        if not matrix or not matrix[0]:
            return False

        # initialize matrix size
        rows, cols = len(matrix), len(matrix[0])

        # First layer: Binary search over rows to find candidate row
        # top and bottom rows
        top, bottom = 0, rows - 1

        # time complexity: binary search over rows
        while top <= bottom:

            # grab mid row
            mid_row = (top + bottom) // 2

            # if target is within curr row
            if matrix[mid_row][0] <= target <= matrix[mid_row][-1]:
                break

            # search above rows (lower rows, see diagram)
            elif matrix[mid_row][0] > target:
                bottom = mid_row - 1

            # search below rows (upper rows, see diagram)
            else:
                top = mid_row + 1

        # Target is outside all row ranges
        else:
            return False
            
        # Second layer: Found valid row candidate, binary search within row
        row = mid_row
        left, right = 0, cols - 1

        # binary search
        while left <= right:
            mid_col = (left + right) // 2
            if matrix[row][mid_col] == target:
                return True
            elif matrix[row][mid_col] < target:
                left = mid_col + 1
            else:
                right = mid_col - 1

        # overall: time complexity 
        # overall: space complexity
        return False
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Binary search rows | O(log m) | O(1) | Binary search across m rows O(log m) | No additional memory allocation for binary search O(1) |
| Binary search columns | O(log n) | O(1) | Binary search across column of n length O(log n) | No additional memory allocation for binary search O(1) |
| Overall | O(log m + log n) = O(log (m*n)) | O(1) | Sum of two binary searches dominates, leading to O(log m + log n) | No additional memory allocation, leading to O(1)  |


