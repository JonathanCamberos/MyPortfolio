---
title: "2D Dynamic Programming"
description: "2D dynamic programming"
image: "../../public/Notes/2d-dynamic-programming.png"
publishedAt: "2025-05-03"
updatedAt: "2025-05-03" 
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---


hello!

### Dynamic Programming Application: 2D Grid Traversal
Each cell depends on top and or left neighbors (classic grid DP)

Ex: Unique Paths
```python
    def uniquePaths(m, n):
        # dp[r][c] = number of ways to reach (r, c)
        dp = [[1]*n for _ in range(m)]
        for r in range(1, m):
            for c in range(1, n):
                dp[r][c] = dp[r-1][c] + dp[r][c-1]
        return dp[m-1][n-1]
```

### Dynamic Programming Application: Knapsack Pattern
Choose or skip and item with branching recurrence.

Ex: 0/1 Knapsack
```python
    def knapsack(weights, values, capacity):
        n = len(weights)
        dp = [[0]*(capacity+1) for _ in range(n+1)]
        for i in range(1, n+1):
            for w in range(1, capacity+1):
                if weights[i-1] <= w:
                    dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
                else:
                    dp[i][w] = dp[i-1][w]
        return dp[n][capacity]
```

### Dynamic Programming Application: Interval Pattern
Sub problems are defined over intervals [i..j], often solved 
by increasing interval length.

Ex: Matrix Chain Multiplication
```python
    def matrixChain(p):
        n = len(p) - 1
        dp = [[0]*n for _ in range(n)]
        for length in range(2, n+1):
            for i in range(n-length+1):
                j = i + length - 1
                dp[i][j] = min(
                    dp[i][k] + dp[k+1][j] + p[i]*p[k+1]*p[j+1]
                    for k in range(i, j)
                )
        return dp[0][n-1]
```

### Dynamic Programming Application: Subsequence Pattern
Compare characters or elements -> branch on match/mismatch.

Ex: Longest Common Subsequence
```python
    def lcs(text1, text2):
        m, n = len(text1), len(text2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if text1[i] == text2[j]:
                    dp[i][j] = 1 + dp[i+1][j+1]
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j+1])
        return dp[0][0]
```

### Dynamic Programming Application: Tree Pattern
Solve each subtree, combine children’s results, bubble up

Ex: House Robber III
```python
    def dfs(node):
        if not node: return (0, 0)
        leftRob, leftSkip = dfs(node.left)
        rightRob, rightSkip = dfs(node.right)

        rob = node.val + leftSkip + rightSkip
        skip = max(leftRob, leftSkip) + max(rightRob, rightSkip)
        return (rob, skip)

    robRoot, skipRoot = dfs(root)
    answer = max(robRoot, skipRoot)
```

### Dynamic Programming Application: Graph Pattern
Each node’s dp depends on its neighbors (outgoing edges)
via Topological sort or DFS memoization.

Ex: Longest Path in DAG
```python
    def dfs(node):
        if node in memo: return memo[node]
        best = 0
        for nei in graph[node]:
            best = max(best, 1 + dfs(nei))
        memo[node] = best
        return best

    answer = max(dfs(node) for node in all_nodes)
```

### Dynamic Programming Application: Graph Pattern
Iterate over subsets or use bitmask recursion
State encodes "which items are chosen"

Ex: Traveling Salesman or Visit All Nodes
```python
    def dp(mask, i):
        if mask == (1 << n) - 1:
            return 0
        if (mask, i) in memo: return memo[(mask, i)]

        best = float('inf')
        for j in range(n):
            if not (mask & (1 << j)):
                best = min(best, graph[i][j] + dp(mask | (1 << j), j))
        memo[(mask, i)] = best
        return best

    answer = min(dp(1 << i, i) for i in range(n))
```
