---
title: "LeetCode: Stacks"
description: "stacks"
image: "../../public/Notes/stack.png"
publishedAt: "2025-06-02"
updatedAt: "2025-06-03"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

## Stack Intro

LeetCode problems with elegant solutions using stacks.

### Stack Application: Tracking Nested or Hierarchical Structures

We can track structure while iterating over an object ensuring it maintains 
some criteria

Ex: Validate if a string containing brackets ()[]{} is properly balanced:
```python
    def balancedParentheses(s: str) -> bool:
        stack = []
        pairs = {')': '(', ']': '[', '}': '{'}
        for char in s:
            if char in pairs.values():
                stack.append(char)
            elif char in pairs:
                if not stack or stack.pop() != pairs[char]:
                    return False
        return not stack
```

### Stack Application: Backtracking by Tracking History or State
We can use stacks in backtracking to store the state of exploration. 
When a branch reaches a dead end or a solution, we pop the state to return
to the previous state and continue exploring other branches.

Ex: Subset Sum with Backtracking
```python
    def subset_sum(nums, target):
        stack = [(0, [], 0)]  # (index, current_subset, current_sum)
        result = []
        
        while stack:
            index, current_subset, current_sum = stack.pop()
            
            if current_sum > target:  # Prune invalid paths
                continue
            
            if current_sum == target:  # Valid solution
                result.append(list(current_subset))
                continue
            
            # Push new states for further exploration
            for i in range(index, len(nums)):
                stack.append((i + 1, current_subset + [nums[i]], current_sum + nums[i]))
        
        return result

    # subset_sum([2, 3, 6, 7], 7) = [[7]]
```


### Stack Application: Monotonic Property Maintenance
A stack can maintain a monotonic property (increasing or decreasing)
over a sequence while processing elements, ensuring efficient lookups
or modifications.

Ex: Find the Next Greater Element
```python
    def nextGreaterElement(nums):
        stack = []  # Stores indices of elements in decreasing order
        result = [-1] * len(nums)  # Initialize result with -1
        
        for i in range(len(nums)):
            while stack and nums[i] > nums[stack[-1]]:
                idx = stack.pop()
                result[idx] = nums[i]  # Found the next greater element
            stack.append(i)
        
        return result

    # Example: nextGreaterElement([2, 1, 2, 4, 3]) -> [4, 2, 4, -1, -1]
```

### Stack Application: Simulating Recursion or Call Stacks
We can use a stack to emulate recursion by explicitly managing the call stack.

Ex: Traverse a binary tree in preorder (root -> left -> right):
```python
    def preorderTraversal(root):
        if not root:
            return []
        
        stack = [root]  # Start with the root node
        result = []
        
        while stack:
            node = stack.pop()  # Simulate recursion by processing the top of the stack
            if node:
                result.append(node.val)  # Visit the node
                # Push right child first so the left child is processed next
                if node.right:
                    stack.append(node.right)
                if node.left:
                    stack.append(node.left)
        
        return result

    # Example: For a tree with root → 1, left → 2, right → 3, preorderTraversal(root) -> [1, 2, 3]
```

### Stack Application: Expression Evaluation and Parsing
We can use a stack to evaluate or parse expressions by storing operands
and incrementally applying operators. 
This approach is well-suited for postfix and prefix notations.

Ex: Post and Prefix
```python
    def evaluatePostfix(expression):
        stack = []  # To hold operands during evaluation
        
        for token in expression.split():
            if token.isdigit():  # If it's an operand, push it to the stack
                stack.append(int(token))
            else:  # If it's an operator, pop two operands and apply the operator
                b = stack.pop()
                a = stack.pop()
                if token == '+':
                    stack.append(a + b)
                elif token == '-':
                    stack.append(a - b)
                elif token == '*':
                    stack.append(a * b)
                elif token == '/':  # Assuming integer division
                    stack.append(a // b)
        
        return stack.pop()  # Final result is the only item left in the stack

    # Example:
    # Input: "3 4 + 2 * 1 +"
    # Output: 15 (Equivalent to (3 + 4) * 2 + 1)
```


### Stack Application: Dynamic Programming State Compression
We can use a stack to compress the necessary state while scanning through data,
especially when enforcing a specific constraint or invariant like monotonicity.
Instead of storing the entire history, we prune irrelevant elements from the stack
to keep only the most useful summary of the past

Ex: Given an array, partition it into the minimum number of strictly 
increasing subsequences
```python
    def min_partitions(nums):
        stacks = []  # Each element represents the last number in a subsequence
        
        for num in nums:
            placed = False
            for i in range(len(stacks)):
                # If we can append to subsequence i
                if stacks[i] < num:
                    stacks[i] = num
                    placed = True
                    break
            if not placed:
                # Start a new subsequence (partition)
                stacks.append(num)
        return len(stacks)

    # Example usage:
    nums = [1, 3, 2, 4, 6, 5]
    print(min_partitions(nums))  # Output: 2
```

### Stack Application: Interval and Range Processing
We can use stacks to efficiently process intervals or ranges,
such as merging overlapping intervals, calculating spans,
or finding next/previous smaller or larger elements within a range.

Ex: Largest Rectangle in Histogram
```python
    def largestRectangleArea(heights):
        stack = []  # stores indices of bars
        max_area = 0
        
        for i, h in enumerate(heights + [0]):  # Add sentinel to flush stack
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                left = stack[-1] if stack else -1
                width = i - left - 1
                max_area = max(max_area, height * width)
            stack.append(i)
        
        return max_area

    # Example:
    # Input: [2, 1, 5, 6, 2, 3]
    # Output: 10  (largest rectangle is formed by heights 5 and 6)
```

## 20. Valid Parentheses ::2:: - Easy

Topics:  String, Stack  

### Intro
> Given a string s containing: ( ) [ ] \{ \},
> determine if the input string is valid. 
> An input string is valid if: 1. Open brackets must be closed by the same type
> of brackets 2. Open brackets must be closed in the correct order. 3. Every close
> bracket has a corresponding open bracket of the same type.

|  Input   | Output  |  
| -------- | ------- | 
| "()"     | true    | 
| "()[]()" | false   |
| "(]"     | true    |
| "([])"   | true    |


Constraints:

1 &le; s.length &le; 10<sup>4</sup>

s consists of parentheses only '()[]{}'

### Abstract
We need to validate that every open parenthesis has a matching close
in the correct order.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (replace with empty) |  |  |  |  |
| Stack (redundant operations) |  |  |  |  |
| Stack |  |  |  |  |

### Brute Force: Replace Pairs with empty
```python
    def isValid(self, s: str) -> bool:
        
        # note: 
        # in python, an empty string "" is falsy evaluating to false
        # not "" -> true

        # each iterate removes at least one pair 
        # there are at most n/2 pairs so O(n/2) iterations O(n/2)
        # each iteration takes O(n)
        # leading to: O(n) * O(n/2) = O(n^2)
        # time complexity: iterate over string of n length O(n)
        while '()' in s or '{}' in s or '[]' in s:
            # time complexity: n/2 replacements O(n/2), per total outer iterations O(n), leading to O(n^2)
            s = s.replace('()', '').replace('{}', '').replace('[]', '')
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return not s
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate over string | O(n) | O(1) | Iterate over array of n length O(n) | No additional memory allocation for iteration O(1) |
| Total Iterations | O(n/2) | O(1) | At most n/2 pairs and thus n/2 removals O(n/2) | No additional memory allocation for iteration O(1) |
| Overall | O(n<sup>2</sup>) | O(1) | Single iteration in O(n) for total iterations n/2 O(n/2), leading to O(n<sup>2</sup>) time complexity | No additional memory allocation for iteration, leading to constant O(1) | 

### Find the Bug: Hashmap Count (does not track order)
```python
    def isValid(self, s: str) -> bool:

        # time complexity: constant hashmap of 3 length O(1)
        counts = {"(": 0, "[": 0, "{": 0}
        closing = {")": "(", "]": "[", "}": "{"}

        # time complexity: iterate over string of n length O(n)
        for c in s:

            # Count opening brackets
            # time complexity: lookup operation in constant O(1)
            if c in counts:  
                counts[c] += 1

            # Count closing brackets
            # time complexity: lookup operation in constant O(1)
            else c in closing:  

                closingMatch = closing[c]

                # No matching opening bracket
                if counts[closingMatch] == 0:  
                    return False

                # Matching opening bracket
                counts[closingMatch] -= 1

        # INCORRECT: hashmap open value may be 0, but did not take into 
        # consideration whether they were in the correct order
        # time complexity: iterate over hashmap of 3 length O(1)
        for count in counts.values():
        if count != 0:
            return False

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return True
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate |  |  |  |  |
| Verify |  |  |  |  |
| Overall |  |  |  |  | 

### Find the Bug: Forgot to append to stack
```python
    def isValid(self, s: str) -> bool:

        stack = []
        mapping = {
            ')' : '(',
            ']' : '[',
            '}' : '{'
        }

        for c in s:

            if c in mapping:

                if not stack:
                    return False

                topElem = stack.pop()

                if mapping[c] != topElem:
                    return False 

            # INCORRECT:
            # missing else clause to append char to stack
            # should be:
            # else:
            #   stack.append(c)

        return not stack
```


### Find the Bug: Did not check for empty Stack
```python
    def isValid(self, s: str) -> bool:

        stack = []

        mapping = {
            ')' : '(',
            ']' : '[',
            '}' : '{'
        }

        for c in s:
            
            if c in mapping:

                if not stack:
                    return False

                topElem = stack.pop()

                if mapping[c] != topElem:
                    return False
            else:
                stack.append(c)
        
        # INCORRECT:
        # stack could still have elements and be invalid
        return True
```

### Solution 1: Manual Condition Stack Check - Stack/Tracking Nested or Hierarchical Structures 
```python
    def isValid(self, s: str) -> bool:

        # note: in python, an empty list [] is falsy evaluating to false
        # not [] -> true

        # space complexity: stack stores up to n opening brackets O(n)
        stack = []

        # time complexity: iterate over list of n length O(n)
        for c in s:

            # found closing bracket, match with opening bracket
            if c in ')]}':

                # check stack is empty, no matching opening available
                if not stack:
                    return False

                # time complexity: pop in constant O(1)
                topElem = stack.pop()

                # check if opening matches closing
                if  ((c == ')' and topElem != '(') or
                     (c == '}' and topElem != '{') or
                     (c == ']' and topElem != '[')):
                    return False

            # found opening bracket, push to stack
            if c in '([{':
                stack.append(c)
                               
        # if stack is empty, success

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return not stack
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration | O(n) | O(n) | Iteration string of n length O(n)| Memory allocation for n opening brackets O(n) |
| Validation | O(1) | O(1) | Pop in constant O(1) and char comparison in constant O(1) | No additional memory allocation for pop or comparison O(1) |
| Overall | O(n) | O(n) | Iteration over string of n length dominates, leading to O(n) | Memory allocation for stack with n opening brackets dominates, leading to O(n) | 


### Solution 2: Stack with Hashmap lookup - Stack/Tracking Nested or Hierarchical Structures
```python
    def isValid(self, s: str) -> bool:

        # space complexity: stack stores opening brackets for string n length O(n)
        stack = []

        # space complexity: closed -> open mapping in constant O(1)
        mapping = {
            ')' : '(',
            ']' : '[',
            '}' : '{'
        }

        # time complexity: iterate over string of n length O(n)
        for c in s:
            
            # found closing bracket, match with opening bracket
            if c in mapping:

                # check stack is empty, no matching opening available
                if not stack:
                    return False

                # time complexity: pop in constant O(1)
                topElem = stack.pop()

                # check if opening matches closing
                if mapping[c] != topElem:
                    return False
            
            # found opening bracket, push to stack
            else:   
                stack.append(c)
                
        # if stack is empty, success

        # overall: time complexity O(n)
        # overall: space complexity
        return not stack
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration | O(n) | O(n) | Iteration over string of n length O(n) | Memory allocation for stack for n opening brackets O(n) |
| Validation | O(1) | O(1) | Pop in constant O(1) and char comparison in constant O(1) | No additional memory allocation for pop or comparison O(1) |
| Overall | O(n) | O(n) | Iteration over string of n length dominates, leading to O(n) | Memory allocation for stack for n opening brackets dominates, leading to O(n) | 


## 155. Min Stack ::2:: - Medium

Topics:  Stack, Design

### Intro
> Design a stack that supports push, pop, top, and retrieving 
> the minimum element in constant time.
> Implement the MinStack class:
> MinStack() initializes the stack object.
> void push(int val) pushes the element val onto the stack.
> void pop() removes the element on the top of the stack.
> int top() gets the top element of the stack.
> int getMin() retrieves the minimum element in the stack.
> You must implement a solution with O(1) time complexity for each function.

|  Input   | Output  |  
| -------- | ------- | 
| ["MinStack","push","push","push","getMin","pop","top","getMin"] [[],[-2],[0],[-3],[],[],[],[]] | [null,null,null,null,-3,null,0,-2]  | 

Constraints:

-2<sup>31</sup> &le; val &le; 2<sup>31</sup> - 1

Methods pop, top and getMin operations will always be called on non-empty stacks.

At most 3 * 10<sup>4</sup> calls will be made to push, pop, top, and getMin.

### Abstract
We need to design a stack that runs in O(1) time complexity for each main function.


### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def __init__(self):
        
        # tracking logical size vs physical size
        # space complexity: stores all n elements O(n)
        self.stack = []
        self.size = 0

    def push(self, val: int) -> None:
        # time complexity: append operation in constant O(1)

        # size = 1     vs [5, _, _]
        # logical size vs physical size -> 
        # stack will only grow when absolutely necessary / avoids unnecessary resizing
        if self.size < len(self.stack):
            # self.size == length, so append at self.size
            self.stack[self.size] = val
        else:
            # stack needs to grow
            self.stack.append(val)

        # increases logical size
        self.size += 1

    def pop(self) -> None:       
        if self.size == 0:
            raise IndexError("Pop from empty stack")

        # size = 2 [5, 4]
        # size = 1 [5, 4]
        # logical size vs physical size -> 
        # time complexity: pop operation in constant O(1)

        # decreases logical size
        self.size -= 1

    def top(self) -> int:
        if self.size == 0:
            raise IndexError("Stack is empty")
 
         # time complexity: index top element in constant O(1)
        return self.stack[self.size - 1]

    def getMin(self) -> int:
        if self.size == 0:
            raise IndexError("Stack is empty")
        
        minVal = float('inf')

        # stack is not minSorted
        # time complexity: iterate over entire stack n length O(n)
        for i in range(self.size):
            if self.stack[i] < minVal:
                min = self.stack[i] 
        return minVal

    # overall: time complexity O(n)
    # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def __init__(self):
        # space complexity: 
        self.stack = []
        self.size = 0
        self.minVal = float('inf')

    def push(self, val: int):
        # time complexity:
        if self.size < len(self.stack)
            self.stack[self.size] = val
        else:
            self.stack.append(val)

        # increases logical size
        self.size += 1

        if val < self.minVal:
            self.minVal = val

    def pop(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Pop from empty stack")
        
        # decreases logical size
        # INCORRECT: does not update minVal when the popped value is the minVal
        # Stack implementation does not track previous minVal for updates
        self.size -= 1

        
    def top(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Stack is empty")
        
        return self.stack[self.size - 1]

    def getMin(self):
        # time complexity:
        return self.minVal

    # overall: time complexity
    # overall: time complexity 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 1: 2 Stacks for main and min - Stack/Dynamic Programming State Compression
```python
class MinStack:

    # overall: space complexity O(n)
    def __init__(self):

        # Note:
        # minTracker stack tracks the min value at each level of the main stack. 

        # space complexity: two stacks for n elements O(n)

        # stores all pushed values
        self.mainStack = []
        # for each level, stores minimum value
        self.minTracker = []
        # logical size
        self.mainSize = 0

    def _validateNotEmpty(self, errMsg: str):
        if self.mainSize == 0:
            raise IndexError(errMsg)

    def _compressStack(self, stack):
        return self.mainSize < len(stack)
            
    # overall: time complexity O(1)
    def push(self, val: int):

        # add new val at index or append
        if self._compressStack(self.mainStack):
            self.mainStack[self.mainSize] = val
        else:
            self.mainStack.append(val)

        # add new min at index or append
        if self._compressStack(self.minTracker):
            # min between (new value, previous level of min stack)
            self.minTracker[self.mainSize] = min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val)
        else:
            self.minTracker.append(min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val))
        
        # increases logical size
        self.mainSize += 1

    # overall: time complexity O(1)
    def pop(self):
        # validate non empty, decrease logical length
        self._validateNotEmpty("Invalid pop, stack is empty")
        self.mainSize -= 1

    # overall: time complexity O(1)
    def top(self):
        # validate non empty, return elem
        self._validateNotEmpty("Invalid top, stack is empty")
        return self.mainStack[self.mainSize - 1]

    # overall: time complexity O(1)
    def getMin(self):
        # validate non empty, return min
        self._validateNotEmpty("Invalid getMin, stack is empty")
        return self.minTracker[self.mainSize - 1]

    # overall: time complexity O(1)
    # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Push | O(1) | O(1) | Insert to main and min stack in constant O(1) | No additional memory allocation for push operation O(1) |
| Pop | O(1) | O(1) | Decrease logical length in constant O(1) | No additional memory allocation for logical length decrease O(1) |
| Top | O(1) | O(1) | Indexing into main array in constant O(1) | No additional memory allocation for indexing array O(1) | 
| getMin | O(1) | O(1) | Indexing into min array in constant O(1) | No additional memory allocation for indexing array O(1) | 
| Overall | O(1) | O(n) | Each individual operation takes constant O(1) | MainStack and minTracker memory allocation dominate for n values, leading to O(n) | 


### Solution 2: Tuple Stack - Stack/Dynamic Programming State Compression
```python
class MinStack:
    
    # overall: space complexity O(n)
    def __init__(self):

        # Note: 
        # We combine the main and minTracker stack via a tuple (val, min), 
        # to track the min at each level of the stack.

        # space complexity: stores all pushed tuples (val, min) O(n)
        self.stack = []
        self.size = 0

    def _validateNotEmpty(self, errMsg: str):
        if self.size == 0:
            raise IndexError(errMsg)

    def _compressStack(self):
        return self.size < len(self.stack)

    # overall: time complexity O(1)
    def push(self, val: int):

        # min between (new value, previous level of stack)
        currMin = min(val, self.stack[self.size - 1][1] if self.size > 0 else val)
        
        # update min at index, or append
        if self._compressStack():
            self.stack[self.size] = (val, currMin)
        else:
            self.stack.append((val, currMin))

        # increases logical size
        self.size += 1

    # overall: time complexity O(1)
    def pop(self):
        self._validateNotEmpty("Invalid pop, stack is empty")
        self.size -= 1

    # overall: time complexity O(1)
    def top(self):
        self._validateNotEmpty("Invalid top, stack is empty")
        return self.stack[self.size - 1][0]

    # overall: time complexity O(1)
    def getMin(self):
        self._validateNotEmpty("Invalid getMin, stack is empty")
        return self.stack[self.size - 1][1]

    # overall: time complexity O(1)
    # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Push | O(1) | O(1) | Insert into stack in constant O(1) | No additional memory allocation for insert O(1) |
| Pop | O(1) | O(1) | Decrease logical length in constant O(1) | No additional memory allocation for decreasing logical length O(1) |
| Top | O(1) | O(1) | Indexing into array in constant O(1) | No additional memory allocation for indexing O(1) | 
| getMin | O(1) | O(1) | Indexing into array in constant O(1) | No additional memory allocation for indexing O(1) | 
| Overall | O(1) | O(n) | Each individual operation takes constant O(1) | Stack memory allocation dominates for n values, leading to O(n) | 
 
## 150. Evaluate Reverse Polish Notation ::1:: - Medium

Topics:  Array, Stack, Math, Design

### Intro
> You are given an array of strings tokens that represents an arithmetic 
> expression in a Reverse Polish Notation.
> Evaluate the expression. Return an integer that represents the value of
> the expression.
> Note that:
> The valid operators are '+', '-', '*', and '/'.
> Each operand may be an integer or another expression.
> The division between two integers always truncates toward zero.
> There will not be any division by zero.
> The input represents a valid arithmetic expression in a reverse polish notation.
> The answer and all the intermediate calculations can be represented in a 32-bit integer.

|  Input   | Output  |  
| -------- | ------- | 
| ["2","1","+","3","*"] | 9 | 
| ["4","13","5","/","+"] | 6 |
| ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] | 22 |

Constraints:

1 &le; tokens.length &le; 10<sup>4</sup>

tokens[i] is either an operator: "+", "-", "*", or "/", 
or an integer in the range [-200, 200].

### Abstract
We're designing abstract syntax tree that when execute, will execute the given
operations in reverse polish notation.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in "+-*/":
                # Push operand onto stack
                stack.append(int(token))
            else:
                # Pop two operands
                b = stack.pop()
                a = stack.pop()
                
                # Perform operation and push result
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                elif token == "/":
                    stack.append(int(a / b))  # Truncate towards 0

        return stack.pop()
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in "+-*/":
                stack.append(int(token))
            else:

                # INCORRECT order of popping operands
                a = stack.pop()  # a should be second operand
                b = stack.pop()  # b should be the first operand
                
                if token == "+":
                    stack.append(a + b)  # Incorrect operand order
                elif token == "-":
                    stack.append(a - b)  # Incorrect operand order
                elif token == "*":
                    stack.append(a * b)  # Correct, since order doesn't matter
                elif token == "/":
                    stack.append(int(a / b))  # Incorrect operand order

        return stack.pop()
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 1: Postfix Expression Evaluation Algorithm - Stack/Expression Evaluation and Parsing 
```python
    def evalRPN(self, tokens: List[str]) -> int:
        # space complexity: stack holds up to n/2 intermediate results O(n)
        stack = []

        # time complexity: iterate over tokens array of n length O(n)
        for token in tokens:

            # found operand, cast to int and push to stack
            if token not in "+-*/":
                stack.append(int(token))
            
            # found operator, grab operands and compute
            else:
                # time complexity: pop two operands from stack O(1)
                # input:    ["4","13","5","/","+"]
                # expected: 4 + (13 / 5) = 6
                # "4"    -> [4]
                # "13"   -> [4, 13]
                # "5"    -> [4, 13, 5]
                # "/"    -> [4, 2]         # a = 13, b = 5 → int(13 / 5) = 2
                # "+"    -> [6]            # a = 4, b = 2 → 4 + 2 = 6

                # 5
                b = stack.pop()
                # 13
                a = stack.pop()

                # apply operator manually and push result
                match token:
                    case "+":
                        stack.append(a + b)
                    case "-":
                        stack.append(a - b)
                    case "*":
                        stack.append(a * b)
                    case "/":
                        # a / b
                        # 13 / 5

                        # Explicit truncation towards zero
                        # -7 / 3         # -2.333  division:        leaves remainder
                        # -7 // 3        # -3      floor division:  rounds down "towards infinity"
                        # int(-7 / 3)    # -2      int(division):   truncates "toward 0", as required by RPN
                        stack.append(int(a / b))

        # return top of stack

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return stack[-1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Operands Stack | O(1) | O(n) | Insert into operands stack in constant O(1) | Stack will store at most n/2 operands, leading to O(n) | 
| Token iteration | O(n) | O(1) | Iteration over tokens array of n length O(n) | No additional memory allocation for iteration O(1) |
| Stack operations | O(1) | O(1) | Push and pop from stack in constant O(1) | No additional memory allocation for stack operations O(1) |
| Stack operations | O(1) | O(1) | Add, sub, multi, and div all in constant O(1) | No additional memory allocation for operations |
| Overall | O(n) | O(n) | Iterating over tokens array dominates, leading to O(n) | Operands stack for token array of n length dominates, leading to O(n) | 

## 22. Generate Parentheses ::4:: - Medium

Topics:  String, Stack, Dynamic Programming, Backtracking

### Intro
> Given n pairs of parentheses, write a function to generate all 
> combinations of well-formed parentheses.

|  Input   | Output  |  
| -------- | ------- | 
| 1 | ["()"] | 
| 3 | ["((()))","(()())","(())()","()(())","()()()"] |

Constraints:

1 &le; n &le; 8

### Abstract
Given a number, generate all possible combinations of parentheses.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # generates all possible combinations of n pairs of parentheses
        def generate_combinations(current, length, combinations):
            
            # base case: if 
            if length == 2 * n:
                combinations.append(current)
                return

            # recursively add '(' and ')' to the current string to generate all possible combinations
            generate_combinations(current + "(", length + 1, combinations)
            generate_combinations(current + ")", length + 1, combinations)

        # checks if given parentheses string is valid
        def isValid(s: str) -> bool:
            # counter to track balance of parentheses
            balance = 0

            # iterate through parentheses string
            for char in s:
                
                # increment balance
                if char == '(':
                    balance += 1
                # decrement balance
                else:
                    balance -= 1
                # closing parenthesis has no matching
                if balance < 0:
                    return False

            # validate all parentheses have match
            return balance == 0

        # grab all possible combinations
        combinations = []
        generate_combinations("", 0, combinations)

        result = []
        
        # generate and validate all combinations
        for combo in combinations:
            if isValid(combo):
                result.append(combo)
        
        # overall: time complexity
        # overall: space complexity
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # Initialize a stack to simulate depth-first search (DFS)        
        # (currString, openParenCount, closedParenCount)
        stack = [("", 0, 0)]
        result = []

        # while stack is non-empty
        while stack:

            # 
            current, openCount, closeCount = stack.pop()

            # if we have a valid combination of n '(' and n ')' add to list
            if openCount == n and closeCount == n:
                result.append(current)
                continue

            # INCORRECT: condition allows ')' to be added even if they exceed the number of '('
            # should be `closeCount < openCount`
            if closeCount < n:
                stack.append((current + ")", openCount, closeCount + 1))
            if openCount < n:
                stack.append((current + "(", openCount + 1, closeCount))

        # overall: time complexity
        # overall: space complexity
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 



### Solution 1: BackTracking with String Concatenation - Stack/Backtracking by Tracking History or State
```python
    def generateParenthesis(self, n: int) -> List[str]:

        # Note:
        # This approach uses backtracking to explore all valid sequences of well-formed parentheses.
        # A new string is created on each recursive call using string concatenation (e.g., current + "(").
        # This incurs additional time cost, as each concatenation creates a new string (not in-place).
        # Since each valid sequence has length 2n, and this concatenation happens at each level,
        # the time overhead accumulates across all recursive paths.
        # This makes the overall complexity O(Catalan(n) * n^2) in the worst case.
        # O(k) string concatenation overhead occurs with immutable strings.

        res = []

        # Backtracking        
        def helper(current: List[str], num_open: int, num_closed: int):
            # space complexity: call stack depth is O(n), string copying adds O(n) per leaf path, leading to O(n^2)

            # Base case: if the length of the current combination is 2 * n, it's complete
            if len(current) == n * 2:
                # convert list to string and add to res
                res.append(current)
                return

            # Recursive case 1: add '(' if the number of '(' used is less than n
            if num_open < n: 
                helper(current + "(", num_open + 1, num_closed)
            
            # Recursive case 2: add ')' if the number of ')' used is less than the number of '(', thus no unbalance
            if num_closed < num_open:
                helper(current + ")", num_open, num_closed + 1)

        # Start Backtracking process with an empty list and counts at 0
        helper("", 0, 0)

        # overall: time complexity O(Catalan(n) * n^2)
        # overall: space complexity O(Catalan(n) * n)
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Recursive Paths | O(Catalan(n)) | O(n) |  |  |
| String concatenation | O(n) per path | O(n) per result |  |  |
| Overall | O(Catalan(n) * n<sup>2</sup>) | O(Catalan(n) * n) |  |  | 

### Solution 2: BackTracking with Mutable List - Stack/Backtracking by Tracking History or State
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # Note:
        # This approach uses backtracking to explore all valid sequences of well-formed parentheses.
        # This avoids the O(k) string concatenation overhead that occurs with immutable strings,
        # by instead using a mutable list is used to efficiently build the current string in O(1) time per operation.
        # Only when a complete sequence is found (length == 2 * n), we convert the list to a string.
        # Compared to the string-based backtracking version, this method reduces overall string building cost.
        # Time complexity improves from O(Catalan(n) * n^2) to O(Catalan(n) * n) due to efficient append/pop.

        res = []
        
        # Backtracking
        def backtrack(current, openCount, closeCount):
            # time complexity: each recursion explores a state; only leaf call does ''.join(), leading to O(n)
            # space complexity: call stack depth O(n), current list holds up to 2n

            # Base case: if we have used all open and close parentheses
            if openCount == n and closeCount == n:
                # time complexity: convert once at leaf O(n)
                res.append("".join(current))
                return
            
            # Recursive case 1: add '(' if the number of '(' used is less than n
            if openCount < n: 
                
                # Backtrack by adding '(' to current string, incrementing openCount by 1
                current.append('(')
                # Recursive call explores all combinations starting from this new state
                helper(current, openCount + 1, closeCount)

                # Backtrack by removing the last added '('
                current.pop()
            
            # recursive case: Add ')' if the number of ')' used is less than the number of '('
            if closeCount < openCount:

                # Backtrack by adding ')' to the curr string, and incrementing closeCount by 1
                current.append(')')
                # Recursive call explores all combinations starting from this new state
                helper(current, openCount, closeCount + 1)

                # Backtrack by removing the last added ')'
                current.pop()

        # starts recursion with an empty string and zero counts
        # backtracking process builds strings by choosing '(' or ')' at each step
        # and checking a possible valid paths through the recursion tree
        backtrack([], 0, 0)

        # overall: time complexity O(Catalan(n) * n)
        # overall: space complexity O(Catalan(n) * n)
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Recursive paths | O(Catalan(n)) | O(n) | Exponential branching | Stack depth of 2n  |
| String creation | O(n) per complete path | O(n) per result | Only joined once per result | Each string result is size 2n |
| Overall | O(Catalan(n) * n) | O(Catalan(n) * n) | Avoids repeated copies | Stores all valid combinations | 

### Solution 3: Iterative Stack with State Tracking - Stack/Backtracking by Tracking History or State
```python
    def generateParenthesis(self, n: int) -> List[str]:

        # Note:
        # This solution uses an explicit stack to simulate the backtracking process iteratively.
        # Each stack element stores the current string and counts of open and closed parentheses,
        # enabling state tracking without recursion.
        # String concatenation cost is similar to recursive solutions.

        # store valid parentheses
        result = []
        # tracks state (current_string, open_count, closed_count)
        stack = [([], 0, 0)] 

        # time complexity: each state processed once, building up to O(Catalan(n)) strings
        # space complexity: stack can grow to O(Catalan(n)), result stores O(Catalan(n)) strings
        while stack:

            # grab current state, explored once
            curr, openCount, closeCount = stack.pop()

            # Base case: reached valid string
            if openCount == n and closeCount == n:
                # add valid string  
                result.append("".join(curr))
                continue

            # create new state by adding '('
            if openCount < n:
                stack.append((curr.append('('), openCount + 1, closeCount))

            # create new state by adding '('
            if closeCount < openCount:
                stack.append((curr.append(')'), openCount, closeCount + 1))

        # overall: time complexity O(Catalan(n) * n)
        # overall: space complexity O(Catalan(n) * n)
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| States explored | O(Catalan(n)) | O(n) per path | One entry and exit per valid state | Stack holds up to O(Catalan(n)) intermediate states |
| Mutable list ops | O(1) per op | O(n) per path | Append and pop are in-place (no copies) | Each state contains up to 2n |
| Final string join | O(n) per result | O(n) per result | Each completed list is joined into a string once | Output list contains O(Catalan(n)) strings, each of length O(n) | 
| Overall | O(Catalan(n) * n) | O(Catalan(n) * n) | One entry and exit per valid state exploring ? | Final output dominates space; stack and temp lists also contribute O(n) each | 

### Solution 4: Dynamic Programming - Stack/Dynamic Programming State Compression
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # Note:
        # This dynamic programming solution builds results from smaller subproblems.
        # dp[i] contains all valid combinations for i pairs of parentheses.
        # For each i, we build dp[i] from all combinations of dp[j] and dp[i - j - 1],
        # wrapped like: "(" + left + ")" + right.
        # This exploits the recursive structure of Catalan numbers.
        # Although recursive calls are avoided, nested loops and string combinations incur cost.


        # Initialize a list to store DP results
        dp = [[] for _ in range(n + 1)]
        # Base case: valid combination for n = 0
        dp[0] = [""]  
        
        # dp for 1 to n
        # time complexity: iterate over list of n length O(n) 
        for i in range(1, n + 1): 

            # Partition parentheses into two parts: 
            # dp[j]: iterates from 0 -> i - 1
            # dp[i - 1 - j]: iterates from i - 1 -> 0
            # grabbing dp 0 + dp (i - 1) + parenthesis in (f"({left}){right}")
            # allows us to generate a valid combination for dp i
            for j in range(i):  

                # iterate over combinations from 0 parentheses pair, to i parentheses pairs
                for left in dp[j]:

                    # iterate over combinations from (i - 1) parentheses pairs dp[0]
                    for right in dp[i - 1 - j]:

                        # Add new permutation to list
                        # Since we are starting from a valid base case, if our formula builds a valid parentheses combination 
                        # any combination of parentheses will guarantee a new valid permutation 
                        # ({left}){right} or {left}({right}) are both valid formulas
                        dp[i].append(f"({left}){right}")

        # overall: time complexity O(Catalan(n) * n)
        # overall: space complexity O(Catalan(n) * n)
        return dp[n]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| DP State build | O(Catalan(n)) | O(Catalan(n)) | Combines all previous results | dp[0] to dp[n] built cumulatively |
| String construction | O(n) per combination | O(n) per result | Each result takes O(n) to form | Final dp[n] holds all combinations |
| Overall | O(Catalan(n) * n) | O(Catalan(n) * n) | No recursion but same asymptotic bound | Store all intermediate and final results | 

## 739. Daily Temperatures ::3:: - Medium

Topics:  Array, Stack, Monotonic Stack, Two Pointer

### Intro
> Given an array of integers temperatures represents the daily 
> temperatures, return an array answer such that answer[i] is the 
> number of days you have to wait after the ith day to get a warmer 
> temperature. If there is no future day for which this is possible, 
> keep answer[i] == 0 instead.

|  Input   | Output  |  
| -------- | ------- | 
| [30,40,50,60] | [1,1,1,0] | 
| [30,60,90] | [1,1,0] |
| [73,74,75,71,69,72,76,73] | [1,1,4,2,1,1,0,0] |

Constraints:

1 &le; temperatures.length &le; 10<sup>5</sup>

30 &le; temperatures[i] &le; 100


### Abstract

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # space complexity: 
        n = len(temperatures)
        res = [0] * n

        # time complexity: iterate over list of n length O(n)
        for i in range(n):

            # time complexity: iterate over list of n length per outer iteration O(n^2)
            for j in range(i + 1, n):

                # found higher temperature, calculate difference
                if temperatures[j] > temperatures[i]:
                    res[i] = j - i
                    break  # Stop once the first warmer day is found
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # space complexity:
        st = []
        res = [0] * len(temperatures)

        # time complexity:
        for i in range(len(temperatures)):

            # 
            while st and temperatures[i] > temperatures[st[-1]]:
                idx = st.pop()
                res[idx] = i - idx  # Correctly compute days difference

            # INCORRECT: current day i is never pushed 

        return res

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Forward Iteration Monotonic Decreasing Stack of Past Cold Temperatures - Stack/Monotonic Property Maintenance
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # Note:
        # Monotonic Stack: A stack that maintains monotonic decreasing temperatures 
        # When monotonic decreasing rule breaks, the current temperature will serve as new higher temperature,
        # and if stack is non empty, wait days distance for top of stack 
        # while monotonic decreasing rule breaks 

        # space complexity: list wait days for n temperatures O(n)
        n = len(temperatures)
        res = [0] * n

        # space complexity: stores indices for up to n unresolved temperatures O(n)
        stack = []

        # time complexity: iterate over list of n length O(n)
        for i in range(n):

            # Check: stack is non empty, unresolved temperature exists
            # Check: if current temperature[i] breaks monotonic decreasing order,
            # will be viable to act as right temperature
            # implies: we keep appending while monotonic decreasing stays valid
            # implies: stack is kept in monotonic decreasing order
            # implies: when monotonic decreasing breaks, we have found right temperature
            while stack and temperatures[stack[-1]] < temperatures[i]:
                
                # curr while loop iteration:
                # temperatures[i]: right temperature
                # pop stack[-1]: tempWaitDaysCandidateIndex

                # while stack is non-empty:
                # stack.pop() will iterate tempWaitDays candidate
                # essentially dragging the right temperature over the monotonic stack,
                # calculating all the tempWaitDays, until a temperature is higher than
                # the current right temperature,
                # then we just add the right wall to the stack maintaining monotonic order
                tempWaitDays = stack.pop()

                # After stack.pop():
                # height[i]: right temperature
                # tempWaitDays: tempWaitDaysCandidateIndex

                # Distance from right temperature to current tempWaitDaysCandidate
                # is the days until a warmer temperature for the current candidate
                res[tempWaitDays] = i - tempWaitDays  

            # monotonic decreasing has been re-enabled
            # add right temperature to monotonic stack
            # push right temperature index
            stack.append(i)  
        
        # overall: time complexity
        # overall: space complexity
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Result List | O(n) | O(n) | Initialization of list for n temperature wait days O(n) | Stores wait time for n temperatures O(n) | 
| Iteration | O(n) | O(1) | Iteration over list of temperatures n length O(n) | No additional memory allocation for iteration O(1) |
| Stack operations | O(n) | O(n) | Each index is pushed and popped at most once for n length O(n) | Monotonic stack stores at most n indices O(n) |
| Temperature comparisons | O(1) | O(1) | Comparison operation in constant O(1) | No additional memory allocation for comparison O(1) | 
| Overall | O(n) | O(n) | Iteration over temperatures dominates, leading to O(n) | Stack and result list dominates, leading to O(n) | 

### Solution 2: Reverse Iteration Monotonic Decreasing Stack of Future Warm Temperatures - Stack/Monotonic Property Maintenance
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # Note:
        # Solution 2 tends to use less actual in memory due to more 
        # aggressive pruning of colder temperatures during reverse traversal

        # Note:
        # Brain exercise to do monotonic stack in reverse
        
        # sanity diagram:
        # index: 0  1  2  3  4  5  6
        # temp:[ 1, 4, 6, 8, 5, 3, 2]
        
        # Stack Diagram
        # [2]
        # Pop 2 -> [3]
        # Pop 3 -> [5]
        # Pop 8 -> [8]
        # 6 does not trigger pop -> calculate res[i] = stack[-1] - i 
        # append 6 
        # [8, 6]
        # Since we are popping everything the new element is greater than the stack?

        
        # space complexity: 
        n = len(temperatures)
        stack = []

        # space complexity:
        res = [0] * n

        # time complexity: iterate over list of n temperatures O(n)
        for i in range(n-1, -1, -1):
            
            # Check: stack is non empty
            # Check: if current temperature[i] breaks monotonic increasint,
            # will be viable to 
            # Implies: we have discarded elements increasing in reverse order 
            # Means:   we have discarded elements decreasing in forward order
            # Ex:      [8, 6] comes from [1, 2, 6, 8, 5, 3, 1] 
            while stack and temperatures[stack[-1]] <= temperatures[i]:
                stack.pop()

            # we have found a element that is less than the top of the stack
            # check: is stack non empty
            if stack:
                # found element less than top of stack, 
                # calculate wait days for found element
                res[i] = stack[-1] - i

            # Invariant: ensures that temperature appended to stack in monotonic decreasing 
            # Means:     iterating in reverse, 
            stack.append(i)        
        
        # overall: time complexity 
        # overall: space complexity 
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 3: Dynamic Programming Jump Traversal using Memoized Future Warm Temperatures - Stack/Algorithm
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # Note:
        # This solution uses a jump-based approach via leveraging 
        # results from previously computed indices.
        # It avoids an explicit stack by simulating the search for 
        # the next warmer temperature using a two-pointer like mechanism,
        # jumping ahead using previously filled results.
        # This effectively builds a "path" toward the next warmer day

        # Key Insight:
        # Once we know the next warmer day for some index j, we can skip
        # forward using res[j] to find the next warmer day for earlier indices i.
        
        # space complexity: result list for storing wait times o(n)
        n = len(temperatures)
        res = [0] * n

        # tracking index of hottest day seen so far right to left
        # set hottest day to last element
        hottest_day = n - 1

        # time complexity: reverse iterate through temperatures from second last to first O(n)
        for i in range(n - 2, -1, -1):

            # found new hottest day
            # Iterating: right to left
            # Check: if current temperature is >= hottest_day temp,
            # there is no warmer future day to the right of the current temperature
            if temperatures[i] >= temperatures[hottest_day]:
                # update hottest day index
                hottest_day = i

            # current day is less than hottest day
            # current day is to the left of the hottest day
            else:
                # hotter day candidate j starts at day after current day
                j = i + 1

                # while hotter day candidate j is less than current day temperature
                while temperatures[j] <= temperatures[i]:
                    # jump to the hottest day candidate's hottest day
                    j += res[j]

                # hotter day candidate is hotter than current day
                # calculate days from current day to hottest day candidate
                res[i] = j - i 

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Result list | O(n) | O(n) | Storing next hottest day distance for n temperatures O(n) | Storing next hottest day distance for n temperatures O(n) |
| Hottest day tracker | O(1) | O(1) | Single variable used to track hottest future day O(1) | Constant memory allocation O(1) |
| Jump pointer search | Amortized O(n) | O(1) |  |  | 
| Overall | O(n) | O(n) | Iteration over list of temperatures n length dominates, leading to O(n) |  | 


## 853. Car Fleet ::2:: - Medium

Topics:  Array, Stack, Sorting, Monotonic Stack

### Intro
> There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.
> You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.
> A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.
> A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.
> If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.
> Return the number of car fleets that will arrive at the destination.

|  Input   | Output  |  
| -------- | ------- | 
| target = 10, position = [3], speed = [3] | 1 |
| target = 100, position = [0,2,4], speed = [4,2,1] | 1 |
| target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] | 3 | 

Constraints:

1 &le; n &le; 10<sup>5</sup>

0 &lt; target &le; 10<sup>10</sup>

0 &le; position[i] &lt; target

All of values of position are unique 

0 &lt; speed[i] &le; 10<sup>6</sup>

### Abstract



### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Stack - Stack/Monotonic Property Maintenance
```python
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        # Sort cars by position in descending order
        cars = sorted(zip(position, speed), reverse=True)
        
        # Stack to store the time each fleet takes to reach the target
        stack = []  

        # time complexity
        for pos, spd in cars:
            time_to_target = (target - pos) / spd  # Time for current car to reach target
            
            # Push the current car's time only if it doesn't merge with the fleet at the top
            if not stack or time_to_target > stack[-1]:
                stack.append(time_to_target)
        
        # overall
        # overall
        return len(stack)
```

### Solution 2: Greedy - Stack/Algorithm
```python
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        ans = prev = 0
        for pp, ss in sorted(zip(position, speed), reverse=True): 
            tt = (target - pp)/ss # time to arrive at target 
            if prev < tt: 
                ans += 1
                prev = tt
        return ans 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 




## 84. Largest Rectangle in Histogram ::3:: - Hard

Topics:  Array, Stack, Monotonic Stack

### Intro
> Given an array of integers heights representing the 
> histogram's bar height where the width of each bar is 1, 
> return the area of the largest rectangle in the histogram.

|  Input   | Output  |  
| -------- | ------- | 
| [2,4] | 4 |
| [2,1,5,6,2,3] | 10 |

Constraints:

1 &le; heights.length &le; 10<sup>5</sup>

0 &le; heights[i] &le; 10<sup>4</sup>

### Abstract


### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        max_area = 0

        for i in range(n):
            min_height = heights[i]
            for j in range(i, n):
                min_height = min(min_height, heights[j])
                max_area = max(max_area, min_height * (j - i + 1))

        return max_area

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Optimal Stack - Stack/Monotonic Property Maintenance
```python
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0

        for i, h in enumerate(heights + [0]):  # Add a sentinel height of 0
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)

        return max_area
```

### Solution 2: Divide and Conquer - Stack/Algorithm
```python
    def calculate_area(start, end):
        if start > end:
            return 0
        
        min_index = start
        for i in range(start, end + 1):
            if heights[i] < heights[min_index]:
                min_index = i
        
        left_area = calculate_area(start, min_index - 1)
        right_area = calculate_area(min_index + 1, end)
        current_area = heights[min_index] * (end - start + 1)
        
        return max(left_area, right_area, current_area)

    return calculate_area(0, len(heights) - 1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 3: Non Stack - Stack/Algorithm
```python
    class SegmentTree:
        def __init__(self, heights):
            self.n = len(heights)
            self.tree = [0] * (4 * self.n)
            self.build(heights, 0, 0, self.n - 1)

        def build(self, heights, node, start, end):
            if start == end:  # Leaf node
                self.tree[node] = start
            else:
                mid = (start + end) // 2
                left = 2 * node + 1
                right = 2 * node + 2

                self.build(heights, left, start, mid)
                self.build(heights, right, mid + 1, end)

                # Combine the results of the children
                if heights[self.tree[left]] < heights[self.tree[right]]:
                    self.tree[node] = self.tree[left]
                else:
                    self.tree[node] = self.tree[right]

        def query(self, heights, node, start, end, l, r):
            if start > r or end < l:  # Range outside query bounds
                return -1
            if l <= start and end <= r:  # Range completely within query bounds
                return self.tree[node]

            mid = (start + end) // 2
            left = self.query(heights, 2 * node + 1, start, mid, l, r)
            right = self.query(heights, 2 * node + 2, mid + 1, end, l, r)

            if left == -1:  # If left part is out of range
                return right
            if right == -1:  # If right part is out of range
                return left
            return left if heights[left] < heights[right] else right

    
    def largestRectangleArea(self, heights: List[int]) -> int:
        def calculate_area(start, end):
                if start > end:
                    return 0
                min_index = tree.query(heights, 0, 0, len(heights) - 1, start, end)
                left_area = calculate_area(start, min_index - 1)
                right_area = calculate_area(min_index + 1, end)
                current_area = heights[min_index] * (end - start + 1)
                return max(left_area, right_area, current_area)

        tree = SegmentTree(heights)
        return calculate_area(0, len(heights) - 1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


## 402. Remove K Digits ::1:: - Medium

Topics:  String, Stack, Greedy, Monotonic Stack

### Intro
> Given string num representing a non-negative integer num, and an integer k, 
> return the smallest possible integer after removing k digits from num.

|  Input   | Output  |  
| -------- | ------- | 
| num = "10", k = 2 | "0" |
| num = "10200", k = 1 | "200" |
| num = "1432219", k = 3 | "1219" | 

Constraints:

1 &le; k &le; num.length &le; 10<sup>5</sup>

num consists of only digits

num does not have any leading zeros except for 0 itself

### Abstract
Remove k digits in a way so that resulting integer is as large as possible.

### Solution 1: Optimal Stack - Stack/Monotonic Property Maintenance
```python
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []  # Stack to hold the digits of the resulting number

        for digit in num:
            # Remove digits from the stack if the current digit is smaller
            # and we still need to remove more digits (k > 0)
            while stack and k > 0 and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)

        # If there are still digits to remove, remove from the end of the stack
        stack = stack[:-k] if k else stack

        # Join the stack into a number and remove leading zeros
        result = ''.join(stack).lstrip('0')

        # Return "0" if the result is empty
        return result or "0"
```