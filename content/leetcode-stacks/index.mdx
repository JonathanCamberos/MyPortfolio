---
title: "LeetCode: Stacks"
description: "stacks"
image: "../../public/blogs/stack.png"
publishedAt: "2025-06-02"
updatedAt: "2025-06-03"
author: "jonathancamberos"
isPublished: true
tags:
- data structures & algorithms
---

## Stack Intro

Leetcode problems with elegant solutions using stacks.

### What are stacks 


## 20. Valid Parentheses - Easy

### Intro
> Given a string s containing: ( ) [ ] \{ \},
> determine if the input string is valid. 
> An input string is valid if: 1. Open brackets must be closed by the same type
> of brackets 2. Open brackets must be closed in the correct order. 3. Every close
> bracket has a corresponding open bracket of the same type.

|  Input   | Output  |  
| -------- | ------- | 
| "()"     | true    | 
| "()[]()" | false   |
| "(]"     | true    |
| "([])"   | true    |


Constraints:

1 &le; s.length &le; 10<sup>4</sup>

s consists of parentheses only '()[]{}'

### Abstract
We need to validate that every open parenthesis has a matching close
in the correct order.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (replace with empty) |  |  |  |  |
| Stack (redundant operations) |  |  |  |  |
| Stack |  |  |  |  |

### Brute Force: (replace with empty)
```python
    def isValid(self, s: str) -> bool:
        
        # note: in python, an empty string "" is falsy evaluating to false
        # not "" -> true

        # time complexity: iterate over string of n length O(n)
        # each iterate removes at least one pair, and there are at most n/2 pairs so O(n/2) iterations O(n/2)
        # O(n) * O(n/2) = O(n^2)
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '').replace('{}', '').replace('[]', '')
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return not s
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate over string | O(n) | O(1) |  |  |
| Total Iterations | O(n/2) | O(1) |  |  |
| Overall | O(n<sup>2</sup>) | O(1) |  |  | 

### Find the Bug: (Hashmap)
```python
    def isValid(self, s: str) -> bool:

        # time complexity: constant hashmap of 3 length O(1)
        counts = {"(": 0, "[": 0, "{": 0}
        closing = {")": "(", "]": "[", "}": "{"}

        # time complexity: iterate over string of n length O(n)
        for c in s:

            # Count opening brackets
            # time complexity: lookup operation in constant O(1)
            if c in counts:  
                counts[c] += 1

            # Count closing brackets
            # time complexity: lookup operation in constant O(1)
            else c in closing:  

                closingMatch = closing[c]

                # No matching opening bracket
                if counts[closingMatch] == 0:  
                    return False

                # Matching opening bracket
                counts[closingMatch] -= 1

        # INCORRECT: hashmap open value may be 0, but did not take into 
        # consideration whether they were in the correct order
        # time complexity: iterate over hashmap of 3 length O(1)
        for count in counts.values():
        if count != 0:
            return False

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return True
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate |  |  |  |  |
| Verify |  |  |  |  |
| Overall |  |  |  |  | 


### Solution 1: Stack (redundant operations)
```python
    def isValid(self, s: str) -> bool:

        # note: in python, an empty list [] is falsy evaluating to false
        # not [] -> true

        # space complexity: 
        stack = []

        # time complexity:
        for c in s:

            # add opening parenthesis
            if c in '([{':
                stack.append(c)

            # validate closing parenthesis
            elif c in ')]}':
                if not stack or (c == ')' and stack[-1] != '(') or \
                                (c == '}' and stack[-1] != '{') or \
                                (c == ']' and stack[-1] != '['):
                    return False
                stack.pop()

        # overall: time complexity
        # overall: space complexity
        return not stack
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2: Stack
```python
    def isValid(self, s: str) -> bool:

        # space complexity: 
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}

        # time complexity: iterate over list of n length O(n)
        for c in s:
            
            # validate closing parenthesis
            if c in mapping:  
                
                # pop top element if stack is non-empty
                topElem = stack.pop() if stack else '#'

                if mapping[c] != topElem:
                    return False

            # append opening bracket
            else:
                stack.append(c)

        # overall: time complexity
        # overall: space complexity
        return not stack
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 




## 155. Min Stack - Medium

### Intro
> Design a stack that supports push, pop, top, and retrieving 
> the minimum element in constant time.
> Implement the MinStack class:
> MinStack() initializes the stack object.
> void push(int val) pushes the element val onto the stack.
> void pop() removes the element on the top of the stack.
> int top() gets the top element of the stack.
> int getMin() retrieves the minimum element in the stack.
> You must implement a solution with O(1) time complexity for each function.

|  Input   | Output  |  
| -------- | ------- | 
| ["MinStack","push","push","push","getMin","pop","top","getMin"] [[],[-2],[0],[-3],[],[],[],[]] | [null,null,null,null,-3,null,0,-2]  | 

Constraints:

-2<sup>31</sup> &le; val &le; 2<sup>31</sup> - 1

Methods pop, top and getMin operations will always be called on non-empty stacks.

At most 3 * 10<sup>4</sup> calls will be made to push, pop, top, and getMin.

### Abstract
We need to design a stack that runs in O(1) time complexity for each main function.


### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def __init__(self):
        
        # tracking logical size vs physical size
        # space complexity: stores all n elements O(n)
        self.stack = []
        self.size = 0

    def push(self, val: int) -> None:
        # time complexity: append operation in constant O(1)

        # size = 1     vs [5, _, _]
        # logical size vs physical size -> 
        # stack will only grow when absolutely necessary / avoids unnecessary resizing
        if self.size < len(self.stack):
            # self.size == length, so append at self.size
            self.stack[self.size] = val
        else:
            # stack needs to grow
            self.stack.append(val)

        # increases logical size
        self.size += 1

    def pop(self) -> None:       
        if self.size == 0:
            raise IndexError("Pop from empty stack")

        # size = 2 [5, 4]
        # size = 1 [5, 4]
        # logical size vs physical size -> 
        # time complexity: pop operation in constant O(1)

        # decreases logical size
        self.size -= 1

    def top(self) -> int:
        if self.size == 0:
            raise IndexError("Stack is empty")
 
         # time complexity: index top element in constant O(1)
        return self.stack[self.size - 1]

    def getMin(self) -> int:
        if self.size == 0:
            raise IndexError("Stack is empty")
        
        minVal = float('inf')

        # stack is not minSorted
        # time complexity: iterate over entire stack n length O(n)
        for i in range(self.size):
            if self.stack[i] < minVal:
                min = self.stack[i] 
        return minVal

    # overall: time complexity O(n)
    # overall: space complexity O(n)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def __init__(self):
        # space complexity: 
        self.stack = []
        self.size = 0
        self.minVal = float('inf')

    def push(self, val: int):
        # time complexity:
        if self.size < len(self.stack)
            self.stack[self.size] = val
        else:
            self.stack.append(val)

        # increases logical size
        self.size += 1

        if val < self.minVal:
            self.minVal = val

    def pop(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Pop from empty stack")
        
        # decreases logical size
        # INCORRECT: does not update minVal when the popped value is the minVal
        # Stack implementation does not track previous minVal for updates
        self.size -= 1

        
    def top(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Stack is empty")
        
        return self.stack[self.size - 1]

    def getMin(self):
        # time complexity:
        return self.minVal

    # overall: time complexity
    # overall: time complexity 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 1: Main Stack + Min Tracker
```python
    def __init__(self):

        # using a minTracker stack, we track the min value at each
        # level of the main stack. Ensures when we pop a top value
        # we can instantly know the min value at that point

        # space complexity:
        self.mainStack = []
        self.minTracker = []
        self.mainSize = 0

    def push(self, val: int):

        # logical size vs physical size
        if self.mainSize < len(self.mainStack):
            self.mainStack[self.mainSize] = val
        else:
            self.mainStack.append(val)

        # logical size vs physical size
        if self.mainSize < len(self.minTracker)
            
            # compares new value with previous level of minTracker
            self.minTracker[self.mainSize] = min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val)
        else:
            self.minTracker.append(min(val, self.minTracker[self.mainSize - 1] if self.mainSize > 0 else val))
        
        # increases logical size
        self.mainSize += 1

    def pop(self):
        # time complexity: 
        if self.mainSize == 0:
            raise IndexError("Pop from empty stack")
        
        self.mainSize -= 1

    def top(self):
        # time complexity:
        if self.mainSize == 0:
            raise IndexError("Stack is empty")
        return self.mainStack[self.mainSize - 1]

    def getMin(self):
        # time complexity:
        if self.mainSize == 0:
            raise IndexError("Stack is empty")

        return self.minTracker[self.mainSize - 1]

    # overall: time complexity
    # overall: time complexity 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2: Tuple Stack
```python
    def __init__(self):

        # using of having a separate minTracker stack, we track the min value
        # at each level of the main stack using tuples (val, min).
        # Ensures when we pop a top value we can instantly know 
        # the min value at that level of the stack 

        # space complexity:
        self.stack = []
        self.size = 0

    def push(self, val: int):

        # compares val with previous level tuple minValue
        # sets new (val, minValue) to lower value
        currMin = min(val, self.stack[self.size - 1][1] if self.size > 0 else val)
        
        # logical size vs physical size
        if self.size < len(self.stack):
            self.stack[self.size] = (val, currMin)
        else:
            self.stack.append((val, currMin))

        # increases logical size
        self.size += 1

    def pop(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Pop from empty stack")
        self.size -= 1

    def top(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Stack is empty")
        
        return self.stack[self.size - 1][0]

    def getMin(self):
        # time complexity:
        if self.size == 0:
            raise IndexError("Stack is empty")

        return self.stack[self.size - 1][1]

    # overall: time complexity
    # overall: time complexity 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 



## 150. Evaluate Reverse Polish Notation - Medium

### Intro
> You are given an array of strings tokens that represents an arithmetic 
> expression in a Reverse Polish Notation.
> Evaluate the expression. Return an integer that represents the value of
> the expression.
> Note that:
> The valid operators are '+', '-', '*', and '/'.
> Each operand may be an integer or another expression.
> The division between two integers always truncates toward zero.
> There will not be any division by zero.
> The input represents a valid arithmetic expression in a reverse polish notation.
> The answer and all the intermediate calculations can be represented in a 32-bit integer.

|  Input   | Output  |  
| -------- | ------- | 
| ["2","1","+","3","*"] | 9 | 
| ["4","13","5","/","+"] | 6 |
| ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] | 22 |

Constraints:

1 &le; tokens.length &le; 10<sup>4</sup>

tokens[i] is either an operator: "+", "-", "*", or "/", 
or an integer in the range [-200, 200].

### Abstract
We're designing abstract syntax tree that when execute, will execute the given
operations in reverse polish notation.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in "+-*/":
                # Push operand onto stack
                stack.append(int(token))
            else:
                # Pop two operands
                b = stack.pop()
                a = stack.pop()
                
                # Perform operation and push result
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                elif token == "/":
                    stack.append(int(a / b))  # Truncate towards 0

        return stack.pop()
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in "+-*/":
                stack.append(int(token))
            else:

                # INCORRECT order of popping operands
                a = stack.pop()  # a should be second operand
                b = stack.pop()  # b should be the first operand
                
                if token == "+":
                    stack.append(a + b)  # Incorrect operand order
                elif token == "-":
                    stack.append(a - b)  # Incorrect operand order
                elif token == "*":
                    stack.append(a * b)  # Correct, since order doesn't matter
                elif token == "/":
                    stack.append(int(a / b))  # Incorrect operand order

        return stack.pop()
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 1: 
```python
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in "+-*/":
                stack.append(int(token))
            else:
                b = stack.pop()
                a = stack.pop()

                match token:
                    case "+":
                        stack.append(a + b)
                    case "-":
                        stack.append(a - b)
                    case "*":
                        stack.append(a * b)
                    case "/":
                        stack.append(int(a / b))  # Explicit truncation towards zero

        return stack[-1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2:
```python
    from operator import add, sub, mul, floordiv

    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        operations = {"+": add, "-": sub, "*": mul, "/": lambda a, b: int(a / b)}

        for token in tokens:
            if token not in operations:
                stack.append(int(token))
            else:
                b = stack.pop()
                a = stack.pop()
                stack.append(operations[token](a, b))

        return stack[-1]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 




## 22. Generate Parentheses - Medium

### Intro
> Given n pairs of parentheses, write a function to generate all 
> combinations of well-formed parentheses.

|  Input   | Output  |  
| -------- | ------- | 
| 1 | ["()"] | 
| 3 | ["((()))","(()())","(())()","()(())","()()()"] |

Constraints:

1 &le; n &le; 8

### Abstract
Given a number, generate all possible combinations of parentheses.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force:
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # generates all possible combinations of n pairs of parentheses
        def generate_combinations(current, length, combinations):
            
            # base case: if 
            if length == 2 * n:
                combinations.append(current)
                return

            # recursively add '(' and ')' to the current string to generate all possible combinations
            generate_combinations(current + "(", length + 1, combinations)
            generate_combinations(current + ")", length + 1, combinations)

        # checks if given parentheses string is valid
        def isValid(s: str) -> bool:
            # counter to track balance of parentheses
            balance = 0

            # iterate through parentheses string
            for char in s:
                
                # increment balance
                if char == '(':
                    balance += 1
                # decrement balance
                else:
                    balance -= 1
                # closing parenthesis has no matching
                if balance < 0:
                    return False

            # validate all parentheses have match
            return balance == 0

        # grab all possible combinations
        combinations = []
        generate_combinations("", 0, combinations)

        result = []
        
        # generate and validate all combinations
        for combo in combinations:
            if isValid(combo):
                result.append(combo)
        
        # overall: time complexity
        # overall: space complexity
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug:
```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        # Initialize a stack to simulate depth-first search (DFS)        
        # (currString, openParenCount, closedParenCount)
        stack = [("", 0, 0)]
        result = []

        # while stack is non-empty
        while stack:

            # 
            current, open_count, close_count = stack.pop()

            # if we have a valid combination of n '(' and n ')' add to list
            if open_count == n and close_count == n:
                result.append(current)
                continue

            # INCORRECT: condition allows ')' to be added even if they exceed the number of '('
            # should be `close_count < open_count`
            if close_count < n:
                stack.append((current + ")", open_count, close_count + 1))
            if open_count < n:
                stack.append((current + "(", open_count + 1, close_count))

        # overall: time complexity
        # overall: space complexity
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 1: Iterative Stack
```python
    def generateParenthesis(self, n: int) -> List[str]:

        # stack initial state
        stack = [("", 0, 0)] 

        # store valid parentheses
        result = []

        # 
        while stack:

            # grab the current state of the stack
            current, open_count, close_count = stack.pop()

            # base case: if we have used all open and close parentheses
            if open_count == n and close_count == n:

                # add valid combination  
                result.append(current)
                continue

            # push new state with '(' added
            if open_count < n:
                stack.append((current + "(", open_count + 1, close_count))

            # push new state with '(' added
            if close_count < open_count:
                stack.append((current + ")", open_count, close_count + 1))

        # overall: time complexity
        # overall: space complexity
        return result
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Extra Solution 1: BackTracking (String)
```python
    def generateParenthesis(self, n: int) -> List[str]:

        res = []

        # Backtracking        
        def helper(current: List[str], num_open: int, num_closed: int):
            
            # Base case: If the length of the current combination is 2 * n, it's complete
            if len(current) == n * 2:
                # convert list to string and add to res
                res.append("".join(current))
                return

            # Recursive case 1: Add '(' if the number of '(' used is less than n
            if num_open < n: 
                current.append('(')
                helper(current, num_open + 1, num_closed)

                # Backtrack by removing the last added '('
                current.pop()  
            
            # Recursive case 2: Add ')' if the number of ')' used is less than the number of '('
            if num_closed < num_open:
                current.append(')')
                helper(current, num_open, num_closed + 1)

                # Backtrack by removing the last added ')'
                current.pop()

        # Start Backtracking process with an empty list and counts at 0
        helper([], 0, 0)

        # overall: time complexity
        # overall: space complexity
        return res
```


### Extra Solution 2: BackTracking (Mutable List)

```python
    def generateParenthesis(self, n: int) -> List[str]:
        
        res = []
        
        # Backtracking
        def backtrack(current, open_count, close_count):

            # Base case: if we have used all open and close parentheses
            if open_count == n and close_count == n:
                # add valid combination to res
                res.append(current)
                return
            
            # Recursive case 1: Add '(' if the number of '(' used is less than n
            if open_count < n: 

                # Backtrack by adding '(' to curr string, and incrementing open_count by 1
                # recursive call explores all combinations starting from this new state
                backtrack(current + "(", open_count + 1, close_count)
            
            # recursive case: Add ')' if the number of ')' used is less than the number of '('
            if close_count < open_count:

                # Backtrack by adding ')' to the curr string, and incrementing close_count by 1
                # recursive call explores all combinations starting from this new state
                backtrack(current + ")", open_count, close_count + 1)
        
        # starts recursion with an empty string and zero counts
        # backtracking process builds strings by choosing '(' or ')' at each step
        # and checking a possible valid paths through the recursion tree
        backtrack("", 0, 0)

        # overall: time complexity
        # overall: space complexity
        return res
```




## 739. Daily Temperatures - Medium

### Intro
> Given an array of integers temperatures represents the daily 
> temperatures, return an array answer such that answer[i] is the 
> number of days you have to wait after the ith day to get a warmer 
> temperature. If there is no future day for which this is possible, 
> keep answer[i] == 0 instead.

|  Input   | Output  |  
| -------- | ------- | 
| [30,40,50,60] | [1,1,1,0] | 
| [30,60,90] | [1,1,0] |
| [73,74,75,71,69,72,76,73] | [1,1,4,2,1,1,0,0] |

Constraints:

1 &le; temperatures.length &le; 10<sup>5</sup>

30 &le; temperatures[i] &le; 100


### Abstract

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # space complexity: 
        n = len(temperatures)
        res = [0] * n

        # time complexity: iterate over list of n length O(n)
        for i in range(n):

            # time complexity: iterate over list of n length per outer iteration O(n^2)
            for j in range(i + 1, n):

                # found higher temperature, calculate difference
                if temperatures[j] > temperatures[i]:
                    res[i] = j - i
                    break  # Stop once the first warmer day is found
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # space complexity:
        st = []
        res = [0] * len(temperatures)

        # time complexity:
        for i in range(len(temperatures)):

            # 
            while st and temperatures[i] > temperatures[st[-1]]:
                idx = st.pop()
                res[idx] = i - idx  # Correctly compute days difference

            # INCORRECT: current day i is never pushed 

        return res

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Monotonic Stack
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        # space complexity:
        n = len(temperatures)
        res = [0] * n
        stack = []  # Indices of temperatures

        # time complexity:
        for i in range(n):

            # compares curr temp with top of stack
            while stack and temperatures[i] > temperatures[stack[-1]]:
                idx = stack.pop()

                # Days until a warmer temperature
                res[idx] = i - idx  

            # Push current index
            stack.append(i)  
        
        return res

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Extra Solution 1: Reverse Traversal
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        st = []
        res = [0] * len(temperatures)

        for i in range(len(temperatures)):
            while st and temperatures[i] > temperatures[st[-1]]:
                idx = st.pop()
                res[idx] = i - idx
            st.append(i)
        
        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Extra Solution 2: Two-Pointer Sliding Window
```python
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n
        hottest_day = n - 1  # Track the hottest day from the end of the list

        for i in range(n - 2, -1, -1):  # Start from the second last element
            if temperatures[i] >= temperatures[hottest_day]:
                hottest_day = i  # Update the hottest day
            else:
                j = i + 1
                while temperatures[j] <= temperatures[i]:
                    j += res[j]  # Jump to the next warmer day
                res[i] = j - i  # Calculate days to next warmer temperature

        return res
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 




## 853. Car Fleet - Medium

### Intro
> There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.
> You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.
> A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.
> A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.
> If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.
> Return the number of car fleets that will arrive at the destination.

|  Input   | Output  |  
| -------- | ------- | 
| target = 10, position = [3], speed = [3] | 1 |
| target = 100, position = [0,2,4], speed = [4,2,1] | 1 |
| target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] | 3 | 

Constraints:

1 &le; n &le; 10<sup>5</sup>

0 &lt; target &le; 10<sup>10</sup>

0 &le; position[i] &lt; target

All of values of position are unique 

0 &lt; speed[i] &le; 10<sup>6</sup>

### Abstract



### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution Semi Optimal 1: Stack
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution Optimal 2: Stack
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Stack
```python
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        # Sort cars by position in descending order
        cars = sorted(zip(position, speed), reverse=True)
        
        # Stack to store the time each fleet takes to reach the target
        stack = []  

        # time complexity
        for pos, spd in cars:
            time_to_target = (target - pos) / spd  # Time for current car to reach target
            
            # Push the current car's time only if it doesn't merge with the fleet at the top
            if not stack or time_to_target > stack[-1]:
                stack.append(time_to_target)
        
        # overall
        # overall
        return len(stack)
```

### Extra Solution 1: Greedy
```python
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        ans = prev = 0
        for pp, ss in sorted(zip(position, speed), reverse=True): 
            tt = (target - pp)/ss # time to arrive at target 
            if prev < tt: 
                ans += 1
                prev = tt
        return ans 
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 




## 84. Largest Rectangle in Histogram - Hard

### Intro
> Given an array of integers heights representing the 
> histogram's bar height where the width of each bar is 1, 
> return the area of the largest rectangle in the histogram.

|  Input   | Output  |  
| -------- | ------- | 
| [2,4] | 4 |
| [2,1,5,6,2,3] | 10 |

Constraints:

1 &le; heights.length &le; 10<sup>5</sup>

0 &le; heights[i] &le; 10<sup>4</sup>

### Abstract


### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Brute Force: Stack
```python
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        max_area = 0

        for i in range(n):
            min_height = heights[i]
            for j in range(i, n):
                min_height = min(min_height, heights[j])
                max_area = max(max_area, min_height * (j - i + 1))

        return max_area

```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Find the Bug: Stack 
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Optimal Stack
```python
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0

        for i, h in enumerate(heights + [0]):  # Add a sentinel height of 0
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)

        return max_area
```

### Extra Optimal Solution 1: Divide and Conquer
```python
    def calculate_area(start, end):
        if start > end:
            return 0
        
        min_index = start
        for i in range(start, end + 1):
            if heights[i] < heights[min_index]:
                min_index = i
        
        left_area = calculate_area(start, min_index - 1)
        right_area = calculate_area(min_index + 1, end)
        current_area = heights[min_index] * (end - start + 1)
        
        return max(left_area, right_area, current_area)

    return calculate_area(0, len(heights) - 1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Extra Optimal Solution 2: Non Stack
```python
    class SegmentTree:
        def __init__(self, heights):
            self.n = len(heights)
            self.tree = [0] * (4 * self.n)
            self.build(heights, 0, 0, self.n - 1)

        def build(self, heights, node, start, end):
            if start == end:  # Leaf node
                self.tree[node] = start
            else:
                mid = (start + end) // 2
                left = 2 * node + 1
                right = 2 * node + 2

                self.build(heights, left, start, mid)
                self.build(heights, right, mid + 1, end)

                # Combine the results of the children
                if heights[self.tree[left]] < heights[self.tree[right]]:
                    self.tree[node] = self.tree[left]
                else:
                    self.tree[node] = self.tree[right]

        def query(self, heights, node, start, end, l, r):
            if start > r or end < l:  # Range outside query bounds
                return -1
            if l <= start and end <= r:  # Range completely within query bounds
                return self.tree[node]

            mid = (start + end) // 2
            left = self.query(heights, 2 * node + 1, start, mid, l, r)
            right = self.query(heights, 2 * node + 2, mid + 1, end, l, r)

            if left == -1:  # If left part is out of range
                return right
            if right == -1:  # If right part is out of range
                return left
            return left if heights[left] < heights[right] else right

    
    def largestRectangleArea(self, heights: List[int]) -> int:
        def calculate_area(start, end):
                if start > end:
                    return 0
                min_index = tree.query(heights, 0, 0, len(heights) - 1, start, end)
                left_area = calculate_area(start, min_index - 1)
                right_area = calculate_area(min_index + 1, end)
                current_area = heights[min_index] * (end - start + 1)
                return max(left_area, right_area, current_area)

        tree = SegmentTree(heights)
        return calculate_area(0, len(heights) - 1)
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 