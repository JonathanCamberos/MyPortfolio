---
title: "LeetCode Problems: Arrays & Hashing"
description: "Arrays & Hashing"
image: "../../public/blogs/code_3.jpg"
publishedAt: "2024-08-05"
updatedAt: "2024-08-05"
author: "codebucks"
isPublished: true
tags:
- data structures & algorithms
- web development
---

## Arrays & Hashing:

Getting aquanted and learning how hashmaps and hashsets can solve wide 'array' of problems

### What is a Hashmap
First lets understand what hashing is. Hashing is the process of transforming any given key 
or string of charactesr into another value. The result is normally a shorter, fixed-length
value that makes it computationally easier to work with than the original key.

Hashmaps, aka hashtable, are one of the most common implementations of hashing.
Hashmaps store key-value pairs (eg: employee ID / employee name) in a list that is 
accessible through its index.

A hash table uses a hash function to compute the index, aka hash code, into an arrary 
of buckets ro slots, from which the desired value can be found. 
During lookup, the same method is followed. The key is hashed and the resulting hash
indiates where the corresponding value is stored

### Hashmap benefits
Hash tables are O(1) average if implemented well and O(n) worst case.
1. Hash tables suffer from O(n) worst time complexity due to two reasons:
If too many elements were hashed into the same key: looking inside this key may take
O(n) time.

Once a hash table has passed its load abalance - it has to rehash and create a bigger table/reinsert elements 

2. Hash tables are said to be O(1) average if implement well 
It is rare that many items will be hashed to the same key (if you used a good hash function
and dont have too big load balance) 

The rehash operation, which is O(n), can at most happen after n/2 ops, which are all
assumed O(1): Thus when you sum the average time per op, you get: (n*O(1) + O(n)) / n) = O(1)

### Hashmap applications
Due to their quick O(1) average time, they are great for storing key pairs of lists of elements 
to perform more complex tasks. Essentially they are the first step of switching to a leetcode
mind set where both time complexity and space complextiy are important.


### What is a Hashset

### Hashset benefits

### Hashset applications

## 217. Contains Duplicate - Easy

### Intro
>Given an integer array nums, return true if any value appears at least twice in the array, 
> return false if every element is distinct.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,2,3,1] | true   |
| nums = [1,2,3,4] | false  |  
| nums = [1,1,1,3,3,4,3,2,4,2] | true |
 
### Abstraction
Bascially, we just have a list of elements and need to `check if any of those elements are duplicated`.
Minimum: we need to traverse the list at least once to peak at every element in it.
So our best possible time complexity is by definition O(N).
Since we need to check every elemeent, best space complexity should be O(unique(N))



### Solution 1: hashmap

```python
    def containsDuplicate(self, nums: List[int]) -> bool:
        # hashmap
        seen = {}
        # for every element, check if element count >= 1
        for num in nums:
            if num in seen and seen[num] >= 1:
                return True
            seen[num] = seen.get(num, 0) + 1
        return False
```

Here, we traverse the list, adding a count for every element we've seen. Thus, if we check an 
element in the hashmap which has >= 1 count, it means we've seen that element previously and 
have found a duplicate

### Solution 2: hashset 
```python
    def containsDuplicate(self, nums: List[int]) -> bool:
        # hashset
        seen = set()
        # for every eleemnt, check if element present in hashset
        for n in nums:
           if n in seen:
              return True
           seen.add(n)
        return False
```

Here, we also traverse the list, but instead of a count we simply check if its present in the hashset.
Arguably this is a more simple solution than the previous hashmap one.

## 242. Valid Anagram - Easy

### Intro

>Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.


|  Example Input 'S'  | Example Input 'T' | Output |  
| ------------------- | ----------------- | ------ | 
| "anagram"           | "nagaram"         | true   |
| "rat"               | "car"             | false  |  


### Constraints:
   
### Abstraction
This builds directly off of the previous find duplicates problem. `Before we were 
checking if two elements had a count of >= 1`. We simply add an extra step and 
`now we check if the total count for every element in the list is equal` 
between any two lists. 

### Solution 1: hashmap
```python
    def isAnagram(self, s: str, t: str) -> bool:
        # hashmap
        count = defaultdict(int)
        for x in s:
           count[x] += 1
        for x in t:
           count[x] -= 1
        for value in count.values():
           if value != 0:
               return False
        return True
```

### Solution 2: hashset 