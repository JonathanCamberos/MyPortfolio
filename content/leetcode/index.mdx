---
title: "LeetCode Problems: Arrays & Hashing"
description: "Arrays & Hashing"
image: "../../public/blogs/code_3.jpg"
publishedAt: "2024-08-05"
updatedAt: "2024-08-05"
author: "codebucks"
isPublished: true
tags:
- data structures & algorithms
- web development
---

## Arrays & Hashing:

Getting aquanted and learning how hashmaps and hashsets can solve wide 'array' of problems

### What is a Hashmap
First lets understand what hashing is. Hashing is the process of transforming any given key 
or string of charactesr into another value. The result is normally a shorter, fixed-length
value that makes it computationally easier to work with than the original key.

Hashmaps, aka hashtable, are one of the most common implementations of hashing.
Hashmaps store key-value pairs (eg: employee ID / employee name) in a list that is 
accessible through its index.

A hash table uses a hash function to compute the index, aka hash code, into an arrary 
of buckets ro slots, from which the desired value can be found. 
During lookup, the same method is followed. The key is hashed and the resulting hash
indiates where the corresponding value is stored

### Hashmap benefits
Hash tables are O(1) average if implemented well and O(n) worst case.
1. Hash tables suffer from O(n) worst time complexity due to two reasons:
If too many elements were hashed into the same key: looking inside this key may take
O(n) time.

Once a hash table has passed its load abalance - it has to rehash and create a bigger table/reinsert elements 

2. Hash tables are said to be O(1) average if implement well 
It is rare that many items will be hashed to the same key (if you used a good hash function
and dont have too big load balance) 

The rehash operation, which is O(n), can at most happen after n/2 ops, which are all
assumed O(1): Thus when you sum the average time per op, you get: (n*O(1) + O(n)) / n) = O(1)

### Hashmap applications
Due to their quick O(1) average time, they are great for storing key pairs of lists of elements 
to perform more complex tasks. Essentially they are the first step of switching to a leetcode
mind set where both time complexity and space complextiy are important.


### What is a Hashset

### Hashset benefits

### Hashset applications

## 217. Contains Duplicate - Easy

### Intro
>Given an integer array nums, return true if any value appears at least twice in the array, 
> return false if every element is distinct.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,2,3,1] | true   |
| nums = [1,2,3,4] | false  |  
| nums = [1,1,1,3,3,4,3,2,4,2] | true |
 
### Constraints
length: 1 `leq` nums.length `leq` 10^5 

integer: -10^9 `leq` nums[i] `leq` 10^9  


### Abstraction
Bascially, we just have a list of elements and need to `check if any of those elements are duplicated`.
Minimum: we need to traverse the list at least once to peak at every element in it.
So our best possible time complexity is by definition O(N).
Since we need to check every elemeent, best space complexity should be O(unique(N))


### Solution 1: hashmap

```python
    def containsDuplicate(self, nums: List[int]) -> bool:
        # hashmap
        seen = {}
        # for every element, check if element count >= 1
        for num in nums:
            if num in seen and seen[num] >= 1:
                return True
            seen[num] = seen.get(num, 0) + 1
        return False
```

Here, we traverse the list, adding a count for every element we've seen. Thus, if we check an 
element in the hashmap which has >= 1 count, it means we've seen that element previously and 
have found a duplicate

### Solution 2: hashset 
```python
    def containsDuplicate(self, nums: List[int]) -> bool:
        # hashset
        seen = set()
        # for every eleemnt, check if element present in hashset
        for n in nums:
           if n in seen:
              return True
           seen.add(n)
        return False
```

Here, we also traverse the list, but instead of a count we simply check if its present in the hashset.
Arguably this is a more simple solution than the previous hashmap one.

## 242. Valid Anagram - Easy

### Intro

>Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.


|  Example Input 'S'  | Example Input 'T' | Output |  
| ------------------- | ----------------- | ------ | 
| "anagram"           | "nagaram"         | true   |
| "rat"               | "car"             | false  |  


### Constraints
1 `leq` s.length, t.length `leq` 5 * 104

s and t consist of lowercase English letters

### Abstraction
This builds directly off of the previous find duplicates problem. `Before we were 
checking if two elements had a count of >= 1`. We simply add an extra step and 
`now we check if the total count for every element in the list is equal` 
between any two lists. 

### Solution 1: hashmap
```python
    def isAnagram(self, s: str, t: str) -> bool:
        # hashmap
        count = defaultdict(int)
        for x in s:
           count[x] += 1
        for x in t:
           count[x] -= 1
        for value in count.values():
           if value != 0:
               return False
        return True
```
Creates a hashmap (key,value) pair matching any alphabetic character 
to an integer representing the count.
Iterate over s incrementing +1 per appearence.
Iterate over t decrementing -1 per appearance.
If at the end, each (key,value) pair maps to 0, then you have a valid anagram.

### Solution 2: hashset 
```python
    def isAnagram(self, s: str, t: str) -> bool:
        # hashmap (as an array)
        count = [0] * 26
        for x in s:
           count[ord(x) - ord('a')] += 1
        for x in t:
           count[ord(x) - ord('a')] -= 1
        for value in count:
           if value != 0:
              return False
        return True
```
Same as above but taking into account alphabetic contraints and creating array
of size 26. 



## 1. Two Sum - Easy

### Intro
>Given an array of integers nums and an integer target, `return indices of the two numbers` such that they `add up to target`.
>You may assume that each input would have exactly one solution, and you may not use the same element twice.
>You can return the answer in any order.

|  nums[]         | Target    | Output |  
| --------------- | ----------| ------ | 
| [2,7,11,15]     | 9         | [0,1]  |
| [3,2,4]         | 6         | [1,2]  |  
| [3,3]           | 6         | [0,1]  |

### Constraints
Only one valid answer exists

length: 2 `leq` nums.length `leq` 10^4

target: -10^9 `leq` target `leq` 10^9

### Abstraction
Somewhat of a step-up from the previous questions. The question asks us to find a combination
of two elements in the array that add up to the target. 

Lets say we were to `iterate left to right` over the array. At any given moment, we would only 
have `half of the solution`. We still need to find the second element. 
But we still have the target! We can do `target - currNum = complement` and get the second half of the solution.
Since we are traversing the array, `we cannot do array.contains(complement)`, but if we `build
a hashset as we go` we will be able to use the `contains()` function. 

Thus, the pattern to find the pair is, grab element in array, check if complement is inside hashset.

However, the question asks us to `return the index` of the pair. Thus we must use a `HashMap instead with
(element, index)` where `element is the complement` we search using the contains().

A littttle bit of a step up from the previous, but great way to show versitily of hashmap/hashsets.

### Solution 1: hashmap 1-pass
```python
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        n = len(nums)
        numMap = {}

        # for every element  
        for i in range (n):
            
            complement = target - nums[i]

            # search for complement of curr element
            if complement in numMap and numMap[complement] != i:
                return [i, numMap[complement]]
    
            # if miss, push (currElement, index) into HashMap
            numMap[nums[i]] = i
```
