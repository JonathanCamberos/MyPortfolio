---
title: "1D Dynamic Programming"
description: "1D dynamic programming"
image: "../../public/Notes/1d-dynamic-programming.png"
publishedAt: "2025-05-03"
updatedAt: "2025-05-03" 
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---

## 1D Dynamic Programming Intro

LeetCode problems solved with dynamic programming

### What is 1D Dynamic Programming 

Dynamic Programming (DP) is a technique for solving problems that 
can be broken into overlapping sub problems and have optimal 
substructure, meaning the optimal solution can be built from
optimal solutions of sub problems.

Instead of solving the same subproblem repeatedly, DP stores
solutions in a table via memorization or a bottom up array,
to avoid redundant work.

### 1D Dynamic Programming Characteristics

- Optimal Substructure: global optimum is constructed from local optima.
- Overlapping Sub Problems: same subproblem is solved multiple times
when using naive recursion
- Memoization Top Down vs Tabulation Bottom Up
- Time complexity is typically: # of sub problems * time per sub problem

### 1D Dynamic Programming Representation

- 1D Array: climbing stairs, Fibonacci
- 2D Grid: edit distance, unique paths
- HashMap: Sparse states (like coin change with memoization)

### 1D Dynamic Programming IRL
- Shortest paths: Bellman-Ford
- Resource Allocation: Knapsack
- String Processing: Edit Distance, LCS
- Game Theory: minimax DP

### 1D Dynamic Programming Application: Sequential State Transition
Pattern: Each state depends on one or two prior states (linear recurrence).
Use When: Counting paths, sequences, or arrangements (Fibonacci, climbing stairs).
Recurrence: dp[i] = dp[i-1] + dp[i-2]

Ex: Climbing Stairs
```python
    def climbStairs(n: int) -> int:
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1

        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
```

### 1D Dynamic Programming Application: Choose or Skip Non Adjacent
Pattern: Decide whether to take or skip the current element.
Use When: Problems disallow consecutive selections (House Robber, Max Non-Adjacent Sum).
Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])

Ex: House Robber
```python
    def rob(nums: list[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        if n == 1: return nums[0]

        dp = [0] * n
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])

        for i in range(2, n):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

        return dp[-1]
```

### 1D Dynamic Programming Application: Circular Choose or Skip Non Adjacent
Pattern: Linear sequence with a circular constraint — first and last elements are considered adjacent. Solve by splitting into two linear subproblems (exclude first or exclude last).
Use When: Problems where selections are from a circular array (e.g., House Robber II, max non-adjacent circular sums).
Recurrence: Apply standard choose-or-skip recurrence on each linear subarray.

Ex: House Robber II 
```python
    def rob(nums: list[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]

        def rob_linear(arr):
            prev2, prev1 = 0, 0
            for num in arr:
                curr = max(prev1, num + prev2)
                prev2, prev1 = prev1, curr
            return prev1

        # Exclude first house OR exclude last house
        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))
```

### 1D Dynamic Programming Application: Min Max Contiguous Segment
Pattern: Track the best contiguous subarray sum (Kadane’s style).
Use When: Maximum sum, minimum sum, or subarray optimization problems.
Recurrence: dp[i] = max(nums[i], dp[i-1] + nums[i])

Ex: Maximum Subarray
```python
    def maxResult(nums: list[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]
        dq = deque([0])

        for i in range(1, n):
            while dq and dq[0] < i - k:
                dq.popleft()
            dp[i] = nums[i] + dp[dq[0]]
            while dq and dp[dq[-1]] <= dp[i]:
                dq.pop()
            dq.append(i)

        return dp[-1]
```

### 1D Dynamic Programming Application: Sliding Window Monotonic Queue
Pattern: Linear scan using a sliding window to track the best state efficiently.
Use When: DP recurrence depends on the best value in a recent window.
Recurrence: dp[i] = nums[i] + max(dp[j] for j in i-k..i-1)

Ex: Jump Game VI
```python
    def maxResult(nums: list[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]

        dq = deque([0])  # indices of "best" dp values

        for i in range(1, n):
            # Remove indices outside the window [i-k, i-1]
            while dq and dq[0] < i - k:
                dq.popleft()
            
            # Current dp depends on best in window
            dp[i] = nums[i] + dp[dq[0]]
            
            # Maintain deque in decreasing order of dp values
            while dq and dp[dq[-1]] <= dp[i]:
                dq.pop()
            dq.append(i)
        
        return dp[-1]
```

### 1D Dynamic Programming Application: Min Max Path Sum in Linear Sequence
Pattern: Track the cumulative minimum or maximum along a sequence.
Use When: Optimize total cost or reward along a linear path.
Recurrence: dp[i] = nums[i] + min/max(dp[i-1], dp[i-2], ...)

Ex: Minimum Cost Climbing Stairs
```python
    def minCostClimbingStairs(cost: list[int]) -> int:
        n = len(cost)
        dp = [0] * n
        dp[0], dp[1] = cost[0], cost[1]

        for i in range(2, n):
            dp[i] = cost[i] + min(dp[i-1], dp[i-2])

        return min(dp[-1], dp[-2])
```

### 1D Dynamic Programming Application: Bitmask Subset Linear
Pattern: Encode chosen elements as a bitmask for linear sequences of small size (n ≤ 20-25).
Use When: Problems involve selecting subsets or combinations with constraints.
Recurrence: dp[mask] = max(dp[mask ^ (1 < < i)] + nums[i])

Ex: Max Subset Sum with No Adjacent Selected
```python
    def maxSubsetSum(nums: list[int]) -> int:
        n = len(nums)
        dp = [0] * (1 << n)

        for mask in range(1, 1 << n):
            for i in range(n):
                if mask & (1 << i):
                    if i == 0 or not (mask & (1 << (i-1))):
                        dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + nums[i])

        return max(dp)
```

### 1D Dynamic Programming Application: Prefix Sum
Pattern: Use cumulative sums to speed up range-dependent DP.
Use When: DP depends on sums of ranges in a 1D array.
Recurrence: dp[i] = max(dp[j] + prefix[i] - prefix[j])

Ex: Maximum Subarray Sum with Length Constraint
```python
def maxSubarrayLenK(nums: list[int], k: int) -> int:
    n = len(nums)
    prefix = [0] * (n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + nums[i]

    dp = [0] * (n+1)
    for i in range(1, n+1):
        if i >= k:
            dp[i] = max(dp[i-1], prefix[i] - prefix[i-k])
        else:
            dp[i] = dp[i-1]

    return dp[n]
```

### 1D Dynamic Programming Application: Linear Decision with Multiple States
Pattern: Track multiple states per index when multiple choices exist (take/skip, hold/sell, etc.)
Use When: Problems have several options per position with state transitions.
Recurrence: dp[i][state] = max/min(choice1, choice2, ...)

Ex: Best Time to Buy/Sell Stock with Cooldown
```python
    def maxProfit(prices: list[int]) -> int:
        n = len(prices)
        if n == 0: return 0

        hold, sold, rest = -prices[0], 0, 0

        for i in range(1, n):
            prev_sold = sold
            sold = hold + prices[i]
            hold = max(hold, rest - prices[i])
            rest = max(rest, prev_sold)

        return max(sold, rest)
```

### 1D Dynamic Programming Application: Linear Property Tracking
Pattern: Track whether a property holds for each position in a sequence (true/false, max/min, count, etc.) using prior information.
Use When: You need to know if a subarray or subsequence satisfies a property at each index (palindrome, valid sum, valid jump, etc.).
Recurrence: dp[i] = f(dp[prev_indices], sequence[i])

Ex: Longest Palindromic Substring (DP Table)
```python
    def longestPalindrome(s: str) -> str:
        n = len(s)
        dp = [[False]*n for _ in range(n)]
        start, max_len = 0, 1

        for i in range(n):
            dp[i][i] = True

        for length in range(2, n+1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i+1][j-1]:
                        dp[i][j] = True
                        if length > max_len:
                            start, max_len = i, length

        return s[start:start+max_len]
```

### 1D Dynamic Programming Application: Min Max with Choices (Unbounded Knapsack style)
Pattern: Track the optimal value (minimum or maximum) for a linear state where each state can consider multiple choices repeatedly.
Use When: Problems involve selecting from a set of options multiple times to optimize a total, e.g., minimum coins, maximum value, maximum sum.
Recurrence: dp[i] = min/max(dp[i - choice] + value_of_choice for choice in choices if i - choice >= 0)

Ex: Coin Change (Minimum Coins)
```python
    def coinChange(coins: list[int], amount: int) -> int:
        max_val = amount + 1
        dp = [max_val] * (amount + 1)
        dp[0] = 0

        for a in range(1, amount + 1):
            for coin in coins:
                if a - coin >= 0:
                    dp[a] = min(dp[a], dp[a - coin] + 1)

        return dp[amount] if dp[amount] != max_val else -1
```

### 1D Dynamic Programming Application: Track Multiple States per Index (Max Min Tracking)
Pattern: Maintain multiple states per position when a single state cannot capture all possibilities. For example, track both maximum and minimum values at each step because future states depend on both.
Use When: Problems involve sequences where each element can affect multiple outcomes depending on prior states, such as max/min product subarray, stock problems with multiple options, or sequences with sign changes.
Recurrence:
max[i] = max(nums[i], max[i-1]*nums[i], min[i-1]*nums[i])
min[i] = min(nums[i], max[i-1]*nums[i], min[i-1]*nums[i])

Ex: Maximum Product Subarray
```python
    def maxProduct(nums: list[int]) -> int:
        n = len(nums)
        if n == 0: return 0

        max_prod = min_prod = result = nums[0]

        for i in range(1, n):
            num = nums[i]
            temp_max = max(num, max_prod * num, min_prod * num)
            min_prod = min(num, max_prod * num, min_prod * num)
            max_prod = temp_max
            result = max(result, max_prod)

        return result
```


### 1D Dynamic Programming Application: Sequential Segment Choice Validation
Pattern: Determine if a linear sequence can be segmented or satisfies a condition by checking all possible prior segments or choices.
Use When: Problems involve checking if a prefix/subsequence is valid based on previous valid segments (Word Break, Jump Game reachability, sequence segmentation).
Recurrence: dp[i] = any(dp[j] and valid_segment(j, i) for j in 0..i-1)

Ex: Word Break
```python
    def wordBreak(s: str, wordDict: list[str]) -> bool:
        word_set = set(wordDict)
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True  # empty string is segmentable

        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break  # early prune, found valid segmentation

        return dp[n]

```


### 1D Dynamic Programming Application: Subsequence Optimization Constrained
Pattern: Track the best subsequence ending at each index, respecting a relational/order constraint between elements.
Use When: Problems involve subsequences (not necessarily contiguous) where selected elements must satisfy a specific order or relational condition.
Recurrence: dp[i] = best(dp[j] + contribution[i]) for all j < i satisfying relation(nums[j], nums[i])

Ex: Longest Increasing Subsequence
```python
    def lengthOfLIS(nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0

        dp = [1] * n  # dp[i] = length of LIS ending at i
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

### 1D Dynamic Programming Application: Subset Sum Linear Choice Selection
Pattern: Track achievable sums or states when choosing elements sequentially, often under a “pick or skip” or additive constraint.
Use When: Problems involve deciding which elements to include/exclude to satisfy a global condition (subset sum, partitioning, knapsack with 0/1 choices, bitmask DP, etc.).
Recurrence Template: dp[i] = combine(dp[i], dp[i - contribution[j]])   # update achievable state

Ex: Partition Equal Subset Sum
```python
    def canPartition(nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0:
            return False
        target = total // 2
        dp = [False] * (target + 1)
        dp[0] = True
        for num in nums:
            for i in range(target, num - 1, -1):
                dp[i] = dp[i] or dp[i - num]
        return dp[target]
```



## 70. Climbing Stairs ::2:: - Easy

Topics:  Math, Dynamic Programming, Memoization

### Intro
> You are climbing a staircase. It takes n steps to reach   
> the top.
> Each time you can either climb 1 or 2 steps. In how 
> many distinct ways can you climb to the top?


|  Example Input           | Output |  
| ---------------- | ------ | 
| n = 2 | 2 |
| n = 3 | 3 |

Constraints:

1 &leq; n &leq; 45

### Abstraction
Given a number of steps, return the number of unique ways to reach the top,
by either climbing 1 or 2 steps at a time.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Memoization Top Down - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:

        # Note:
        # Top Down DP (memoized recursion)
        # Start from top and make recursive call creating left/right subtrees
        # 1. Process root -> current step index i
        # 2. Explore choices -> move 1 step or 2 steps
        # 3. Build -> accumulate number of ways to reach n
        # 4. Memoize -> store results to avoid recomputation
        # Result: number of ways to climb to the nth step

        # store number of ways from step i to n
        memo = {}

        def dfs(i):

            # Process Root -> memoized check
            if i in memo:
                return memo[i]
            
            # Base Cases -> if step index reaches or overshoots
            if i == n:
                # valid path
                return 1
            if i > n:
                # overshoot
                return 0   # Overshoot
            
            # Explore Choices -> move 1 or 2 steps
            left = dfs(i + 1)
            right = dfs(i + 2)

            # Build: sum of paths from next steps 
            memo[i] = left + right

            # Backtrack: return ith
            return memo[i]

        # initial call from step 0
        res = dfs(0)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: Iterative DP Bottom Up Optimal - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:
        
        # Note:
        # Bottom-up DP (iterative, optimal space)
        # Start from bottom, the ways to climb to the ith step, 
        # is the number of ways to climb to the ith-1 + ith-2 step.
        # 1. Process root -> initialize base cases f(1), f(2)
        # 2. Explore choices -> each i-th step = sum of ways to reach i-1 and i-2
        # 3. Build -> slide window for space optimization
        # Result: number of ways to climb to the nth step

        # Base cases
        if n == 1:
            return 1
        if n == 2:
            return 2

        # Initialize Sliding Window for f(1) and f(2)
        prev2, prev1 = 1, 2

        # Process -> compute f(3) to f(n)
        for i in range(3, n + 1):

            # build: sum of previous two
            curr = prev1 + prev2

            # Slide Window Forward
            prev2, prev1 = prev1, curr
        
        # f(n)
        res = prev1

        # overall: time complexity
        # overall: space complexity
        return res
```


## 746. Min Cost Climbing Stairs ::3:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> You are given an integer array cost where cost[i] is 
> the cost of ith step on a staircase. Once you pay the 
> cost, you can either climb one or two steps.
> You can either start from the step with index 0, or the 
> step with index 1.
> Return the minimum cost to reach the top of the floor.


|  Example Input           | Output |  
| ---------------- | ------ | 
| cost = [10,15,20] | 15 |
| [1,100,1,1,1,100,1,1,100,1] | 6 |

Constraints:

2 &leq; cost.length &leq; 1000

0 &leq; cost[i] &leq; 999

### Abstraction
Given a number of steps, and the cost to process a step,
find the cheapest cost to climb to the top.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Top-down DP (recursive with memoization)
        # 1. Process root -> current step index i
        # 2. Explore choices -> move 1 or 2 steps
        # 3. Build -> add cost at current step + min cost from next steps
        # 4. Memoize -> store results to avoid recomputation
        
        n = len(cost)

        # store min cost from step i to top
        memo = {}

        def dfs(i):

            # Memoized check
            if i in memo:
                return memo[i]

            # Base case -> reached or passed top
            if i >= n:
                return 0
            
            # Explore choices -> move 1 or 2 steps
            left = dfs(i+1)
            right = dfs(i+2)

            # Build: cost at current step + min of next steps
            minNext = min(left, right)
            memo[i] = cost[i] + min(dfs(i+1), dfs(i+2))

            # Backtrack: return min at ith
            return memo[i]

        # initial call from step 0 and 1 (can start from either)
        res1, res2 = dfs(0), dfs(1)
        res = min(res1, res2)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: Iterative DP Bottom Up - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Bottom-up DP
        # 1. Process root -> initialize base costs dp[0], dp[1]
        # 2. Explore choices -> dp[i] = cost[i] + min(dp[i-1], dp[i-2])
        # 3. Build -> fill dp array sequentially

        n = len(cost)
        dp = [0] * n

        # Base cases:
        dp[0], dp[1] = cost[0], cost[1]

        # Build DP array
        for i in range(2, n):

            # Explore Choices -> previous 2
            left = dp[i-1]
            right = dp[i-2]

            # Build -> Cost for current
            minNext = min(left, right)
            dp[i] = cost[i] + min(dp[i-1], dp[i-2])

        # Build -> cost for nth
        res1, res2 = dp[n-1], dp[n-2]
        res = min(res1, res2)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: Space Optimized DP - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Bottom-up DP with space optimization
        # Only previous two steps are needed for recurrence
        # 1. Initialize prev2, prev1 -> cost of first two steps
        # 2. Iterate -> compute current step cost using prev1, prev2
        # 3. Slide window -> update prev2, prev1

        n = len(cost)

        # Base cases
        prev2, prev1 = cost[0], cost[1]

        for i in range(2, n):
            
            # Build -> previous two + current
            curr = cost[i] + min(prev1, prev2)

            # slide window forward
            prev2, prev1 = prev1, curr

        # build for nth
        res = min(prev1, prev2)

        # overall: time complexity
        # overall: space complexity
        return res
```

## 198. House Robber ::3:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> You are a professional robber planning to rob houses 
> along a street. Each house has a certain amount of 
> money stashed, the only constraint stopping you from 
> robbing each of them is that adjacent houses have 
> security systems connected and it will automatically 
> contact the police if two adjacent houses were 
> broken into on the same night.
> Given an integer array nums representing the amount 
> of money of each house, return the maximum amount 
> of money you can rob tonight without alerting the police.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,2,3,1] | 4 |
| nums = [2,7,9,3,1] | 12 |

Constraints:

1 &leq; nums.length &leq; 100

0 &leq; nums[i] &leq; 400

### Abstraction
Given an array of cash, determine the max you can steal when you
cannot steal from two adjacent entries.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Top-down DP (recursive with memoization)
        # 1. Process root -> current house index i
        # 2. Explore choices -> rob current house or skip it
        # 3. Build -> max of robbing current + dfs(i-2) vs skipping dfs(i-1)
        # 4. Memoize -> store results to avoid recomputation

        # store max loot from house i to start
        memo = {}

        def dfs(i):
            # Process Root -> overshoot, no houses left
            if i < 0:
                return 0

            # Process Root -> memo check
            if i in memo:
                return memo[i]
            
            # Explore Choices:
            # 1. Skip current house dfs(i-1)
            left = dfs(i-1)

            # 2. Rob current house: nums[i] + dfs(i-2)
            right = nums[i] + dfs(i-2)

            # Build -> choose max of two options
            memo[i] = max(left, right)

            # Backtrack -> return max loot from this house
            return memo[i]

        # max loot for nth house
        res = dfs(len(nums)-1)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: Iterative DP Bottom Up - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Bottom-up DP
        # 1. Process root -> initialize base cases dp[0], dp[1]
        # 2. Explore choices -> dp[i] = max(dp[i-1], nums[i] + dp[i-2])
        # 3. Build -> fill dp array sequentially

        n = len(nums)

        # Base case check
        if n == 1:
            return nums[0]

        dp = [0] * n

        # Base cases
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])

        for i in range(2, n):

            # Explore Choices -> 
            left = dp[i-1]
            right = nums[i] + dp[i-2]

            # Build -> choose max between options
            dp[i] = max(left + right)

        # Build -> max for nth
        res = dp[-1]

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: Space Optimized DP - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with space optimization
        # Only previous two houses needed for recurrence
        # 1. Initialize prev2, prev1 -> max loot at first two houses
        # 2. Iterate -> compute current max using prev1, prev2
        # 3. Slide window -> update prev2, prev1

        n = len(nums)

        # Base case check
        if n == 1:
            return nums[0]

        # Base cases
        prev2, prev1 = nums[0], max(nums[0], nums[1])

        for i in range(2, n):

            # Build -> max from previous two
            curr = max(prev1, nums[i] + prev2)

            # Explore -> Slide Window
            prev2, prev1 = prev1, curr

        # max for nth
        res = prev1

        # overall: time complexity
        # overall: space complexity
        return res
```


## 213. House Robber II ::3:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> You are a professional robber planning to rob houses 
> along a street. Each house has a certain amount of 
> money stashed. All houses at this place are arranged 
> in a circle. That means the first house is the neighbor 
> of the last one. Meanwhile, adjacent houses have a 
> security system connected, and it will automatically 
> contact the police if two adjacent houses were 
> broken into on the same night.
> Given an integer array nums representing the amount 
> of money of each house, return the maximum amount 
> of money you can rob tonight without alerting the police.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = nums = [2,3,2] | 3 |
| nums = [1,2,3,1] | 4 |
| nums = [1,2,3] | 3 |

Constraints:

1 &leq; nums.length &leq; 100

0 &leq; nums[i] &leq; 1000

### Abstraction
Given an array of cash, determine the max you can steal when you
cannot steal from two adjacent entries, when array is circular.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Top-down DP (recursive with memoization) for circular houses
        # 1. Process root -> current house index i in linear range
        # 2. Explore choices -> rob current house or skip it
        # 3. Build -> max of robbing current + dfs(i-2) vs skipping dfs(i-1)
        # 4. Memoize -> store results to avoid recomputation
        # 5. Handle circular constraint -> cannot rob both first and last

        n = len(nums)

        # Base case check
        if n == 1:
            return nums[0]

        def rob_range(start, end):

            # build max loot from start - end houses
            memo = {}

            def dfs(i):
                
                # overshoot
                if i < start:
                    return 0

                # memo check
                if i in memo:
                    return memo[i]

                # Explore Choices -> 
                # 1. rob current
                left = dfs(i-1)

                # 2. skip
                right = nums[i] + dfs(i-2)

                # Build -> max loot at ith
                memo[i] = max(left, right)

                # Backtrack -> return max loot at ith
                return memo[i]

            # max loot from endth house
            return dfs(end)

        # consider houses from first to second to last, exclude last house
        res1 = rob_range(0, n-2)

        # consider houses from second to last, exclude the first house
        res2 = rob_range(1, n-1)

        # by disconnecting the circle, we are able to solve
        res = max(res1, res2)

        # overall: time complexity
        # overall: space complexity
        return res
```


### Solution 2: Iterative DP Bottom Up - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Bottom-up DP for circular houses
        # 1. Process root -> compute linear DP for given subarray
        # 2. Explore choices -> dp[i] = max(dp[i-1], arr[i] + dp[i-2])
        # 3. Build -> fill dp array sequentially
        # 4. Handle circular constraint -> two linear runs

        n = len(nums)

        # Base case check
        if n == 1:
            return nums[0]

        def rob_linear(arr):

            #
            m = len(arr)
            
            # 
            if m == 1:
                return arr[0]

            # 
            dp = [0] * m

            # Base cases
            dp[0], dp[1] = arr[0], max(arr[0], arr[1])

            for i in range(2, m):
                
                # Explore Choices ->
                left = dp[i-1]
                right = arr[i] + dp[i-2]

                # Build -> max current
                dp[i] = max(left, right)

            # Max for last house
            return dp[-1]

        # exclude last
        res1 = rob_linear(nums[:-1])

        # exclude first
        res2 = rob_linear(nums[1:])

        # max for both permutations
        res = max(res1, res2)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: Space Optimized DP - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with space optimization
        # Only previous two houses needed for recurrence
        # Handle circular constraint by two linear runs with sliding window

        n = len(nums)
        if n == 1:
            return nums[0]

        def rob_linear(arr):

            # dp[i-2], dp[i-1] for linear run
            prev2, prev1 = 0, 0
            for num in arr:

                # Build -> : max for ith house
                curr = max(prev1, num + prev2)

                # slide window
                prev2, prev1 = prev1, curr

            # max for last house
            return prev1

        # Exclude last house
        res1 = rob_linear(nums[:-1])
        # Exclude first house
        res2 = rob_linear(nums[1:])
        # Max from permutations
        res = max(res1, res2)

        # overall: time complexity
        # overall: space complexity
        return res
```

## 5. Longest Palindromic Substring ::3:: - Medium

Topics: Two Pointers, String, Dynamic Programming

### Intro
> Given a string s, return the longest palindromic substring in s. 

|  Input | Output  |  
| ------- | ------- | 
| "cbbd"  | "bb"           |
| "babad" | "bab" or "aba" |


Constraints: 

1  &leq; s.length &leq; 1000 

s consists of only digits and English letters.

### Abstraction 

Find the longest palindrome in a string.

### Find the Bug: Did not create Expanded String
```python
    def longestPalindrome(self, s: str) -> str:
        
        # INCORRECT:
        # did not create expandedStr
        # did not solve odd vs even palindrome problem
        # missing:
        # expandedStr = "#".join(f"^{s}$")
        
        center = 0
        right = 0
        n = len(s)
        p = [0] * n

        for i in range(1, n-1):
            
            # 1 
            mirror = (2*center) - i

            # 2 
            if i < right:
                p[i] = min(right-i, p[mirror])

            # 3
            while s[i + p[i] + 1] == s[i - p[i] - 1]:
                p[i] += 1

            # 4
            if i + p[i] > right:
                center = i
                right = i + p[i]
        
        (maxRadius, center) = max((maxRadius, i) for (i, maxRadius) in enumerate(p))
        start = (center-maxRadius) // 2 

        return s[start:start+maxRadius]
```

### Find the Bug: Defined List instead of Slicing
```python
    def longestPalindrome(self, s: str) -> str:
        
        def expandAroundCenter(left, right):
            while left >= 0 and right < n and s[left] == s[right]:
                left -= 1
                right += 1

            # INCORRECT:
            # defined list instead of slicing
            # should be: s[left+1:right]
            return s[left+1, right]
        
        n = len(s)
        maxPalin = ""

        for i in range(n):
            oddPalin = expandAroundCenter(i, i)
            evenPalin = expandAroundCenter(i, i+1)

            if len(oddPalin) > len(maxPalin):
                maxPalin = oddPalin
            if len(evenPalin) > len(maxPalin):
                maxPalin = evenPalin
                
        return maxPalin
```

### Find the Bug: Bad iteration leading to out of bounds on string expansion
```python
    def longestPalindrome(self, s: str) -> str:
        
        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)
        p = [0] * n
        center = 0
        right = 0

        # INCORRECT:
        # iteration will also expand from the sentinals '^' and '$'
        for i in range(n):

            # grab mirror
            mirror = (2*center)-i

            # validate mirror
            if i < right:
                p[i] = min(p[mirror], (right-i))

            # expand
            # INCORRECT:
            # due to iteration, expansion is not guaranteed and prevent
            # out of bounds grab, since we are missing the eventual
            # '^' != '$'
            while expandedStr[i - p[i] - 1] == expandedStr[i + p[i] + 1]:
                p[i] += 1

            # find new right most
            if p[i] + i > right:
                center = i
                right = p[i] + i

        # translate back to height
        maxRadi, center = max((maxRadi, center) for (center, maxRadi) in enumerate(p))

        startIndex = (center-maxRadi)//2


        return s[startIndex:startIndex+maxRadi]
```

### Find the Bug: Bad enumerate method:
```python
    def longestPalindrome(self, s: str) -> str:
        
        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)
        p = [0] * n
        center = 0
        right = 0

        for i in range(1, n-1):

            # grab mirror
            mirror = (2*center)-i

            # validate mirror
            if i < right:
                p[i] = min(p[mirror], (right-i))

            # expand
            while expandedStr[i - p[i] - 1] == expandedStr[i + p[i] + 1]:
                p[i] += 1

            # find new right most
            if p[i] + i > right:
                center = i
                right = p[i] + i

        # translate back to height
        # INCORRECT:
        # should be 
        # enumerate(p)
        # instead of p.enumerate()
        maxRadi, center = max((maxRadi, center) for (center, maxRadi) in p.enumerate())

        startIndex = (center-maxRadi)//2


        return s[startIndex:startIndex+maxRadi]
```

### Solution 1: Manacher's Algorithm (iterate, mirror radius optimization, and expand) - Two Pointers/Algorithm
```python
    def longestPalindrome(self, s: str) -> str:

        # Note: 
        # Preprocessing with #, ^, and $:
        # '#': ensures uniform expansion, for both odd and even length palindromes
        # '^' and '$': sentinel characters don't match valid input characters, serve as true start and end markers
        # '#': ensures all palindromes start and end with '#'
        # '#': occur on odd indexes

        # Mapping:
        # we can map odd '#' indexes to their even character:
        # mapping '#' at index 1 to char pair 'a' at index 2, to original 'a' at index 0
        # [ ^ # a # b # a # $ ] -> [ a b a ]    via : originalStart = (expandedCenter - radius) / 2
        #   0 1 2 3 4 5 6 7 8        0 1 2      thus: originalStart = (4 - 3) / 2 = 0
        
        # Boundary expansion: 
        # For any index i, center of palindrome at i can either be: 
        # - character from the original string
        # - placeholder '#'
        # Center definition allows even length palindromes such as "abba", see below,
        # to have a single middle point, allowing the same expanding logic 
        # for even and odd strings for palindrome validation

        # Ex:
        # ^ # a # b # b # a # $    || new string len 11,
        # 0 1 2 3 4 5 6 7 8 9 10   ||
        #           ^              || index 5 center for even length "abba"

        # index 1 palindrome: "#"
        # index 2 palindrome: "#a#"
        # index 5 palindrome: "#a#b#b#a#"
        # etc...

        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)

        # Right Most Palindrome and Mirror Trick: 
        # Iteration tracks the right boundary for the current farthest right palindromic substring, 
        # which allows us to take advantage of the mirror radius trick.
        # It speeds up palindrome expansion by starting the current palindrome radius
        # at the radius value of its mirror

        # p[i]: radius of palindrome centered at some index i
        p = [0] * n

        # mirror radius validation: tracking right boundary
        # right: right boundary of the current right most palindrome
        right = 0

        # mirror radius validation: tracking center of right most in order to calculate mirror index
        # center: center index of the current right most palindrome
        center = 0 

        # iteration range ignores sentinel indexes 0 and (n-1): ^ and $
        # i: center of current palindrome
        # time complexity: iterate over list of n length O(n)
        for i in range(1, n - 1):

            # mirror:
            # i is current index being processed
            # i is to the right of center and has a mirror to the left of center
            # ex: center = 6, i = 7 => mirror = (2 * 6) - 7 = 5
            mirror = (2 * center) - i 

            # mirror radius validation:
            # if i lies within bounds of the right most palindrome,
            # the right most palindrome symmetry guarantees that the palindrome radius
            # for the mirror of i, is applicable to i as well,
            # while within the bounds of the right most palindrome
            if i < right:

                # mirror radius is either:
                # - less than the distance between i and right bound,
                #   in which case all of the radius is valid
                # - exceeds bounds and is farther than right bound,
                #   in which case only the radius up until the right bound is valid
                
                # i radius is thus, bounded by minimum between: 
                # - mirror radius
                # - distance from i to the right bound
                p[i] = min(right - i, p[mirror])

            # assumption: if valid mirror, we pre-set p[i] to p[mirror]
            # now expand: expand radius p[i] until palindromic status is broken
            while expandedStr[i + p[i] + 1] == expandedStr[i - p[i] - 1]:
                p[i] += 1

            # p[i]: radius for palindrome at i
            # i: center for palindrome at i
            # check: if we have a new right most boundary, update center and right 
            if i + p[i] > right:
                right = i + p[i]
                center = i

        # expandedStr iteration complete:
        # p[] stores radius of palindrome centered at each index

        # scan p[] grabbing max palindrome radius alongside its center
        maxRadius, centerIndex = max((palindromeRadius, i) for (i, palindromeRadius) in enumerate(p))

        # Note:
        # index and radius are relative to expandedStr, not the original string
        # thus, we need to translate to original string indexes

        # Notice, how in the expanded string, 
        #  - all original characters are on even index
        #  - all original characters have matching # on the left odd index

        # abba =>  ^ # a # b # b # a # $   | a=2, b=4, b=6, a=8
        # 0123 =>  0 1 2 3 4 5 6 7 8 9 10  | #=1, #=3, #=5, #=7

        # aba =>   ^ # a # b # a # $       | a=2, b=4, a=6
        # 012 =>   0 1 2 3 4 5 6 7 8       | #=1, #=3, #=5

        # any palindrome will always end with a '#'.
        # so if we divide the starting odd position by 2, it will always map
        # to an original character.
        # so an easy translation formula is:

        start = (centerIndex - maxRadius) // 2
        
        # splice longest substring

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return s[start: start + maxRadius]
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Preprocessing | O(n) | O(n) | Building expanded string | Memory allocation for processed string O(n) |
| Iterating | O(n) | O(1) | Iterate over processed string of n length O(n) | No additional memory allocation for iteration O(1) |
| Expanding radii | O(n) | O(n) | Radius expansion over processed string of n length O(n) | Radius array to store radii for each index for string of n length O(n) |
| Updating mirror bounds | O(1) | O(1) | Updating center and right for right most palindrome in constant O(1) | No additional memory allocation for center and right variables O(1) |
| Overall | O(n) | O(n) | Iterating over expanded string dominates, leading to O(n) time complexity. | Expanding string dominates, leading to O(n) space complexity. |


### Solution 2: Expand Around Center checking for Odd and Even palindromes (constant space) - Two Pointers/Algorithm
```python
    def longestPalindrome(self, s: str) -> str:

        # expand from a given left and right while 
        # maintaining palindrome property
        def expandAroundCenter(left, right):
            while left >= 0 and right < n and s[left] == s[right]:
                left -= 1
                right += 1

            # curr iteration is not valid:
            # ignore left: incrementing index
            # ignore right: noninclusive right slicing
            return s[left+1:right] 
         
        n = len(s)
        maxPalindrome = ""

        # time complexity: iterate over list of n length O(n)
        for i in range(n):
            # odd expansion, centered at i
            oddPalindrome = expandAroundCenter(i, i)      
            # even expansion, centered at i and i + 1
            evenPalindrome = expandAroundCenter(i, i+1)

            # update longest
            if len(oddPalindrome) > len(maxPalindrome):
                maxPalindrome = oddPalindrome
            if len(evenPalindrome) > len(maxPalindrome):
                maxPalindrome = evenPalindrome

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return maxPalindrome
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterating | O(n) | O(1) | Iterating over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Odd expansion | O(n^2) | O(1) | For each center, expands outward for odd length palindromes n length O(n), for each outer iteration O(n), leading to O(n^2) | No additional memory allocation needed during expansion O(1) |
| Even expansion | O(n^2) | O(1) | For each center, expands outward for even length palindromes n length O(n), for each outer iteration O(n), leading to O(n^2) | No additional memory allocation needed during expansion O(1) |
| Updating longest | O(1) | O(1) | Comparing odd and even length palindrome to current max in constant O(1) | No additional memory allocation needed for comparison to current max O(1) |
| Overall | O(n^2) | O(1) | Even and odd expansion per outer iteration dominate, leading to O(n<sup>2</sup>) | No additional memory allocation required for in place expansion or iteration, leading to constant O(1) |


### Solution 3: Dynamic Programming - 1D Dynamic Programming/Linear Property Tracking
```python
        def longestPalindrome(self, s: str) -> str:
        
        n = len(s)
        dp = [[False]*n for _ in range(n)]
        start, max_len = 0, 1

        for i in range(n):
            dp[i][i] = True

        for length in range(2, n+1):  # substring length
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i+1][j-1]:
                        dp[i][j] = True
                        if length > max_len:
                            start, max_len = i, length

        return s[start:start+max_len]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 647. Palindromic Substrings ::2:: - Medium

Topics:  Two Pointers, String, Dynamic Programming

### Intro
> Given a string s, return the number of palindromic 
> substrings in it.
> A string is a palindrome when it reads the same 
> backward as forward.
> A substring is a contiguous sequence of characters 
> within the string.


|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "abc" | 3 |
| s = "aaa" | 6 |

Constraints:

1 &leq; s.length &leq; 1000

s consists of lowercase English letters.

### Abstraction
Given a string, determine how many palindromic substrings exist.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Two Pointers Expand Around Center - 1D Dynamic Programming/Linear Property Tracking
```python
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        count = 0

        # helper: expand from center
        def expand(l: int, r: int) -> int:
            local_count = 0
            while l >= 0 and r < n and s[l] == s[r]:
                local_count += 1   # found a palindrome
                l -= 1
                r += 1
            return local_count

        # expand around all possible centers
        for i in range(n):
            count += expand(i, i)     # odd-length palindromes
            count += expand(i, i + 1) # even-length palindromes

        return count
```

### Solution 2: Dynamic Programming - 1D Dynamic Programming/Linear Property Tracking
```python
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        count = 0

        # single characters
        for i in range(n):
            dp[i][i] = True
            count += 1

        # substring lengths 2 -> n
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i + 1][j - 1]:
                        dp[i][j] = True
                        count += 1

        return count
```


## 91. Decode Ways ::2:: - Medium

Topics:  String, Dynamic Programming

### Intro
> You have intercepted a secret message encoded as a 
> string of numbers. The message is decoded via the 
> following mapping:
> "1" -> 'A'
> "2" -> 'B'
> ...
> "25" -> 'Y'
> "26" -> 'Z'
> However, while decoding the message, you realize that 
> there are many different ways you can decode the 
> message because some codes are contained in other
> codes ("2" and "5" vs "25").
> For example, "11106" can be decoded into:
> "AAJF" with the grouping (1, 1, 10, 6)
> "KJF" with the grouping (11, 10, 6)
> The grouping (1, 11, 06) is invalid because 
> "06" is not a valid code (only "6" is valid).
> Note: there may be strings that are impossible to decode.
> Given a string s containing only digits, return the 
> number of ways to decode it. If the entire string 
> cannot be decoded in any valid way, return 0.
> The test cases are generated so that the answer fits in
> a 32-bit integer.


|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "12" | 2 |
| s = "226" | 3 |
| s = "06" | 0 |

Constraints:

1 &leq; s.length &leq; 100

s contains only digits and may contain leading zero(s).

### Abstraction
Given a string, determine how many ways there to decode the string.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming Bottom Up - 1D Dynamic Programming/Sequential State Transition
```python
    def numDecodings(self, s: str) -> int:

        # Note:
        # Bottom-up DP (1D array)
        # 1. Process root -> dp[i] = number of ways to decode first i characters
        # 2. Explore choices -> single-digit and two-digit decoding
        # 3. Build -> accumulate valid ways using previous dp values

        n = len(s)

        # Invalid string
        if not s or s[0] == '0':
            return 0

        dp = [0] * (n + 1)

        # Base cases:
        # empty string has 1 way
        dp[0] = 1
        # first char is valid (not '0') 
        dp[1] = 1

        for i in range(2, n + 1):
            # Explore Choices -> single digit
            if s[i-1] != '0':
                dp[i] += dp[i-1]

            # Explore Choices -> double digit
            two_digit = int(s[i-2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i-2]

        # Build -> dp[n] has total decoding ways
        res = dp[n]

        # overall: time complexity
        # overall: space complexity
        return res
```


### Solution 2: Space Optimized DP - 1D Dynamic Programming/Sequential State Transition
```python
    def numDecodings(self, s: str) -> int:

        # Note:
        # Bottom-up DP with space optimization
        # Only previous two dp values needed
        # 1. prev2 = dp[i-2], prev1 = dp[i-1]
        # 2. For current index, accumulate ways from single-digit and two-digit checks
        # 3. Slide window forward to maintain only two previous states

        # Invalid check
        if not s or s[0] == '0':
            return 0

        n = len(s)

        # Base cases
        prev2, prev1 = 1, 1  # dp[0], dp[1]

        for i in range(1, n):

            curr = 0

            # Explore Choices -> single digit
            if s[i] != '0':
                curr += prev1

            # Explore Choices -> double digit
            two_digit = int(s[i-1:i+1])
            if 10 <= two_digit <= 26:
                curr += prev2

            # Slide Window ->
            prev2, prev1 = prev1, curr

        # Decode ways for nth
        res = prev1

        # overall: time complexity
        # overall: space complexity
        return res
```


## 322. Coin Change ::3:: - Medium

Topics:  Array, Dynamic Programming, Breadth First Search

### Intro
> You are given an integer array coins representing
> coins of different denominations and an integer 
> amount representing a total amount of money.
> Return the fewest number of coins that you need to 
> make up that amount. If that amount of money cannot 
> be made up by any combination of the coins, return -1.
> You may assume that you have an infinite number of 
> each kind of coin.

|  Example Input           | Output |  
| ---------------- | ------ | 
| coins = [1,2,5], amount = 11 | 3 |
| coins = [2], amount = 3 | -1 |
| coins = [1], amount = 0 | 0 |

Constraints:

1 &leq; coins.length &leq; 12

1 &leq; coins[i] &leq; 2<sup>31</sup> - 1

0 &leq; amount &leq; 10<sup>4</sup>


### Abstraction
Given a array of coin cost and a price, determine the minimum number
of coins needed to make the price.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming Bottom Up - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        # Note:
        # Bottom-up DP (1D array)
        # 1. Process root -> dp[a] = minimum coins needed for amount a
        # 2. Explore choices -> for each coin, consider using it
        # 3. Build -> dp[a] = min(dp[a], dp[a-coin] + 1)
        # 4. Result -> dp[amount] contains minimum coins if possible
        
        # sentinel for impossible
        max_val = amount + 1

        dp = [max_val] * (amount + 1)
        
        # Base case -> zero coins needed for 0
        dp[0] = 0 

        # Process price from 1 to target
        for a in range(1, amount + 1):

            # Explore Choices -> try each coin
            for coin in coins:

                # Valid choice
                if a - coin >= 0:
                    
                    # Explore Choices ->
                    # 1. ignore coin
                    left = dp[a]
                    # 2. use coin
                    right = dp[a-coin] + 1

                    # Build -> min between two options
                    dp[a] = min(left, right)

        res = dp[amount] if dp[amount] != max_val else -1

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: Recursive DP with Memoization - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:

        # Note:
        # Top-down DP (recursive with memoization)
        # 1. Process root -> remaining amount rem
        # 2. Explore choices -> recursively subtract each coin
        # 3. Build -> minimum coins among all choices
        # 4. Memoize -> store min coins for rem to avoid recomputation
        
        memo = {}

        def dfs(rem: int) -> int:
            # Process Root -> Base cases

            # Overshoot
            if rem < 0:
                return -1
            
            # Exact Match
            if rem == 0:
                return 0

            # Memoized
            if rem in memo:
                return memo[rem]

            min_coins = float('inf')

            # Explore Choices -> try each coin
            for coin in coins:
                
                # ??????
                res = dfs(rem - coin)

                if res >= 0:
                    # Build -> take min among all valid choices
                    min_coins = min(min_coins, res + 1)

            # Memoize result
            memo[rem] = -1 if min_coins == float('inf') else min_coins

            # Backtrack -> return value
            return memo[rem]

        # initial call with full amount
        res = dfs(amount)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: BFS - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        # Note:
        # BFS (level-order) to find min coins
        # 1. Process root -> start with remaining amount = amount
        # 2. Explore choices -> subtract each coin to get next remaining amounts
        # 3. Build -> increment steps (coins used) at each BFS level
        # 4. Early stop -> return steps+1 when remaining reaches 0
        # 5. Result -> -1 if queue exhausted (impossible)

        if amount == 0:
            return 0

        # (remaining amount, coins used so far)
        queue = deque([(amount, 0)])

        # avoid revisiting same amount
        visited = set([amount])

        while queue:

            # Process Root -> current state
            rem, steps = queue.popleft()

            # Explore Choices -> try each coin
            for coin in coins:

                next_rem = rem - coin

                # Explore Choices -> rob/subtract each coin

                # target
                if next_rem == 0:
                    return steps + 1
                
                elif next_rem > 0 and next_rem not in visited:
                    # Build -> add next state to queue
                    visited.add(next_rem)
                    queue.append((next_rem, steps + 1))

        # impossible to reach target
        return -1
```


## 152. Maximum Product Subarray ::2:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> Given an integer array nums, find a subarray that has 
> the largest product, and return the product.
> The test cases are generated so that the answer will fit 
> in a 32-bit integer.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [2,3,-2,4] | 6 |
| nums = [-2,0,-1] | 0 |

Constraints:

1 &leq; nums.length &leq; 2 * 10<sup>4</sup>

-10 &leq; nums[i] &leq; 10

The product of any subarray of nums is guaranteed 
to fit in a 32-bit integer.


### Abstraction
Given a array, find the subarray with the largest product 
and return the product.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DP Array Version - 1D Dynamic Programming/Track Multiple States per Index (Max Min Tracking)
```python
    def maxProduct(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with arrays
        # At each index, we conceptually explore 3 choices:
        # 1. Start new subarray with current num (root)
        # 2. Extend previous max product subarray (left)
        # 3. Extend previous min product subarray (right)
        # Then pick the max/min result to continue

        n = len(nums)
        if n == 0:
            return 0

        # Initialize DP arrays and result
        max_dp = [0] * n
        min_dp = [0] * n
        max_dp[0] = min_dp[0] = result = nums[0]

        for i in range(1, n):
            num = nums[i]

            # Explore Choices:
            left = max_dp[i-1] * num       # extend previous max subarray
            right = min_dp[i-1] * num      # extend previous min subarray
            root = num                      # start new subarray at current index

            # Build: pick max/min product at this index
            max_dp[i] = max(root, left, right)
            min_dp[i] = min(root, left, right)

            # Update overall result
            result = max(result, max_dp[i])

        # overall: 
        return result
```



### Solution 2: DP with Rolling Max Min - 1D Dynamic Programming/Track Multiple States per Index (Max Min Tracking)
```python
    def maxProduct(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with rolling variables (space optimized)
        # 1. Process root -> current element nums[i]
        # 2. Explore choices -> multiply current with previous max or min
        # 3. Build -> track max_prod and min_prod at each step
        #    (min_prod important due to negative numbers flipping sign)
        # 4. Result -> update overall max product seen so far

        n = len(nums)
        if n == 0:
            return 0

        # Initialize rolling max, min, and result
        max_prod = min_prod = result = nums[0]

        for i in range(1, n):
            num = nums[i]

            # Explore Choices:
            # left = extend previous max_prod
            left = max_prod * num
            # right = extend previous min_prod
            right = min_prod * num
            # root = start new subarray
            root = num

            # Build: compute current max/min at this index
            temp_max = max(root, left, right)
            min_prod = min(root, left, right)
            max_prod = temp_max

            # Update overall result
            result = max(result, max_prod)


        return result
```

## 139. Word Break ::3:: - Medium

Topics:  Array, Hash Table, String, Dynamic Programming, Trie, Memoization

### Intro
> Given a string s and a dictionary of strings wordDict,
> return true if s can be segmented into a space 
> separated sequence of one or more dictionary words. 
> Note that the same word in the dictionary may be 
> reused multiple times in the segmentation.

|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "leetcode", wordDict = ["leet","code"] | true |
| s = "applepenapple", wordDict = ["apple","pen"] | true |
| s = "catsandog", wordDict = ["cats","dog","sand","and","cat"] | false |

Constraints:

1 &leq; s.length &leq; 300

1 &leq; wordDict.length &leq; 1000

1 &leq; wordDict[i].length &leq; 20

s and wordDict[i] consist of only lowercase English letters.

All the strings of wordDict are unique.

### Abstraction
Given a string and an array of strings, determine if the string
can be separated into some combination of strings from the array.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        # Note:
        # Bottom-up DP
        # 1. Process root -> current substring ending at i
        # 2. Explore choices -> partition at every possible previous index j
        # 3. Build -> dp[i] = True if any dp[j] is True and s[j:i] in wordDict
        # 4. Early prune -> break if valid segment found

        # quick lookup
        word_set = set(wordDict)
        n = len(s)
        dp = [False] * (n + 1)

        # Base case: empty string is segmentable
        dp[0] = True

        for i in range(1, n + 1):
            for j in range(i):
                
                # Explore Choice: segment s[j:i]
                if dp[j] and s[j:i] in word_set:

                    # Build -> segmentable
                    dp[i] = True 
                    # early prune, found valid segmentation
                    break  

        # Result: can full string be segmented
        return dp[n]
```

### Solution 2: Recursive DFS with Memoization - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        # Note:
        # Top-down DP (memoized recursion)
        # 1. Process root -> current start index
        # 2. Explore Choices -> try every end index forming s[start:end]
        # 3. Build -> if s[start:end] in word_set and dfs(end) is True, memo[start] = True
        # 4. Backtrack -> store False if no valid segmentation

        # quick lookup
        word_set = set(wordDict)
        memo = {}

        def dfs(start: int) -> bool:

            # Process Root -> Base cases

            # Reached end
            if start == len(s):
                return True

            # Memo check
            if start in memo:
                return memo[start]

            for end in range(start + 1, len(s) + 1):
                # Explore Choices -> s[start:end] as a segment
                if s[start:end] in word_set and dfs(end):

                    # Build: segmentable from start
                    memo[start] = True
                    return True

            # Backtrack: cannot segment from this start
            memo[start] = False
            return False

        # original call from top
        res = dfs(0)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: Optimized DFS by Matching Words - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        # Note:
        # Optimized top-down DFS
        # 1. Process root -> current index i
        # 2. Explore choices -> iterate only over words in wordDict
        # 3. Build -> if s[i:i+len(word)] == word and dfs(i+len(word)) True, cache[i] = True
        # 4. Backtrack -> store False if no valid segmentation

        cache = {}
        def dfs(i):
            # Process Root -> base cases

            # reached end
            if i == len(s):
                return True

            # overshoot
            if i > len(s):
                return False

            # memo check
            if i in cache:
                return cache[i]
            for word in wordDict:
                # Explore Choice -> try matching void
                if i + len(word) <= len(s) and s[i:i+len(word)] == word:
                    cache[i] = dfs(i+len(word))
                    if cache[i]:
                        return True
            return False
        return dfs(0)
```


## 300. Longest Increasing Subsequence ::2:: - Medium

Topics:  Array, Binary Search, Dynamic Programming

### Intro
> Given an integer array nums, return the length of the 
> longest strictly increasing subsequence.
> Follow up: Can you come up with an algorithm that runs
> in O(n log(n)) time complexity?


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [10,9,2,5,3,7,101,18] | 4 |
| nums = [0,1,0,3,2,3] | 4 |
| nums = [7,7,7,7,7,7,7] | 1 |

Constraints:

1 &leq; nums.length &leq; 2500

-10<sup>4</sup> &leq; nums[i] &leq; 10<sup>4</sup>

### Abstraction
Given an integer array, find the longest increasing subsequence.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Classic DP for LIS
        # 1. Process root -> current index i (end of subsequence)
        # 2. Explore choices -> for all j < i, check if nums[i] can extend subsequence ending at j
        # 3. Build -> dp[i] = max(dp[i], dp[j]+1)
        # 4. Result -> maximum of dp array

        n = len(nums)
        if n == 0:
            return 0

        # dp[i] = length of LIS ending at i
        dp = [1] * n

        for i in range(n):
            for j in range(i):

                # Explore Choice -> extend subsequence ending at j
                if nums[i] > nums[j]:

                    # Build -> max between current and extending j
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```

### Solution 2: Binary Search Patience Sorting - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Patience sorting method (efficient O(n log n))
        # 1. Process root -> current number in nums
        # 2. Explore choices -> find insertion point in current LIS tails
        # 3. Build -> append if new tail is larger, else replace to minimize tail
        # 4. Result -> length of tails array = length of LIS

        # tails[i] = smallest possible tail of LIS of length 
        tails = []

        for num in nums:
            
            # Explore Choice -> find where num fits
            index = bisect.bisect_left(tails, num)

            if index == len(tails):
                # Build: extend LIS with new larger tail
                tails.append(num)
            else:
                # Build: replace to keep minimal tail (better chance for future extension)
                tails[index] = num

        return len(tails)
```

### Solution 3: Binary Search - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Same as Solution 2, but manual binary search instead of bisect
        # 1. Process root -> current number
        # 2. Explore choices -> search for first tail >= num
        # 3. Build -> append if end, replace otherwise
        # 4. Result -> length of tails = LIS length

        tails = []

        for num in nums:
            left, right = 0, len(tails) - 1
            
            # Explore Choices -> find insertion/replacement index
            while left <= right:
                mid = (left + right) // 2
                if tails[mid] < num:
                    left = mid + 1
                else:
                    right = mid - 1
            
            # Build: insert or replace
            if left == len(tails):
                tails.append(num)
            else:
                tails[left] = num

        return len(tails)
```


## 416. Partition Equal Subset Sum ::2:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> Given an integer array nums, return true if you can 
> partition the array into two subsets such that the sum
> of the elements in both subsets is equal or false 
> otherwise.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,5,11,5] | true |
| nums = [1,2,3,5] | false |

Constraints:

1 &leq; nums.length &leq; 200

1 &leq; nums[i] &leq; 100

### Abstraction
Given an integer array, determine if you can split it into two arrays
such that the sum of each arrays is equal.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming Subset Sum - 1D Dynamic Programming/Subset Sum Linear Choice Selection
```python
    def canPartition(self, nums: List[int]) -> bool:
        
        # Note:
        # 1D DP for subset sum
        # 1. Process root -> current number in nums
        # 2. Explore choices -> include current number or skip it
        # 3. Build -> update achievable sums in dp
        # 4. Result -> check if target sum is achievable
        
        total = sum(nums)
        # If total sum is odd, cannot partition equally
        if total % 2 != 0:
            return False

        target = total // 2
        n = len(nums)

        # dp[i] = True if sum i is achievable with some subset
        dp = [False] * (target + 1)
        # sum 0 is always achievable (root/base case)
        dp[0] = True

        for num in nums:
            # Explore choices in reverse to avoid using same number twice
            for i in range(target, num - 1, -1):
                # Build: include num if sum i-num was achievable
                dp[i] = dp[i] or dp[i - num]

        # Result: can we achieve target sum?
        return dp[target]
```


### Solution 2: Bitmask Bitset DP - 1D Dynamic Programming/Subset Sum Linear Choice Selection
```python
    def canPartition(self, nums: List[int]) -> bool:
        
        # Note:
        # Bitmask DP (bitset)
        # 1. Process root -> each number
        # 2. Explore choices -> include or skip number, track sums as bits
        # 3. Build -> shift bits to represent new achievable sums
        # 4. Result -> check if target sum bit is set

        total = sum(nums)
        if total % 2 != 0:
            return False

        target = total // 2

        # bitset where i-th bit = True if sum i achievable
        bits = 1  # only 0 sum is achievable initially

        for num in nums:
            # Build: shift current bits by num to represent including it
            bits |= bits << num

        # Result: check if target sum is achievable
        return (bits >> target) & 1 == 1
```