---
title: "1D Dynamic Programming"
description: "1D dynamic programming"
image: "../../public/Notes/1d-dynamic-programming.png"
publishedAt: "2025-08-29"
updatedAt: "2025-08-29" 
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---

## 1D Dynamic Programming Intro

LeetCode problems solved with dynamic programming

### What is 1D Dynamic Programming 

Dynamic Programming (DP) is a technique for solving problems that 
can be broken into overlapping sub problems and have optimal 
substructure, meaning the optimal solution can be built from
optimal solutions of sub problems.

Instead of solving the same subproblem repeatedly, DP stores
solutions in a table via memorization or a bottom up array,
to avoid redundant work.

### Memoization: Improving Recursion

Many 1D Dynamic Programming problems naturally arise from recursion.
In climbing stairs problem, a naive recursive solutions explores all paths:

```
dfs(i) = dfs(i+1) + dfs(i+2)
```

While this recursion works logically, it recomputes overlapping sub problems.

1. dfs(i) calls dfs(i+1) and dfs(i+2).
2. dfs(i+1) recomputes dfs(i+2), with its own dfs(i+1) -> dfs(i+1+1)
3. dfs(i+2) is computed twice, as n grows, recursion trees grows to O(2<sup>n</sup>)

Memoization solves this by caching results of sub problems to avoid recomputation.


### Tabulation vs Optimal

Dynamic Programming can also be implemented iteratively via bottom up
by computing solutions from small sub problems to larger ones.

1. Tabulation Full Array

Here we store the solution of ever sub problem in an array dp[].
Each state depends on previous states, and we compute all of them 
sequentially from 0 -> N.
Leads to an array of O(n)

2. Optimal

Often, each state depends on a fixed number of previous states,
usually the last 1 or 2.
Here, we replace the tabulation array with variables, reducing
the space form O(n) to O(1).

### 1D Dynamic Programming IRL
- Finance: Maximize profit in trading tracking best profit up to day if
- Resource Allocation: Task scheduling with constraints (eg, cannot pick consecutive tasks)
- Networking: Optimize packet processing sequences with limited buffers.


### 1D Dynamic Programming Application: DFS with Caching Top Down with Memoization
Pattern: Recursive DFS explores choices, memo stores results to avoid recomputation.
Use When: Natural recursive definition exists (e.g., subsequences, partitioning, path problems).
Recurrence: dfs(state) = combine(dfs(substate1), dfs(substate2), ...)

Ex: Fibonacci (Top Down Memoization)
```python
    def climbStairs(n: int) -> int:
        
        memo = {}

        def dfs(i: int) -> int:
            if i <= 1:
                return i
            if i in memo:
                return memo[i]

            # recursive relation with memoization
            memo[i] = dfs(i-1) + dfs(i-2)
            return memo[i]

        return dfs(n)
```

### 1D Dynamic Programming Application: Iterative Tabulation Bottom Up
Pattern: Iteratively fill a DP array from base case to target.
Use When: Clear order of dependencies, can compute sequentially.
Recurrence: dp[i] = dp[i-1] + dp[i-2] (or problem-specific relation).

Ex: Fibonacci (Bottom Up Tabulation)
```python
    def fib(n: int) -> int:
        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[0], dp[1] = 0, 1

        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
```

### 1D Dynamic Programming Application: Optimal Iterative Variables Bottom Up
Pattern: Reduce DP array to a few variables if each state depends only on recent ones.
Use When: DP only needs O(1) rolling state, no need to keep full history.
Recurrence: curr = prev1 + prev2 → shift forward each step.

Ex: Fibonacci (Optimal Bottom Up)
```python
    def fib(n: int) -> int:
        if n <= 1:
            return n
        prev2, prev1 = 0, 1

        for _ in range(2, n + 1):
            curr = prev1 + prev2
            prev2, prev1 = prev1, curr

        return prev1
```


### 1D Dynamic Programming Application: Sequential State Transition
Pattern: Each state depends on one or two prior states (linear recurrence).
Use When: Counting paths, sequences, or arrangements (Fibonacci, climbing stairs).
Recurrence: dp[i] = dp[i-1] + dp[i-2]

Ex: Climbing Stairs
```python
    def climbStairs(n: int) -> int:
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1

        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
```

### 1D Dynamic Programming Application: Choose or Skip Non Adjacent
Pattern: Decide whether to take or skip the current element.
Use When: Problems disallow consecutive selections (House Robber, Max Non-Adjacent Sum).
Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])

Ex: House Robber
```python
    def rob(nums: list[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        if n == 1: return nums[0]

        dp = [0] * n
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])

        for i in range(2, n):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

        return dp[-1]
```

### 1D Dynamic Programming Application: Circular Choose or Skip Non Adjacent
Pattern: Linear sequence with a circular constraint — first and last elements are considered adjacent. Solve by splitting into two linear subproblems (exclude first or exclude last).
Use When: Problems where selections are from a circular array (e.g., House Robber II, max non-adjacent circular sums).
Recurrence: Apply standard choose-or-skip recurrence on each linear subarray.

Ex: House Robber II 
```python
    def rob(nums: list[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]

        def rob_linear(arr):
            prev2, prev1 = 0, 0
            for num in arr:
                curr = max(prev1, num + prev2)
                prev2, prev1 = prev1, curr
            return prev1

        # Exclude first house OR exclude last house
        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))
```

### 1D Dynamic Programming Application: Min Max Contiguous Segment
Pattern: Track the best contiguous subarray sum (Kadane’s style).
Use When: Maximum sum, minimum sum, or subarray optimization problems.
Recurrence: dp[i] = max(nums[i], dp[i-1] + nums[i])

Ex: Maximum Subarray
```python
    def maxResult(nums: list[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]
        dq = deque([0])

        for i in range(1, n):
            while dq and dq[0] < i - k:
                dq.popleft()
            dp[i] = nums[i] + dp[dq[0]]
            while dq and dp[dq[-1]] <= dp[i]:
                dq.pop()
            dq.append(i)

        return dp[-1]
```

### 1D Dynamic Programming Application: Sliding Window Monotonic Queue
Pattern: Linear scan using a sliding window to track the best state efficiently.
Use When: DP recurrence depends on the best value in a recent window.
Recurrence: dp[i] = nums[i] + max(dp[j] for j in i-k..i-1)

Ex: Jump Game VI
```python
    def maxResult(nums: list[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]

        dq = deque([0])  # indices of "best" dp values

        for i in range(1, n):
            # Remove indices outside the window [i-k, i-1]
            while dq and dq[0] < i - k:
                dq.popleft()
            
            # Current dp depends on best in window
            dp[i] = nums[i] + dp[dq[0]]
            
            # Maintain deque in decreasing order of dp values
            while dq and dp[dq[-1]] <= dp[i]:
                dq.pop()
            dq.append(i)
        
        return dp[-1]
```

### 1D Dynamic Programming Application: Min Max Path Sum in Linear Sequence
Pattern: Track the cumulative minimum or maximum along a sequence.
Use When: Optimize total cost or reward along a linear path.
Recurrence: dp[i] = nums[i] + min/max(dp[i-1], dp[i-2], ...)

Ex: Minimum Cost Climbing Stairs
```python
    def minCostClimbingStairs(cost: list[int]) -> int:
        n = len(cost)
        dp = [0] * n
        dp[0], dp[1] = cost[0], cost[1]

        for i in range(2, n):
            dp[i] = cost[i] + min(dp[i-1], dp[i-2])

        return min(dp[-1], dp[-2])
```

### 1D Dynamic Programming Application: Bitmask Subset Linear
Pattern: Encode chosen elements as a bitmask for linear sequences of small size (n ≤ 20-25).
Use When: Problems involve selecting subsets or combinations with constraints.
Recurrence: dp[mask] = max(dp[mask ^ (1 < < i)] + nums[i])

Ex: Max Subset Sum with No Adjacent Selected
```python
    def maxSubsetSum(nums: list[int]) -> int:
        n = len(nums)
        dp = [0] * (1 << n)

        for mask in range(1, 1 << n):
            for i in range(n):
                if mask & (1 << i):
                    if i == 0 or not (mask & (1 << (i-1))):
                        dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + nums[i])

        return max(dp)
```

### 1D Dynamic Programming Application: Prefix Sum
Pattern: Use cumulative sums to speed up range-dependent DP.
Use When: DP depends on sums of ranges in a 1D array.
Recurrence: dp[i] = max(dp[j] + prefix[i] - prefix[j])

Ex: Maximum Subarray Sum with Length Constraint
```python
def maxSubarrayLenK(nums: list[int], k: int) -> int:
    n = len(nums)
    prefix = [0] * (n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + nums[i]

    dp = [0] * (n+1)
    for i in range(1, n+1):
        if i >= k:
            dp[i] = max(dp[i-1], prefix[i] - prefix[i-k])
        else:
            dp[i] = dp[i-1]

    return dp[n]
```

### 1D Dynamic Programming Application: Linear Decision with Multiple States
Pattern: Track multiple states per index when multiple choices exist (take/skip, hold/sell, etc.)
Use When: Problems have several options per position with state transitions.
Recurrence: dp[i][state] = max/min(choice1, choice2, ...)

Ex: Best Time to Buy/Sell Stock with Cooldown
```python
    def maxProfit(prices: list[int]) -> int:
        n = len(prices)
        if n == 0: return 0

        hold, sold, rest = -prices[0], 0, 0

        for i in range(1, n):
            prev_sold = sold
            sold = hold + prices[i]
            hold = max(hold, rest - prices[i])
            rest = max(rest, prev_sold)

        return max(sold, rest)
```

### 1D Dynamic Programming Application: Linear Property Tracking
Pattern: Track whether a property holds for each position in a sequence (true/false, max/min, count, etc.) using prior information.
Use When: You need to know if a subarray or subsequence satisfies a property at each index (palindrome, valid sum, valid jump, etc.).
Recurrence: dp[i] = f(dp[prev_indices], sequence[i])

Ex: Longest Palindromic Substring (DP Table)
```python
    def longestPalindrome(s: str) -> str:
        n = len(s)
        dp = [[False]*n for _ in range(n)]
        start, max_len = 0, 1

        for i in range(n):
            dp[i][i] = True

        for length in range(2, n+1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i+1][j-1]:
                        dp[i][j] = True
                        if length > max_len:
                            start, max_len = i, length

        return s[start:start+max_len]
```

### 1D Dynamic Programming Application: Min Max with Choices (Unbounded Knapsack style)
Pattern: Track the optimal value (minimum or maximum) for a linear state where each state can consider multiple choices repeatedly.
Use When: Problems involve selecting from a set of options multiple times to optimize a total, e.g., minimum coins, maximum value, maximum sum.
Recurrence: dp[i] = min/max(dp[i - choice] + value_of_choice for choice in choices if i - choice >= 0)

Ex: Coin Change (Minimum Coins)
```python
    def coinChange(coins: list[int], amount: int) -> int:
        max_val = amount + 1
        dp = [max_val] * (amount + 1)
        dp[0] = 0

        for a in range(1, amount + 1):
            for coin in coins:
                if a - coin >= 0:
                    dp[a] = min(dp[a], dp[a - coin] + 1)

        return dp[amount] if dp[amount] != max_val else -1
```

### 1D Dynamic Programming Application: Track Multiple States per Index (Max Min Tracking)
Pattern: Maintain multiple states per position when a single state cannot capture all possibilities. For example, track both maximum and minimum values at each step because future states depend on both.
Use When: Problems involve sequences where each element can affect multiple outcomes depending on prior states, such as max/min product subarray, stock problems with multiple options, or sequences with sign changes.
Recurrence:
max[i] = max(nums[i], max[i-1]*nums[i], min[i-1]*nums[i])
min[i] = min(nums[i], max[i-1]*nums[i], min[i-1]*nums[i])

Ex: Maximum Product Subarray
```python
    def maxProduct(nums: list[int]) -> int:
        n = len(nums)
        if n == 0: return 0

        max_prod = min_prod = result = nums[0]

        for i in range(1, n):
            num = nums[i]
            temp_max = max(num, max_prod * num, min_prod * num)
            min_prod = min(num, max_prod * num, min_prod * num)
            max_prod = temp_max
            result = max(result, max_prod)

        return result
```


### 1D Dynamic Programming Application: Sequential Segment Choice Validation
Pattern: Determine if a linear sequence can be segmented or satisfies a condition by checking all possible prior segments or choices.
Use When: Problems involve checking if a prefix/subsequence is valid based on previous valid segments (Word Break, Jump Game reachability, sequence segmentation).
Recurrence: dp[i] = any(dp[j] and valid_segment(j, i) for j in 0..i-1)

Ex: Word Break
```python
    def wordBreak(s: str, wordDict: list[str]) -> bool:
        word_set = set(wordDict)
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True  # empty string is segmentable

        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break  # early prune, found valid segmentation

        return dp[n]

```


### 1D Dynamic Programming Application: Subsequence Optimization Constrained
Pattern: Track the best subsequence ending at each index, respecting a relational/order constraint between elements.
Use When: Problems involve subsequences (not necessarily contiguous) where selected elements must satisfy a specific order or relational condition.
Recurrence: dp[i] = best(dp[j] + contribution[i]) for all j < i satisfying relation(nums[j], nums[i])

Ex: Longest Increasing Subsequence
```python
    def lengthOfLIS(nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0

        dp = [1] * n  # dp[i] = length of LIS ending at i
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

### 1D Dynamic Programming Application: Subset Sum Linear Choice Selection
Pattern: Track achievable sums or states when choosing elements sequentially, often under a “pick or skip” or additive constraint.
Use When: Problems involve deciding which elements to include/exclude to satisfy a global condition (subset sum, partitioning, knapsack with 0/1 choices, bitmask DP, etc.).
Recurrence Template: dp[i] = combine(dp[i], dp[i - contribution[j]])   # update achievable state

Ex: Partition Equal Subset Sum
```python
    def canPartition(nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0:
            return False
        target = total // 2
        dp = [False] * (target + 1)
        dp[0] = True
        for num in nums:
            for i in range(target, num - 1, -1):
                dp[i] = dp[i] or dp[i - num]
        return dp[target]
```



## 70. Climbing Stairs ::4:: - Easy

Topics:  Math, Dynamic Programming, Memoization

### Intro
> You are climbing a staircase. It takes n steps to reach   
> the top.
> Each time you can either climb 1 or 2 steps. In how 
> many distinct ways can you climb to the top?


|  Example Input           | Output |  
| ---------------- | ------ | 
| n = 2 | 2 |
| n = 3 | 3 |

Constraints:

1 &leq; n &leq; 45

### Abstraction
Given a number of steps, return the number of unique ways to reach the top,
by either climbing 1 or 2 steps at a time.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: i to N Recursive with Memoization Top Down - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:

        # Note:
        # Top Down DP (memoized recursion)
        # 1. Memo Check -> computed previously
        # 2. Boundary Check -> reached n or overshot
        # 3. Explore Choices -> grab num of ways from +1 or +2 to n
        # 4. Build -> sum paths from +1 and +2 steps to current step
        # 5. Memo Return -> return ways from i to nth step, calculated once
        # Result: Ways to climb from 0 to nth step

        # Ways to get climb from i to nth
        memo = {}

        def dfs(i):

            # Memoized check
            if i in memo:
                return memo[i]
            
            # Boundary Check -> overshot, 0 ways to reach out of bounds
            if i > n:
                return 0

            # Boundary Check -> reached nth, 1 way to reach n from n-1
            if i == n:
                return 1
            
            # Explore Choices -> grab num of ways from +1 or +2 to n
            left = dfs(i + 1)
            right = dfs(i + 2)

            # Build: sum paths from +1 and +2 steps to current step
            memo[i] = left + right

            # Memo return: return ways from i to nth step, calculated once
            return memo[i]

        # ways to get from 0 to nth step
        res = dfs(0)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: 0 to i Recursive with Memoization Top Down - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:

        # Note:
        # Top Down DP (memoized recursion)
        # Start from target n and recursively reduce to smaller sub problems.
        # 1. Memo Check -> computed previously
        # 2. Boundary Check -> base case 1 and 2
        # 3. Explore Choices ->  grab num of ways from 0 to -2 or -1 steps
        # 4. Build -> sum paths from -2 and -1 steps to current step
        # 5. Memo return -> return ways from 0 to ith step, calculated once
        # Result: Ways to climb from 0 to nth step

        # Ways to climb from 0 to ith step
        memo = {}

        def dfs(i):

            # Memo Check -> computed previously
            if i in memo:
                return memo[i]
            
            # Boundary Check -> bottom, 1 way to reach step 1
            if i == 1:
                return 1

            # Boundary Check -> bottom, 2 ways to reach step 2
            if i == 2:
                return 2

            # Explore Choices -> grab num of ways from 0 to -2 or -1 steps
            left = dfs(i - 1)
            right = dfs(i - 2)

            # Build: sum paths from -2 and -1 steps to current step
            memo[i] = left + right

            # Memo return -> return ways from 0 to ith step, calculated once
            return memo[i]

        # ways to climb from 0 to nth step
        res = dfs(n)

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```

### Solution 3: Iterative Bottom Up Array - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:
        
        # Note:
        # Iterative Bottom Up Tabulation
        # 1. Catch Initialize -> cover n=1 case
        # 2. Base Set Up -> 1 and 2
        # 3. Iterate -> 3 to n
        # 4. Explore -> grab num of ways from 0 to -2 or -1 steps
        # 5. Build -> sum paths from -2 and -1 steps to current step
        # Result: ways to climb to nth step

        # Catch Initialize -> for n=1 assign n=2 will fail
        if n == 1:
            return 1

        # Initialize dp array (n is indexed 1)
        dp = [0] * (n + 1)

        # Base Set Up -> 1 and 2 
        dp[1] = 1
        dp[2] = 2

        # Process -> 3 to nth
        for i in range(3, n + 1):

            # Explore Choices -> grab num of ways from 0 to -2 or -1 steps
            left = dp[i-2]
            right = dp[i-1]

            # Build -> sum paths from -2 and -1 steps to current step
            dp[i] = left + right

        # ways to climb to nth step
        res = dp[n]

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```

### Solution 4: Iterative Bottom Up Variables - 1D Dynamic Programming/Sequential State Transition
```python
    def climbStairs(self, n: int) -> int:
        
        # Note:
        # Iterative Bottom Up Variables
        # 1. Catch Initialize -> cover n=1 case
        # 2. Base Set Up -> 1 and 2
        # 3. Iterate -> 3 to n
        # 4. Explore + Build -> grab num of ways from 0 to -2 or -1 steps, sum to current
        # 5. Slide Window -> iterate variables
        # Result: ways to climb to nth step

        # Catch Initialize -> for n=1 assign n=2 will fail
        if n == 1:
            return 1

        # Base Set Up -> 1 and 2 
        TwoPrev = 1
        OnePrev = 2

        # Process -> 3 to nth
        for i in range(3, n + 1):

            # Explore + Build -> grab num of ways from 0 to -2 or -1 steps, sum to current
            curr = TwoPrev + OnePrev

            # Slide Window -> iterate variables
            TwoPrev, OnePrev = OnePrev, curr
        
        # ways to climb to nth step
        res = OnePrev

        # overall: time complexity
        # overall: space complexity
        return res
```


## 746. Min Cost Climbing Stairs ::3:: - Easy

Topics:  Array, Dynamic Programming

### Intro
> You are given an integer array cost where cost[i] is 
> the cost of ith step on a staircase. Once you pay the 
> cost, you can either climb one or two steps.
> You can either start from the step with index 0, or the 
> step with index 1.
> Return the minimum cost to reach the top of the floor.


|  Example Input           | Output |  
| ---------------- | ------ | 
| cost = [10,15,20] | 15 |
| [1,100,1,1,1,100,1,1,100,1] | 6 |

Constraints:

2 &leq; cost.length &leq; 1000

0 &leq; cost[i] &leq; 999

### Abstraction
Given a number of steps, and the cost to process a step,
find the cheapest cost to climb to the top.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Top Down DP (recursive with memoization)
        # 1. Memo Check -> avoid recomputation
        # 2. Boundary Check -> reached or passed top
        # 3. Explore Choices -> jump 1 or 2 steps
        # 4. Build -> add cost at current step + min of next steps
        # Result: min cost to reach top step from step 0 or 1
        
        n = len(cost)

        # store min cost from step i to top
        memo = {}

        def dfs(i):

            # Memoized check
            if i in memo:
                return memo[i]

            # Boundary Check -> reached/passed tpo, 0 additional cost
            if i >= n:
                return 0
            
            # Explore choices -> jump to next 1 or 2 steps
            left = dfs(i+1)
            right = dfs(i+2)

            # Build: cost at current step + min cost between either next steps
            memo[i] = cost[i] + min(left, right)

            # Memo Return: computed value for current step, calculated once
            return memo[i]

        # initial call: can start from step 0 or 1
        res = min(dfs(0), dfs(1))

        # overall: time complexity O(n)
        # overall: space complexity O(n) memo + recursive stack
        return res
```

### Solution 2: Iterative Bottom Up Array - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Bottom Up Tabulation
        # 1. Process root -> initialize base costs dp[0], dp[1]
        # 2. Explore choices -> dp[i] = cost[i] + min(dp[i-1], dp[i-2])
        # 3. Build -> fill dp array sequentially
        # Result: min cost to reach top from step 0 or 1

        n = len(cost)
        dp = [0] * n

        # Base Set Up -> 0 and 1
        dp[0], dp[1] = cost[0], cost[1]

        # Process -> steps 2 to n-1
        for i in range(2, n):

            # Explore Choices -> previous 2 steps
            left = dp[i-2]
            right = dp[i-1]

            # Build -> cost for current step
            dp[i] = cost[i] + min(left, right)

        # Build -> cost for nth
        res1, res2 = dp[n-1], dp[n-2]
        res = min(res1, res2)

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```

### Solution 3: Iterative Bottom Up Variables - 1D Dynamic Programming/Min Max Path Sum in Linear Sequence
```python
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # Note:
        # Bottom Up Variables
        # 1. Base Set Up -> prev2, prev1
        # 2. Explore 2 to n-1 -> compute current step cost
        # 3. Slide window -> update prev2, prev1
        # Result: min cost to reach top from step 0 or 1

        n = len(cost)

        # Base Set Up -> 0 and 1
        prev2, prev1 = cost[0], cost[1]

        # Process -> 2 to n-1
        for i in range(2, n):
            
            # Explore + Build -> cost at current step + min cost from previous 2
            curr = cost[i] + min(prev1, prev2)

            # Slide Window- > move variables forward
            prev2, prev1 = prev1, curr

        # Result -> min cost to reach top
        res = min(prev1, prev2)

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return res
```

## 198. House Robber ::3:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> You are a professional robber planning to rob houses 
> along a street. Each house has a certain amount of 
> money stashed, the only constraint stopping you from 
> robbing each of them is that adjacent houses have 
> security systems connected and it will automatically 
> contact the police if two adjacent houses were 
> broken into on the same night.
> Given an integer array nums representing the amount 
> of money of each house, return the maximum amount 
> of money you can rob tonight without alerting the police.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,2,3,1] | 4 |
| nums = [2,7,9,3,1] | 12 |

Constraints:

1 &leq; nums.length &leq; 100

0 &leq; nums[i] &leq; 400

### Abstraction
Given an array of cash, determine the max you can steal when you
cannot steal from two adjacent entries.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Top down recursive with memoization
        # 1. Memo Check -> avoid recomputation
        # 2. Boundary Checks -> no houses left i < 0
        # 3. Explore Choices -> rob current house or skip it
        # 4. Build -> max of robbing current + dfs(i-2) vs skipping dfs(i-1)
        # Result: max loop from first to last house

        # store max loot from house start to ith house
        memo = {}

        def dfs(i):

            # Memo Check ->
            if i in memo:
                return memo[i]

            # Boundary Check -> no houses left
            if i < 0:
                return 0
            
            # Explore Choices -> Rob current, skip neighbor: nums[i] + dfs(i-2)
            right = nums[i] + dfs(i-2)

            # Explore Choices -> Skip current house dfs(i-1)
            left = dfs(i-1)

            # Build -> choose max between rob and skip
            memo[i] = max(left, right)

            # Memo return -> return max loot from 0 to ith, computed once
            return memo[i]

        # initial call for last house
        res = dfs(len(nums)-1)

        # overall: time complexity O(n)
        # overall: space complexity O(n) (memo + recursion stack)
        return res
```

### Solution 2: Iterative DP Bottom Up - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Bottom Up Tabulation
        # 1. Base Set Up -> 0 and 1
        # 2. Explore -> 2 to n-1
        # 2. Explore choices -> dp[i] = max(dp[i-1], nums[i] + dp[i-2])
        # 3. Build -> fill dp array sequentially
        # Result: max loot from first to last house

        n = len(nums)

        # Catch Initialize: for n=1 assign n=2 will fail
        if n == 1:
            return nums[0]

        dp = [0] * n

        # Base Set Up -> 0 and 1
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])

        # Process -> houses 2 to n-1
        for i in range(2, n):

            # Explore Choices -> rob current house or skip
            left = nums[i] + dp[i-2]
            right = dp[i-1]

            # Build -> choose max between rob or skip
            dp[i] = max(left + right)

        # Result -> max loot at last house
        res = dp[-1]

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```

### Solution 3: Space Optimized DP - 1D Dynamic Programming/Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Bottom Up Variables
        # 1. Base Set Up -> prev2, prev1
        # 2. Explore 2 to n-1-> compute current max loot
        # 3. Slide window -> update prev2, prev1
        # Result: max loot first to last house

        n = len(nums)

        # Catch Initialize: for n=1 assign n=2 will fail
        if n == 1:
            return nums[0]

        # Base Set Up -> 0 and 1
        prev2, prev1 = nums[0], max(nums[0], nums[1])

        # Process -> houses 2 to n-1
        for i in range(2, n):

            # Explore + Build -> max between rob and skip
            curr = max(prev1, nums[i] + prev2)

            # Slide Window -> update variables
            prev2, prev1 = prev1, curr

        # Result -> max loot at last house
        res = prev1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return res
```


## 213. House Robber II ::3:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> You are a professional robber planning to rob houses 
> along a street. Each house has a certain amount of 
> money stashed. All houses at this place are arranged 
> in a circle. That means the first house is the neighbor 
> of the last one. Meanwhile, adjacent houses have a 
> security system connected, and it will automatically 
> contact the police if two adjacent houses were 
> broken into on the same night.
> Given an integer array nums representing the amount 
> of money of each house, return the maximum amount 
> of money you can rob tonight without alerting the police.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = nums = [2,3,2] | 3 |
| nums = [1,2,3,1] | 4 |
| nums = [1,2,3] | 3 |

Constraints:

1 &leq; nums.length &leq; 100

0 &leq; nums[i] &leq; 1000

### Abstraction
Given an array of cash, determine the max you can steal when you
cannot steal from two adjacent entries, when array is circular.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Recursive with Explicit Memoization Top Down - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Top down recursive with memoization
        # 1. Memo Check -> avoid recomputation
        # 2. Boundary Check -> i < start
        # 3. Explore Choices -> rob or skip
        # 4. Build -> max between robbing current + dfs(i-2) vs skipping dfs(i-1)
        # 5. Handle circular constraint -> cannot rob both first and last
        # Result: max loot for circular house array

        n = len(nums)

        # Base case check
        if n == 1:
            return nums[0]

        # Workaround circular constrain by robbing houses start -> end
        def rob_range(start, end):

            # build max loot from start to end
            memo = {}

            def dfs(i):

                # Memo check ->
                if i in memo:
                    return memo[i]

                # Boundary Check -> no houses left
                if i < start:
                    return 0

                # Explore Choices -> 1. rob current
                left = nums[i] + dfs(i-2)

                # Explore Choices -> 2. skip
                right = dfs(i-1)

                # Build -> max between rob and skip
                memo[i] = max(left, right)

                # Memo return -> return max loot at ith, calculated once
                return memo[i]

            # Initial call for last house within range start -> end
            return dfs(end)

        # Avoid circular constraint
        # Rob houses from 'first' -> 'second to last', then 'second' -> 'last'
        res1 = rob_range(0, n-2)
        res2 = rob_range(1, n-1)

        # Result -> Max loot from both ranges
        res = max(res1, res2)

        # overall: time complexity O(n)
        # overall: space complexity O(n) (memo + recursion stack)
        return res
```

### Solution 2: Iterative Bottom Up Stack - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:
        
        # Note:
        # Bottom up array
        # 1. Memo Check root -> compute linear DP for given subarray
        # 2. Boundary Check -> handle single house cases
        # 2. Explore choices -> max between rob current or skip
        # 3. Build -> max from start to ith
        # 4. Handle circular constraint -> 2 subsets to break circular array
        # Result: max loot from circular houses array

        n = len(nums)

        # Empty check:
        if n == 1:
            return nums[0]

        # Break Circular Array: find max loot from start -> endth house 
        def rob_range(start, end):

            # number of houses in subarray
            numHouses = end - start + 1

            # Empty check:
            if numHouses == 1:
                return nums[start]

            # Init array (houses 0 indexed)
            dp = [0] * numHouses

            # Base Set Up -> 0 and 1
            dp[0] = nums[start]
            dp[1] = max(nums[start], nums[start + 1])

            # Process from 2 to numHouses-1
            for i in range(2, numHouses):

                # Explore Choices -> 1. rob current
                left = nums[i + start] + dp[i-2]

                # Explore Choices -> 2. skip
                right = dp[i-1]

                # Build -> max between rob and skip
                dp[i] = max(left, right)

            # Memo return -> return max loot at ith, calculated once
            return dp[end]

        # Avoid circular constraint
        # Rob houses from 'first' -> 'second to last', then 'second' -> 'last'
        res1 = rob_range(0, n-2)
        res2 = rob_range(1, n-1)

        res = max(res1, res2)

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return res
```

### Solution 3: Iterative Bottom Up Variables - 1D Dynamic Programming/Circular Choose or Skip Non Adjacent
```python
    def rob(self, nums: List[int]) -> int:

        # Note:
        # Bottom up variables
        # 1. Memo Check -> 
        # 2. Explore Choices -> rob current or skip
        # 3. Build -> only previous two variables needed
        # 4. Handle Circular Constraint -> two subarray
        # Result: max loot from circular houses array
        
        n = len(nums)
        if n == 1:
            return nums[0]

        # max loot from subarray start -> en
        def rob_range(start, end):

            # Number of houses in subarray
            numHouses = end - start + 1

            # Edge case: single house
            if numHouses == 1:
                return nums[start]

            # Base setup -> first two houses
            prev2 = nums[start]
            prev1 = max(nums[start], nums[start + 1])

            # Process houses 2 to numHouses-1
            for i in range(2, numHouses):

                # Explore + Build -> max loot at ith house
                curr = max(prev1, nums[start + i] + prev2)

                # Slide window -> update previous two
                prev2, prev1 = prev1, curr

            # Memo return -> last variable holds max loot
            return prev1

        # Avoid circular constraint: exclude last house, exclude first house
        res1 = rob_range(0, n-2)
        res2 = rob_range(1, n-1)

        # Max loot from either permutation
        res = max(res1, res2)

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return res
```

## 5. Longest Palindromic Substring ::3:: - Medium

Topics: Two Pointers, String, Dynamic Programming

### Intro
> Given a string s, return the longest palindromic substring in s. 

|  Input | Output  |  
| ------- | ------- | 
| "cbbd"  | "bb"           |
| "babad" | "bab" or "aba" |


Constraints: 

1  &leq; s.length &leq; 1000 

s consists of only digits and English letters.

### Abstraction 

Find the longest palindrome in a string.

### Find the Bug: Did not create Expanded String
```python
    def longestPalindrome(self, s: str) -> str:
        
        # INCORRECT:
        # did not create expandedStr
        # did not solve odd vs even palindrome problem
        # missing:
        # expandedStr = "#".join(f"^{s}$")
        
        center = 0
        right = 0
        n = len(s)
        p = [0] * n

        for i in range(1, n-1):
            
            # 1 
            mirror = (2*center) - i

            # 2 
            if i < right:
                p[i] = min(right-i, p[mirror])

            # 3
            while s[i + p[i] + 1] == s[i - p[i] - 1]:
                p[i] += 1

            # 4
            if i + p[i] > right:
                center = i
                right = i + p[i]
        
        (maxRadius, center) = max((maxRadius, i) for (i, maxRadius) in enumerate(p))
        start = (center-maxRadius) // 2 

        return s[start:start+maxRadius]
```

### Find the Bug: Defined List instead of Slicing
```python
    def longestPalindrome(self, s: str) -> str:
        
        def expandAroundCenter(left, right):
            while left >= 0 and right < n and s[left] == s[right]:
                left -= 1
                right += 1

            # INCORRECT:
            # defined list instead of slicing
            # should be: s[left+1:right]
            return s[left+1, right]
        
        n = len(s)
        maxPalin = ""

        for i in range(n):
            oddPalin = expandAroundCenter(i, i)
            evenPalin = expandAroundCenter(i, i+1)

            if len(oddPalin) > len(maxPalin):
                maxPalin = oddPalin
            if len(evenPalin) > len(maxPalin):
                maxPalin = evenPalin
                
        return maxPalin
```

### Find the Bug: Bad iteration leading to out of bounds on string expansion
```python
    def longestPalindrome(self, s: str) -> str:
        
        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)
        p = [0] * n
        center = 0
        right = 0

        # INCORRECT:
        # iteration will also expand from the sentinals '^' and '$'
        for i in range(n):

            # grab mirror
            mirror = (2*center)-i

            # validate mirror
            if i < right:
                p[i] = min(p[mirror], (right-i))

            # expand
            # INCORRECT:
            # due to iteration, expansion is not guaranteed and prevent
            # out of bounds grab, since we are missing the eventual
            # '^' != '$'
            while expandedStr[i - p[i] - 1] == expandedStr[i + p[i] + 1]:
                p[i] += 1

            # find new right most
            if p[i] + i > right:
                center = i
                right = p[i] + i

        # translate back to height
        maxRadi, center = max((maxRadi, center) for (center, maxRadi) in enumerate(p))

        startIndex = (center-maxRadi)//2


        return s[startIndex:startIndex+maxRadi]
```

### Find the Bug: Bad enumerate method:
```python
    def longestPalindrome(self, s: str) -> str:
        
        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)
        p = [0] * n
        center = 0
        right = 0

        for i in range(1, n-1):

            # grab mirror
            mirror = (2*center)-i

            # validate mirror
            if i < right:
                p[i] = min(p[mirror], (right-i))

            # expand
            while expandedStr[i - p[i] - 1] == expandedStr[i + p[i] + 1]:
                p[i] += 1

            # find new right most
            if p[i] + i > right:
                center = i
                right = p[i] + i

        # translate back to height
        # INCORRECT:
        # should be 
        # enumerate(p)
        # instead of p.enumerate()
        maxRadi, center = max((maxRadi, center) for (center, maxRadi) in p.enumerate())

        startIndex = (center-maxRadi)//2


        return s[startIndex:startIndex+maxRadi]
```

### Solution 1: Manacher's Algorithm (iterate, mirror radius optimization, and expand) - Two Pointers/Algorithm
```python
    def longestPalindrome(self, s: str) -> str:

        # Note: 
        # Preprocessing with #, ^, and $:
        # '#': ensures uniform expansion, for both odd and even length palindromes
        # '^' and '$': sentinel characters don't match valid input characters, serve as true start and end markers
        # '#': ensures all palindromes start and end with '#'
        # '#': occur on odd indexes

        # Mapping:
        # we can map odd '#' indexes to their even character:
        # mapping '#' at index 1 to char pair 'a' at index 2, to original 'a' at index 0
        # [ ^ # a # b # a # $ ] -> [ a b a ]    via : originalStart = (expandedCenter - radius) / 2
        #   0 1 2 3 4 5 6 7 8        0 1 2      thus: originalStart = (4 - 3) / 2 = 0
        
        # Boundary expansion: 
        # For any index i, center of palindrome at i can either be: 
        # - character from the original string
        # - placeholder '#'
        # Center definition allows even length palindromes such as "abba", see below,
        # to have a single middle point, allowing the same expanding logic 
        # for even and odd strings for palindrome validation

        # Ex:
        # ^ # a # b # b # a # $    || new string len 11,
        # 0 1 2 3 4 5 6 7 8 9 10   ||
        #           ^              || index 5 center for even length "abba"

        # index 1 palindrome: "#"
        # index 2 palindrome: "#a#"
        # index 5 palindrome: "#a#b#b#a#"
        # etc...

        expandedStr = "#".join(f"^{s}$")
        n = len(expandedStr)

        # Right Most Palindrome and Mirror Trick: 
        # Iteration tracks the right boundary for the current farthest right palindromic substring, 
        # which allows us to take advantage of the mirror radius trick.
        # It speeds up palindrome expansion by starting the current palindrome radius
        # at the radius value of its mirror

        # p[i]: radius of palindrome centered at some index i
        p = [0] * n

        # mirror radius validation: tracking right boundary
        # right: right boundary of the current right most palindrome
        right = 0

        # mirror radius validation: tracking center of right most in order to calculate mirror index
        # center: center index of the current right most palindrome
        center = 0 

        # iteration range ignores sentinel indexes 0 and (n-1): ^ and $
        # i: center of current palindrome
        # time complexity: iterate over list of n length O(n)
        for i in range(1, n - 1):

            # mirror:
            # i is current index being processed
            # i is to the right of center and has a mirror to the left of center
            # ex: center = 6, i = 7 => mirror = (2 * 6) - 7 = 5
            mirror = (2 * center) - i 

            # mirror radius validation:
            # if i lies within bounds of the right most palindrome,
            # the right most palindrome symmetry guarantees that the palindrome radius
            # for the mirror of i, is applicable to i as well,
            # while within the bounds of the right most palindrome
            if i < right:

                # mirror radius is either:
                # - less than the distance between i and right bound,
                #   in which case all of the radius is valid
                # - exceeds bounds and is farther than right bound,
                #   in which case only the radius up until the right bound is valid
                
                # i radius is thus, bounded by minimum between: 
                # - mirror radius
                # - distance from i to the right bound
                p[i] = min(right - i, p[mirror])

            # assumption: if valid mirror, we pre-set p[i] to p[mirror]
            # now expand: expand radius p[i] until palindromic status is broken
            while expandedStr[i + p[i] + 1] == expandedStr[i - p[i] - 1]:
                p[i] += 1

            # p[i]: radius for palindrome at i
            # i: center for palindrome at i
            # check: if we have a new right most boundary, update center and right 
            if i + p[i] > right:
                right = i + p[i]
                center = i

        # expandedStr iteration complete:
        # p[] stores radius of palindrome centered at each index

        # scan p[] grabbing max palindrome radius alongside its center
        maxRadius, centerIndex = max((palindromeRadius, i) for (i, palindromeRadius) in enumerate(p))

        # Note:
        # index and radius are relative to expandedStr, not the original string
        # thus, we need to translate to original string indexes

        # Notice, how in the expanded string, 
        #  - all original characters are on even index
        #  - all original characters have matching # on the left odd index

        # abba =>  ^ # a # b # b # a # $   | a=2, b=4, b=6, a=8
        # 0123 =>  0 1 2 3 4 5 6 7 8 9 10  | #=1, #=3, #=5, #=7

        # aba =>   ^ # a # b # a # $       | a=2, b=4, a=6
        # 012 =>   0 1 2 3 4 5 6 7 8       | #=1, #=3, #=5

        # any palindrome will always end with a '#'.
        # so if we divide the starting odd position by 2, it will always map
        # to an original character.
        # so an easy translation formula is:

        start = (centerIndex - maxRadius) // 2
        
        # splice longest substring

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return s[start: start + maxRadius]
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Preprocessing | O(n) | O(n) | Building expanded string | Memory allocation for processed string O(n) |
| Iterating | O(n) | O(1) | Iterate over processed string of n length O(n) | No additional memory allocation for iteration O(1) |
| Expanding radii | O(n) | O(n) | Radius expansion over processed string of n length O(n) | Radius array to store radii for each index for string of n length O(n) |
| Updating mirror bounds | O(1) | O(1) | Updating center and right for right most palindrome in constant O(1) | No additional memory allocation for center and right variables O(1) |
| Overall | O(n) | O(n) | Iterating over expanded string dominates, leading to O(n) time complexity. | Expanding string dominates, leading to O(n) space complexity. |


### Solution 2: Expand Around Center checking for Odd and Even palindromes (constant space) - Two Pointers/Algorithm
```python
    def longestPalindrome(self, s: str) -> str:

        # expand from a given left and right while 
        # maintaining palindrome property
        def expandAroundCenter(left, right):
            while left >= 0 and right < n and s[left] == s[right]:
                left -= 1
                right += 1

            # curr iteration is not valid:
            # ignore left: incrementing index
            # ignore right: noninclusive right slicing
            return s[left+1:right] 
         
        n = len(s)
        maxPalindrome = ""

        # time complexity: iterate over list of n length O(n)
        for i in range(n):
            # odd expansion, centered at i
            oddPalindrome = expandAroundCenter(i, i)      
            # even expansion, centered at i and i + 1
            evenPalindrome = expandAroundCenter(i, i+1)

            # update longest
            if len(oddPalindrome) > len(maxPalindrome):
                maxPalindrome = oddPalindrome
            if len(evenPalindrome) > len(maxPalindrome):
                maxPalindrome = evenPalindrome

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return maxPalindrome
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterating | O(n) | O(1) | Iterating over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Odd expansion | O(n^2) | O(1) | For each center, expands outward for odd length palindromes n length O(n), for each outer iteration O(n), leading to O(n^2) | No additional memory allocation needed during expansion O(1) |
| Even expansion | O(n^2) | O(1) | For each center, expands outward for even length palindromes n length O(n), for each outer iteration O(n), leading to O(n^2) | No additional memory allocation needed during expansion O(1) |
| Updating longest | O(1) | O(1) | Comparing odd and even length palindrome to current max in constant O(1) | No additional memory allocation needed for comparison to current max O(1) |
| Overall | O(n^2) | O(1) | Even and odd expansion per outer iteration dominate, leading to O(n<sup>2</sup>) | No additional memory allocation required for in place expansion or iteration, leading to constant O(1) |


### Solution 3: Dynamic Programming - 1D Dynamic Programming/Linear Property Tracking
```python
        def longestPalindrome(self, s: str) -> str:
        
        n = len(s)
        dp = [[False]*n for _ in range(n)]
        start, max_len = 0, 1

        for i in range(n):
            dp[i][i] = True

        for length in range(2, n+1):  # substring length
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i+1][j-1]:
                        dp[i][j] = True
                        if length > max_len:
                            start, max_len = i, length

        return s[start:start+max_len]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |



## 647. Palindromic Substrings ::2:: - Medium

Topics:  Two Pointers, String, Dynamic Programming

### Intro
> Given a string s, return the number of palindromic 
> substrings in it.
> A string is a palindrome when it reads the same 
> backward as forward.
> A substring is a contiguous sequence of characters 
> within the string.


|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "abc" | 3 |
| s = "aaa" | 6 |

Constraints:

1 &leq; s.length &leq; 1000

s consists of lowercase English letters.

### Abstraction
Given a string, determine how many palindromic substrings exist.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Two Pointers Expand Around Center - 1D Dynamic Programming/Linear Property Tracking
```python
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        count = 0

        # helper: expand from center
        def expand(l: int, r: int) -> int:
            local_count = 0
            while l >= 0 and r < n and s[l] == s[r]:
                local_count += 1   # found a palindrome
                l -= 1
                r += 1
            return local_count

        # expand around all possible centers
        for i in range(n):
            count += expand(i, i)     # odd-length palindromes
            count += expand(i, i + 1) # even-length palindromes

        return count
```

### Solution 2: Dynamic Programming - 1D Dynamic Programming/Linear Property Tracking
```python
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        count = 0

        # single characters
        for i in range(n):
            dp[i][i] = True
            count += 1

        # substring lengths 2 -> n
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    if length == 2 or dp[i + 1][j - 1]:
                        dp[i][j] = True
                        count += 1

        return count
```


## 91. Decode Ways ::2:: - Medium

Topics:  String, Dynamic Programming

### Intro
> You have intercepted a secret message encoded as a 
> string of numbers. The message is decoded via the 
> following mapping:
> "1" -> 'A'
> "2" -> 'B'
> ...
> "25" -> 'Y'
> "26" -> 'Z'
> However, while decoding the message, you realize that 
> there are many different ways you can decode the 
> message because some codes are contained in other
> codes ("2" and "5" vs "25").
> For example, "11106" can be decoded into:
> "AAJF" with the grouping (1, 1, 10, 6)
> "KJF" with the grouping (11, 10, 6)
> The grouping (1, 11, 06) is invalid because 
> "06" is not a valid code (only "6" is valid).
> Note: there may be strings that are impossible to decode.
> Given a string s containing only digits, return the 
> number of ways to decode it. If the entire string 
> cannot be decoded in any valid way, return 0.
> The test cases are generated so that the answer fits in
> a 32-bit integer.


|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "12" | 2 |
| s = "226" | 3 |
| s = "06" | 0 |

Constraints:

1 &leq; s.length &leq; 100

s contains only digits and may contain leading zero(s).

### Abstraction
Given a string, determine how many ways there to decode the string.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```
### Solution 1: Recursive with Memoization Top Down - 1D Dynamic Programming/Sequential State Transition
```python
    def numDecodings(self, s: str) -> int:

        # Note:
        # Top down (recursive with memoization)
        # 1. Memo Check ->
        # 2. Boundary Check -> 
        # 2. Explore choices -> single-digit and two-digit decoding
        # 3. Build -> sum of valid decodings from current index onward
        # 4. Memoize -> store results to avoid recomputation
        # Result: total decode ways from index 0 to end

        n = len(s)
        memo = {}

        def dfs(i):
            # Boundary Check -> reached end, one valid decoding
            if i == n:
                return 1

            # Memo check
            if i in memo:
                return memo[i]

            # Invalid start -> cannot decode
            if s[i] == '0':
                return 0

            # Explore Choices -> single digit
            count = dfs(i + 1)

            # Explore Choices -> two-digit
            if i + 1 < n and 10 <= int(s[i:i+2]) <= 26:
                count += dfs(i + 2)

            # Build -> memoize result for index i
            memo[i] = count

            # Backtrack -> return total count from i
            return count

        res = dfs(0)

        # overall: time complexity O(n)
        # overall: space complexity O(n) (memo + recursion stack)
        return res
```



### Solution 2: Iterative Bottom Up Array - 1D Dynamic Programming/Sequential State Transition
```python
    def numDecodings(self, s: str) -> int:

        # Note:
        # Bottom-up DP (1D array)
        # 1. Process root -> dp[i] = number of ways to decode first i characters
        # 2. Explore choices -> single-digit and two-digit decoding
        # 3. Build -> accumulate valid ways using previous dp values

        n = len(s)

        # Invalid string
        if not s or s[0] == '0':
            return 0

        dp = [0] * (n + 1)

        # Base cases:
        # empty string has 1 way
        dp[0] = 1
        # first char is valid (not '0') 
        dp[1] = 1

        for i in range(2, n + 1):
            # Explore Choices -> single digit
            if s[i-1] != '0':
                dp[i] += dp[i-1]

            # Explore Choices -> double digit
            two_digit = int(s[i-2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i-2]

        # Build -> dp[n] has total decoding ways
        res = dp[n]

        # overall: time complexity
        # overall: space complexity
        return res
```


### Solution 3: Iterative Bottom Up Variables - 1D Dynamic Programming/Sequential State Transition
```python
    def numDecodings(self, s: str) -> int:

        # Note:
        # Bottom-up DP with space optimization
        # Only previous two dp values needed
        # 1. prev2 = dp[i-2], prev1 = dp[i-1]
        # 2. For current index, accumulate ways from single-digit and two-digit checks
        # 3. Slide window forward to maintain only two previous states

        # Invalid check
        if not s or s[0] == '0':
            return 0

        n = len(s)

        # Base cases
        prev2, prev1 = 1, 1  # dp[0], dp[1]

        for i in range(1, n):

            curr = 0

            # Explore Choices -> single digit
            if s[i] != '0':
                curr += prev1

            # Explore Choices -> double digit
            two_digit = int(s[i-1:i+1])
            if 10 <= two_digit <= 26:
                curr += prev2

            # Slide Window ->
            prev2, prev1 = prev1, curr

        # Decode ways for nth
        res = prev1

        # overall: time complexity
        # overall: space complexity
        return res
```


## 322. Coin Change ::3:: - Medium

Topics:  Array, Dynamic Programming, Breadth First Search

### Intro
> You are given an integer array coins representing
> coins of different denominations and an integer 
> amount representing a total amount of money.
> Return the fewest number of coins that you need to 
> make up that amount. If that amount of money cannot 
> be made up by any combination of the coins, return -1.
> You may assume that you have an infinite number of 
> each kind of coin.

|  Example Input           | Output |  
| ---------------- | ------ | 
| coins = [1,2,5], amount = 11 | 3 |
| coins = [2], amount = 3 | -1 |
| coins = [1], amount = 0 | 0 |

Constraints:

1 &leq; coins.length &leq; 12

1 &leq; coins[i] &leq; 2<sup>31</sup> - 1

0 &leq; amount &leq; 10<sup>4</sup>


### Abstraction
Given a array of coin cost and a price, determine the minimum number
of coins needed to make the price.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming Bottom Up - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        # Note:
        # Bottom-up DP (1D array)
        # 1. Process root -> dp[a] = minimum coins needed for amount a
        # 2. Explore choices -> for each coin, consider using it
        # 3. Build -> dp[a] = min(dp[a], dp[a-coin] + 1)
        # 4. Result -> dp[amount] contains minimum coins if possible
        
        # sentinel for impossible
        max_val = amount + 1

        dp = [max_val] * (amount + 1)
        
        # Base case -> zero coins needed for 0
        dp[0] = 0 

        # Process price from 1 to target
        for a in range(1, amount + 1):

            # Explore Choices -> try each coin
            for coin in coins:

                # Valid choice
                if a - coin >= 0:
                    
                    # Explore Choices ->
                    # 1. ignore coin
                    left = dp[a]
                    # 2. use coin
                    right = dp[a-coin] + 1

                    # Build -> min between two options
                    dp[a] = min(left, right)

        res = dp[amount] if dp[amount] != max_val else -1

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 2: Recursive DP with Memoization - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:

        # Note:
        # Top-down DP (recursive with memoization)
        # 1. Process root -> remaining amount rem
        # 2. Explore choices -> recursively subtract each coin
        # 3. Build -> minimum coins among all choices
        # 4. Memoize -> store min coins for rem to avoid recomputation
        
        memo = {}

        def dfs(rem: int) -> int:
            # Process Root -> Base cases

            # Overshoot
            if rem < 0:
                return -1
            
            # Exact Match
            if rem == 0:
                return 0

            # Memoized
            if rem in memo:
                return memo[rem]

            min_coins = float('inf')

            # Explore Choices -> try each coin
            for coin in coins:
                
                # ??????
                res = dfs(rem - coin)

                if res >= 0:
                    # Build -> take min among all valid choices
                    min_coins = min(min_coins, res + 1)

            # Memoize result
            memo[rem] = -1 if min_coins == float('inf') else min_coins

            # Backtrack -> return value
            return memo[rem]

        # initial call with full amount
        res = dfs(amount)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: BFS - 1D Dynamic Programming/Min Max with Choices (Unbounded Knapsack style)
```python
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        # Note:
        # BFS (level-order) to find min coins
        # 1. Process root -> start with remaining amount = amount
        # 2. Explore choices -> subtract each coin to get next remaining amounts
        # 3. Build -> increment steps (coins used) at each BFS level
        # 4. Early stop -> return steps+1 when remaining reaches 0
        # 5. Result -> -1 if queue exhausted (impossible)

        if amount == 0:
            return 0

        # (remaining amount, coins used so far)
        queue = deque([(amount, 0)])

        # avoid revisiting same amount
        visited = set([amount])

        while queue:

            # Process Root -> current state
            rem, steps = queue.popleft()

            # Explore Choices -> try each coin
            for coin in coins:

                next_rem = rem - coin

                # Explore Choices -> rob/subtract each coin

                # target
                if next_rem == 0:
                    return steps + 1
                
                elif next_rem > 0 and next_rem not in visited:
                    # Build -> add next state to queue
                    visited.add(next_rem)
                    queue.append((next_rem, steps + 1))

        # impossible to reach target
        return -1
```


## 152. Maximum Product Subarray ::2:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> Given an integer array nums, find a subarray that has 
> the largest product, and return the product.
> The test cases are generated so that the answer will fit 
> in a 32-bit integer.

|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [2,3,-2,4] | 6 |
| nums = [-2,0,-1] | 0 |

Constraints:

1 &leq; nums.length &leq; 2 * 10<sup>4</sup>

-10 &leq; nums[i] &leq; 10

The product of any subarray of nums is guaranteed 
to fit in a 32-bit integer.


### Abstraction
Given a array, find the subarray with the largest product 
and return the product.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: DP Array Version - 1D Dynamic Programming/Track Multiple States per Index (Max Min Tracking)
```python
    def maxProduct(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with arrays
        # At each index, we conceptually explore 3 choices:
        # 1. Start new subarray with current num (root)
        # 2. Extend previous max product subarray (left)
        # 3. Extend previous min product subarray (right)
        # Then pick the max/min result to continue

        n = len(nums)
        if n == 0:
            return 0

        # Initialize DP arrays and result
        max_dp = [0] * n
        min_dp = [0] * n
        max_dp[0] = min_dp[0] = result = nums[0]

        for i in range(1, n):
            num = nums[i]

            # Explore Choices:
            left = max_dp[i-1] * num       # extend previous max subarray
            right = min_dp[i-1] * num      # extend previous min subarray
            root = num                      # start new subarray at current index

            # Build: pick max/min product at this index
            max_dp[i] = max(root, left, right)
            min_dp[i] = min(root, left, right)

            # Update overall result
            result = max(result, max_dp[i])

        # overall: 
        return result
```



### Solution 2: DP with Rolling Max Min - 1D Dynamic Programming/Track Multiple States per Index (Max Min Tracking)
```python
    def maxProduct(self, nums: List[int]) -> int:

        # Note:
        # Bottom-up DP with rolling variables (space optimized)
        # 1. Process root -> current element nums[i]
        # 2. Explore choices -> multiply current with previous max or min
        # 3. Build -> track max_prod and min_prod at each step
        #    (min_prod important due to negative numbers flipping sign)
        # 4. Result -> update overall max product seen so far

        n = len(nums)
        if n == 0:
            return 0

        # Initialize rolling max, min, and result
        max_prod = min_prod = result = nums[0]

        for i in range(1, n):
            num = nums[i]

            # Explore Choices:
            # left = extend previous max_prod
            left = max_prod * num
            # right = extend previous min_prod
            right = min_prod * num
            # root = start new subarray
            root = num

            # Build: compute current max/min at this index
            temp_max = max(root, left, right)
            min_prod = min(root, left, right)
            max_prod = temp_max

            # Update overall result
            result = max(result, max_prod)


        return result
```

## 139. Word Break ::3:: - Medium

Topics:  Array, Hash Table, String, Dynamic Programming, Trie, Memoization

### Intro
> Given a string s and a dictionary of strings wordDict,
> return true if s can be segmented into a space 
> separated sequence of one or more dictionary words. 
> Note that the same word in the dictionary may be 
> reused multiple times in the segmentation.

|  Example Input           | Output |  
| ---------------- | ------ | 
| s = "leetcode", wordDict = ["leet","code"] | true |
| s = "applepenapple", wordDict = ["apple","pen"] | true |
| s = "catsandog", wordDict = ["cats","dog","sand","and","cat"] | false |

Constraints:

1 &leq; s.length &leq; 300

1 &leq; wordDict.length &leq; 1000

1 &leq; wordDict[i].length &leq; 20

s and wordDict[i] consist of only lowercase English letters.

All the strings of wordDict are unique.

### Abstraction
Given a string and an array of strings, determine if the string
can be separated into some combination of strings from the array.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        # Note:
        # Bottom-up DP
        # 1. Process root -> current substring ending at i
        # 2. Explore choices -> partition at every possible previous index j
        # 3. Build -> dp[i] = True if any dp[j] is True and s[j:i] in wordDict
        # 4. Early prune -> break if valid segment found

        # quick lookup
        word_set = set(wordDict)
        n = len(s)
        dp = [False] * (n + 1)

        # Base case: empty string is segmentable
        dp[0] = True

        for i in range(1, n + 1):
            for j in range(i):
                
                # Explore Choice: segment s[j:i]
                if dp[j] and s[j:i] in word_set:

                    # Build -> segmentable
                    dp[i] = True 
                    # early prune, found valid segmentation
                    break  

        # Result: can full string be segmented
        return dp[n]
```

### Solution 2: Recursive DFS with Memoization - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        # Note:
        # Top-down DP (memoized recursion)
        # 1. Process root -> current start index
        # 2. Explore Choices -> try every end index forming s[start:end]
        # 3. Build -> if s[start:end] in word_set and dfs(end) is True, memo[start] = True
        # 4. Backtrack -> store False if no valid segmentation

        # quick lookup
        word_set = set(wordDict)
        memo = {}

        def dfs(start: int) -> bool:

            # Process Root -> Base cases

            # Reached end
            if start == len(s):
                return True

            # Memo check
            if start in memo:
                return memo[start]

            for end in range(start + 1, len(s) + 1):
                # Explore Choices -> s[start:end] as a segment
                if s[start:end] in word_set and dfs(end):

                    # Build: segmentable from start
                    memo[start] = True
                    return True

            # Backtrack: cannot segment from this start
            memo[start] = False
            return False

        # original call from top
        res = dfs(0)

        # overall: time complexity
        # overall: space complexity
        return res
```

### Solution 3: Optimized DFS by Matching Words - 1D Dynamic Programming/Sequential Segment Choice Validation
```python
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        # Note:
        # Optimized top-down DFS
        # 1. Process root -> current index i
        # 2. Explore choices -> iterate only over words in wordDict
        # 3. Build -> if s[i:i+len(word)] == word and dfs(i+len(word)) True, cache[i] = True
        # 4. Backtrack -> store False if no valid segmentation

        cache = {}
        def dfs(i):
            # Process Root -> base cases

            # reached end
            if i == len(s):
                return True

            # overshoot
            if i > len(s):
                return False

            # memo check
            if i in cache:
                return cache[i]
            for word in wordDict:
                # Explore Choice -> try matching void
                if i + len(word) <= len(s) and s[i:i+len(word)] == word:
                    cache[i] = dfs(i+len(word))
                    if cache[i]:
                        return True
            return False
        return dfs(0)
```


## 300. Longest Increasing Subsequence ::2:: - Medium

Topics:  Array, Binary Search, Dynamic Programming

### Intro
> Given an integer array nums, return the length of the 
> longest strictly increasing subsequence.
> Follow up: Can you come up with an algorithm that runs
> in O(n log(n)) time complexity?


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [10,9,2,5,3,7,101,18] | 4 |
| nums = [0,1,0,3,2,3] | 4 |
| nums = [7,7,7,7,7,7,7] | 1 |

Constraints:

1 &leq; nums.length &leq; 2500

-10<sup>4</sup> &leq; nums[i] &leq; 10<sup>4</sup>

### Abstraction
Given an integer array, find the longest increasing subsequence.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Classic DP for LIS
        # 1. Process root -> current index i (end of subsequence)
        # 2. Explore choices -> for all j < i, check if nums[i] can extend subsequence ending at j
        # 3. Build -> dp[i] = max(dp[i], dp[j]+1)
        # 4. Result -> maximum of dp array

        n = len(nums)
        if n == 0:
            return 0

        # dp[i] = length of LIS ending at i
        dp = [1] * n

        for i in range(n):
            for j in range(i):

                # Explore Choice -> extend subsequence ending at j
                if nums[i] > nums[j]:

                    # Build -> max between current and extending j
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```

### Solution 2: Binary Search Patience Sorting - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Patience sorting method (efficient O(n log n))
        # 1. Process root -> current number in nums
        # 2. Explore choices -> find insertion point in current LIS tails
        # 3. Build -> append if new tail is larger, else replace to minimize tail
        # 4. Result -> length of tails array = length of LIS

        # tails[i] = smallest possible tail of LIS of length 
        tails = []

        for num in nums:
            
            # Explore Choice -> find where num fits
            index = bisect.bisect_left(tails, num)

            if index == len(tails):
                # Build: extend LIS with new larger tail
                tails.append(num)
            else:
                # Build: replace to keep minimal tail (better chance for future extension)
                tails[index] = num

        return len(tails)
```

### Solution 3: Binary Search - 1D Dynamic Programming/Subsequence Optimization Constrained
```python
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Note:
        # Same as Solution 2, but manual binary search instead of bisect
        # 1. Process root -> current number
        # 2. Explore choices -> search for first tail >= num
        # 3. Build -> append if end, replace otherwise
        # 4. Result -> length of tails = LIS length

        tails = []

        for num in nums:
            left, right = 0, len(tails) - 1
            
            # Explore Choices -> find insertion/replacement index
            while left <= right:
                mid = (left + right) // 2
                if tails[mid] < num:
                    left = mid + 1
                else:
                    right = mid - 1
            
            # Build: insert or replace
            if left == len(tails):
                tails.append(num)
            else:
                tails[left] = num

        return len(tails)
```


## 416. Partition Equal Subset Sum ::2:: - Medium

Topics:  Array, Dynamic Programming

### Intro
> Given an integer array nums, return true if you can 
> partition the array into two subsets such that the sum
> of the elements in both subsets is equal or false 
> otherwise.


|  Example Input           | Output |  
| ---------------- | ------ | 
| nums = [1,5,11,5] | true |
| nums = [1,2,3,5] | false |

Constraints:

1 &leq; nums.length &leq; 200

1 &leq; nums[i] &leq; 100

### Abstraction
Given an integer array, determine if you can split it into two arrays
such that the sum of each arrays is equal.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


### Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


### Find the Bug:
```python
```

### Solution 1: Dynamic Programming Subset Sum - 1D Dynamic Programming/Subset Sum Linear Choice Selection
```python
    def canPartition(self, nums: List[int]) -> bool:
        
        # Note:
        # 1D DP for subset sum
        # 1. Process root -> current number in nums
        # 2. Explore choices -> include current number or skip it
        # 3. Build -> update achievable sums in dp
        # 4. Result -> check if target sum is achievable
        
        total = sum(nums)
        # If total sum is odd, cannot partition equally
        if total % 2 != 0:
            return False

        target = total // 2
        n = len(nums)

        # dp[i] = True if sum i is achievable with some subset
        dp = [False] * (target + 1)
        # sum 0 is always achievable (root/base case)
        dp[0] = True

        for num in nums:
            # Explore choices in reverse to avoid using same number twice
            for i in range(target, num - 1, -1):
                # Build: include num if sum i-num was achievable
                dp[i] = dp[i] or dp[i - num]

        # Result: can we achieve target sum?
        return dp[target]
```


### Solution 2: Bitmask Bitset DP - 1D Dynamic Programming/Subset Sum Linear Choice Selection
```python
    def canPartition(self, nums: List[int]) -> bool:
        
        # Note:
        # Bitmask DP (bitset)
        # 1. Process root -> each number
        # 2. Explore choices -> include or skip number, track sums as bits
        # 3. Build -> shift bits to represent new achievable sums
        # 4. Result -> check if target sum bit is set

        total = sum(nums)
        if total % 2 != 0:
            return False

        target = total // 2

        # bitset where i-th bit = True if sum i achievable
        bits = 1  # only 0 sum is achievable initially

        for num in nums:
            # Build: shift current bits by num to represent including it
            bits |= bits << num

        # Result: check if target sum is achievable
        return (bits >> target) & 1 == 1
```