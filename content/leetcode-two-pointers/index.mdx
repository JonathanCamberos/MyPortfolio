---
title: "LeetCode: Two Pointers"
description: "two pointers"
image: "../../public/blogs/laptop_3.jpg"
publishedAt: "2024-07-04"
updatedAt: "2024-07-04"
author: "jonathancamberos"
isPublished: true
tags: 
- leetcode
- data structures & algorithms
---


## Two Pointer Intro

Getting aquanted and learning how two simple pointers can can 'point' to the solution

### What are Two Pointers 
First lets understand what two pointers are 



## 125. Valid Palindrome

### Intro
> A phrase is a palindrome if, after converting all uppercase letters into lowercase letters 
> and removing all non-alphanumeric characters, it reads the same forward and backward. 
> Alphanumeric characters include letters and numbers.
> Given a string s, return true if it is a palindrome, or false otherwise.

|  Input                             | Output  |  
| ---------------------------------- | ------- | 
| "A man, a plan, a canal: Panama"   | true    | 
| "race a car"                       | false   |
| " "                                | true    |

### Constraints
s consists only of printable ASCII characters.

### Abstraction 
Not much abstraction is needed but rather steps

First we need to convert the string s into lowercase.
Then we need to remove non-alphanumeric characters, isalnum() comes handy 
Then simple traverse or reverse the string to compare

### Solution 1: Two Pointers L + R
```python
    def isPalindrome(self, s: str) -> bool:
        
        # simultanious assignment
        l, r = 0, len(s) - 1

        while l < r:
            
            # moving both pointers until both are at alphaNum
            while l < r and not self.alphaNum(s[l]):
                l += 1
            while r > l and not self.alphaNum(s[r]):
                r -= 1

            # check both curr alphaNum for match 
            if s[l].lower() != s[r].lower():
                return False

            # move pointers to next step
            l, r = l + 1, r - 1

        return True
    
    # simple way for alphaNum check
    def alphaNum(self, c):
        return (ord('A') <= ord(c) <= ord('Z') or 
                ord('a') <= ord(c) <= ord('z') or 
                ord('0') <= ord(c) <= ord('9'))
```

Here we simply follow the steps we mentioned above. 

Use pointers l and r, skip over all non-alphaNum chars, 
then check if the pointers match, and continue

### Solution 2: Reverse String
```python 
def isPalindrome(self, s: str) -> bool:
    ans = ""
    for c in s.lower():
        if c.isalnum():
            ans += c
    return ans == ans[::-1]
        
``` 
For this problem, its actually quicker to use the library functions as the alphaNum function from 
solution 1 is incredibly slow

We simply loop over the string after calling lowercase, then add only the alphaNumeric characters 
to the string that reverse and check over. 


## 167. Two Sum II - Input Array Is Sorted

### Intro
> Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, 
> find two numbers such that they add up to a specific target number. 
> Let these two numbers be numbers[index1] and numbers[index2] where 1 `leq` index1 `lt` index2 `leq` numbers.length.
> Return the indices of the two numbers, index1 and index2, added by one as an 
> integer array [index1, index2] of length 2.
> The tests are generated such that there is exactly one solution. 
> You may not use the same element twice.

|  nums          | target | Output |  
| -------------- | ------ | ------ | 
| [2, 7, 11, 15] | 9      | [1,2]  |
| [2, 3, 4]      | 6      | [1,3]  |
| [-1, 0]        | -1     | [1,2]  |

### Constraints
Your solution must use only constant extra space.

### Abstraction
There are two main abstractions to help simplify this problem, 
specifically because the array is sorted

If we start with the naive solution where we iterate of the array with 
2 pointers L & R starting at index 0 and iterate n^2 times

| 1 | 3 | 4 | 5 | 7 | 10 | 11 |    Target = 9

L^ ------------- R^

Lets say L = 1 and R = 10
1 + 10 = 11, so we know that this is bigger than our target (11 > 9) and we know that
the array is sorted, we know that any number to the right of 10 is too large and we can
discard that half of the array.

Thus are array becomes 

| 1 | 3 | 4 | 5 | 7 |    Target = 9

-L/R^


And we start both pointers on the left, and shift the L pointer to the right by one index 
and start the R pointer iteration again, starting at the number 3. 

Essentially we are chopping off the right handside of the array if our current L + R > Target. 

We can replicate this via 2 pointers if L = 0 and R = len(nums)-1 

and move R - 1 index if L + R > Target 

and move L + 1 index if L + R < Target

because of the chopping off patern that we mentioned from the O(n^2) solution above

### Solution 1:
```python 
 def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l,r = 0,len(numbers)-1

        while l < r:
            tmp = numbers[l] + numbers[r]
        
            if tmp > target:
                r -= 1
            elif tmp < target:
                l += 1
            else:
                return [l+1,r+1]
```

To summarize abstraction:

If tmp is bigger than target, move R to the left (because every elem to the 
right of R is bigger and thus could not be the answer )

If tmp is smaller than target, move L to the right (because every elem to the 
left of L is smaller and thus could not be the answer )

## 15. 3Sum

### Intro
> Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] 
> such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

> Notice that the solution set must not contain duplicate triplets.

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [-1,0,1,2,-1,-4] | [[-1,-1,2],[-1,0,1]]  |
| [0,1,1]          | []                    |
| [0,0,0]          | [[0,0,0]]             |

### Constraints

### Abstraction
While this may be a pointer problem, solving it cleanly is simply a matter of breaking it down cleanly

Our main cases:
1. (0, 0, 0)
2. (-num1, +num1, 0)
3. (-num1, -num2, num3)
4. (num1, num2, -num3)

So if we just use sets to help us find that then we are good to go.

### Solution 1: Split list into positives, negatives, and zeros
```python
def threeSum(self, nums: List[int]) -> List[List[int]]:

	res = set()

	#1. Split nums into three lists: negative numbers, positive numbers, and zeros
	n, p, z = [], [], []
	for num in nums:
		if num > 0:
			p.append(num)
		elif num < 0: 
			n.append(num)
		else:
			z.append(num)

	#2. Create a separate set for negatives and positives for O(1) look-up times
	N, P = set(n), set(p)

	#3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P
	#   i.e. (-3, 0, 3) = 0
	if z:
		for num in P:
			if -1*num in N:
				res.add((-1*num, 0, num))

	#3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0
	if len(z) >= 3:
		res.add((0,0,0))

	#4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)
	#   exists in the positive number set
	for i in range(len(n)):
		for j in range(i+1,len(n)):
			target = -1*(n[i]+n[j])
			if target in P:
				res.add(tuple(sorted([n[i],n[j],target])))

	#5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)
	#   exists in the negative number set
	for i in range(len(p)):
		for j in range(i+1,len(p)):
			target = -1*(p[i]+p[j])
			if target in N:
				res.add(tuple(sorted([p[i],p[j],target])))

	return res
```

Here, we simply account for each of the cases in abstraction, and code it out.

### Solution 2: itertools small optimization
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
            
        if len(nums) < 3:
            return []

        res = set()

        # 1. Split nums into three lists: negative numbers, positive numbers, and zeros
        n, p, z = [], [], []
        for num in nums:
            if num > 0:
                p.append(num)
            elif num < 0:
                n.append(num)
            else:
                z.append(num)

        # 2. Create a separate set for negatives and positives for O(1) look-up times
        N, P = set(n), set(p)

        # 3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P
        #   i.e. (-3, 0, 3) = 0
        if z:
            for num in P:
                if -1 * num in N:
                    res.add((-1 * num, 0, num))

            # 3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0
            if len(z) >= 3:
                res.add((0, 0, 0))

        # 4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)
        #   exists in the positive number set
        
        from itertools import combinations

        for x, y in combinations(n, 2):
            target = -1 * (x + y)
            if target in P:
                res.add(tuple(sorted([x, y, target])))

        # 5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)
        #   exists in the negative number set

        for x, y in combinations(p, 2):
            target = -1 * (x + y)
            if target in N:
                res.add(tuple(sorted([x, y, target])))

        return [list(x) for x in res]
``` 

For the double for loops, itertools provides an efficient way of 