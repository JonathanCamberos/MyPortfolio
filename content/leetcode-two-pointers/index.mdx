---
title: "LeetCode: Two Pointers"
description: "two pointers"
image: "../../public/blogs/two-pointer-9.png"
publishedAt: "2025-05-28"
updatedAt: "2025-05-28"
author: "jonathancamberos"
isPublished: true
tags: 
- data structures & algorithms
---

## Two Pointer Intro
Leetcode problems with elegant solutions using two pointers. 

### L + R
Two Pointers is the strategy of using L and R pointers to iterate over a list of elements
to solve logic problems.

## 125. Valid Palindrome - Easy

### Intro
> A phrase is a palindrome if, after converting all uppercase letters into lowercase letters 
> and removing all non-alphanumeric characters, it reads the same forward and backward. 
> Alphanumeric characters include letters and numbers.
> Given a string s, return true if it is a palindrome, or false otherwise.

|  Input                             | Output  |  
| ---------------------------------- | ------- | 
| "A man, a plan, a canal: Panama"   | true    | 
| "race a car"                       | false   |
| " "                                | true    |

Constraints:
string s consists only of printable ASCII characters.

### Abstraction 
Using two pointers, L and R, we can traverse the string validating palindrome status.

We can convert the string s into lowercase, 
traverse using pointers comparing characters on the start and end of the string.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force One Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer In Place | O(n) | O(1) | Iterate over string of n length O(n) | No additional memory allocation for in place comparison O(1) |

### Brute Force One Pointer
```python
    def isPalindrome(self, s: str) -> bool:

        # space complexity: list to store cleaned string of n length O(n)
        cleaned = []

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:

            if alphaNum(c):
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # time complexity: two pointer iteration of string of n length O(n)
        n = len(cleaned)
        for i in range(n // 2):
            if cleaned[i] != cleaned[n - i - 1]:
                return False

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterate over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Palindrome Check | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(n) | Iterating over list of n length dominates leading to O(n) | Memory allocation to store clean string of n length dominates leading to O(n) | 

### Solution 1: Two Pointers
```python
    def isPalindrome(self, s: str) -> bool:
        
        # space complexity: list to store cleaned string of n length O(n)
        cleaned = []

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:
            # Check if character is alphanumeric
            if isAlphaNum(c):
                # Convert uppercase to lowercase
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # time complexity: two-pointer traversal of cleaned string O(n)
        left, right = 0, len(cleaned) - 1
        while left < right:
            if cleaned[left] != cleaned[right]:
                return False
            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterating over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over list of n length dominates leading to O(n) | No additional memory allocation for comparison O(1) | 


### Solution 2: Two Pointers In Place
```python 
    def isPalindrome(self, s: str) -> bool:
        # space complexity: no additional space used for storage O(1)
        left, right = 0, len(s) - 1

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iteration over string of n length O(n)
        while left < right:
            # time complexity: moving left pointer to next alphanumeric character O(n)
            while left < right and not isAlphaNum(s[left]):
                left += 1

            # time complexity: moving right pointer to previous alphanumeric character O(n)
            while left < right and not isAlphaNum(s[right]):
                right -= 1

            # Convert characters to lowercase
            leftChar = s[left]
            if 'A' <= left_char <= 'Z':
                left_char = chr(ord(leftChar) + 32)

            rightChar = s[right]
            if 'A' <= right_char <= 'Z':
                rightChar = chr(ord(rightChar) + 32)

            # Compare characters
            if leftChar != rightChar:
                return False

            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return True
            
``` 

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over string n length dominates leading to O(n) | No additional memory allocation O(1) |


## 271. String Encode and Decode - Medium

### Intro

> Design an algorithm to encode a list of strings to a single string.
> The encoded string is then decoded back to the original list of strings
> Please implement encode and decode

|  Input                           | Output                              |  
| -------------------------------- | ----------------------------------- | 
| ["leet", "code", "love", "you"]  | ["leet", "code", "love", "you"]     |
| ["we", "say", ":", "yes"]        | ["we", "say", ":", "yes"]           |

Constraints:

### Abstraction
We need to create an encode and decode function and mark the start of a new string
as well as its length.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Two Pointers Length Delimiter |  |  |  |  |

### Solution 1: One Pointer Length Delimiter
```python
    def encode(self, strs: List[str]) -> str:

        # python strings are immutable so concatenation creates new string time complexity o(n^2)
        # python list allows us to add encoded strings in O(n)
        # space complexity: storage for encoding all strings in a list O(n)
        encoded = []

        # time complexity: iterate over list of strings n length O(n)
        for s in strings:
            
            # time complexity: iterate over all chars in string O(n)

            # lenDelim = len + delim
            left = 0
            lenDelim = str(len(s)) + "#"

            # append each char of (length + delimiter) O(n)
            while left < len(lenDelim):
                encoded.append(lenDelim[left])
                left += 1
            
            # append each char of string itself O(n)
            left = 0
            while left < len(s):
                encoded.append(s[left])
                left += 1
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return ''.join(res)


    def decode(self, s: str) -> List[str]:

        # space complexity:
        decoded = []
        left = 0

        # time complexity: iterate over list of n chars O(n)
        while left < len(encoded):

            # time complexity: 
            currLen = 0
            while encoded[left] != "#":

                # grabbing value ensuring base 10
                currLen = currLen * 10 + int(encoded[i]) 
                left += 1

            # skip delimiter, point to string
            left += 1  

            # grabbing currLen many chars to form string
            # time complexity: 
            substring = ""
            while left < range(currLen)

                # forming string
                substring += encoded[left]
                left += 1
            
            # added string to decoded list of strings
            decoded.append(substring)

        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return decoded
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Encode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterating over list of strings n length O(n) | Memory allocation for encoded string of length O(n)  |
| Decode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterate over encoded string with delimiter n length o(n) | Memory allocation for list of strings n length |


## 167. Two Sum II - Input Array Is Sorted - Medium

### Intro
> Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, 
> find two numbers such that they add up to a specific target number. 
> Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length.
> Return the indices of the two numbers, index1 and index2, added by one as an 
> integer array [index1, index2] of length 2.
> The tests are generated such that there is exactly one solution. 
> You may not use the same element twice.

|  Input List          | Input Target | Output |  
| -------------- | ------ | ------ | 
| [2, 7, 11, 15] | 9      | [1,2]  |
| [2, 3, 4]      | 6      | [1,3]  |
| [-1, 0]        | -1     | [1,2]  |

Constraints:

Your solution must use only constant extra space O(1)

### Abstraction
Since the array is sorted we can make assumptions as we traverse the array using pointers.
Lets build up to the assumption.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (all pair comparison) |  |  |  |  |
| Binary Search for Complement |  |  |  |  |
| Two Pointers |  |  |  |  |

### Brute Force (all pairs comparison)
```python
    def twoSum(self, numbers: List[int], target: int) -> List[int]:

        # time complexity: iteration of O(n)
        for i in range(len(numbers)): 

            # time complexity: iteration of O(n^2)
            for j in range(i + 1, len(numbers)): 

                # time complexity: sum and comparison operations take constant O(1)
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]  # Convert to 1-indexed

        # overall: time complexity
        # overall: space complexity 
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1: Binary Search for Complement
```python 
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        
        # time complexity: iteration over list of n length O(n)
        for i in range(len(numbers)): 

            complement = target - numbers[i]
            
            # Binary search: O(log n)
            left, right = i + 1, len(numbers) - 1
            while left <= right:
                mid = (left + right) // 2
                if numbers[mid] == complement:
                    return [i + 1, mid + 1]  # Convert to 1-indexed
                elif numbers[mid] < complement:
                    left = mid + 1
                else:
                    right = mid - 1

        # overall: time complexity O(n log n)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2: Two Pointers
```python
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # Time complexity: O(n), Space complexity: O(1)
        left, right = 0, len(numbers) - 1  # Initialize two pointers
        while left < right:  # Traverse until pointers meet
            current_sum = numbers[left] + numbers[right]  # O(1) sum calculation
            if current_sum == target:
                return [left + 1, right + 1]  # Convert to 1-indexed
            elif current_sum < target:
                left += 1  # Move left pointer to increase the sum
            else:
                right -= 1  # Move right pointer to decrease the sum

        # overall: time complexity
        # overall: space complexity
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


## 15. threeSum - Medium

### Intro
> Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] 
> such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
> Notice that the solution set must not contain duplicate triplets.

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [-1,0,1,2,-1,-4] | [[-1,-1,2],[-1,0,1]]  |
| [0,1,1]          | []                    |
| [0,0,0]          | [[0,0,0]]             |

Constraints:

### Abstraction
This is a step up from the previous 167. Two Sum II - Sorted problem. 

The only differences is that we are using 3 integers for the sum, and our array is not sorted.

We have two main ways to do this:
1. sort() + frozen negative number + mini twoSum
2. 
3. grouping by parity + 4 subcases

sort() + frozen negative number + mini twoSum:

Here, we are converting the threeSum problem into a twoSum problem.

By freezing some negative element, we have 2 elements left that must be the complement of the frozen element, 
adding up to zero. 

These two elements are found by setting L to the index of the current frozen negative element + 1, and R to the right most element.

Via this, we portion our array into a mini twoSum problem

grouping by parity + 4 subcases:

Here, we iterate the array once and place each number into a bucket of postive, negative, a zero numbers.

We then iterate over the original array while going through the 3 following cases:

1. (0, 0, 0)
2. (-num1, +num1, 0)
3. (-num1, -num2, num3)
4. (num1, num2, -num3)

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 1: sort() + frozen negative number + mini twoSum
```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    res = []
    nums.sort()

    # (index, value) iterator
    for i, a in enumerate(nums):
        
        # we are freezing one pointer on a negative number
        # if we hit postive number we can end
        if a > 0:
            break

        # if we hit a repeated negative number, skip
        if i > 0 and a == nums[i-1]:
            continue

        # mini twoSum problem
        # chunk of array to the right of the frozen negative number
        L, R, = i + 1, len(nums)-1
        while L < R:
            curr3Sum = a + nums[L] + nums[R]

            if curr3Sum < 0:
                L += 1
            elif curr3Sum > 0:
                R -= 1
            else:
                res.append([a, nums[L], nums[R]])

                # why dont we just shift over L?
                # following while loops moves L until we hit a new number
                # but we know that a + L + R --> 0
                # thus, there is no a + new_L + R != 0
                # so we must shift both pointers
                L += 1
                R -= 1

                while nums[L] == nums[L-1] and L < R:
                    L += 1
    return res
``` 

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 3: grouping by parity + 4 subcases
```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    p, n, z = [], [], []
    res = set()

    for i in nums:
        if i < 0:
            n.append(i)
        elif i > 0:
            p.append(i)
        else:
            z.append(i)

    # sets for access
    P, N = set(p), set(n)

    # 1. (0, num, -num) if at least one 0
    if len(z) > 0:
        for i in P:
            n_target = -i
            if n_target in N:
                res.add((n_target, 0, i ))

    # 2. (0, 0, 0) if at least three 0's
    if len(z) > 2:
        res.add((0, 0, 0))

    # 3. (-, -, +) negative pairs
    for i in range(len(n)):
        for j in range(i+1, len(n)):
            p_target = -(n[i] + n[j])
            if p_target in P:
                res.add(tuple(sorted([n[i], n[j], p_target])))
    
    # 4. (-, +, +) positive pairs
    for i in range(len(p)):
        for j in range(i+1, len(p)):
            n_target = -(p[i] + p[j])
            if n_target in N:
                res.add(tuple(sorted([p[i], p[j], n_target])))

    return res	
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

while this is arguably cleaner and more satisfying than the mini twoSum solution, this is again 
not utilziing two pointers. But its still a cool approach to the problem.


## 11. Container With Most Water - Medium

### Intro
> You are given an integer array height of length n. There are n vertical lines drawn 
> such that the two endpoints of the ith line are (i, 0) and (i, hieght[i]).
> Find two lines that together with the x-axis form a container, such that the container
> contains the most water
> Return the maximum amount of water a container can store


|  nums            | Output                |  
| ---------------- | --------------------- | 
|  |   |
|           |                     |
|         |              |



Constraints:

Notice you may not slant the container

### Abstract
If we image the array 'height' as a bar graph, we are using the max(L, R) heigh and the 
distance between the two bars in order to calculate the amount of water stored.

Here, both height of bars and distance are the important steps.

We start our points are the left and right hand edge of the array. Similarly to the twoSum 
problem, we calculate the current water stored, compare it to the currMax, and the shift the
the pointer which is currently at min(height[L], height[R]).

A small optimization is that we keep shifting this chosen pointer until we find a new bar 
with a higher height than the first bar.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 1: 
```python
def maxArea(self, height: List[int]) -> int:
    L, R = 0, len(height)-1
    maxWater = 0 

    while L < R:
        smallerHeight = min(height[L], height[R])
        currWater = smallerHeight * (R-L)
        maxWater = max(maxWater, currWater)

        if height[L] < height[R]:
            L += 1

            while height[L] < smallerHeight:
                L += 1 
        
        else:
            R -= 1

            while height[R] < smallerHeight:
                R -= 1

    return maxWater
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


## 42. Trapping Rain Water - Hard

### Intro
> Given n non-negative integers representing an elevation map where the width of 
> each bar is 1, computer how much water it can trap after raining

|  height                   | Output  |  
| ------------------------- | ------- | 
| [0,1,0,2,1,0,1,3,2,1,2,1] | 6       |
| [4,2,0,3,2,5]             | 9       |

Constraints: 

### Abstraction 
Lets define how we can trap water.

[1, 0, 1]: allows us to trap 1 unit of water. 

[1, 0, 2]: also allows 1 unit of water

[1, 0, 0]: also 0 units of water

Easy enough, the pattern is: min(left, right) - currHeight

Now we need a way to traverse the array that allows us to take advantage of this pattern.

Our main restriction for caputuring water, is the less of the two pointers/sides. 

So lets say: [0, 1, 0, 0, 0, 0, 0, 10]

Here, the L pointer would always be L < R since R = 10. We want to keep track of our restriction 
(the lesser of the two pointers), but we also want to traverse the array at some point. 

Thus, we need both L/R pointers, and left_max and right_max for heights.

The max heights will keep track of our "restrictions" and the pointers will be used to traverse 
the array. 

Here, we know that each of the 0 height spaces can capture 1 unit of water, being restricted by the 
1 unit height barrier on the left side. 

Thus: min(left_max, right_max) - height[0 unit]
Thus: 1 - 0  --> for the 5 spaces with 0 height.

NOTE: here we are only moving the L pointer as the R pointer is always L < R.

Thus we know we also need: if L < R --> L += 1 

NOTE: we also need to check if everytime we move the pointer, we find a new max_height for the left 
or right 

Thus we know we also need: left or rigth_max_height = max(left or right_max_height, height[L or R])

We simply put this into code now: 

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |

### Solution 1: Two Pointers 
```python 
def trap(self, height: List[int]) -> int:
    L, R = 0, len(height) - 1
    left_max, right_max = height[L], height[R]
    water = 0

    while L < R:
        
        if height[L] < height[R]:
            L += 1
            left_max = max(left_max, height[L])
            water += min(left_max, right_max) - height[L]
        else: 
            R -= 1
            right_max = max(right_max, height[R])
            water += min(left_max, right_max) - height[R]
    
    return water
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 