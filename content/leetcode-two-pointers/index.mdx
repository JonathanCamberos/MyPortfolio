---
title: "LeetCode: Two Pointers"
description: "two pointers"
image: "../../public/blogs/laptop_3.jpg"
publishedAt: "2024-07-04"
updatedAt: "2024-07-04"
author: "jonathancamberos"
isPublished: true
tags: 
- leetcode
- data structures & algorithms
---


## Two Pointer Intro:

Getting aquanted and learning how two simple pointers can can 'point' to the solution

### What are Two Pointers 
First lets understand what two pointers are 



## 125. Valid Palindrome

### Intro
> A phrase is a palindrome if, after converting all uppercase letters into lowercase letters 
> and removing all non-alphanumeric characters, it reads the same forward and backward. 
> Alphanumeric characters include letters and numbers.
> Given a string s, return true if it is a palindrome, or false otherwise.

|  Input                             | Output  |  
| ---------------------------------- | ------- | 
| "A man, a plan, a canal: Panama"   | true    | 
| "race a car"                       | false   |
| " "                                | true    |

### Constraints
s consists only of printable ASCII characters.

### Abstraction 
Not much abstraction is needed but rather steps

First we need to convert the string s into lowercase.
Then we need to remove non-alphanumeric characters, isalnum() comes handy 
Then simple traverse or reverse the string to compare

### Solution 1: Two Pointers L + R
```python
    def isPalindrome(self, s: str) -> bool:
        
        # simultanious assignment
        l, r = 0, len(s) - 1

        while l < r:
            
            # moving pointer until it hits an alphaNum
            while l < r and not self.alphaNum(s[l]):
                l += 1
            while r > l and not self.alphaNum(s[r]):
                r -= 1

            # check the current alphaNum for match 
            if s[l].lower() != s[r].lower():
                return False

            # move the points to next step
            l, r = l + 1, r - 1

        return True
    
    # simple way for alphaNum check
    def alphaNum(self, c):
        return (ord('A') <= ord(c) <= ord('Z') or 
                ord('a') <= ord(c) <= ord('z') or 
                ord('0') <= ord(c) <= ord('9'))
```

Here we simply follow the steps we mentioned above. 

Use pointers l and r, skip over all non-alphaNum chars, 
then check if the pointers match, and continue until the pointer hit eachother

### Solution 2: Reverse String
```python 
def isPalindrome(self, s: str) -> bool:
    ans = ""
    for c in s.lower():
        if c.isalnum():
            ans += c
    return ans == ans[::-1]
        
``` 
For this problem, its actually quicker to use the library functions as the alphaNum function from 
solution 1 is incredibly slow

We simply loop over the string after calling lowercase, then add only the alphaNumeric characters 
to the string that reverse and check over. 


## 167. Two Sum II - Input Array Is Sorted

### Intro 
> Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, 
> find two numbers such that they add up to a specific target number. 
> Let these two numbers be numbers[index1] and numbers[index2] where 1 `leq` index1 `lt` index2 `leq` numbers.length.
> Return the indices of the two numbers, index1 and index2, added by one as an 
> integer array [index1, index2] of length 2.
> The tests are generated such that there is exactly one solution. 
> You may not use the same element twice.

|  nums          | target | Output |  
| -------------- | ------ | ------ | 
| [2, 7, 11, 15] | 9      | [1,2]  |
| [2, 3, 4]      | 6      | [1,3]  |
| [-1, 0]        | -1     | [1,2]  |

### Constraints
Your solution must use only constant extra space.

### Abstraction
There are two main abstractions to help simplify this problem, 
specifically because the array is sorted

If we start with the naive solution where we iterate of the array with 
2 pointers L & R starting at index 0 and iterate n^2 times

| 1 | 3 | 4 | 5 | 7 | 10 | 11 |    Target = 9

L^ ------------- R^

Lets say L = 1 and R = 10
1 + 10 = 11, so we know that this is bigger than our target (11 > 9) and we know that
the array is sorted, we know that any number to the right of 10 is too large and we can
discard that half of the array.

Thus are array becomes 

| 1 | 3 | 4 | 5 | 7 |    Target = 9

-L/R^


And we start both pointers on the left, and shift the L pointer to the right by one index 
and start the R pointer iteration again, starting at the number 3. 

Essentially we are chopping off the right handside of the array if our current L + R > Target. 

We can replicate this via 2 pointers if L = 0 and R = len(nums)-1 

and move R - 1 index if L + R > Target 

and move L + 1 index if L + R < Target

because of the chopping off patern that we mentioned from the O(n^2) solution above

### Solution 1:
```python 
 def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l,r = 0,len(numbers)-1

        while l < r:
            tmp = numbers[l] + numbers[r]
        
            if tmp > target:
                r -= 1
            elif tmp < target:
                l += 1
            else:
                return [l+1,r+1]
```

To summarize abstraction:

If tmp is bigger than target, move R to the left (because every elem to the 
right of R is bigger and thus could not be the answer )

If tmp is smaller than target, move L to the right (because every elem to the 
left of L is smaller and thus could not be the answer )