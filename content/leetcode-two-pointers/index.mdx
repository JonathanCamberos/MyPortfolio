---
title: "LeetCode: Two Pointers"
description: "two pointers"
image: "../../public/Notes/two-pointer.png"
publishedAt: "2025-05-28"
updatedAt: "2025-05-31"
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---

## Two Pointer Intro
Leetcode problems with elegant solutions using two pointers. 

### L + R
Two Pointers is the strategy of using L and R pointers to solve logic problems.

### Two Pointers Application: One Pointer with Auxiliary State
Use a single pointer to scan linearly and keep track of additional state 
variables to simulate a second pointer.

Ex: Move all zeros while maintaining order
```python
    def move_zeros(nums: list[int]) -> None:
        # `last_non_zero_found_at` tracks the position where the next non-zero
        # element should be placed, simulating a second pointer.
        last_non_zero_found_at = 0

        for current in range(len(nums)):
            if nums[current] != 0:
                nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]
                last_non_zero_found_at += 1

    # arr = [0, 1, 0, 3, 12] 
    # move_zeros(arr)  Output: [1, 3, 12, 0, 0]
```

### Two Pointers Application: Opposite Ends
We can have two pointers starting at opposite ends of a list and move them inward 
while validating some sort of logic.

Ex: Determine if a string is a palindrome
```python
    def is_palindrome(s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    # Example:
    print(is_palindrome("radar"))  # Output: True
    print(is_palindrome("hello"))  # Output: False
```

### Two Pointers Application: Sliding Window
We can have two pointers represent a window over a sequence that expands or shrinks
to satisfy a condition.

Ex: Find the length of the longest substring without repeating characters.
```python
    def longest_unique_substring(s: str) -> int:
        char_set = set()
        left = 0
        max_length = 0

        for right in range(len(s)):
            while s[right] in char_set:
                char_set.remove(s[left])
                left += 1
            char_set.add(s[right])
            max_length = max(max_length, right - left + 1)
        
        return max_length

    # Example:
    print(longest_unique_substring("abcabcbb"))  # Output: 3
```


### Two Pointers Application: Fast & Slow Pointers 
We can have have two pointers moving at different speeds to detect cycles or find midpoints
in linked lists or arrays.

Ex: Detect a cycle in a linked list.
```python
    class ListNode:
        def __init__(self, value=0, next=None):
            self.value = value
            self.next = next

    def has_cycle(head: ListNode) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False

    # Example:
    # Construct a list with a cycle: 1 -> 2 -> 3 -> 4 -> 2 (cycle)
    node1 = ListNode(1)
    node2 = ListNode(2)
    node3 = ListNode(3)
    node4 = ListNode(4)
    node1.next = node2
    node2.next = node3
    node3.next = node4
    node4.next = node2
    print(has_cycle(node1))  # Output: True
```

### Two Pointers Application: Partitioning
We can have two pointers in the same array moving inward/outward to rearrange elements
based on a condition.

Ex: Move all zeros in an array to the end while maintaining the order of other elements
```python
    def move_zeros(nums):
        left, right = 0, 0
        while right < len(nums):
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1
        return nums

    # Example:
    print(move_zeros([0, 1, 0, 3, 12]))  # Output: [1, 3, 12, 0, 0]
```

### Two Pointers Application: Parallel Pointer Traversal 
We can have two pointers traversing two separate arrays in parallel to merge, compare,
or find intersections.

Ex: Merge two sorted arrays into one sorted array
```python
    def merge_sorted_arrays(arr1, arr2):
        result = []
        i, j = 0, 0

        while i < len(arr1) and j < len(arr2):
            if arr1[i] < arr2[j]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        result.extend(arr1[i:])
        result.extend(arr2[j:])
        return result

    # Example:
    print(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))  # Output: [1, 2, 3, 4, 5, 6]
```

### Two Pointers Application: K-Pointer Variants 
We can extend the two pointer case to track k pointers simultaneously.
These pointers can traverse the same list, different lists, or freeze while moving
other pointers.

Ex: Given an integer array nums, return all the unique triplets [nums[i], nums[j], nums[k]] that sum to 0.
```python
    def threeSum(nums):
        nums.sort()  # Step 1: Sort the array
        result = []

        for i in range(len(nums)):
            # Avoid duplicates for the first element
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # Two-pointer approach
            left, right = i + 1, len(nums) - 1
            while left < right:
                current_sum = nums[i] + nums[left] + nums[right]
                if current_sum == 0:
                    result.append([nums[i], nums[left], nums[right]])

                    # Move pointers and avoid duplicates
                    left += 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    right -= 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1

                elif current_sum < 0:
                    left += 1  # Increase sum by moving left pointer rightward
                else:
                    right -= 1  # Decrease sum by moving right pointer leftward

        return result

    # Example usage:
    nums = [-1, 0, 1, 2, -1, -4]
    print(threeSum(nums))  # Output: [[-1, -1, 2], [-1, 0, 1]]
```


## 125. Valid Palindrome - Easy

Topics:  Two Pointers, String 

### Intro
> A phrase is a palindrome if, after converting all uppercase letters into lowercase letters 
> and removing all non-alphanumeric characters, it reads the same forward and backward. 
> Alphanumeric characters include letters and numbers.
> Given a string s, return true if it is a palindrome, or false otherwise.

|  Input                             | Output  |  
| ---------------------------------- | ------- | 
| "A man, a plan, a canal: Panama"   | true    | 
| "race a car"                       | false   |
| " "                                | true    |

Constraints:
string s consists only of printable ASCII characters.

### Abstraction 
Using two pointers, L and R, we can traverse the string validating palindrome status.

We can convert the string s into lowercase, 
traverse using pointers comparing characters on the start and end of the string.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force One Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer In Place | O(n) | O(1) | Iterate over string of n length O(n) | No additional memory allocation for in place comparison O(1) |

### Brute Force One Pointer
```python
    def isPalindrome(self, s: str) -> bool:

        # space complexity: list to store cleaned string of n length O(n)
        cleaned = []

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:

            if alphaNum(c):
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # time complexity: two pointer iteration of string of n length O(n)
        n = len(cleaned)
        for i in range(n // 2):
            if cleaned[i] != cleaned[n - i - 1]:
                return False

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterate over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Palindrome Check | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(n) | Iterating over list of n length dominates leading to O(n) | Memory allocation to store clean string of n length dominates leading to O(n) | 

### Solution 1: Two Pointers
Application: Opposite Ends
```python
    def isPalindrome(self, s: str) -> bool:
        
        # space complexity: list to store cleaned string of n length O(n)
        cleaned = []

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:
            # Check if character is alphanumeric
            if isAlphaNum(c):
                # Convert uppercase to lowercase
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # time complexity: two-pointer traversal of cleaned string O(n)
        left, right = 0, len(cleaned) - 1
        while left < right:
            if cleaned[left] != cleaned[right]:
                return False
            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterating over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over list of n length dominates leading to O(n) | No additional memory allocation for comparison O(1) | 


### Solution 2: Two Pointers In Place
Application: Opposite Ends
```python 
    def isPalindrome(self, s: str) -> bool:
        # space complexity: no additional space used for storage O(1)
        left, right = 0, len(s) - 1

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iteration over string of n length O(n)
        while left < right:
            # time complexity: moving left pointer to next alphanumeric character O(n)
            while left < right and not isAlphaNum(s[left]):
                left += 1

            # time complexity: moving right pointer to previous alphanumeric character O(n)
            while left < right and not isAlphaNum(s[right]):
                right -= 1

            # Convert characters to lowercase
            leftChar = s[left]
            if 'A' <= left_char <= 'Z':
                left_char = chr(ord(leftChar) + 32)

            rightChar = s[right]
            if 'A' <= right_char <= 'Z':
                rightChar = chr(ord(rightChar) + 32)

            # Compare characters
            if leftChar != rightChar:
                return False

            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return True
            
``` 

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over string n length dominates leading to O(n) | No additional memory allocation O(1) |


## 271. String Encode and Decode - Medium

Topics:  Two Pointers, Design

### Intro

> Design an algorithm to encode a list of strings to a single string.
> The encoded string is then decoded back to the original list of strings
> Please implement encode and decode

|  Input                           | Output                              |  
| -------------------------------- | ----------------------------------- | 
| ["leet", "code", "love", "you"]  | ["leet", "code", "love", "you"]     |
| ["we", "say", ":", "yes"]        | ["we", "say", ":", "yes"]           |

Constraints:

### Abstraction
We need to create an encode and decode function and mark the start of a new string
as well as its length.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Two Pointers Length Delimiter |  |  |  |  |

### Solution 1: One Pointer Length Delimiter
```python
    def encode(self, strs: List[str]) -> str:

        # python strings are immutable so concatenation creates new string time complexity o(n^2)
        # python list allows us to add encoded strings in O(n)
        # space complexity: storage for encoding all strings in a list O(n)
        encoded = []

        # time complexity: iterate over list of strings n length O(n)
        for s in strings:
            
            # time complexity: iterate over all chars in string O(n)

            # lenDelim = len + delim
            left = 0
            lenDelim = str(len(s)) + "#"

            # append each char of (length + delimiter) O(n)
            while left < len(lenDelim):
                encoded.append(lenDelim[left])
                left += 1
            
            # append each char of string itself O(n)
            left = 0
            while left < len(s):
                encoded.append(s[left])
                left += 1
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return ''.join(res)


    def decode(self, s: str) -> List[str]:

        # space complexity:
        decoded = []
        left = 0

        # time complexity: iterate over list of n chars O(n)
        while left < len(encoded):

            # time complexity: 
            currLen = 0
            while encoded[left] != "#":

                # grabbing value ensuring base 10
                currLen = currLen * 10 + int(encoded[i]) 
                left += 1

            # skip delimiter, point to string
            left += 1  

            # grabbing currLen many chars to form string
            # time complexity: 
            substring = ""
            while left < range(currLen)

                # forming string
                substring += encoded[left]
                left += 1
            
            # added string to decoded list of strings
            decoded.append(substring)

        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return decoded
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Encode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterating over list of n strings of n n length O(n) | Memory allocation for encoded string of length O(n)  |
| Decode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterate over encoded n strings with delimiter n length o(n) | Memory allocation for list of strings n length |


## 167. Two Sum II - Input Array Is Sorted - Medium

Topics:  Array, Two Pointers, Binary Search

### Intro
> Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, 
> find two numbers such that they add up to a specific target number. 
> Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length.
> Return the indices of the two numbers, index1 and index2, added by one as an 
> integer array [index1, index2] of length 2.
> The tests are generated such that there is exactly one solution. 
> You may not use the same element twice.

|  Input List          | Input Target | Output |  
| -------------- | ------ | ------ | 
| [2, 7, 11, 15] | 9      | [1,2]  |
| [2, 3, 4]      | 6      | [1,3]  |
| [-1, 0]        | -1     | [1,2]  |

Constraints:

Your solution must use only constant extra space O(1)

### Abstraction
Given a sorted array, find two numbers which add up to target.

Unlike Two Sum I, we do not neccesarrily have to traverse the entire array, as since
the given array is sorted, we can make assumptions about our traversal using l and r pointers.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (all pair comparison) | O(n<sup>2</sup>) | O(1) | For each pair of elements, we compare them, leading to quadratic number of comparison O(n<sup>2</sup>) | No additional memory allocation O(1) |
| Binary Search for Complement | O(n log n) | O(1) | Iterates over list of n elements O(n), performing binary search on each O(log n) leading to O(n log n) | No additional memory allocation O(1) |
| Two Pointers | Iterates through array of n length using two pointers O(n) | No additional memory allocation O(1) |  |  |

### Brute Force (all pairs comparison)
```python
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:

        # time complexity: iteration of O(n)
        for i in range(len(numbers)): 

            # time complexity: iteration of O(n^2)
            for j in range(i + 1, len(numbers)): 

                # time complexity: sum and comparison operations take constant O(1)
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]  # Convert to 1-indexed

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iterates over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Inner loop | O(n<sup>2</sup>) | O(1) | For each element in the outer loop, the inner loop iterates through all subsequent elements with Big(O) is O(n<sup>2</sup>). Derivation [here](/Notescommon-formulas#brute-case-double-for-loop) | No additional memory allocation for iteration O(1) |
| Comparison | O(1) | O(1) | Sum and comparison operations in constant O(1) | No additional memory allocation for sum or comparison O(1) | 
| Overall | O(n<sup>2</sup>) | O(1) | The inner loop dominates leading to O(n<sup>2</sup>) time complexity | No additional memory was allocated leading to constant O(1) space complexity. |


### Solution 1: Binary Search for Complement
```python 
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:
        
        # time complexity: iteration over list of n length O(n)
        for i in range(len(numbers)): 

            complement = target - numbers[i]
            
            # Binary search: O(log n)
            left, right = i + 1, len(numbers) - 1
            while left <= right:
                mid = (left + right) // 2
                if numbers[mid] == complement:

                    # Convert to 1-indexed array
                    return [i + 1, mid + 1]  
                elif numbers[mid] < complement:
                    left = mid + 1
                else:
                    right = mid - 1

        # overall: time complexity O(n log n)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iterates over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Binary Search | O(log n) | O(1) | Binary search over array for complement O(log n) | No additional memory allocation for binary search O(1) |
| Overall | O(n log n) | O(1) | Binary search for each element dominates leading to O(n log n) | No additional memory allocation leading to constant O(1). | 


### Solution 2: Two Pointers
```python
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:

        # space complexity: l and r pointers constant O(1)
        left, right = 0, len(numbers) - 1  

        # time complexity: iterate over list of n length until l and r pointers meet O(n)
        while left < right:

            # check current pointer values
            currSum = numbers[left] + numbers[right]  

            if currSum == target:
                # convert to 1-indexed array
                return [left + 1, right + 1]

            # increase left pointer to increase currSum
            elif currSum < target:
                left += 1

            # decrease right pointer to decrease currSum
            else:
                right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Pointer Loop | O(n) | O(1) | Left and right pointers iterate over list of n length O(n) | No additional memory allocation O(1) |
| Comparison | O(1) | O(1) | Sum and comparison operations take constant O(1) | No additional memory allocation for sum and comparison operations O(1) |
| Overall | O(n) | O(1) | Iterating with left and right pointers over list of n length dominates leading to O(n) | No additional memory allocation leading to constant O(1) | 

## 15. 3Sum (Two Sum II.2) - Medium

Topics:  Array, Two Pointers, Sorting

### Intro
> Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] 
> such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
> Notice that the solution set must not contain duplicate triplets.

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [-1,0,1,2,-1,-4] | [[-1,-1,2],[-1,0,1]]  |
| [0,1,1]          | []                    |
| [0,0,0]          | [[0,0,0]]             |

Constraints:

### Abstraction
Given an array find all the groups of 3 integers that add up to 0, without duplicates.

Sorting vs non-sorting is the first distinction which will lead to different solutions.

We can:
- Sort by increasing value
- Sort by parity

Both of these give us different assumptions we can use to our advantage as we traverse the array.
Let see:

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (all triplets comparison) |  |  |  |  |
| Hashmap (Two Sum I Approach) |  |  |  |  |
| Two Pointers Set |  |  |  |  |
| Two Pointers Early Breaks Set |  |  |  |  |

### Brute Force (all triplets comparison)
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        # space complexity: set of unique m triplets tuples O(m)
        res = set() 
        n = len(nums)

        # time complexity: n choose three for all triplet combinations / three nested loops O(n^3)
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    
                    # time complexity: sum and comparison operation in constant O(1)
                    if nums[i] + nums[j] + nums[k] == 0:

                        # time complexity: sorting 3 elements in near constant O(1)
                        triplet = sorted([nums[i], nums[j], nums[k]])
                        
                        # time complexity: insert operation in constant O(1)
                        res.add(tuple(triplet))

        # overall: time complexity O(n^3)
        # overall: space complexity O(,)
        return [list(triplet) for triplet in res]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 1. Hashmap Two Sum I Approach (No Sorting)
```python    
    def threeSum(self, nums: List[int]) -> List[List[int]]:
       
        # space complexity: set of unique m triplet tuples O(m)
        n = len(nums)
        res = set()

        # freezing one of the triple tuple values
        # time complexity: iteration over list of n length O(n)
        for i in range(n - 2):

            # grab complement
            target = -nums[i]
            seen = {}      # [ (value → its index), ...]

            # freezing second of the triple tuple values
            # time complexity: iteration over list of n length per outer iteration O(n^2)
            for j in range(i + 1, n):

                # grab complement
                complement = target - nums[j]

                # time complexity: lookup operation in constant O(1)
                if complement in seen:

                    # add unique tuple to res
                    triplet = tuple(sorted((nums[i], nums[j], complement)))
                    res.add(triplet)
                else:
                    seen[nums[j]] = j

        # overall: time complexity  
        # overall: space complexity 
        return [list(t) for t in res]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2: Two Pointers Early Break (Sorting)
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        # space complexity:
        results = set()
        n = len(nums)

        # time complexity:
        nums.sort()

        # time complexity
        for i in range(n - 2):

            #
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # early break: eliminate redundant comparisons
            # can't get to 0 without negative number
            if nums[i] > 0:
                break

            left, right = i + 1, n - 1
            while left < right:
                curr_sum = nums[i] + nums[left] + nums[right]

                if curr_sum == 0:
                    results.add((nums[i], nums[left], nums[right]))
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif curr_sum < 0:
                    left += 1
                else:
                    right -= 1

        # Time Complexity: O(n^2) for two-pointer traversal + O(n^2) for manual sorting.
        # Space Complexity: O(k), where k is the number of unique triplets.
        return [list(triplet) for triplet in results]
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

while this is arguably cleaner and more satisfying than the mini twoSum solution, this is again 
not utilziing two pointers. But its still a cool approach to the problem.


### Solution 3: Grouping By Parity (No Sorting)
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        p, n, z = [], [], []
        res = set()

        for i in nums:
            if i < 0:
                n.append(i)
            elif i > 0:
                p.append(i)
            else:
                z.append(i)

        # sets for access
        P, N = set(p), set(n)

        # 1. (0, num, -num) if at least one 0
        if len(z) > 0:
            for i in P:
                n_target = -i
                if n_target in N:
                    res.add((n_target, 0, i ))

        # 2. (0, 0, 0) if at least three 0's
        if len(z) > 2:
            res.add((0, 0, 0))

        # 3. (-, -, +) negative pairs
        for i in range(len(n)):
            for j in range(i+1, len(n)):
                p_target = -(n[i] + n[j])
                if p_target in P:
                    res.add(tuple(sorted([n[i], n[j], p_target])))
        
        # 4. (-, +, +) positive pairs
        for i in range(len(p)):
            for j in range(i+1, len(p)):
                n_target = -(p[i] + p[j])
                if n_target in N:
                    res.add(tuple(sorted([p[i], p[j], n_target])))

        return list(res)  
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


## 11. Container With Most Water - Medium

Topics:  Array, Two Pointers, Greedy

### Intro
> You are given an integer array height of length n. There are n vertical lines drawn 
> such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
> Find two lines that together with the x-axis form a container, 
> such that the container contains the most water.
> Return the maximum amount of water a container can store

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [1,8,6,2,5,4,8,3,7] | 49 | 
| [1,1] | 1 |

Constraints:

Notice you may not slant the container

### Abstract
We need to calculate the container with the most water.

The integer value represents the height of a side of a container, and the distance between
two sides is calculated using the index of the array

We can iterate over the array calculating the sides of the container that will 
give us the most water.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  |  |
| Two Pointer Early Break |  |  |  |  |

### Brute Force
```python
    def maxArea(self, height: List[int]) -> int:

        n = len(height)
        maxWater = 0
        
        # time complexity: iterate over array of n length O(n)
        for i in range(n - 1):

            # time complexity: iterate over array of n length for each outer iteration O(n^2)
            for j in range(i + 1, n):

                # calculate current water
                currWater = min(height[i], height[j]) * (j - i)
                maxWater = max(maxWater, currWater)
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return maxWater
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iteration over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Inner loop | O(n<sup>2</sup>) | O(1) | Iteration over list of n length per iteration in outer loop O(n<sup>2</sup>) | No additional memory allocation for iteration O(1) |
| Curr Water | O(1) | O(1) | Water height operation takes constant O(1) | No additional memory allocation O(1) | 
| Overall | O(n<sup>2</sup>) | O(1) | Inner loop dominates leading to O(n<sup>2</sup>) | No additional memory allocation leading to O(1) | 

### Solution 1: Two Pointer Early Break
```python
    def maxArea(self, height: List[int]) -> int:
        
        L, R = 0, len(height)-1
        maxWater = 0 

        # time complexity: iterate over list of n length with two pointers O(n)
        while L < R:

            # grabbing weak link
            smallerHeight = min(height[L], height[R])

            # calculate curr water = (smallerHeight * width)
            currWater = smallerHeight * (R-L)
            
            # compare to max
            maxWater = max(maxWater, currWater)

            # grabbing weak link, continue past it
            # time complexity: continue iterating over list n length with two pointers O(n)
            if height[L] < height[R]:
                L += 1

                # early break: eliminate redundant comparisons
                # by skipping heights guaranteed to be suboptimal
                while height[L] < smallerHeight:
                    L += 1 
            
            else:
                R -= 1

                # early break: eliminate redundant comparisons
                # by skipping heights guaranteed to be suboptimal 
                while height[R] < smallerHeight:
                    R -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return maxWater
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration | O(n) | O(1) | Iteration over list of n length with two pointers O(n) | No additional memory allocation for iteration O(1) |
| Curr Water | O(1) | O(1) | Water height operation takes constant O(1) | No additional memory allocation O(1) |
| Overall | O(n) | O(1) | Iteration over list of n length dominates leading to O(n) | No additional memory allocation O(1) | 

### Solution 2: Greedy 

## 42. Trapping Rain Water - Hard

Topics:  Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack

### Intro
> Given n non-negative integers representing an elevation map where the width of 
> each bar is 1, compute how much water it can trap after raining.

|  height                   | Output  |  
| ------------------------- | ------- | 
| [0,1,0,2,1,0,1,3,2,1,2,1] | 6       |
| [4,2,0,3,2,5]             | 9       |

Constraints: 

### Abstraction 
To calculate trapped water:

[1, 0, 1] -> 1 unit of water

[1, 0, 2] -> 1 unit of water

[1, 0, 0] -> 0 units of water

Definition of trapped water is: [ min(left, right) - currHeight ]

Now we need a way to traverse the array that allows us to take advantage of this pattern.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  |  |
| Two Pointer Early Break |  |  |  |  |
|  |  |  |  |  |



### Brute Force
```python
    def trap(self, height: List[int]) -> int:
        n = len(height)
        water = 0

        # time complexity: iterate over list of n length o(n)
        for i in range(n):

            # Use two pointers to calculate leftMax and rightMax
            leftMax, left = 0, i
            rightMax, right = 0, i

            # time complexity: iterate over left hand side of list n length per outer iteration O(n^2)
            while left >= 0:
                leftMax = max(leftMax, height[left])
                left -= 1

            # time complexity: iterate over right hand side of list n length per outer iteration O(n^2)
            while right < n:
                rightMax = max(rightMax, height[right])
                right += 1

            # curr water trapped for curr bar i
            water += min(leftMax, rightMax) - height[i]

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return water
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate |  |  |  |  |
| Left/Right max |  |  |  |  |
| Curr Water |  |  |  |  | 
| Overall | | | | |

### Find the Bug: Two Pointers Early Break
```python 
    def trap(self, height: List[int]) -> int:
        
        L, R = 0, len(height) - 1
        water = 0

        # setting curr left/right max to ends of list
        leftMax, rightMax = height[L], height[R]

        # time complexity: iterate over list of n length with two pointers O(n)
        while L < R:
            
            # grabbing weak link
            if height[L] < height[R]:
                # INCORRECT: skips water trapped at previous position before the pointer moved
                L += 1

                # INCORRECT: updating leftMax *before* calculating trapped water causes error
                leftMax = max(leftMax, height[L])

                # INCORRECT: water calculation uses updated leftMax prematurely
                water += min(leftMax, rightMax) - height[L]

            # grabbing weak link
            else: 
                # INCORRECT: skips water trapped at previous position before the pointer moved
                R -= 1

                # INCORRECT: updating rightMax *before* calculating trapper water causes error
                rightMax = max(rightMax, height[R])

                # INCORRECT: water calculation uses updated rightMax prematurely
                water += min(leftMax, rightMax) - height[R]
        
        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return water
```


### Solution 1: Two Pointers Early Break
```python
    def trap(self, height: List[int]) -> int:

        # Set initial variables
        L, R = 0, len(height) - 1
        water = 0
        leftMax, rightMax = 0, 0

        # time complexity: iterate over list of n length with two pointers O(n)
        while L <= R:

            # grabbing weak link
            if height[L] < height[R]:

                # Update leftMax
                if height[L] >= leftMax:
                    leftMax = height[L]

                # outer if/else implies right is taller, so simply add to water count
                else:
                    water += leftMax - height[L]

                # shifting pointer after calculation
                L += 1

            # grabbing weak link
            else:
                # Update rightMax
                if height[R] >= rightMax:
                    rightMax = height[R]

                # outer if/else implies left is taller, so simply add to water count
                else:
                    water += rightMax - height[R]

                # shifting pointer after calculation
                R -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Solution 2: Monotonic Stack
```python
    def trap(self, height: List[int]) -> int:
        stack = []  # Monotonic stack to store indices
        water = 0
        n = len(height)

        # Traverse the height array
        for i in range(n):
            # While current height > height at stack top (possible water trap)
            while stack and height[i] > height[stack[-1]]:
                top = stack.pop()  # Index of the bottom of the trapped water

                # No water can be trapped without both left and right walls
                if not stack:
                    break

                # Calculate the distance and bounded height
                distance = i - stack[-1] - 1
                bounded_height = min(height[i], height[stack[-1]]) - height[top]
                water += distance * bounded_height

            stack.append(i)

        # overall: time complexity O(n)
        # overall: space complexity O(n) (due to the stack)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 3: Dynamic Programming
```python
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n == 0:
            return 0

        # Arrays to store max heights from the left and right
        left_max = [0] * n
        right_max = [0] * n
        water = 0

        # Calculate left max for each bar
        left_max[0] = height[0]
        for i in range(1, n):
            left_max[i] = max(left_max[i - 1], height[i])

        # Calculate right max for each bar
        right_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            right_max[i] = max(right_max[i + 1], height[i])

        # Calculate trapped water for each bar
        for i in range(n):
            water += min(left_max[i], right_max[i]) - height[i]

        # overall: time complexity O(n)
        # overall: space complexity O(n) (for left_max and right_max arrays)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 