---
title: "LeetCode: Two Pointers"
description: "two pointers"
image: "../../public/Notes/two-pointer.png"
publishedAt: "2025-05-28"
updatedAt: "2025-05-31"
author: "jonathancamberos"
isPublished: true
tags: 
- data structures and algorithms
---

## Two Pointers Intro
Leetcode problems with elegant solutions using two pointers. 

### What are Two Pointers
Two Pointers is the strategy of using a Left and Right pointer to iterate over 
a data structure, usually an array, to solve a problem.

### Two Pointers Application: One Pointer with Auxiliary State
Use a single pointer to scan linearly and keep track of additional state 
variables to simulate a second pointer.

Ex: Move all zeros while maintaining order
```python
    def move_zeros(nums: list[int]) -> None:
        # `last_non_zero_found_at` tracks the position where the next non-zero
        # element should be placed, simulating a second pointer.
        last_non_zero_found_at = 0

        for current in range(len(nums)):
            if nums[current] != 0:
                nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]
                last_non_zero_found_at += 1

    # arr = [0, 1, 0, 3, 12] 
    # move_zeros(arr)  Output: [1, 3, 12, 0, 0]
```

### Two Pointers Application: Opposite Ends
We can have two pointers starting at opposite ends of a list and move them inward 
while validating some sort of logic.

Ex: Determine if a string is a palindrome
```python
    def is_palindrome(s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    # Example:
    print(is_palindrome("radar"))  # Output: True
    print(is_palindrome("hello"))  # Output: False
```

### Two Pointers Application: Sliding Window
We can have two pointers represent a window over a sequence that expands or shrinks
to satisfy a condition.

Ex: Find the length of the longest substring without repeating characters.
```python
    def longest_unique_substring(s: str) -> int:
        char_set = set()
        left = 0
        max_length = 0

        for right in range(len(s)):
            while s[right] in char_set:
                char_set.remove(s[left])
                left += 1
            char_set.add(s[right])
            max_length = max(max_length, right - left + 1)
        
        return max_length

    # Example:
    print(longest_unique_substring("abcabcbb"))  # Output: 3
```


### Two Pointers Application: Fast & Slow Pointers 
We can have have two pointers moving at different speeds to detect cycles or find midpoints
in linked lists or arrays.

Ex: Detect a cycle in a linked list.
```python
    class ListNode:
        def __init__(self, value=0, next=None):
            self.value = value
            self.next = next

    def has_cycle(head: ListNode) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False

    # Example:
    # Construct a list with a cycle: 1 -> 2 -> 3 -> 4 -> 2 (cycle)
    node1 = ListNode(1)
    node2 = ListNode(2)
    node3 = ListNode(3)
    node4 = ListNode(4)
    node1.next = node2
    node2.next = node3
    node3.next = node4
    node4.next = node2
    print(has_cycle(node1))  # Output: True
```

### Two Pointers Application: Partitioning
We can have two pointers in the same array moving inward/outward to rearrange elements
based on a condition.

Ex: Move all zeros in an array to the end while maintaining the order of other elements
```python
    def move_zeros(nums):
        left, right = 0, 0
        while right < len(nums):
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1
        return nums

    # Example:
    print(move_zeros([0, 1, 0, 3, 12]))  # Output: [1, 3, 12, 0, 0]
```

### Two Pointers Application: Parallel Pointer Traversal 
We can have two pointers traversing two separate arrays in parallel to merge, compare,
or find intersections.

Ex: Merge two sorted arrays into one sorted array
```python
    def merge_sorted_arrays(arr1, arr2):
        result = []
        i, j = 0, 0

        while i < len(arr1) and j < len(arr2):
            if arr1[i] < arr2[j]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        result.extend(arr1[i:])
        result.extend(arr2[j:])
        return result

    # Example:
    print(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))  # Output: [1, 2, 3, 4, 5, 6]
```

### Two Pointer Application: Catchup
We have two pointers traversing one array. One remains frozen, but catches up
to the other after logic is complete on a subsection.

Ex: Decode Two Pointer Splicing
```python

```

### Two Pointers Application: K Pointer Variants 
We can extend the two pointer case to track k pointers simultaneously.
These pointers can traverse the same list, different lists, or freeze while moving
other pointers.

Ex: Given an integer array nums, return all the unique triplets [nums[i], nums[j], nums[k]] that sum to 0.
```python
    def threeSum(nums):
        nums.sort()  # Step 1: Sort the array
        result = []

        for i in range(len(nums)):
            # Avoid duplicates for the first element
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # Two-pointer approach
            left, right = i + 1, len(nums) - 1
            while left < right:
                current_sum = nums[i] + nums[left] + nums[right]
                if current_sum == 0:
                    result.append([nums[i], nums[left], nums[right]])

                    # Move pointers and avoid duplicates
                    left += 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    right -= 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1

                elif current_sum < 0:
                    left += 1  # Increase sum by moving left pointer rightward
                else:
                    right -= 1  # Decrease sum by moving right pointer leftward

        return result

    # Example usage:
    nums = [-1, 0, 1, 2, -1, -4]
    print(threeSum(nums))  # Output: [[-1, -1, 2], [-1, 0, 1]]
```

### Two Pointers Application: Algorithm
Case where a problem that seems to require Two Pointers is easily solved by 
an algorithm specifically made for that problem

Ex: Manacher's Algorithm, find the longest palindromic substring 
```python
    def longestPalindrome(s: str) -> str:
        # Preprocess the string to handle even-length palindromes
        t = "#".join(f"^{s}$")
        n = len(t)
        p = [0] * n
        center = right = 0

        
        for i in range(1, n - 1):
            mirror = 2 * center - i  # Mirror of `i` with respect to `center`

            # If within bounds of the current right boundary
            if i < right:
                p[i] = min(right - i, p[mirror])

            # Expand around `i`
            while t[i + p[i] + 1] == t[i - p[i] - 1]:
                p[i] += 1

            # Update the center and right boundary if the palindrome is expanded
            if i + p[i] > right:
                center = i
                right = i + p[i]

        # Find the maximum length palindrome
        max_len, center_index = max((n, i) for i, n in enumerate(p))
        start = (center_index - max_len) // 2  # Convert index back to original string
        return s[start: start + max_len]
```



## 125. Valid Palindrome - Easy

Topics:  Two Pointers, String 

### Intro
> A phrase is a palindrome if, after converting all uppercase letters into lowercase letters 
> and removing all non-alphanumeric characters, it reads the same forward and backward. 
> Alphanumeric characters include letters and numbers.
> Given a string s, return true if it is a palindrome, or false otherwise.

|  Input                             | Output  |  
| ---------------------------------- | ------- | 
| "A man, a plan, a canal: Panama"   | true    | 
| "race a car"                       | false   |
| " "                                | true    |

Constraints:
string s consists only of printable ASCII characters.

### Abstraction 
Using two pointers, L and R, we can traverse the string validating palindrome status.

We can convert the string s into lowercase, 
traverse using pointers comparing characters on the start and end of the string.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force One Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer | O(n) | O(n) | Iterate over string of n length O(n) | Memory allocation for cleaned list of n length O(n) |
| Two Pointer In Place | O(n) | O(1) | Iterate over string of n length O(n) | No additional memory allocation for in place comparison O(1) |

### Brute Force One Pointer
```python
    def isPalindrome(self, s: str) -> bool:

        # space complexity: list to store cleaned string of n length O(n)
        cleaned = []

        # simple way for alphaNum check
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:

            if alphaNum(c):
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # time complexity: two pointer iteration of string of n length O(n)
        n = len(cleaned)
        for i in range(n // 2):
            if cleaned[i] != cleaned[n - i - 1]:
                return False

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterate over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Palindrome Check | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(n) | Iterating over list of n length dominates leading to O(n) | Memory allocation to store clean string of n length dominates leading to O(n) | 

### Solution 1: Compare Ends Pre Clean - Two Pointers/Opposite Ends
```python
    def isPalindrome(self, s: str) -> bool:
        
        # space complexity: cleaned version string of n length O(n)
        cleaned = []

        # alphaNum check using ord()
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iterate over string of n length O(n)
        for c in s:

            # skip until alphaNum char
            if isAlphaNum(c):
                
                # Convert to lowercase char
                if 'A' <= c <= 'Z':
                    cleaned.append(chr(ord(c) + 32))
                else:
                    cleaned.append(c)

        # clean is now lowercase alphaNum
        # compare using left and right pointers
        # time complexity: iterate over list of n length O(n)
        left, right = 0, len(cleaned) - 1
        while left < right:
            if cleaned[left] != cleaned[right]:
                return False
            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return True
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Cleaned list | O(n) | O(n) | Iterating over list of n length O(n) | Memory allocation to store clean string of n length O(n) |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over list of n length dominates leading to O(n) | No additional memory allocation for comparison O(1) | 


### Solution 2: Compare Ends In Place - Two Pointers/Opposite Ends
```python 
    def isPalindrome(self, s: str) -> bool:
        # space complexity: no additional space used for storage O(1)
        left, right = 0, len(s) - 1

        # alphaNum check using ord()
        def alphaNum(c):
            return (ord('A') <= ord(c) <= ord('Z') or 
                    ord('a') <= ord(c) <= ord('z') or 
                    ord('0') <= ord(c) <= ord('9'))

        # time complexity: iteration over string of n length O(n)
        while left < right:
            
            # time complexity: move left and right to alphaNum char O(n)
            while left < right and not isAlphaNum(s[left]):
                left += 1
            while left < right and not isAlphaNum(s[right]):
                right -= 1

            # Convert left and right to lowercase char
            leftChar = s[left]
            if 'A' <= leftChar <= 'Z':
                leftChar = chr(ord(leftChar) + 32)
            rightChar = s[right]
            if 'A' <= rightChar <= 'Z':
                rightChar = chr(ord(rightChar) + 32)

            # Compare left and right char
            if leftChar != rightChar:
                return False

            left += 1
            right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return True
            
``` 

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Two Pointer | O(n) | O(1) | Comparison operation of two chars takes constant O(1) for string of n length O(n) | No additional memory allocation for comparison or iteration O(1) |
| Overall | O(n) | O(1) | Iterating over string n length dominates leading to O(n) | No additional memory allocation O(1) |


## 271. String Encode and Decode - Medium

Topics:  Two Pointers, Design

### Intro

> Design an algorithm to encode a list of strings to a single string.
> The encoded string is then decoded back to the original list of strings
> Please implement encode and decode.
> strs[i] contains only UTF-8 characters.

|  Input                           | Output                              |  
| -------------------------------- | ----------------------------------- | 
| ["leet", "code", "love", "you"]  | ["leet", "code", "love", "you"]     |
| ["we", "say", ":", "yes"]        | ["we", "say", ":", "yes"]           |

Constraints:

### Abstraction
We need to create an encode and decode function and mark the start of a new string
as well as its length.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Two Pointers Length Delimiter |  |  |  |  |

### Find the Bug: (did not convert len using int())
```python
    def decode(self, encoded: str) -> List[str]:

        # space complexity: list of n strings O(n) each of n length O(n), leading to O(n^2)
        decoded = []
        left = 0

        # time complexity: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)
        while left < len(encoded):

            # grab length prefix behind "#" delimiter
            right = left
            while encoded[right] != "#":
                right += 1

            # splicing the length of the string
            # INCORRECT: 
            # length is a string, cannot use it to index or add
            # need to use int()
            length = encoded[left:right]

            # skip delimiter, point to start of string
            right += 1

            # splicing the string of 'length' characters
            # time complexity: splice over string n length O(n) for n iterations O(n), leading to O(n^2)
            decoded.append(encoded[right:right + length])

            # skip string, point to start of next len
            left = right + length

        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return decoded
```

### Solution 1: Two Pointer Splicing Delimiter - Two Pointers/Catchup
```python
    def encode(self, strs: List[str]) -> str:

        # Note: python strings are immutable so concatenation with += "" 
        # python creates new string time complexity o(n^2)
        # python list .append() modifies list in place by adding a single
        # element at end in O(1) operation
        # so doing .append() with a "".join() at the end is more efficient  

        # space complexity: for n strings O(n) store n characters O(n), leading to O(n^2)
        encoded = []

        # time complexity: iterate over list of n strings O(n)
        for s in strs:
            
            # lenDelim = len + delim
            lenDelim = str(len(s)) + "#"

            # append length and delimiter "5#"
            left = 0
            while left < len(lenDelim):
                encoded.append(lenDelim[left])
                left += 1
            
            # append string itself
            # time complexity: iterate over string of n length O(n), for n iterations, leading to O(n^2)
            left = 0
            while left < len(s):
                encoded.append(s[left])
                left += 1
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return ''.join(encoded)


    def decode(self, encoded: str) -> List[str]:

        # space complexity: list of n strings O(n) each of n length O(n), leading to O(n^2)
        decoded = []
        left = 0

        # time complexity: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)
        while left < len(encoded):

            # grab length prefix behind "#" delimiter
            right = left
            while encoded[right] != "#":
                right += 1

            # splicing the length of the string
            length = int(encoded[left:right])

            # skip delimiter, point to start of string
            right += 1

            # splicing the string of 'length' characters
            # time complexity: splice over string n length O(n) for n iterations O(n), leading to O(n^2)
            decoded.append(encoded[right:right + length])

            # skip string, point to start of next len
            left = right + length

        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return decoded
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Encode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterating over list of n strings of n n length O(n) | Memory allocation for encoded string of length O(n)  |
| Decode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterate over encoded n strings with delimiter n length o(n) | Memory allocation for list of strings n length |


### Solution 2: One Pointer Base 10 Delimiter - Two Pointers/One Pointer with Auxiliary State
```python
    def encode(self, strs: List[str]) -> str:

        # Note: python strings are immutable so concatenation with += "" 
        # python creates new string time complexity o(n^2)
        # python list .append() modifies list in place by adding a single
        # element at end in O(1) operation
        # so doing .append() with a "".join() at the end is more efficient  

        # space complexity: for n strings O(n) store n characters O(n), leading to O(n^2)
        encoded = []

        # time complexity: iterate over list of strings n length O(n)
        for s in strs:
            
            # lenDelim = len + delim
            lenDelim = str(len(s)) + "#"

            # append length and delimiter "5#"
            left = 0
            while left < len(lenDelim):
                encoded.append(lenDelim[left])
                left += 1
            
            # append string itself
            # time complexity: iterate over string of n length O(n), for n iterations, leading to O(n^2)
            left = 0
            while left < len(s):
                encoded.append(s[left])
                left += 1
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return ''.join(encoded)


    def decode(self, encoded: str) -> List[str]:

        # space complexity: list of n strings O(n) each of n length O(n), leading to O(n^2)
        decoded = []
        left = 0

        # time complexity: iterate over representation of n strings O(n) each of n length O(n), leading to O(n^2)
        while left < len(encoded):

            # grab length prefix behind "#" delimiter
            currLen = 0
            while encoded[left] != "#":

                # grabbing value while calculating base 10 of prev
                currLen = currLen * 10 + int(encoded[left]) 
                left += 1

            # skip delimiter, point to start of string
            left += 1  

            # extract substring of 'currLen' characters
            # time complexity: iterate over string n length O(n) for n iterations O(n), leading to O(n^2)
            substring = []
            for _ in range(currLen):

                # forming string
                substring.append(encoded[left])
                left += 1
            
            # left is pointing to start of next len

            # add string to decoded list of strings
            decoded.append(''.join(substring))


        # overall: time complexity O(n^2)
        # overall: space complexity O(n^2)
        return decoded
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Encode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterating over list of n strings of n n length O(n) | Memory allocation for encoded string of length O(n)  |
| Decode loop | O(n<sup>2</sup>) | O(n<sup>2</sup>) | Iterate over encoded n strings with delimiter n length o(n) | Memory allocation for list of strings n length |


## 167. Two Sum II (Input Array Is Sorted) - Medium

Topics:  Array, Two Pointers, Binary Search

### Intro
> Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, 
> find two numbers such that they add up to a specific target number. 
> Let these two numbers be numbers[index1] and numbers[index2] where 1 &le; index1 &lt; index2 &le; numbers.length.
> Return the indices of the two numbers, index1 and index2, added by one as an 
> integer array [index1, index2] of length 2.
> The tests are generated such that there is exactly one solution. 
> You may not use the same element twice.

|  Input List    | Input Target | Output |  
| -------------- | ------ | ------ | 
| [2, 7, 11, 15] | 9      | [1,2]  |
| [2, 3, 4]      | 6      | [1,3]  |
| [-1, 0]        | -1     | [1,2]  |

Constraints:

Your solution must use only constant extra space O(1)

### Abstraction
Given a sorted array, find two numbers which add up to target.

Unlike Two Sum I, we do not neccesarrily have to traverse the entire array, as since
the given array is sorted, we can make assumptions about our traversal using l and r pointers.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (all pair comparison) | O(n<sup>2</sup>) | O(1) | For each pair of elements, we compare them, leading to quadratic number of comparison O(n<sup>2</sup>) | No additional memory allocation O(1) |
| Binary Search for Complement | O(n log n) | O(1) | Iterates over list of n elements O(n), performing binary search on each O(log n) leading to O(n log n) | No additional memory allocation O(1) |
| Two Pointers | Iterates through array of n length using two pointers O(n) | No additional memory allocation O(1) |  |  |

### Brute Force (all pairs comparison)
```python
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:

        # time complexity: iteration of O(n)
        for i in range(len(numbers)): 

            # time complexity: iteration of O(n^2)
            for j in range(i + 1, len(numbers)): 

                # time complexity: sum and comparison operations take constant O(1)
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]  # Convert to 1-indexed

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iterates over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Inner loop | O(n<sup>2</sup>) | O(1) | For each element in the outer loop, the inner loop iterates through all subsequent elements with Big(O) is O(n<sup>2</sup>). Derivation [here](/Notescommon-formulas#brute-case-double-for-loop) | No additional memory allocation for iteration O(1) |
| Comparison | O(1) | O(1) | Sum and comparison operations in constant O(1) | No additional memory allocation for sum or comparison O(1) | 
| Overall | O(n<sup>2</sup>) | O(1) | The inner loop dominates leading to O(n<sup>2</sup>) time complexity | No additional memory was allocated leading to constant O(1) space complexity. |


### Solution 1: BinarySearch Per Element for Complement - Two Pointers/One Pointer with Auxiliary State
```python 
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:
        
        # time complexity: iteration over list of n length O(n)
        for i in range(len(numbers)): 

            # search for complement
            currComplementSearch = target - numbers[i]
            
            # Set up BinarySearch
            # set new left boundary for iteration BinarySearch
            # reset right boundary for iteration BinarySearch
            # given constraint index1 < index2
            # BinarySearch on right section of array after left element
            # time complexity: binarySearch O(log n) for each iteration O(n), leading to O(n log n)
            left, right = i + 1, len(numbers) - 1
            
            # BinarySearch
            # "<=": working within subarray [i+1, j] separate from i, 
            # so must evaluate num at left == right, as might be currComplementSearch
            # Base Case: no more array remaining to search
            # complement for numbers[i] was not found, continue iteration
            while left <= right:
                
                # middle element
                midIndex = (left + right) // 2
                midNum = numbers[midIndex]

                # found target complement
                if midNum == currComplementSearch:
                    # convert to 1-indexed array, per input/output example
                    return [i + 1, midIndex + 1]  

                # "BinarySearch" on relevant subsection
                # update left or right pointer
                elif midNum < currComplementSearch:
                    left = midIndex + 1
                else:
                    right = midIndex - 1

        # overall: time complexity O(n log n)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iterates over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Binary Search | O(log n) | O(1) | Binary search over array for complement O(log n) | No additional memory allocation for binary search O(1) |
| Overall | O(n log n) | O(1) | Binary search for each element dominates leading to O(n log n) | No additional memory allocation leading to constant O(1). | 


### Solution 2: Opposite Ends Pointer Shift by BinarySearch Modification for Target - Two Pointers/Opposite Ends
```python
    def twoSumII(self, numbers: List[int], target: int) -> List[int]:

        # Set up BinarySearch Modification
        # initialize outer pointers
        # space complexity: left and right pointers constant O(1)
        left, right = 0, len(numbers) - 1  

        # BinarySearch Modification
        # "<": working within subarray containing left and right
        # cannot evaluate num at left == right, breaks constraints of index1 < index2
        # Base Case: no more array remaining to search, 
        # return []
        # time complexity: iterate over list of n length O(n)
        while left < right:

            # grab current sum
            currSum = numbers[left] + numbers[right]  

            # found target sum
            if currSum == target:
                # convert to 1-indexed array, per input/output example
                return [left + 1, right + 1]

            # "BinarySearch" on relevant subsection
            # update left or right pointer
            elif currSum < target:
                left += 1
            else:
                right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return []
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Pointer Loop | O(n) | O(1) | Left and right pointers iterate over list of n length O(n) | No additional memory allocation O(1) |
| Comparison | O(1) | O(1) | Sum and comparison operations take constant O(1) | No additional memory allocation for sum and comparison operations O(1) |
| Overall | O(n) | O(1) | Iterating with left and right pointers over list of n length dominates leading to O(n) | No additional memory allocation leading to constant O(1) | 

## 15. 3Sum - Medium

Topics:  Array, Two Pointers, Sorting, Binary Search

### Intro
> Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] 
> such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
> Notice that the solution set must not contain duplicate triplets.

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [-1,0,1,2,-1,-4] | [[-1,-1,2],[-1,0,1]]  |
| [0,1,1]          | []                    |
| [0,0,0]          | [[0,0,0]]             |

Constraints:

### Abstraction
Given an array find all the groups of 3 integers that add up to 0, without duplicates.

Sorting vs non-sorting is the first distinction which will lead to different solutions.

We can:
- Sort by increasing value
- Sort by parity

Both of these give us different assumptions we can use to our advantage as we traverse the array.
Let see:

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force (all triplets comparison) |  |  |  |  |
| Hashmap (Two Sum I Approach) |  |  |  |  |
| Two Pointers Set |  |  |  |  |
| Two Pointers Early Breaks Set |  |  |  |  |

### Brute Force (all triplets comparison)
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        # space complexity: set of unique m triplets tuples O(m)
        res = set() 
        n = len(nums)

        # time complexity: n choose three for all triplet combinations / three nested loops O(n^3)
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    
                    # time complexity: sum and comparison operation in constant O(1)
                    if nums[i] + nums[j] + nums[k] == 0:

                        # time complexity: sorting 3 elements in near constant O(1)
                        triplet = sorted([nums[i], nums[j], nums[k]])
                        
                        # time complexity: insert operation in constant O(1)
                        res.add(tuple(triplet))

        # overall: time complexity O(n^3)
        # overall: space complexity O(,)
        return [list(triplet) for triplet in res]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Brute Force Hashmap Two Sum I Approach (No Sorting)
```python    
    def threeSum(self, nums: List[int]) -> List[List[int]]:
       
        # space complexity: set of unique m triplet tuples O(m)
        n = len(nums)
        res = set()

        # freezing one of the triple tuple values
        # time complexity: iteration over list of n length O(n)
        for i in range(n - 2):

            # grab complement
            target = -nums[i]
            seen = {}      # [ (value â†’ its index), ...]

            # freezing second of the triple tuple values
            # time complexity: iteration over list of n length per outer iteration O(n^2)
            for j in range(i + 1, n):

                # grab complement
                complement = target - nums[j]

                # time complexity: lookup operation in constant O(1)
                if complement in seen:

                    # add unique tuple to res
                    triplet = tuple(sorted((nums[i], nums[j], complement)))
                    res.add(triplet)
                else:
                    seen[nums[j]] = j

        # overall: time complexity  
        # overall: space complexity 
        return [list(t) for t in res]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


### Find the Bug: List is unHashable
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        # Note: Two Sum vs 3Sum
        # Two sum, finding two numbers whose sum equals a target is simple
        # with hashmaps or two pointer approaches being efficient
        # 3Sum adds complexity with a third variable.
        # Grouping techniques aim to narrow and organize the solution space
        # reducing redundant checks while finding valid triplets

        # positive, negative, and zero sets
        # space complexity: 
        p, n, z = [], [], []
        
        # set ensures no duplicate triplets
        # space complexity: 
        res = set()

        # time complexity: iterate over list of n length O(n)
        for i in nums:
            if i < 0:
                n.append(i)
            elif i > 0:
                p.append(i)
            else:
                z.append(i)

        # sets for unique groups
        # time complexity: convert list into set O(n)
        P, N = set(p), set(n)

        # (0, num, -num)
        # time complexity: iterate over positive numbers list n length O(n)
        if len(z) > 0:
            for i in P:                
                # time complexity: negative target lookup in constant O(1)
                nTarget = -i
                if nTarget in N:
                    res.add((nTarget, 0, i))

        # (0, 0, 0)
        # time complexity: len operation constant O(1)
        if len(z) >= 3:
            res.add((0, 0, 0))

        # (-, -, +) negative pairs
        # time complexity: iterate over list of negative numbers n length O(n)
        for i in range(len(n)):
            # time complexity: iterate over list of negative numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(n)):
                # time complexity: lookup operation constant O(1)
                pTarget = -(n[i] + n[j])
                if pTarget in P:
                    # INCORRECT:
                    # sorted() -> List[int]
                    # cannot hash list into set()
                    # must use tuple(sorted())
                    res.add((sorted([n[i], n[j], pTarget])))
        
        # (-, +, +) positive pairs
        # time complexity: iterate over list of positive numbers n length O(n)
        for i in range(len(p)):
            # time complexity: iterate over list of positive numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(p)):
                # time complexity: lookup operation constant O(1)
                nTarget = -(p[i] + p[j])
                if nTarget in n:
                    # INCORRECT:
                    # sorted() -> List[int]
                    # cannot hash list into set()
                    # must use tuple(sorted())
                    res.add(tuple(sorted([p[i], p[j], nTarget])))

        # convert valid set of tuple triplets into valid list of tuple triplets

        # overall: time complexity O(n^2) 
        # overall: space complexity O(n)
        return list(res)  
```

### Find the Bug: Index Into Wrong Array [im half asleep rn ok? :) cut me some slack]
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        # Note: Two Sum vs 3Sum
        # Two sum, finding two numbers whose sum equals a target is simple
        # with hashmaps or two pointer approaches being efficient
        # 3Sum adds complexity with a third variable.
        # Grouping techniques aim to narrow and organize the solution space
        # reducing redundant checks while finding valid triplets

        # positive, negative, and zero sets
        # space complexity: 
        p, n, z = [], [], []
        
        # set ensures no duplicate triplets
        # space complexity: 
        res = set()

        # time complexity: iterate over list of n length O(n)
        for i in nums:
            if i < 0:
                n.append(i)
            elif i > 0:
                p.append(i)
            else:
                z.append(i)

        # sets for unique groups
        # time complexity: convert list into set O(n)
        P, N = set(p), set(n)

        # (0, num, -num)
        # time complexity: iterate over positive numbers list n length O(n)
        if len(z) > 0:
            for i in P:                
                # time complexity: negative target lookup in constant O(1)
                nTarget = -i
                if nTarget in N:
                    res.add((nTarget, 0, i ))

        # (0, 0, 0)
        # time complexity: len operation constant O(1)
        if len(z) >= 3:
            res.add((0, 0, 0))

        # (-, -, +) negative pairs
        # time complexity: iterate over list of negative numbers n length O(n)
        for i in range(len(n)):
            # time complexity: iterate over list of negative numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(n)):
                # time complexity: lookup operation constant O(1)
                # INCORRECT:
                # stop being half asleep, index into the correct array
                pTarget = -(nums[i] + nums[j])
                if pTarget in P:
                    # INCORRECT:
                    # stop being half asleep, index into the correct array
                    res.add(tuple(sorted([nums[i], nums[j], pTarget])))
        
        # (-, +, +) positive pairs
        # time complexity: iterate over list of positive numbers n length O(n)
        for i in range(len(p)):
            # time complexity: iterate over list of positive numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(p)):
                # time complexity: lookup operation constant O(1)
                # INCORRECT:
                # stop being half asleep, index into the correct array
                nTarget = -(nums[i] + nums[j])
                if nTarget in n:
                    # INCORRECT:
                    # stop being half asleep, index into the correct array
                    res.add(tuple(sorted([nums[i], nums[j], nTarget])))

        # convert valid set of tuple triplets into valid list of tuple triplets

        # overall: time complexity O(n^2) 
        # overall: space complexity O(n)
        return list(res)  
```

### Solution 1: Two Sum Mimic by Opposite Ends Pointer Shift by BinarySearch Modification Per Element for 0 (Sorting) - Two Pointers/K Pointer Variants
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        # Note: Two Sum vs 3Sum
        # Two sum, finding two numbers whose sum equals a target is simple
        # with hashmaps or two pointer solutions being efficient
        # 3Sum adds complexity with a third variable,
        # but converting 3Sum into a two sum problem allows
        # the use of hashmap or two pointer solutions again

        # set ensures no duplicate triplets
        # space complexity: 
        results = set()
        n = len(nums)

        # time complexity: default python sorting TimSort, O(n log n)
        nums.sort()

        # mimic 
        # time complexity
        for i in range(n - 2):

            # skip iteration:
            # i should only "BinarySearch" through any number once 
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # early break: 
            # only allow negative numbers for i in (i, j, k)
            if nums[i] > 0:
                break

            # Set up "BinarySearch" modification:          
            # set new left boundary for iteration BinarySearch
            # reset right boundary for iteration BinarySearch  
            left, right = i + 1, n - 1

            # "BinarySearch" modification: 
            # "<": working within subarray separate from i
            # cannot evaluate num at left == right given constraint i != j, i != k, j != k
            # Base case: no more array remaining to search
            # complement for numbers[i] was not found, 
            # continue iteration for i
            # time complexity: BinarySearch on subarray of n elements O(log n) for n iterations, leading to O(n log n)
            while left < right:
                
                # grab current sum (i, j, k)
                currSum = nums[i] + nums[left] + nums[right]

                # found target sum
                if currSum == 0:
                    
                    # add triplet to result set
                    results.add((nums[i], nums[left], nums[right]))

                    # skip iteration:
                    # j and k should only "BinarySearch" through any number once 
                    left += 1
                    right -= 1

                    # skip iteration:
                    # j and k should only "BinarySearch" through any number once 
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1

                # "BinarySearch" on relevant subsection
                # update left or right pointer
                elif currSum < 0:
                    left += 1
                else:
                    right -= 1

        # convert valid set of tuple triplets into valid list of tuple triplets

        # Time Complexity: O(n^2)
        # Space Complexity: O(n)
        return list(results)
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Sorting | O(n log n) | O(1) | Sorting array using TimSort in O(n log n) | No additional memory allocation for in place sorting |
| Outer Loop | O(n) | O(1) | Iterate over n elements O(n) | No additional memory allocation for iteration constant O(1) |
| Inner Loop | O(n<sup>2</sup>) | O(1) | Two pointer traversal for subarray search over n elements O(n) per outer iteration n O(n), leading to O(n<sup>2</sup>)  | No additional memory allocation for pointer traversal | 
| Result Storage | O(1) | O(n) | Insert takes constant O(1) | Stores k unique triplets O(k) which in worst case is just O(n) | 
| Overall | O(n<sup>2</sup>) | O(n) | Two pointer traversal for n elements dominates, leading to O(n<sup>2</sup>) | Worst case of n/3 valid triplets O(n/3), which leads to O(n) | 

### Solution 2: Grouping By Parity (No Sorting) - Two Pointers/Algorithm
```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        # Note: Two Sum vs 3Sum
        # Two sum, finding two numbers whose sum equals a target is simple
        # with hashmaps or two pointer approaches being efficient
        # 3Sum adds complexity with a third variable.
        # Grouping techniques aim to narrow and organize the solution space
        # reducing redundant checks while finding valid triplets

        # positive, negative, and zero sets
        # space complexity: 
        p, n, z = [], [], []
        
        # set ensures no duplicate triplets
        # space complexity: 
        res = set()

        # time complexity: iterate over list of n length O(n)
        for i in nums:
            if i < 0:
                n.append(i)
            elif i > 0:
                p.append(i)
            else:
                z.append(i)

        # sets for unique groups
        # time complexity: convert list into set O(n)
        P, N = set(p), set(n)

        # (0, num, -num)
        # time complexity: iterate over positive numbers list n length O(n)
        if len(z) > 0:
            for i in P:                
                # time complexity: negative target lookup in constant O(1)
                nTarget = -i
                if nTarget in N:
                    res.add((nTarget, 0, i ))

        # (0, 0, 0)
        # time complexity: len operation constant O(1)
        if len(z) >= 3:
            res.add((0, 0, 0))

        # (-, -, +) negative pairs
        # time complexity: iterate over list of negative numbers n length O(n)
        for i in range(len(n)):
            # time complexity: iterate over list of negative numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(n)):
                # time complexity: lookup operation constant O(1)
                pTarget = -(n[i] + n[j])
                if pTarget in P:
                    res.add(tuple(sorted([n[i], n[j], pTarget])))
        
        # (-, +, +) positive pairs
        # time complexity: iterate over list of positive numbers n length O(n)
        for i in range(len(p)):
            # time complexity: iterate over list of positive numbers n length O(n) per outer iteration O(n), leading to O(n^2)
            for j in range(i+1, len(p)):
                # time complexity: lookup operation constant O(1)
                nTarget = -(p[i] + p[j])
                if nTarget in n:
                    res.add(tuple(sorted([p[i], p[j], nTarget])))

        # convert valid set of tuple triplets into valid list of tuple triplets

        # overall: time complexity O(n^2) 
        # overall: space complexity O(n)
        return list(res)  
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Grouping Iteration | O(n) | O(n) | Iterate over list of n length to group into positive, negative, and zero lists O(n) | Grouping list of n length into three groups O(n) |
| Conversion to Sets | O(n) | O(n) | Convert list of positive and negative numbers into sets O(n) | Convert list of n length O(n) |
| Inverse Check | O(n) | O(1) | Iterate over positive list n length O(n) and lookup inverse in negative set O(1), leading to O(n) | No additional memory allocation for iteration O(1) | 
| Zero Check | O(1) | O(1) | Zero list len check in constant O(1) | No additional memory allocation for len check O(1) | 
| Negative Pairs | O(n<sup>2</sup>) | O(n) | Outer/Inner iteration over list of negative numbers O(n<sup>2</sup>) with inverse positive lookup O(1), leading to O(n<sup>2</sup>) | Adding n/3 triplets to result O(n/3), leading to O(n) | 
| Positive Pairs | O(n<sup>2</sup>) | O(n) | Outer/Inner iteration over list of positive numbers O(n<sup>2</sup>) with inverse positive lookup O(1), leading to O(n<sup>2</sup>) | Adding n/3 triplets to result O(n/3), leading to O(n) | 
| Overall | O(n<sup>2</sup>) | O(n) | Negative and positive iterations dominate leading to O(n<sup>2</sup>) | Memory allocation for n/3 valid triplets, leading to O(n) | 


## 11. Container With Most Water - Medium

Topics:  Array, Two Pointers, Greedy

### Intro
> You are given an integer array height of length n. There are n vertical lines drawn 
> such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
> Find two lines that together with the x-axis form a container, 
> such that the container contains the most water.
> Return the maximum amount of water a container can store

|  nums            | Output                |  
| ---------------- | --------------------- | 
| [1,8,6,2,5,4,8,3,7] | 49 | 
| [1,1] | 1 |

Constraints:

trapped water involves the space between and including two walls (bars).
width = (right - left)

### Abstract
We need to calculate the container with the most water.

The integer value represents the height of a side of a container, and the distance between
two sides is calculated using the index of the array

We can iterate over the array calculating the sides of the container that will 
give us the most water.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  |  |
| Two Pointer Early Break |  |  |  |  |

### Brute Force
```python
    def maxArea(self, height: List[int]) -> int:

        n = len(height)
        maxWater = 0
        
        # time complexity: iterate over array of n length O(n)
        for i in range(n - 1):

            # time complexity: iterate over array of n length for each outer iteration O(n^2)
            for j in range(i + 1, n):

                # calculate current water
                currWater = min(height[i], height[j]) * (j - i)
                maxWater = max(maxWater, currWater)
        
        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return maxWater
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Outer loop | O(n) | O(1) | Iteration over list of n length O(n) | No additional memory allocation for iteration O(1) |
| Inner loop | O(n<sup>2</sup>) | O(1) | Iteration over list of n length per iteration in outer loop O(n<sup>2</sup>) | No additional memory allocation for iteration O(1) |
| Curr Water | O(1) | O(1) | Water height operation takes constant O(1) | No additional memory allocation O(1) | 
| Overall | O(n<sup>2</sup>) | O(1) | Inner loop dominates leading to O(n<sup>2</sup>) | No additional memory allocation leading to O(1) | 

### Solution 1: Greedy Opposite Ends Pointer Shift by BinarySearch Modification - Two Pointers/Opposite Ends 
```python
    def maxArea(self, height: List[int]) -> int:
        
        # set up "BinarySearch" modification
        left, right = 0, len(height)-1
        maxWater = 0 

        # time complexity: two pointer iteration over list of n length O(n)
        while left < right:

            # grab smaller height between outside pointers
            smallerHeight = min(height[left], height[right])

            # width includes walls: 
            # [1, 1] is 1 water, so (rightIndex - leftIndex) = width
            # calculate curr water between outside pointers, (smallerHeight * width)
            currWater = smallerHeight * (right-left)
            
            # compare to global max
            maxWater = max(maxWater, currWater)

            # Greedy:
            # As we move pointers inwards, width is guaranteed to get shrink
            # Thus, we can continue to move our pointers,
            # until we hit a bigger height than our current smaller height
            # time complexity: two pointer iteration over list of n length O(n)
            if height[left] < height[right]:
                # step past current left/right wall combination
                left += 1
                # Greedy:
                while left < right and height[left] < smallerHeight:
                    left += 1 
            else:
                # step past current left/right wall combination
                right -= 1
                # Greedy:
                while left < right and height[right] < smallerHeight:
                    right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return maxWater
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration | O(n) | O(1) | Iteration over list of n length with two pointers O(n) | No additional memory allocation for iteration O(1) |
| Curr Water | O(1) | O(1) | Water height operation takes constant O(1) | No additional memory allocation O(1) |
| Overall | O(n) | O(1) | Iteration over list of n length dominates leading to O(n) | No additional memory allocation O(1) | 

## 42. Trapping Rain Water - Hard

Topics:  Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack

### Intro
> Given n non-negative integers representing an elevation map where the width of 
> each bar is 1, compute how much water it can trap after raining.

|  height                   | Output  |  
| ------------------------- | ------- | 
| [0,1,0,2,1,0,1,3,2,1,2,1] | 6       |
| [4,2,0,3,2,5]             | 9       |

Constraints: 

trapped water involves the space between two walls (bars).
width = (right - left - 1)

### Abstraction 
To calculate trapped water:

[1, 0, 1] -> 1 unit of water

[1, 0, 2] -> 1 unit of water

[1, 0, 0] -> 0 units of water

Definition of trapped water is: [ min(left, right) - currHeight ]

Now we need a way to traverse the array that allows us to take advantage of this pattern.

### Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
| Brute Force |  |  |  |  |
| Two Pointer Early Break |  |  |  |  |
|  |  |  |  |  |



### Brute Force
```python
    def trap(self, height: List[int]) -> int:
        n = len(height)
        water = 0

        # time complexity: iterate over list of n length o(n)
        for i in range(n):

            # Use two pointers to calculate leftMax and rightMax
            leftMax, left = 0, i
            rightMax, right = 0, i

            # time complexity: iterate over left hand side of list n length per outer iteration O(n^2)
            while left >= 0:
                leftMax = max(leftMax, height[left])
                left -= 1

            # time complexity: iterate over right hand side of list n length per outer iteration O(n^2)
            while right < n:
                rightMax = max(rightMax, height[right])
                right += 1

            # curr water trapped for curr bar i
            water += min(leftMax, rightMax) - height[i]

        # overall: time complexity O(n^2)
        # overall: space complexity O(1)
        return water
```

|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iterate |  |  |  |  |
| Left/Right max |  |  |  |  |
| Curr Water |  |  |  |  | 
| Overall | | | | |

### Find the Bug: Two Pointers Early Break
```python 
    def trap(self, height: List[int]) -> int:
        
        L, R = 0, len(height) - 1
        water = 0

        # setting curr left/right max to ends of list
        leftMax, rightMax = height[L], height[R]

        # time complexity: iterate over list of n length with two pointers O(n)
        while L < R:
            
            # grabbing weak link
            if height[L] < height[R]:
                # INCORRECT: skips water trapped at previous position before the pointer moved
                L += 1

                # INCORRECT: updating leftMax *before* calculating trapped water causes error
                leftMax = max(leftMax, height[L])

                # INCORRECT: water calculation uses updated leftMax prematurely
                water += min(leftMax, rightMax) - height[L]

            # grabbing weak link
            else: 
                # INCORRECT: skips water trapped at previous position before the pointer moved
                R -= 1

                # INCORRECT: updating rightMax *before* calculating trapper water causes error
                rightMax = max(rightMax, height[R])

                # INCORRECT: water calculation uses updated rightMax prematurely
                water += min(leftMax, rightMax) - height[R]
        
        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return water
```


### Solution 1: Monotonic Traversal 2 Outer/2 Inner Pointers Creating Bounds Opposite Ends Pointer Shift by BinarySearch Modification (Sorting) - Two Pointers/K Pointer Variants
```python
    def trap(self, height: List[int]) -> int:

        # Note: 
        # Outer Pointers: act as wall/side to bound inner pointers
        # Inner Pointers: traverse inward from both ends to track height for current position
        # Water Trapping: compare inner pointer to outer pointers wall/side to determine 
        # if theres enough depth to trap water

        # Set up "BinarySearch" modification
        # outer pointers
        outerLeftMax, outerRightMax = 0, 0
        # inner pointers
        left, right = 0, len(height) - 1
        water = 0

        # Monotonic "BinarySearch" modification
        # time complexity: two pointer iteration over list of n length O(n)
        while left < right:

            # Monotonic "BinarySearch" on relevant subsection
            # implies: height[left] < height[right]
            # case 1: [5, 0, 3, 2, 4, 6], left < right for entire array 
            # case 2: [5, 0, 3, 9, 4, 6], left < right broken at some point
            # case 1 implies: while height[left] < height[right] 
            # and while height[left] < outerLeftMax
            # then: water is limited by outerLeft/outerRight 
            # as water will eventually be caught by right
            if height[left] < height[right]:

                # case 1: implication broken
                # implies: outerLeftMax < height[left] < height[right] 
                # then: update outerLeftMax             
                if height[left] >= outerLeftMax:
                    outerLeftMax = height[left]

                # case 1: implication applies
                # implies: height[left] < outerLeftMax < height[right]
                else:
                    water += outerLeftMax - height[left]

                # shift pointer
                left += 1

            # implies: height[right] < height[left]
            else:
                
                # case 1: implication broken
                # implies: outerRightMax < height[right] < height[left]     
                # then: update outerRightMax
                if height[right] >= outerRightMax:
                    outerRightMax = height[right]

                # case 1: implication applies
                # implies: height[right] < outerRightMax < height[left]
                else:
                    water += outerRightMax - height[right]

                # shift pointer
                right -= 1

        # overall: time complexity O(n)
        # overall: space complexity O(1)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| Iteration | O(n) | O(1) | Two pointer iteration over list of n length O(n) | No additional memory allocation required for iteration O(1) |
| Comparing Heights | O(1) | O(1) | Height lookup and comparison in constant O(1) | No additional memory allocation for lookup or comparison O(1) |
| Water Calculation | O(1) | O(1) | Water calculation and sum in constant O(1) | No additional memory allocation for water calculation or sum O(1) | 
| Overall | O(n) | O(1) | Two pointer iteration over list of n length dominates, leading to O(n) | No additional memory allocation required, leading to O(1) | 


### Solution 2: Monotonic Stack - Two Pointers/Algorithm
```python
    def trap(self, height: List[int]) -> int:

        # Note: 2 concepts here: 
        # Monotonic Stack: A stack that maintains non-increasing heights 
        # When non-increasing breaks: curr height will serve as right wall,
        # top of stack will serve as depth, and top of stack - 1 will serve as left wall

        # Monotonic stack to store indices
        stack = []  
        water = 0
        n = len(height)

        # push and pop each bar at most once
        # time complexity: iterate over list of n length O(n)
        for i in range(n):

            # Check: stack is non empty, depth candidate exists
            # Check: if current height[i] breaks non-increasing order,
            # will be viable to act as a right wall
            # implies: we keep appending while monotonic non-increasing stays valid
            # implies: stack is kept in monotonic non-increasing order
            # implies: when monotonic non-increasing breaks, we have found right wall
            while stack and height[i] > height[stack[-1]]:
                
                # height[i]: right wall
                # stack[-1]: depth candidate
                # stack[-2]: left wall

                # stack.pop(): stack[-1] depth candidate
                # while stack is non-empty:
                # keep grabbing new depth candidates and new left walls
                # we essentially drag the right wall over the monotonic stack, 
                # checking all: left wall + depth candidates
                # until a depth candidate is taller than the current right wall
                # then we just add the right wall to the stack maintaining monotonic order
                depthCandidate = stack.pop() 

                # Check: if stack empty after pop, no left wall exists
                # implies: cannot trap water, end while loop, add item to stack
                if not stack:
                    break

                # trapped water involves the space between two walls, excluding walls
                # width = (right - left - 1)

                # After stack.pop():
                # height[i]: right wall
                # depthCandidate: depth
                # stack[-1]: left wall
                # implies: depthCandidate < stack[-1] && depthCandidate < height[i]
                rightWall = i
                leftWall = stack[-1]
                distance = rightWall - leftWall - 1

                rightHeight = height[i]
                depthHeight = height[depthCandidate]
                leftHeight = height[leftWall]

                # subtract the depth minus smaller height to get water depth
                boundedHeight = min(rightHeight, leftHeight) - depthHeight

                # add the trapped water for the current segment 
                water += distance * boundedHeight

            # implies: monotonic non-increasing is still valid
            # implies: append height to stack
            stack.append(i)

        # overall: time complexity O(n)
        # overall: space complexity O(n) (due to the stack)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 

### Solution 3: Dynamic Programming - Two Pointers/Algorithm
```python
    def trap(self, height: List[int]) -> int:
        
        # Note:
        # Dynamic Programming Concept:
        # Left Maximum Array: Stores the maximum height encountered from the start up to each index i.
        # Right Maximum Array: Stores the maximum height encountered from the end up to each index i.
        # Avoid recomputing maximum heights repeatedly.

        n = len(height)
        if n == 0:
            return 0

        # Arrays to store max heights from the left and right
        # leftMax[i]: Maximum height from 0 to index i
        # rightMax[i]: Maximum height from index i to (n-1)
        leftMax = [0] * n
        rightMax = [0] * n
        water = 0

        # calculate left max for each bar
        # time complexity: iterate over list of n length O(n)
        leftMax[0] = height[0]
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        # calculate right max for each bar
        # time complexity: iterate over list of n length O(n)
        rightMax[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        # calculate trapped water for each bar
        # time complexity: iterate over list of n length O(n)
        for i in range(n):

            # The water trapped above bar i is determined by the minimum between
            # leftMax[i] and rightMax[i] minus the curr bar height
            water += min(leftMax[i], rightMax[i]) - height[i]

        # overall: time complexity O(n)
        # overall: space complexity O(n)
        return water
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
| LeftMax Calculation | O(n) | O(1) | Iterate over height list of n length O(n) | Stores max height for current index for list of n length O(n) |
| RightMax Calculation | O(n) | O(n) | Iterate over height list of n length O(n) | Store max height for current index for list of n length O(n) |
| Water Calculation | O(n) | o(1) | Iterate over max height list of n length O(n) | No additional memory allocation for water calculation O(n) | 
| Overall | O(n) | O(n) | Iterating over height list dominates, leading to O(n) | Memory allocation for leftMax and rightMax arrays dominates, leading to O(n) | 


## 5. Longest Palindromic Substring - Medium

Topics: Two Pointers, String, Dynamic Programming


### Intro
> Given a string s, return the longest palindromic substring in s. 

|  Input | Output  |  
| ------- | ------- | 
| "cbbd"  | "bb"           |
| "babad" | "bab" or "aba" |


Constraints: 

1  &leq; s.length &leq; 1000 

s consists of only digits and English letters.

### Abstraction 

Find the longest palindrome in a string.

### Solution 1: Manacher's Algorithm - Two Pointers/Algorithm
```python
    def longestPalindrome(self, s: str) -> str:
        # Preprocess the string to handle even-length palindromes
        t = "#".join(f"^{s}$")
        n = len(t)
        p = [0] * n
        center = right = 0

        
        for i in range(1, n - 1):
            mirror = 2 * center - i  # Mirror of `i` with respect to `center`

            # If within bounds of the current right boundary
            if i < right:
                p[i] = min(right - i, p[mirror])

            # Expand around `i`
            while t[i + p[i] + 1] == t[i - p[i] - 1]:
                p[i] += 1

            # Update the center and right boundary if the palindrome is expanded
            if i + p[i] > right:
                center = i
                right = i + p[i]

        # Find the maximum length palindrome
        max_len, center_index = max((n, i) for i, n in enumerate(p))
        start = (center_index - max_len) // 2  # Convert index back to original string
        return s[start: start + max_len]
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  | 


