---
title: "LeetCode: Graphs II 01 BFS"
description: "advanced graphs"
image: "../../public/Notes/0-1-bfs.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Zero One BFS Algorithm Intro 

## Intro
01 BFS is an efficient shortest path algorithm for graphs where edge weights 
are only 0 or 1

Special case of BFS/Dijkstras

Instead of using a standard priority queue, it uses a deque to achieve O(V + E) time

Efficiently computes shortest distances from a single source in such graphs

## Graph Requirements
1. Weighted graph with edge weights only 0 or 1 only
2. Directed or Undirected
3. Represented Using:
    - Adjacency List

## Output
Shortest distance from the source node to all other nodes
Optionally, the path itself

## Video Animation

## Pseudo Code
```python
    from collections import deque

    def zero_one_bfs(graph, source):

        n = len(graph)
        dist = [float('inf')] * n
        dist[source] = 0

        dq = deque()
        dq.append(source)

        while dq:
            node = dq.popleft()
            for neighbor, weight in graph[node]:
                if dist[node] + weight < dist[neighbor]:
                    dist[neighbor] = dist[node] + weight
                    if weight == 0:
                        dq.appendleft(neighbor)  # 0-weight edges prioritized
                    else:
                        dq.append(neighbor)      # 1-weight edges go to back

        return dist
```

## Time Complexity
Each vertex is processed at most once
Each edge is considered at most once

Must faster than Dijkstras for this specific case O(E + V) instead of O(E log V)

## Space Complexity
Distance Array: O(V)
Deque: O(V) in worst case

## IRL Use Case
- Special Graphs
    Slide (0 cost) vs Step (1 cost)

- Network Propagation With Free/Paid Edges
    0 for instance transfer, 1 for delayed transfer


# 2290. Minimum Obstacle Removal to Reach Corner ::1:: - Hard

Topics:  Array, Breadth First Search, Graph Theory, Heap (Priority Queue), Matrix, Shortest Path

## Intro
> You are given a 0-indexed 2D integer array grid of size m x n.
> Each cell has one of two values:
> 0 represents an empty cell,
> 1 represents an obstacle that may be removed.
> You can move up, down, left, or right from and to an empty cell.
> Return the minimum number of obstacles to remove so you 
> can move from the upper left corner (0, 0) to the lower right 
> corner (m - 1, n - 1).


|  Example Input           | Output |  
| ---------------- | ------ | 
| grid = [[0,1,1],[1,1,0],[1,1,0]] | 2 |
| grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]] | 0 |

Constraints:

m == grid.length

n == grid[i].length

1 &leq; m, n &leq; 10^5

2 &leq; m*n &leq; 10^5

grid[i][j] is either 0 or 1

grid[0][0] == grid[m-1][n-1] == 0

## Abstraction
Given a graph full of empty cell or obstacles, determine the minimum number of obstacles 
to remove to move from top left to bottom right

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: [01 BFS] 01 BFS Approach - Advanced Graphs/Advanced Graphs
```python
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        # Grid dimensions
        m, n = len(grid), len(grid[0])

        # Directions: up, down, left, right
        directions = [(1,0), (-1,0), (0,1), (0,-1)]

        # distance matrix: min obstacles removed to reach each cell
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = grid[0][0]  # starting cost (remove if starting on 1)

        # deque for 0-1 BFS
        dq = deque()
        dq.append((0,0))

        while dq:

            r, c = dq.popleft()

            # Explore neighbors
            for dr, dc in directions:
                nr, nc = r + dr, c + dc

                # Valid boundaries
                if 0 <= nr < m and 0 <= nc < n:

                    # New distance = current + cost to enter neighbor
                    new_dist = dist[r][c] + grid[nr][nc]

                    # Relaxation
                    if new_dist < dist[nr][nc]:
                        dist[nr][nc] = new_dist

                        # 0-cost move → appendleft
                        if grid[nr][nc] == 0:
                            dq.appendleft((nr, nc))
                        # 1-cost move → append to back
                        else:
                            dq.append((nr, nc))

        # Result: min obstacles to remove to reach bottom-right
        return dist[m-1][n-1]
```


