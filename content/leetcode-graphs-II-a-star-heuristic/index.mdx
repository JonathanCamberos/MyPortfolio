---
title: "LeetCode: Graphs II A Star Heuristic"
description: "advanced graphs"
image: "../../public/Notes/a-star.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# A Star Heuristic Algorithm Intro

## Intro
A* is a graph search algorithm used to find the shortest path from a start node
to a goal node efficiently

Combines Dijkstra's Algorithm with a heuristic function to guide the search.

Uses f(n) = g(n) + h(n):
    - g(n): cost from start to current node
    - h(n): estimated cost from current node to goal (heuristic)

The heuristic helps prioritize nodes likely to lead to the goal,
making it faster than Dijkstras in many cases.

## Graph Requirements
1. Weighted Graph (non-negative weights for correctness)
2. Directed or Undirected
3. Heuristic function h(n) must be admissible (never overestimates the true cost)
4. Represented Using:
    - Adjacency List
    - Grid or coordinate system for spatial problem

## Output
Shortest path from start to goal
Total path cost
Optionally the sequence of nodes visited

## Video Animation
A Star Heuristic: https://www.youtube.com/watch?v=71CEj4gKDnE

## Pseudo Code
```python
    def a_star(graph, start, goal, h):

        open_set = []
        heapq.heappush(open_set, (h(start), 0, start, [start]))  # (f = g+h, g, node, path)

        visited = set()

        while open_set:
            f, g, node, path = heapq.heappop(open_set)

            if node == goal:
                return path, g

            if node in visited:
                continue
            visited.add(node)

            for neighbor, cost in graph[node]:
                if neighbor not in visited:
                    g_new = g + cost
                    f_new = g_new + h(neighbor)
                    heapq.heappush(open_set, (f_new, g_new, neighbor, path + [neighbor]))

        return None, float('inf')  # no path found
```

## Time Complexity
Best case (good heuristic): O(E) only relevant nodes explored

Worst case (bad heuristic) O(E log V), becomes Dijkstras

## Space Complexity
Priority Queue: O(V)
Visited Set: O(V)
Path Storage: O(V)

## IRL Use Case
- Path Finding In Games
    NPC movements on maps, grids or graph navigation

- GPS Navigation
    Shortest path considering estimated distance to destination

- Robotics
    Efficient movement planning for autonomous robots

# 1091. Shortest Path In Binary Matrix ::1:: - Medium

Topics:  Array, Breadth First Search, Matrix

## Intro
> Given an n x n binary matrix grid, return the length of the shortest
> clear path in the matrix. If there is no clear path, return -1.
> A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0))
> to the bottom-right cell (i.e., (n - 1, n - 1)) such that:
> All the visited cells of the path are 0.
> All the adjacent cells of the path are 8-directionally connected 
> (i.e., they are different and they share an edge or a corner).
> The length of a clear path is the number of visited cells of this path.

|  Example Input           | Output |  
| ---------------- | ------ | 
| grid = [[0,1],[1,0]] | 2 |
| grid = [[0,0,0],[1,1,0],[1,1,0]] | 4 |
| grid = [[1,0,0],[1,1,0],[1,1,0]] | -1 |

Constraints:

n == grid.length

n == grid[i].length

1 &leq; n &leq; 100

grid[i][j] is 0 or 1

## Abstraction
Given a matrix, determine the shortest clear path

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: [A Star] a star - Advanced Graphs/Advanced Graphs
```python
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:

        import heapq
        from typing import List

        
        # A* Algorithm (Heuristic Guided Shortest Path)
        # ---------------------------------------------------
        # Goal:
        # Find shortest path from (0,0) â†’ (n-1,n-1)
        #
        # Core Idea:
        # - Similar to Dijkstra, but guided using heuristic.
        # - Priority = g(n) + h(n)
        #
        # g(n) = distance travelled so far
        # h(n) = estimated distance to goal (Chebyshev distance)

        n = len(grid)

        # ---------------------------------------------------
        # Step 1: Early Pruning
        # ---------------------------------------------------
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1

        # 8 directions
        directions = [
            (1,0), (-1,0), (0,1), (0,-1),
            (1,1), (1,-1), (-1,1), (-1,-1)
        ]

        # ---------------------------------------------------
        # Heuristic Function (Chebyshev Distance)
        # ---------------------------------------------------
        def heuristic(r, c):
            return max(abs(n-1-r), abs(n-1-c))

        # ---------------------------------------------------
        # MinHeap:
        # (f = g+h, g, row, col)
        # ---------------------------------------------------
        heap = [(1 + heuristic(0,0), 1, 0, 0)]

        visited = set()

        # ---------------------------------------------------
        # A* Traversal
        # ---------------------------------------------------
        while heap:

            f, dist, r, c = heapq.heappop(heap)

            if (r, c) in visited:
                continue
            visited.add((r, c))

            # Goal reached
            if r == n-1 and c == n-1:
                return dist

            # Explore neighbors
            for dr, dc in directions:
                nr, nc = r + dr, c + dc

                # valid + clear cell
                if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 0:
                    if (nr, nc) not in visited:

                        g = dist + 1
                        h = heuristic(nr, nc)

                        heapq.heappush(heap, (g + h, g, nr, nc))

        return -1
```


