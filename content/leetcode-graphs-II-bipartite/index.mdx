---
title: "LeetCode: Graphs II Bipartite"
description: "advanced graphs"
image: "../../public/Notes/bipartite.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Bipartite Algorithm Intro

## Intro
A bipartite graph is a graph whose vertices can be divided into two disjoint sets
such that every edge connects a vertex from one set to a vertex from the other.

No edge exists between vertices within the same set
Commonly used in matching problems, scheduling, and network flows
Can be checked using BFS or DFS coloring techniques

## Graph Requirements
1. Directed or Undirected
2. Represented Using:
    - Adjacency List
    - Adjacency Matrix

## Output
True or False whether the graph is bipartite
Optionally, the two sets of vertices if it is bipartite


## Video Animation
Bipartite: https://www.youtube.com/watch?v=Zg6UAnAzGGs

## BFS Pseudo Code
```python
    from collections import deque

    def is_bipartite(graph):

        color = {}

        for node in graph:
            if node not in color:
                queue = deque([node])
                color[node] = 0  # start coloring with 0

                while queue:
                    u = queue.popleft()
                    for v in graph[u]:
                        if v not in color:
                            color[v] = 1 - color[u]  # alternate color
                            queue.append(v)
                        elif color[v] == color[u]:
                            return False  # conflict detected

        return True
```

### DFS Pseudo Code
```python
    def is_bipartite_dfs(graph):
        color = {}

        def dfs(node, c):
            color[node] = c
            for neighbor in graph[node]:
                if neighbor not in color:
                    if not dfs(neighbor, 1 - c):
                        return False
                elif color[neighbor] == c:
                    return False
            return True

        for node in graph:
            if node not in color:
                if not dfs(node, 0):
                    return False

        return True
```

## Time Complexity
Each vertex is visited once
Each edge is processed once

O(V + E)

## Space Complexity
Color map: O(V)
BFS queue: O(V)
DFS recursion stack: O(V)

## IRL Use Case
- Matching Problems
    Job assignments or tasks
- Network Flows
    Bipartite graphs are foundational for max flow/min cut problems
- Scheduling
    Two groups that must not conflict


# 785. Is Graph Bipartite ::1:: - Medium

Topics:  Depth First Search, Breadth First Search, Union Find, Graph Theory

## Intro
> There is an undirected graph with n nodes, where each node is 
> numbered between 0 and n - 1. You are given a 2D array 
> graph, where graph[u] is an array of nodes that node u is
> adjacent to. More formally, for each v in graph[u], there is an 
> undirected edge between node u and node v. The graph has 
> the following properties:
> There are no self-edges (graph[u] does not contain u).
> There are no parallel edges (graph[u] does not contain duplicate values).
> If v is in graph[u], then u is in graph[v] (the graph is undirected).
> The graph may not be connected, meaning there may be 
> wo nodes u and v such that there is no path between them.
> A graph is bipartite if the nodes can be partitioned into two 
> independent sets A and B such that every edge in the graph 
> connects a node in set A and a node in set B.
> Return true if and only if it is bipartite.


|  Example Input           | Output |  
| ---------------- | ------ | 
| graph = [[1,2,3],[0,2],[0,1,3],[0,2]] | false |
| graph = [[1,3],[0,2],[1,3],[0,2]] | true |

Constraints:

graph.length == n

1 &leq; n &leq; 100

0 &leq; graph[u].length &lt;

0 &leq; graph[u][i] &leq; n-1

graph[u] does not contain u

All the values of graph[u] are unique

If graph[u] contains v, then graph[v], contains u


## Abstraction
Given a graph, determine if it is bipartite

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: [Bipartite] Topological Sort using BFS - Advanced Graphs/Advanced Graphs
```python

    def isBipartite(self, graph: List[List[int]]) -> bool:
        
        from collections import deque
        from typing import List

        # Initialization
        n = len(graph)              # number of nodes
        color = [0] * n             # 0 = uncolored, 1 = color A, -1 = color B
        
        # Traverse all components (graph may be disconnected)
        for i in range(n):
            if color[i] != 0:
                continue            # already colored in a previous BFS
            
            # Start BFS from uncolored node i
            queue = deque([i])
            color[i] = 1             # assign initial color
            
            # BFS traversal for coloring
            while queue:
                node = queue.popleft()
                
                # Explore neighbors
                for nei in graph[node]:
                    
                    if color[nei] == 0:
                        # Neighbor uncolored: assign opposite color
                        color[nei] = -color[node]
                        queue.append(nei)
                    
                    elif color[nei] == color[node]:
                        # Neighbor already colored same as current: conflict
                        # Graph is not bipartite
                        return False
        
        # If all nodes processed without conflict: bipartite
        return True
```

