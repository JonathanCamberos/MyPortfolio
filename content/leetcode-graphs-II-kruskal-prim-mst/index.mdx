---
title: "LeetCode: Graphs II Kruskal Prim Minimum Spanning Tree"
description: "advanced graphs"
image: "../../public/Notes/kruskal.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Kruskal Algorithm Intro

## Intro
Kruskal's Algorithm is a greedy algorithm for finding a Minimum Spanning Tree (MST)
in a weighted, connected graph.

It connects all vertices with a minimum total edge weight while avoiding cycles.

## Graph Requirements
1. Weight Graph
2. Directed or Undirected (usually undirected for MST)
3. Edge weights can be 0 or positive numbers
4. Represented using:
    - Edge List (most common)
    - Adjacency List or Matrix 

## Output
A Minimum Spanning Tree: a subset of edges connecting all vertices
with minimum total weight

Total weight of the Minimum Spanning Tree

## Video Animation
Kruskal: https://www.youtube.com/watch?v=71UQH7Pr9kU

## Pseudo Code
```python
    def kruskal(edges, V):

        # Sort edges by weight
        edges.sort(key=lambda x: x[2])

        # Union Find data structure
        parent = [i for i in range(V)]
        rank = [0] * V

        def find(u):
            if parent[u] != u:
                parent[u] = find(parent[u])
            return parent[u]

        def union(u, v):
            pu, pv = find(u), find(v)
            if pu == pv:
                return False
            if rank[pu] < rank[pv]:
                parent[pu] = pv
            else:
                parent[pv] = pu
                if rank[pu] == rank[pv]:
                    rank[pu] += 1
            return True

        mst = []
        total_weight = 0
        for u, v, w in edges:
            if union(u, v):
                mst.append((u, v, w))
                total_weight += w

        return mst, total_weight
```

## Time Complexity
Sorting Edges: O(E log E)
Union Find operations: O(E) with path compression and union by rank

Overall: O(E log E)

## Space Complexity
Union Find parent and rank arrays: O(V)
MST edges storage: O(V)

## IRL Use Case
-  Network Design
    Minimizing the cost of connecting computers, phones, or cables
- Road Rail Planning:
    Building a minimal network connecting all cities


# Prims Algorithm Intro

## Intro
Prim's Algorithm is a greedy algorithm to find a Minimum Spanning Tree (MST)
starting from a node and growing the tree edge by edge

Unlike Kruskal, which sorts edges globally, Prim's always expands
from the current MST

## Graph Requirements
1. Weight Graph
2. Directed or Undirected (usually undirected for MST)
3. Edge weights non-negative
4. Represented Using:
    - Adjacency List (most efficient)
    - Adjacency Matrix

## Output
A Minimum Spanning Tree: subset of edges connecting all vertices with
minimal total edge weight

Total weight of the Minimum Spanning Tree.

## Video Animation
Prims: www.youtube.com/watch?v=cplfcGZmX7I

## Pseudo Code
```python
    def prim(graph, start):
        """
        graph: adjacency list {node: [(neighbor, weight), ...]}
        start: starting vertex
        """

        visited = set()
        min_heap = [(0, start)]
        total_weight = 0
        mst = []

        while min_heap and len(visited) < len(graph):
            w, u = heapq.heappop(min_heap)
            if u in visited:
                continue
            visited.add(u)
            total_weight += w

            for v, weight in graph[u]:
                if v not in visited:
                    heapq.heappush(min_heap, (weight, v))
                    mst.append((u, v, weight))

        return mst, total_weight
```

## Time Complexity
Using Adjacency List + MinHeap: O(E log V)

Each edge is pushed once, each heap operation costs O(log v)

## Space Complexity
MinHeap: O(V)
Visited Set: O(V)
MST Edge: O(V)

## IRL Use Case
-  Network Design
    Minimizing the cost of connecting computers, phones, or cables
- Road Rail Planning:
    Building a minimal network connecting all cities


# 1584. Min Cost to Connect All Points ::2:: - Medium

Topics:  Array, Union Find, Graph, Minimum Spanning Tree

## Intro
> You are given an array points representing integer 
> coordinates of some points on a 2D-plane, where 
> points[i] = [xi, yi].
> The cost of connecting two points [xi, yi] and [xj, yj] 
> is the manhattan distance between them: 
> |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
> Return the minimum cost to make all points connected. All 
> points are connected if there is exactly one simple path 
> between any two points.

|  Example Input           | Output |  
| ---------------- | ------ | 
| points = [[0,0],[2,2],[3,10],[5,2],[7,0]] | 20 |
| points = [[3,12],[-2,5],[-4,1]] | 18 |

Constraints:

1 &leq; points.length &leq; 1000

-10<sup>6</sup> &leq; xi, yi &leq; 10<sup>6</sup>

All pairs (xi, yi) are distinct.

## Abstraction
Given a graph, determine the min cost to connect all nodes.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: [Kruskal] Algorithm + Union-Find - Advanced Graphs/Advanced Graphs
```python
class UnionFind:

    def __init__(self, n):

        # Each node starts as its own parent (separate component)
        # sc: O(V)
        self.parent = list(range(n))

        # Rank approximates tree depth (used for balancing)
        # sc: O(V)
        self.rank = [0] * n

    def find(self, x):
        # Find root representative of component
        # Path Compression:
        # Flattens tree for faster future lookups
        # tc: O(1) amortized
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):

        xr, yr = self.find(x), self.find(y)

        # Already connected: adding edge creates cycle
        if xr == yr:
            return False

        # Union by Rank:
        # Attach smaller tree under larger tree
        if self.rank[xr] < self.rank[yr]:
            self.parent[xr] = yr
        elif self.rank[xr] > self.rank[yr]:
            self.parent[yr] = xr
        else:
            self.parent[yr] = xr
            self.rank[xr] += 1
        return True

class Solution:
    def minCostConnectPoints(self, points: list[list[int]]) -> int:
        
        # Kruskal's Algorithm (Minimum Spanning Tree)
        # Connect all points with minimum total edge cost.

        # 1. Build ALL possible edges
        # 2. Sort edges by smallest weight
        # 3. Greedily add edges if they do NOT form a cycle

        # Cycle detection is handled efficiently using Union Find

        n = len(points)
        edges = []


        # Build All Pairwise Edges:
        # Manhattan distance used as edge weight

        # Number of edges:
        # n(n-1)/2 : O(n^2)

        # tc: O(n^2)
        # sc: O(n^2)
        for i in range(n):
            for j in range(i + 1, n):
                xi, yi = points[i]
                xj, yj = points[j]
                cost = abs(xi - xj) + abs(yi - yj)
                edges.append((cost, i, j))


        # Sort edges by cost:
        # tc: O(E log E)
        edges.sort()

        # Greedy Step:
        # Always try smallest edge first

        uf = UnionFind(n)
        total_cost = 0
        edges_used = 0

        # Process edges in increasing order
        for cost, i, j in edges:

            # Union succeeds ONLY if no cycle formed
            if uf.union(i, j):
                total_cost += cost
                edges_used += 1

                # MST complete once n-1 edges chosen
                if edges_used == n - 1:
                    break


        # overall: tc O(n^2 log n)
        # overall: sc: P(n^2)
        return total_cost
```


## Solution 2: [Prim] Algorithm + MinHeap - Advanced Graphs/Advanced Graphs
```python
    def minCostConnectPoints(self, points: List[List[int]]) -> int:

        # Prim's Algorithm (Minimum Spanning Tree)
        # Grow MST from a starting node

        # Idea:
        # 1. Similar to Dijkstra's greedy expansion
        # 2. Always add the CHEAPEST edge connecting
        #    current MST to a new node

        # Difference from Kruskal:
        # Node based expansion (not edge based)
        # No explicit cycle detection needed

        n = len(points)

        # data Structures

        # Minimum cost edge needed to connect each node to MST
        # sc: O(V)
        min_dist = [float('inf')] * n
        
        # Track nodes already included in MST
        # sc: O(V)
        visited = [False] * n

        # Start from node 0
        min_dist[0] = 0

        # MinHeap:
        # (edge_cost, node)
        # ensures smallest connecting edge expanded next
        # sc: O(V)
        heap = [(0,0)]

        total_cost = 0
        

        # Prim Traversal (Greedy Expansion)
        # Similar to dijkstra:
        # always expand lowest cost frontier edge
        # tc: O(n^2 log n)
        while heap:

            cost, u = heapq.heappop(heap)
            
            # Skip outdated heap entries
            if visited[u]:
                continue

            # Add node to MST
            visited[u] = True
            total_cost += cost

            # Explore Candidate Edges:
            # Dynamically compute distance to all unvisited nodes 
            for v in range(n):

                if not visited[v]:
                    dist = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])
                    
                    # if cheaper connection found: update heap
                    if dist < min_dist[v]:
                        min_dist[v] = dist
                        heapq.heappush(heap,(dist, v))

        # overall: tc O(n^2 log n)
        # overall: sc O(n)
        return total_cost
```
