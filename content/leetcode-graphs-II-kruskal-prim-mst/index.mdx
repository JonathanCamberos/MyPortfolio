---
title: "LeetCode: Graphs II Kruskal Prim Minimum Spanning Tree"
description: "advanced graphs"
image: "../../public/Notes/kruskal.png"
publishedAt: "2026-02-12"
updatedAt: "2026-02-12"
author: "jonathancamberos"
isPublished: true
tags:
- data structures and algorithms
---

# Kruskal Algorithm Intro

## Intro
Kruskal's Algorithm is a greedy algorithm for finding a Minimum Spanning Tree (MST)
in a weighted, connected graph.

It connects all vertices with a minimum total edge weight while avoiding cycles.

## Graph Requirements
1. Weight Graph
2. Directed or Undirected (usually undirected for MST)
3. Edge weights can be 0 or positive numbers
4. Represented using:
    - Edge List (most common)
    - Adjacency List or Matrix 

## Output
A Minimum Spanning Tree: a subset of edges connecting all vertices
with minimum total weight

Total weight of the Minimum Spanning Tree

## Video Animation
Kruskal: https://www.youtube.com/watch?v=71UQH7Pr9kU

## Pseudo Code
```python
    def kruskal(edges, V):

        # Sort edges by weight
        edges.sort(key=lambda x: x[2])

        # Union Find data structure
        parent = [i for i in range(V)]
        rank = [0] * V

        def find(u):
            if parent[u] != u:
                parent[u] = find(parent[u])
            return parent[u]

        def union(u, v):
            pu, pv = find(u), find(v)
            if pu == pv:
                return False
            if rank[pu] < rank[pv]:
                parent[pu] = pv
            else:
                parent[pv] = pu
                if rank[pu] == rank[pv]:
                    rank[pu] += 1
            return True

        mst = []
        total_weight = 0
        for u, v, w in edges:
            if union(u, v):
                mst.append((u, v, w))
                total_weight += w

        return mst, total_weight
```

## Time Complexity
Sorting Edges: O(E log E)
Union Find operations: O(E) with path compression and union by rank

Overall: O(E log E)

## Space Complexity
Union Find parent and rank arrays: O(V)
MST edges storage: O(V)

## IRL Use Case
-  Network Design
    Minimizing the cost of connecting computers, phones, or cables
- Road Rail Planning:
    Building a minimal network connecting all cities


# Prims Algorithm Intro

## Intro
Prim's Algorithm is a greedy algorithm to find a Minimum Spanning Tree (MST)
starting from a node and growing the tree edge by edge

Unlike Kruskal, which sorts edges globally, Prim's always expands
from the current MST

## Graph Requirements
1. Weight Graph
2. Directed or Undirected (usually undirected for MST)
3. Edge weights non-negative
4. Represented Using:
    - Adjacency List (most efficient)
    - Adjacency Matrix

## Output
A Minimum Spanning Tree: subset of edges connecting all vertices with
minimal total edge weight

Total weight of the Minimum Spanning Tree.

## Video Animation
Prims: www.youtube.com/watch?v=cplfcGZmX7I

## Pseudo Code
```python
    def prim(graph, start):
        """
        graph: adjacency list {node: [(neighbor, weight), ...]}
        start: starting vertex
        """

        visited = set()
        min_heap = [(0, start)]
        total_weight = 0
        mst = []

        while min_heap and len(visited) < len(graph):
            w, u = heapq.heappop(min_heap)
            if u in visited:
                continue
            visited.add(u)
            total_weight += w

            for v, weight in graph[u]:
                if v not in visited:
                    heapq.heappush(min_heap, (weight, v))
                    mst.append((u, v, weight))

        return mst, total_weight
```

## Time Complexity
Using Adjacency List + MinHeap: O(E log V)

Each edge is pushed once, each heap operation costs O(log v)

## Space Complexity
MinHeap: O(V)
Visited Set: O(V)
MST Edge: O(V)

## IRL Use Case
-  Network Design
    Minimizing the cost of connecting computers, phones, or cables
- Road Rail Planning:
    Building a minimal network connecting all cities


# 1584. Min Cost to Connect All Points ::2:: - Medium

Topics:  Array, Union Find, Graph, Minimum Spanning Tree

## Intro
> You are given an array points representing integer 
> coordinates of some points on a 2D-plane, where 
> points[i] = [xi, yi].
> The cost of connecting two points [xi, yi] and [xj, yj] 
> is the manhattan distance between them: 
> |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
> Return the minimum cost to make all points connected. All 
> points are connected if there is exactly one simple path 
> between any two points.

|  Example Input           | Output |  
| ---------------- | ------ | 
| points = [[0,0],[2,2],[3,10],[5,2],[7,0]] | 20 |
| points = [[3,12],[-2,5],[-4,1]] | 18 |

Constraints:

1 &leq; points.length &leq; 1000

-10<sup>6</sup> &leq; xi, yi &leq; 10<sup>6</sup>

All pairs (xi, yi) are distinct.

## Abstraction
Given a graph, determine the min cost to connect all nodes.

## Space & Time Complexity
|  Solution  | Time Complexity | Space Complexity | Time Remark | Space Remark |  
| ---------- | --------------- | ---------------- | ----------- | ------------ |
|  |  |  |  |  |


| Bug | Error |
| --- | ----- |
|  |  | 


## Brute Force:
```python
```
|  Aspect  | Time Complexity | Space Complexity |  Time Remarks | Space Remarks |
| -------- | --------------- | ---------------- | ------------- |  ------------ |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |


## Find the Bug:
```python
```

## Solution 1: Kruskal's Algorithm + Union-Find - Advanced Graphs/Advanced Graphs
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        # path compression
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)

        # already connected
        if xr == yr:
            return False
        # union by rank
        if self.rank[xr] < self.rank[yr]:
            self.parent[xr] = yr
        elif self.rank[xr] > self.rank[yr]:
            self.parent[yr] = xr
        else:
            self.parent[yr] = xr
            self.rank[xr] += 1
        return True

class Solution:
    def minCostConnectPoints(self, points: list[list[int]]) -> int:
        
        # Why Kruskals Algorithm?
        # Edge Based
        # Good when we can easily compute all pairwise edges
        # Add edges in increasing order + avoiding cycles with Union Find
        # Stop when MST has n-1 edges, ensures min total cost 

        # Note:
        # 1. Compute all pairwise edges with Manhattan distance
        # 2. Sort edges by cost
        # 3. Use Union-Find to connect points without forming cycles
        # 4. Sum the costs of edges added to MST

        n = len(points)
        edges = []

        # Build all edges (Manhattan distance)
        for i in range(n):
            for j in range(i + 1, n):
                xi, yi = points[i]
                xj, yj = points[j]
                cost = abs(xi - xj) + abs(yi - yj)
                edges.append((cost, i, j))

        # Sort edges by cost
        edges.sort()

        uf = UnionFind(n)
        total_cost = 0
        edges_used = 0

        # Kruskalâ€™s main loop
        for cost, i, j in edges:
            if uf.union(i, j):
                total_cost += cost
                edges_used += 1

                # MST complete
                if edges_used == n - 1:
                    break


        # overall: time complexity O(n^2 log n) for edge sorting
        # overall: space complexity O(n^2) for edges
        return total_cost
```


## Solution 2: Prim's Algorithm + MinHeap - Advanced Graphs/Advanced Graphs
```python
    def minCostConnectPoints(self, points: List[List[int]]) -> int:

        # Why Prims Algorithm?
        # Node Based
        # Grow MST from starting point using smallest connecting edge
        # Efficient when checking edges dynamically with a MinHeap
        # Stops when all points are connected, ensures min total cost

        n = len(points)

        # shortest edge to MST
        min_dist = [float('inf')] * n
        visited = [False] * n
        min_dist[0] = 0

        # (cost, point)
        heap = [(0,0)]
        total_cost = 0
        

        while heap:
            cost, u = heapq.heappop(heap)
            if visited[u]:
                continue
            visited[u] = True
            total_cost += cost

            # Explore all possible new edges
            for v in range(n):
                if not visited[v]:
                    dist = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])
                    if dist < min_dist[v]:
                        min_dist[v] = dist
                        heapq.heappush(heap,(dist, v))

        # overall: time complexity O(n^2 log n)
        # overall: space complexity O(n)
        return total_cost
```
